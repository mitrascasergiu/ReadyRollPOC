/*
    Target database:    i-Balancer (configurable)
    Target instance:    (any)
    Generated date:     25/06/2019 14:09:15
    Generated on:       V-GNRC-SG01
    Package version:    (undefined)
    Migration version:  (n/a)
    Baseline version:   (n/a)
    SQL Change Automation version:  3.2.19162.8508
    Migrations pending: (variable)

    IMPORTANT! "SQLCMD Mode" must be activated prior to execution (under the Query menu in SSMS).

    BEFORE EXECUTING THIS SCRIPT, WE STRONGLY RECOMMEND YOU TAKE A BACKUP OF YOUR DATABASE.

    This SQLCMD script is designed to be executed through MSBuild (via the .sqlproj Deploy target) however
    it can also be run manually using SQL Management Studio.

    It was generated by the SQL Change Automation build task and contains logic to deploy the database, ensuring that
    each of the incremental migrations is executed a single time only in alphabetical (filename)
    order. If any errors occur within those scripts, the deployment will be aborted and the transaction
    rolled-back.

    NOTE: Automatic transaction management is provided for incremental migrations, so you don't need to
          add any special BEGIN TRAN/COMMIT/ROLLBACK logic in those script files.
          However if you require transaction handling in your Pre/Post-Deployment scripts, you will
          need to add this logic to the source .sql files yourself.
*/

----====================================================================================================================
---- SQLCMD Variables
---- This script is designed to be called by SQLCMD.EXE with variables specified on the command line.
---- However you can also run it in SQL Management Studio by uncommenting this section (CTRL+K, CTRL+U).
--:setvar DatabaseName "i-Balancer"
--:setvar ReleaseVersion ""
--:setvar ForceDeployWithoutBaseline "False"
--:setvar DefaultFilePrefix "i-Balancer"
--:setvar DefaultDataPath ""
--:setvar DefaultLogPath ""
--:setvar DefaultBackupPath ""
--:setvar DeployPath ""
----====================================================================================================================

:on error exit -- Instructs SQLCMD to abort execution as soon as an erroneous batch is encountered

:setvar PackageVersion "(undefined)"
:setvar IsShadowDeployment 0

GO
:setvar IsSqlCmdEnabled "True"
GO

IF N'$(DatabaseName)' = N'$' + N'(DatabaseName)' OR
   N'$(ReleaseVersion)' = N'$' + N'(ReleaseVersion)' OR
   N'$(ForceDeployWithoutBaseline)' = N'$' + N'(ForceDeployWithoutBaseline)'
      RAISERROR('(This will not throw). Please make sure that all SQLCMD variables are defined before running this script.', 0, 0);
GO

SET IMPLICIT_TRANSACTIONS, NUMERIC_ROUNDABORT OFF;
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, NOCOUNT, QUOTED_IDENTIFIER ON;
SET XACT_ABORT ON; -- Abort the current batch immediately if a statement raises a run-time error and rollback any open transaction(s)

IF N'$(IsSqlCmdEnabled)' <> N'True' -- Is SQLCMD mode not enabled within the execution context (eg. SSMS)
    BEGIN
        IF IS_SRVROLEMEMBER(N'sysadmin') = 1
            BEGIN -- User is sysadmin; abort execution by disconnect the script from the database server
                RAISERROR(N'This script must be run in SQLCMD Mode (under the Query menu in SSMS). Aborting connection to suppress subsequent errors.', 20, 127, N'UNKNOWN') WITH LOG;
            END
        ELSE
            BEGIN -- User is not sysadmin; abort execution by switching off statement execution (script will continue to the end without performing any actual deployment work)
                RAISERROR(N'This script must be run in SQLCMD Mode (under the Query menu in SSMS). Script execution has been halted.', 16, 127, N'UNKNOWN') WITH NOWAIT;
            END
    END
GO
IF @@ERROR != 0
    BEGIN
        SET NOEXEC ON; -- SQLCMD is NOT enabled so prevent any further statements from executing
    END
GO
-- Beyond this point, no further explicit error handling is required because it can be assumed that SQLCMD mode is enabled

IF SERVERPROPERTY('EngineEdition') = 5 AND DB_NAME() != N'$(DatabaseName)'
  RAISERROR(N'Azure SQL Database does not support switching between databases. Connect to [$(DatabaseName)] and then re-run the script.', 16, 127);








------------------------------------------------------------------------------------------------------------------------
------------------------------------------       PRE-DEPLOYMENT SCRIPTS       ------------------------------------------
------------------------------------------------------------------------------------------------------------------------

SET IMPLICIT_TRANSACTIONS, NUMERIC_ROUNDABORT OFF;
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, NOCOUNT, QUOTED_IDENTIFIER ON;

PRINT '----- executing pre-deployment script "Pre-Deployment\01_Create_Database.sql" -----';
GO

------------------------- BEGIN PRE-DEPLOYMENT SCRIPT: "Pre-Deployment\01_Create_Database.sql" ---------------------------
IF (DB_ID(N'$(DatabaseName)') IS NULL)
BEGIN
	PRINT N'Creating $(DatabaseName)...';
END
GO
IF (DB_ID(N'$(DatabaseName)') IS NULL)
BEGIN
	CREATE DATABASE [$(DatabaseName)]; -- MODIFY THIS STATEMENT TO SPECIFY A COLLATION FOR YOUR DATABASE
END

GO
-------------------------- END PRE-DEPLOYMENT SCRIPT: "Pre-Deployment\01_Create_Database.sql" ----------------------------

SET IMPLICIT_TRANSACTIONS, NUMERIC_ROUNDABORT OFF;
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, NOCOUNT, QUOTED_IDENTIFIER ON;









------------------------------------------------------------------------------------------------------------------------
------------------------------------------       INCREMENTAL MIGRATIONS       ------------------------------------------
------------------------------------------------------------------------------------------------------------------------

SET IMPLICIT_TRANSACTIONS, NUMERIC_ROUNDABORT OFF;
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, NOCOUNT, QUOTED_IDENTIFIER ON;

GO
PRINT '# Beginning transaction';

SET TRANSACTION ISOLATION LEVEL READ COMMITTED;

SET XACT_ABORT ON;

BEGIN TRANSACTION;

GO
IF DB_ID('$(DatabaseName)') IS NULL
  RAISERROR ('The database [$(DatabaseName)] could not be found. Please ensure that there is a Pre-Deployment script within your project that contains a CREATE DATABASE statement (e.g. Pre-Deployment\01_Create_Database.sql).', 16, 127);

GO
IF DB_NAME() != '$(DatabaseName)'
  USE [$(DatabaseName)];

GO
PRINT '# Setting up migration log table';
IF (NOT EXISTS (SELECT * FROM sys.objects WHERE [object_id] = OBJECT_ID(N'[dbo].[__MigrationLog]') AND [type] = 'U'))
  BEGIN
    IF OBJECT_ID(N'[dbo].[__MigrationLogCurrent]', 'V') IS NOT NULL
      DROP VIEW [dbo].[__MigrationLogCurrent];
    PRINT '# Creating a new migration log table';
    CREATE TABLE [dbo].[__MigrationLog] (
      [migration_id] UNIQUEIDENTIFIER NOT NULL,
      [script_checksum] NVARCHAR (64) NOT NULL,
      [script_filename] NVARCHAR (255) NOT NULL,
      [complete_dt] DATETIME2 NOT NULL,
      [applied_by] NVARCHAR (100) NOT NULL,
      [deployed] TINYINT CONSTRAINT [DF___MigrationLog_deployed] DEFAULT (1) NOT NULL,
      [version] VARCHAR (255) NULL,
      [package_version] VARCHAR (255) NULL,
      [release_version] VARCHAR (255) NULL,
      [sequence_no] INT IDENTITY (1, 1) NOT NULL CONSTRAINT [PK___MigrationLog] PRIMARY KEY CLUSTERED ([migration_id], [complete_dt], [script_checksum]));
    CREATE NONCLUSTERED INDEX [IX___MigrationLog_CompleteDt]
      ON [dbo].[__MigrationLog]([complete_dt]);
    CREATE NONCLUSTERED INDEX [IX___MigrationLog_Version]
      ON [dbo].[__MigrationLog]([version]);
    CREATE UNIQUE NONCLUSTERED INDEX [UX___MigrationLog_SequenceNo]
      ON [dbo].[__MigrationLog]([sequence_no]);
    EXECUTE ('
	CREATE VIEW [dbo].[__MigrationLogCurrent]
			AS
			WITH currentMigration AS
			(
			  SELECT
				 migration_id, script_checksum, script_filename, complete_dt, applied_by, deployed, ROW_NUMBER() OVER(PARTITION BY migration_id ORDER BY sequence_no DESC) AS RowNumber
			  FROM [dbo].[__MigrationLog]
			)
			SELECT  migration_id, script_checksum, script_filename, complete_dt, applied_by, deployed
			FROM currentMigration
			WHERE RowNumber = 1
	');
    IF OBJECT_ID(N'sp_addextendedproperty', 'P') IS NOT NULL
      BEGIN
        PRINT N'Creating extended properties';
        EXECUTE sp_addextendedproperty N'MS_Description', N'This table is required by SQL Change Automation projects to keep track of which migrations have been executed during deployment. Please do not alter or remove this table from the database.', 'SCHEMA', N'dbo', 'TABLE', N'__MigrationLog', NULL, NULL;
        EXECUTE sp_addextendedproperty N'MS_Description', N'The executing user at the time of deployment (populated using the SYSTEM_USER function).', 'SCHEMA', N'dbo', 'TABLE', N'__MigrationLog', 'COLUMN', N'applied_by';
        EXECUTE sp_addextendedproperty N'MS_Description', N'The date/time that the migration finished executing. This value is populated using the SYSDATETIME function.', 'SCHEMA', N'dbo', 'TABLE', N'__MigrationLog', 'COLUMN', N'complete_dt';
        EXECUTE sp_addextendedproperty N'MS_Description', N'This column contains a number of potential states:

0 - Marked As Deployed: The migration was not executed.
1- Deployed: The migration was executed successfully.
2- Imported: The migration was generated by importing from this DB.

"Marked As Deployed" and "Imported" are similar in that the migration was not executed on this database; it was was only marked as such to prevent it from executing during subsequent deployments.', 'SCHEMA', N'dbo', 'TABLE', N'__MigrationLog', 'COLUMN', N'deployed';
        EXECUTE sp_addextendedproperty N'MS_Description', N'The unique identifier of a migration script file. This value is stored within the <Migration /> Xml fragment within the header of the file itself.

Note that it is possible for this value to repeat in the [__MigrationLog] table. In the case of programmable object scripts, a record will be inserted with a particular ID each time a change is made to the source file and subsequently deployed.

In the case of a migration, you may see the same [migration_id] repeated, but only in the scenario where the "Mark As Deployed" button/command has been run.', 'SCHEMA', N'dbo', 'TABLE', N'__MigrationLog', 'COLUMN', N'migration_id';
        EXECUTE sp_addextendedproperty N'MS_Description', N'If you have enabled SQLCMD Packaging in your SQL Change Automation project, or if you are using Octopus Deploy, this will be the version number that your database package was stamped with at build-time.', 'SCHEMA', N'dbo', 'TABLE', N'__MigrationLog', 'COLUMN', N'package_version';
        EXECUTE sp_addextendedproperty N'MS_Description', N'If you are using Octopus Deploy, you can use the value in this column to look-up which release was responsible for deploying this migration.
If deploying via PowerShell, set the $ReleaseVersion variable to populate this column.
If deploying via Visual Studio, this column will always be NULL.', 'SCHEMA', N'dbo', 'TABLE', N'__MigrationLog', 'COLUMN', N'release_version';
        EXECUTE sp_addextendedproperty N'MS_Description', N'A SHA256 representation of the migration script file at the time of build.  This value is used to determine whether a migration has been changed since it was deployed. In the case of a programmable object script, a different checksum will cause the migration to be redeployed.
Note: if any variables have been specified as part of a deployment, this will not affect the checksum value.', 'SCHEMA', N'dbo', 'TABLE', N'__MigrationLog', 'COLUMN', N'script_checksum';
        EXECUTE sp_addextendedproperty N'MS_Description', N'The name of the migration script file on disk, at the time of build.
If Semantic Versioning has been enabled, then this value will contain the full relative path from the root of the project folder. If it is not enabled, then it will simply contain the filename itself.', 'SCHEMA', N'dbo', 'TABLE', N'__MigrationLog', 'COLUMN', N'script_filename';
        EXECUTE sp_addextendedproperty N'MS_Description', N'An auto-seeded numeric identifier that can be used to determine the order in which migrations were deployed.', 'SCHEMA', N'dbo', 'TABLE', N'__MigrationLog', 'COLUMN', N'sequence_no';
        EXECUTE sp_addextendedproperty N'MS_Description', N'The semantic version that this migration was created under. In SQL Change Automation projects, a folder can be given a version number, e.g. 1.0.0, and one or more migration scripts can be stored within that folder to provide logical grouping of related database changes.', 'SCHEMA', N'dbo', 'TABLE', N'__MigrationLog', 'COLUMN', N'version';
        EXECUTE sp_addextendedproperty N'MS_Description', N'This view is required by SQL Change Automation projects to determine whether a migration should be executed during a deployment. The view lists the most recent [__MigrationLog] entry for a given [migration_id], which is needed to determine whether a particular programmable object script needs to be (re)executed: a non-matching checksum on the current [__MigrationLog] entry will trigger the execution of a programmable object script. Please do not alter or remove this table from the database.', N'SCHEMA', N'dbo', N'VIEW', N'__MigrationLogCurrent', NULL, NULL;
      END
  END

IF NOT EXISTS (SELECT col.COLUMN_NAME FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS AS tab, INFORMATION_SCHEMA.CONSTRAINT_COLUMN_USAGE AS col WHERE col.CONSTRAINT_NAME = tab.CONSTRAINT_NAME AND col.TABLE_NAME = tab.TABLE_NAME AND col.TABLE_SCHEMA = tab.TABLE_SCHEMA AND tab.CONSTRAINT_TYPE = 'PRIMARY KEY' AND col.TABLE_SCHEMA = 'dbo' AND col.TABLE_NAME = '__MigrationLog' AND col.COLUMN_NAME = 'complete_dt')
  BEGIN
    RAISERROR (N'The SQL Change Automation [dbo].[__MigrationLog] table has an incorrect primary key specification. This may be due to the fact that the <SqlChangeAutomationSchemaVersion/> element in your .sqlproj file contains the wrong version number for your database. Please check earlier versions of your .sqlproj file to determine what is the appropriate version for your database (possibly 1.7 or 1.3.1).', 16, 127, N'UNKNOWN')
      WITH NOWAIT;
    RETURN;
  END

IF COL_LENGTH(N'[dbo].[__MigrationLog]', N'sequence_no') IS NULL
  BEGIN
    RAISERROR (N'The SQL Change Automation [dbo].[__MigrationLog] table is missing the [sequence_no] column. This may be due to the fact that the <SqlChangeAutomationSchemaVersion/> element in your .sqlproj file contains the wrong version number for your database. Please check earlier versions of your .sqlproj file to determine what is the appropriate version for your database (possibly 1.7 or 1.3.1).', 16, 127, N'UNKNOWN')
      WITH NOWAIT;
    RETURN;
  END

IF (NOT EXISTS (SELECT * FROM sys.objects WHERE [object_id] = OBJECT_ID(N'[dbo].[__MigrationLogCurrent]') AND [type] = 'V'))
  BEGIN
    EXECUTE ('
	CREATE VIEW [dbo].[__MigrationLogCurrent]
			AS
			WITH currentMigration AS
			(
			  SELECT
				 migration_id, script_checksum, script_filename, complete_dt, applied_by, deployed, ROW_NUMBER() OVER(PARTITION BY migration_id ORDER BY sequence_no DESC) AS RowNumber
			  FROM [dbo].[__MigrationLog]
			)
			SELECT  migration_id, script_checksum, script_filename, complete_dt, applied_by, deployed
			FROM currentMigration
			WHERE RowNumber = 1
	');
  END

GO
PRINT '# Setting up __SchemaSnapshot table';
IF (NOT EXISTS (SELECT * FROM sys.objects WHERE [object_id] = OBJECT_ID(N'[dbo].[__SchemaSnapshot]')))
  BEGIN
    CREATE TABLE [dbo].[__SchemaSnapshot] (
      [Snapshot] VARBINARY (MAX),
      [LastUpdateDate] DATETIME2 CONSTRAINT [__SchemaSnapshotDateDefault] DEFAULT SYSDATETIME());
    IF OBJECT_ID(N'sp_addextendedproperty', 'P') IS NOT NULL
      BEGIN
        EXECUTE sp_addextendedproperty N'MS_Description', N'This table is used by SQL Change Automation projects to store a snapshot of the schema at the time of the last deployment. Please do not alter or remove this table from the database.', 'SCHEMA', N'dbo', 'TABLE', N'__SchemaSnapshot', NULL, NULL;
      END
  END

GO
PRINT '# Truncating __SchemaSnapshot';
TRUNCATE TABLE [dbo].[__SchemaSnapshot];

GO
PRINT '# Check if baseline is required';
DECLARE @baselineRequired AS BIT;

SET @baselineRequired = 0;

IF (EXISTS (SELECT * FROM sys.objects AS o WHERE o.is_ms_shipped = 0 AND NOT (o.name LIKE '%__MigrationLog%' OR o.name LIKE '%__SchemaSnapshot%')) AND (SELECT count(*) FROM [dbo].[__MigrationLog]) = 0)
  SET @baselineRequired = 1;

IF @baselineRequired = 1
  IF '$(ForceDeployWithoutBaseline)' != 'True'
    RAISERROR ('A baseline has not been set for this project, however pre-existing objects have been found in this database. Please set a baseline in the Visual Studio Project Settings, or set ForceDeployWithoutBaseline=True to continue deploying without a baseline.', 16, 127);

GO
SET IMPLICIT_TRANSACTIONS, NUMERIC_ROUNDABORT OFF;
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, NOCOUNT, QUOTED_IDENTIFIER ON;

GO
IF DB_NAME() != '$(DatabaseName)'
  USE [$(DatabaseName)];

GO
IF NOT EXISTS (SELECT 1 FROM [$(DatabaseName)].[dbo].[__MigrationLogCurrent] WHERE [migration_id] = CAST ('12e5f6de-57cb-4306-9967-84097e737154' AS UNIQUEIDENTIFIER))
  PRINT '

***** EXECUTING MIGRATION "Migrations\1.0.0\001_20190625-0815_MitrascaS.sql", ID: {12e5f6de-57cb-4306-9967-84097e737154} *****';

GO
IF EXISTS (SELECT 1 FROM [$(DatabaseName)].[dbo].[__MigrationLogCurrent] WHERE [migration_id] = CAST ('12e5f6de-57cb-4306-9967-84097e737154' AS UNIQUEIDENTIFIER))
BEGIN
  PRINT '----- Skipping "Migrations\1.0.0\001_20190625-0815_MitrascaS.sql", ID: {12e5f6de-57cb-4306-9967-84097e737154} as it has already been run on this database';
  SET NOEXEC ON;
END

GO
EXECUTE ('
PRINT N''Creating role aspnet_Membership_BasicAccess''
');

GO
EXECUTE ('CREATE ROLE [aspnet_Membership_BasicAccess]
AUTHORIZATION [dbo]
');

GO
EXECUTE ('PRINT N''Creating role aspnet_Membership_FullAccess''
');

GO
EXECUTE ('CREATE ROLE [aspnet_Membership_FullAccess]
AUTHORIZATION [dbo]
');

GO
EXECUTE ('PRINT N''Creating role aspnet_Membership_ReportingAccess''
');

GO
EXECUTE ('CREATE ROLE [aspnet_Membership_ReportingAccess]
AUTHORIZATION [dbo]
');

GO
EXECUTE ('PRINT N''Creating role aspnet_Personalization_BasicAccess''
');

GO
EXECUTE ('CREATE ROLE [aspnet_Personalization_BasicAccess]
AUTHORIZATION [dbo]
');

GO
EXECUTE ('PRINT N''Creating role aspnet_Personalization_FullAccess''
');

GO
EXECUTE ('CREATE ROLE [aspnet_Personalization_FullAccess]
AUTHORIZATION [dbo]
');

GO
EXECUTE ('PRINT N''Creating role aspnet_Personalization_ReportingAccess''
');

GO
EXECUTE ('CREATE ROLE [aspnet_Personalization_ReportingAccess]
AUTHORIZATION [dbo]
');

GO
EXECUTE ('PRINT N''Creating role aspnet_Profile_BasicAccess''
');

GO
EXECUTE ('CREATE ROLE [aspnet_Profile_BasicAccess]
AUTHORIZATION [dbo]
');

GO
EXECUTE ('PRINT N''Creating role aspnet_Profile_FullAccess''
');

GO
EXECUTE ('CREATE ROLE [aspnet_Profile_FullAccess]
AUTHORIZATION [dbo]
');

GO
EXECUTE ('PRINT N''Creating role aspnet_Profile_ReportingAccess''
');

GO
EXECUTE ('CREATE ROLE [aspnet_Profile_ReportingAccess]
AUTHORIZATION [dbo]
');

GO
EXECUTE ('PRINT N''Creating role aspnet_Roles_BasicAccess''
');

GO
EXECUTE ('CREATE ROLE [aspnet_Roles_BasicAccess]
AUTHORIZATION [dbo]
');

GO
EXECUTE ('PRINT N''Creating role aspnet_Roles_FullAccess''
');

GO
EXECUTE ('CREATE ROLE [aspnet_Roles_FullAccess]
AUTHORIZATION [dbo]
');

GO
EXECUTE ('PRINT N''Creating role aspnet_Roles_ReportingAccess''
');

GO
EXECUTE ('CREATE ROLE [aspnet_Roles_ReportingAccess]
AUTHORIZATION [dbo]
');

GO
EXECUTE ('PRINT N''Creating role aspnet_WebEvent_FullAccess''
');

GO
EXECUTE ('CREATE ROLE [aspnet_WebEvent_FullAccess]
AUTHORIZATION [dbo]
');

GO
EXECUTE ('PRINT N''Creating role ibalRole''
');

GO
EXECUTE ('CREATE ROLE [ibalRole]
AUTHORIZATION [dbo]
');

GO
EXECUTE ('PRINT N''Altering members of role aspnet_Membership_BasicAccess''
');

GO
EXECUTE ('ALTER ROLE [aspnet_Membership_BasicAccess] ADD MEMBER [aspnet_Membership_FullAccess]
');

GO
EXECUTE ('PRINT N''Altering members of role aspnet_Membership_ReportingAccess''
');

GO
EXECUTE ('ALTER ROLE [aspnet_Membership_ReportingAccess] ADD MEMBER [aspnet_Membership_FullAccess]
');

GO
EXECUTE ('PRINT N''Altering members of role aspnet_Personalization_BasicAccess''
');

GO
EXECUTE ('ALTER ROLE [aspnet_Personalization_BasicAccess] ADD MEMBER [aspnet_Personalization_FullAccess]
');

GO
EXECUTE ('PRINT N''Altering members of role aspnet_Personalization_ReportingAccess''
');

GO
EXECUTE ('ALTER ROLE [aspnet_Personalization_ReportingAccess] ADD MEMBER [aspnet_Personalization_FullAccess]
');

GO
EXECUTE ('PRINT N''Altering members of role aspnet_Profile_BasicAccess''
');

GO
EXECUTE ('ALTER ROLE [aspnet_Profile_BasicAccess] ADD MEMBER [aspnet_Profile_FullAccess]
');

GO
EXECUTE ('PRINT N''Altering members of role aspnet_Profile_ReportingAccess''
');

GO
EXECUTE ('ALTER ROLE [aspnet_Profile_ReportingAccess] ADD MEMBER [aspnet_Profile_FullAccess]
');

GO
EXECUTE ('PRINT N''Altering members of role aspnet_Roles_BasicAccess''
');

GO
EXECUTE ('ALTER ROLE [aspnet_Roles_BasicAccess] ADD MEMBER [aspnet_Roles_FullAccess]
');

GO
EXECUTE ('PRINT N''Altering members of role aspnet_Roles_ReportingAccess''
');

GO
EXECUTE ('ALTER ROLE [aspnet_Roles_ReportingAccess] ADD MEMBER [aspnet_Roles_FullAccess]
');

GO
EXECUTE ('PRINT N''Creating schemas''
');

GO
EXECUTE ('CREATE SCHEMA [admin]
AUTHORIZATION [dbo]
');

GO
EXECUTE ('CREATE SCHEMA [aspnet_Membership_BasicAccess]
AUTHORIZATION [aspnet_Membership_BasicAccess]
');

GO
EXECUTE ('CREATE SCHEMA [aspnet_Membership_FullAccess]
AUTHORIZATION [aspnet_Membership_FullAccess]
');

GO
EXECUTE ('CREATE SCHEMA [aspnet_Membership_ReportingAccess]
AUTHORIZATION [aspnet_Membership_ReportingAccess]
');

GO
EXECUTE ('CREATE SCHEMA [aspnet_Personalization_BasicAccess]
AUTHORIZATION [aspnet_Personalization_BasicAccess]
');

GO
EXECUTE ('CREATE SCHEMA [aspnet_Personalization_FullAccess]
AUTHORIZATION [aspnet_Personalization_FullAccess]
');

GO
EXECUTE ('CREATE SCHEMA [aspnet_Personalization_ReportingAccess]
AUTHORIZATION [aspnet_Personalization_ReportingAccess]
');

GO
EXECUTE ('CREATE SCHEMA [aspnet_Profile_BasicAccess]
AUTHORIZATION [aspnet_Profile_BasicAccess]
');

GO
EXECUTE ('CREATE SCHEMA [aspnet_Profile_FullAccess]
AUTHORIZATION [aspnet_Profile_FullAccess]
');

GO
EXECUTE ('CREATE SCHEMA [aspnet_Profile_ReportingAccess]
AUTHORIZATION [aspnet_Profile_ReportingAccess]
');

GO
EXECUTE ('CREATE SCHEMA [aspnet_Roles_BasicAccess]
AUTHORIZATION [aspnet_Roles_BasicAccess]
');

GO
EXECUTE ('CREATE SCHEMA [aspnet_Roles_FullAccess]
AUTHORIZATION [aspnet_Roles_FullAccess]
');

GO
EXECUTE ('CREATE SCHEMA [aspnet_Roles_ReportingAccess]
AUTHORIZATION [aspnet_Roles_ReportingAccess]
');

GO
EXECUTE ('CREATE SCHEMA [aspnet_WebEvent_FullAccess]
AUTHORIZATION [aspnet_WebEvent_FullAccess]
');

GO
EXECUTE ('CREATE SCHEMA [audit]
AUTHORIZATION [dbo]
');

GO
EXECUTE ('CREATE SCHEMA [marex]
AUTHORIZATION [dbo]
');

GO
EXECUTE ('CREATE SCHEMA [security]
AUTHORIZATION [dbo]
');

GO
EXECUTE ('CREATE SCHEMA [stage]
AUTHORIZATION [dbo]
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_InstrumentType]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_InstrumentType]
(
[InstrumentTypeId] [int] NOT NULL IDENTITY(1, 1),
[Code] [varchar] (100) NOT NULL,
[Name] [varchar] (100) NOT NULL,
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_InstrumentType_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_InstrumentType_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_InstrumentType] on [dbo].[ib_InstrumentType]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_InstrumentType] ADD CONSTRAINT [PK_InstrumentType] PRIMARY KEY CLUSTERED  ([InstrumentTypeId])
');

GO
EXECUTE ('PRINT N''Creating index [AK_InstrumentType_code] on [dbo].[ib_InstrumentType]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_InstrumentType_code] ON [dbo].[ib_InstrumentType] ([Code])
');

GO
EXECUTE ('PRINT N''Creating index [AK_InstrumentType_name] on [dbo].[ib_InstrumentType]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_InstrumentType_name] ON [dbo].[ib_InstrumentType] ([Name])
');

GO
EXECUTE ('PRINT N''Creating trigger [dbo].[InstrumentTypeUpdate] on [dbo].[ib_InstrumentType]''
');

GO
EXECUTE ('
-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE TRIGGER [dbo].[InstrumentTypeUpdate] 
   ON  [dbo].[ib_InstrumentType]
   AFTER UPDATE
	NOT FOR REPLICATION
AS 
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for trigger here
	UPDATE ib_InstrumentType
	SET UpdateDate = CASE WHEN UPDATE(UpdateDate) THEN UpdateDate ELSE GETDATE() END
		, UpdateUsername = CASE WHEN UPDATE(UpdateUsername) THEN UpdateUsername ELSE SUSER_SNAME() END
	WHERE InstrumentTypeId IN (SELECT InstrumentTypeID FROM Inserted)
END


');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Currency]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_Currency]
(
[CurrencyId] [int] NOT NULL IDENTITY(1, 1),
[Code] [varchar] (100) NOT NULL,
[Description] [varchar] (100) NOT NULL,
[IsApproved] [bit] NOT NULL CONSTRAINT [DF_Currency_IsApproved] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_Currency_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_Currency_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL,
[IsActive] [bit] NOT NULL CONSTRAINT [DF__ib_Curren__IsAct__049218CF] DEFAULT ((1))
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_Currency] on [dbo].[ib_Currency]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Currency] ADD CONSTRAINT [PK_Currency] PRIMARY KEY CLUSTERED  ([CurrencyId])
');

GO
EXECUTE ('PRINT N''Creating index [AK_Currency_code] on [dbo].[ib_Currency]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_Currency_code] ON [dbo].[ib_Currency] ([Code]) WHERE ([IsActive]=(1))
');

GO
EXECUTE ('PRINT N''Creating index [AK_Currency_desc] on [dbo].[ib_Currency]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_Currency_desc] ON [dbo].[ib_Currency] ([Description]) WHERE ([IsActive]=(1))
');

GO
EXECUTE ('PRINT N''Creating trigger [dbo].[CurrencyUpdate] on [dbo].[ib_Currency]''
');

GO
EXECUTE ('

-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE TRIGGER [dbo].[CurrencyUpdate] 
   ON  [dbo].[ib_Currency]
   AFTER UPDATE
	NOT FOR REPLICATION
AS 
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for trigger here
	UPDATE ib_Currency
	SET UpdateDate = CASE WHEN UPDATE(UpdateDate) THEN UpdateDate ELSE GETDATE() END
		, UpdateUsername = CASE WHEN UPDATE(UpdateUsername) THEN UpdateUsername ELSE SUSER_SNAME() END
	WHERE CurrencyId IN (SELECT CurrencyID FROM Inserted)
END


');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Site]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_Site]
(
[SiteId] [int] NOT NULL IDENTITY(1, 1),
[Code] [varchar] (100) NOT NULL,
[Name] [varchar] (100) NOT NULL,
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_Site_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_Site_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_Site] on [dbo].[ib_Site]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Site] ADD CONSTRAINT [PK_Site] PRIMARY KEY CLUSTERED  ([SiteId])
');

GO
EXECUTE ('PRINT N''Creating index [AK_code] on [dbo].[ib_Site]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_code] ON [dbo].[ib_Site] ([Code])
');

GO
EXECUTE ('PRINT N''Creating index [AK_name] on [dbo].[ib_Site]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_name] ON [dbo].[ib_Site] ([Name])
');

GO
EXECUTE ('PRINT N''Creating trigger [dbo].[SiteUpdate] on [dbo].[ib_Site]''
');

GO
EXECUTE ('
-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
create TRIGGER [dbo].[SiteUpdate] 
   ON  [dbo].[ib_Site]
   AFTER UPDATE
	NOT FOR REPLICATION
AS 
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for trigger here
	UPDATE ib_Site
	SET UpdateDate = CASE WHEN UPDATE(UpdateDate) THEN UpdateDate ELSE GETDATE() END
		, UpdateUsername = CASE WHEN UPDATE(UpdateUsername) THEN UpdateUsername ELSE SUSER_SNAME() END
	WHERE SiteId IN (SELECT SiteID FROM Inserted)
END


');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_ImbalanceReport]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_ImbalanceReport]
(
[ImbalanceReportId] [int] NOT NULL IDENTITY(1, 1),
[TemplateId] [int] NOT NULL,
[Yesterday] [datetime] NOT NULL,
[Today] [datetime] NOT NULL,
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_ib_ImbalanceReport_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_ib_ImbalanceReport_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_ib_ImbalanceReport] on [dbo].[ib_ImbalanceReport]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_ImbalanceReport] ADD CONSTRAINT [PK_ib_ImbalanceReport] PRIMARY KEY CLUSTERED  ([ImbalanceReportId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_ib_ImbalanceReport_TemplateId] on [dbo].[ib_ImbalanceReport]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_ib_ImbalanceReport_TemplateId] ON [dbo].[ib_ImbalanceReport] ([TemplateId])
');

GO
EXECUTE ('PRINT N''Creating trigger [dbo].[ImbalanceReportUpdate] on [dbo].[ib_ImbalanceReport]''
');

GO
EXECUTE ('
-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
create TRIGGER [dbo].[ImbalanceReportUpdate] 
   ON  [dbo].[ib_ImbalanceReport]
   AFTER UPDATE
	NOT FOR REPLICATION
AS 
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for trigger here
	UPDATE ib_ImbalanceReport
	SET UpdateDate = CASE WHEN UPDATE(UpdateDate) THEN UpdateDate ELSE GETDATE() END
		, UpdateUsername = CASE WHEN UPDATE(UpdateUsername) THEN UpdateUsername ELSE SUSER_SNAME() END
	WHERE ImbalanceReportId IN (SELECT ImbalanceReportID FROM Inserted)
END



');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Instrument]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_Instrument]
(
[InstrumentId] [int] NOT NULL IDENTITY(1, 1),
[InstrumentTypeId] [int] NOT NULL,
[Code] [varchar] (100) NOT NULL,
[Name] [varchar] (100) NOT NULL,
[IsApproved] [bit] NOT NULL CONSTRAINT [DF_Instrument_IsApproved] DEFAULT ((0)),
[LotSize] [decimal] (24, 10) NULL,
[TickSize] [decimal] (24, 10) NULL,
[BaseId] [int] NULL,
[PriceTypeCode] [varchar] (50) NULL,
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_Instrument_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_Instrument_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL,
[IsActive] [bit] NOT NULL CONSTRAINT [DF__ib_Instru__IsAct__47540065] DEFAULT ((1))
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_Instrument] on [dbo].[ib_Instrument]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Instrument] ADD CONSTRAINT [PK_Instrument] PRIMARY KEY CLUSTERED  ([InstrumentId])
');

GO
EXECUTE ('PRINT N''Creating index [AK_Instrument_code] on [dbo].[ib_Instrument]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_Instrument_code] ON [dbo].[ib_Instrument] ([Code]) WHERE ([IsActive]=(1))
');

GO
EXECUTE ('PRINT N''Creating trigger [dbo].[InstrumentUpdate] on [dbo].[ib_Instrument]''
');

GO
EXECUTE ('-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE TRIGGER [dbo].[InstrumentUpdate] 
   ON  [dbo].[ib_Instrument]
   AFTER UPDATE
	NOT FOR REPLICATION
AS 
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for trigger here
	UPDATE ib_Instrument
	SET UpdateDate = CASE WHEN UPDATE(UpdateDate) THEN UpdateDate ELSE GETDATE() END
		, UpdateUsername = CASE WHEN UPDATE(UpdateUsername) THEN UpdateUsername ELSE SUSER_SNAME() END
	WHERE InstrumentId IN (SELECT InstrumentID FROM Inserted)
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_CashGroup]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_CashGroup]
(
[CashGroupId] [int] NOT NULL IDENTITY(1, 1),
[Code] [varchar] (50) NOT NULL,
[Name] [varchar] (100) NOT NULL,
[IsActive] [bit] NOT NULL CONSTRAINT [DF_CashGroup_IsActive] DEFAULT ((1)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_CashGroup_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_CashGroup_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_CashGroup] on [dbo].[ib_CashGroup]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_CashGroup] ADD CONSTRAINT [PK_CashGroup] PRIMARY KEY CLUSTERED  ([CashGroupId])
');

GO
EXECUTE ('PRINT N''Adding constraints to [dbo].[ib_CashGroup]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_CashGroup] ADD CONSTRAINT [AK_CashGroup_Code] UNIQUE NONCLUSTERED  ([Code])
');

GO
EXECUTE ('PRINT N''Adding constraints to [dbo].[ib_CashGroup]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_CashGroup] ADD CONSTRAINT [AK_CashGroup_Name] UNIQUE NONCLUSTERED  ([Name])
');

GO
EXECUTE ('PRINT N''Creating trigger [dbo].[CashGroupUpdate] on [dbo].[ib_CashGroup]''
');

GO
EXECUTE ('CREATE TRIGGER [dbo].[CashGroupUpdate]
    ON [dbo].[ib_CashGroup]
   AFTER UPDATE
	NOT FOR REPLICATION
    AS 
    BEGIN
    	SET NOCOUNT ON

		-- Insert statements for trigger here
		UPDATE [ib_CashGroup]
		SET UpdateDate = CASE WHEN UPDATE(UpdateDate) THEN UpdateDate ELSE GETDATE() END
			, UpdateUsername = CASE WHEN UPDATE(UpdateUsername) THEN UpdateUsername ELSE SUSER_SNAME() END
		WHERE CashGroupId IN (SELECT CashGroupID FROM Inserted)
    END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_CashGroupExchange]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_CashGroupExchange]
(
[CashGroupExchangeId] [int] NOT NULL IDENTITY(1, 1),
[CashGroupId] [int] NOT NULL,
[ExchangeId] [int] NOT NULL,
[SortOrder] [int] NOT NULL CONSTRAINT [DF_CashGroupExchange_SortOrder] DEFAULT ((100)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_CashGroupExchange_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_CashGroupExchange_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_CashGroupExchange] on [dbo].[ib_CashGroupExchange]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_CashGroupExchange] ADD CONSTRAINT [PK_CashGroupExchange] PRIMARY KEY CLUSTERED  ([CashGroupExchangeId])
');

GO
EXECUTE ('PRINT N''Adding constraints to [dbo].[ib_CashGroupExchange]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_CashGroupExchange] ADD CONSTRAINT [AK_CashGroupExchange_Exchange] UNIQUE NONCLUSTERED  ([ExchangeId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_CashGroupExchange_Exchange] on [dbo].[ib_CashGroupExchange]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_CashGroupExchange_Exchange] ON [dbo].[ib_CashGroupExchange] ([ExchangeId])
');

GO
EXECUTE ('PRINT N''Creating trigger [dbo].[CashGroupExchangeUpdate] on [dbo].[ib_CashGroupExchange]''
');

GO
EXECUTE ('CREATE TRIGGER [dbo].[CashGroupExchangeUpdate]
    ON [dbo].[ib_CashGroupExchange]
   AFTER UPDATE
	NOT FOR REPLICATION
    AS 
    BEGIN
    	SET NOCOUNT ON

		-- Insert statements for trigger here
		UPDATE [ib_CashGroupExchange]
		SET UpdateDate = CASE WHEN UPDATE(UpdateDate) THEN UpdateDate ELSE GETDATE() END
			, UpdateUsername = CASE WHEN UPDATE(UpdateUsername) THEN UpdateUsername ELSE SUSER_SNAME() END
		WHERE CashGroupExchangeId IN (SELECT CashGroupExchangeID FROM Inserted)
    END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_CashReportDetail]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_CashReportDetail]
(
[CashReportDetailId] [int] NOT NULL IDENTITY(1, 1),
[CashReportId] [int] NOT NULL,
[DataSourceId] [int] NOT NULL,
[ExchangeId] [int] NOT NULL,
[FirmId] [int] NOT NULL,
[ClassId] [int] NULL,
[AccountId] [int] NULL,
[InstrumentId] [int] NOT NULL,
[CurrencyId] [int] NOT NULL,
[Internal_TOTE] [decimal] (19, 4) NOT NULL,
[Internal_PandS] [decimal] (19, 4) NOT NULL,
[Internal_AdjOTE] [decimal] (19, 4) NOT NULL,
[Internal_AdjSegNon] [decimal] (19, 4) NOT NULL,
[External_TOTE] [decimal] (19, 4) NOT NULL,
[External_PandS] [decimal] (19, 4) NOT NULL,
[External_AdjOTE] [decimal] (19, 4) NOT NULL,
[External_AdjSegNon] [decimal] (19, 4) NOT NULL,
[Difference] [decimal] (19, 4) NOT NULL,
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_CashReportDetail_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_CashReportDetail_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL,
[External_YOTE] [decimal] (19, 4) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_CashReportDetail] on [dbo].[ib_CashReportDetail]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_CashReportDetail] ADD CONSTRAINT [PK_CashReportDetail] PRIMARY KEY CLUSTERED  ([CashReportDetailId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_CashReportDetail_Instrument] on [dbo].[ib_CashReportDetail]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_CashReportDetail_Instrument] ON [dbo].[ib_CashReportDetail] ([InstrumentId])
');

GO
EXECUTE ('PRINT N''Creating trigger [dbo].[CashReportDetailUpdate] on [dbo].[ib_CashReportDetail]''
');

GO
EXECUTE ('CREATE TRIGGER [dbo].[CashReportDetailUpdate]
    ON [dbo].[ib_CashReportDetail]
   AFTER UPDATE
	NOT FOR REPLICATION
    AS 
    BEGIN
    	SET NOCOUNT ON

		-- Insert statements for trigger here
		UPDATE [ib_CashReportDetail]
		SET UpdateDate = CASE WHEN UPDATE(UpdateDate) THEN UpdateDate ELSE GETDATE() END
			, UpdateUsername = CASE WHEN UPDATE(UpdateUsername) THEN UpdateUsername ELSE SUSER_SNAME() END
		WHERE CashReportDetailId IN (SELECT CashReportDetailID FROM Inserted)
    END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Account]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_Account]
(
[AccountId] [int] NOT NULL IDENTITY(1, 1),
[FirmId] [int] NULL,
[Code] [varchar] (100) NOT NULL,
[Name] [varchar] (100) NOT NULL,
[IsApproved] [bit] NOT NULL CONSTRAINT [DF_ib_Account_IsApproved] DEFAULT ((0)),
[ParentAccountId] [int] NULL,
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_Account_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_Account_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL,
[ClassId] [int] NULL,
[IsImported] [bit] NOT NULL CONSTRAINT [DF_ib_Account_IsImported] DEFAULT ((1)),
[FamilyCode] [varchar] (100) NULL,
[IsOmnibus] [bit] NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_Account] on [dbo].[ib_Account]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Account] ADD CONSTRAINT [PK_Account] PRIMARY KEY CLUSTERED  ([AccountId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_Account_Class] on [dbo].[ib_Account]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_Account_Class] ON [dbo].[ib_Account] ([ClassId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_code_firm] on [dbo].[ib_Account]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_code_firm] ON [dbo].[ib_Account] ([Code], [FirmId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_Account_Firm_Account] on [dbo].[ib_Account]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_Account_Firm_Account] ON [dbo].[ib_Account] ([FirmId], [AccountId])
');

GO
EXECUTE ('PRINT N''Creating index [AK_Account_code] on [dbo].[ib_Account]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_Account_code] ON [dbo].[ib_Account] ([FirmId], [Code])
');

GO
EXECUTE ('PRINT N''Creating index [AK_Account_name] on [dbo].[ib_Account]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [AK_Account_name] ON [dbo].[ib_Account] ([FirmId], [Name])
');

GO
EXECUTE ('PRINT N''Creating index [IX_parentAccount] on [dbo].[ib_Account]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_parentAccount] ON [dbo].[ib_Account] ([ParentAccountId])
');

GO
EXECUTE ('PRINT N''Creating trigger [dbo].[AccountUpdate] on [dbo].[ib_Account]''
');

GO
EXECUTE ('-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE TRIGGER [dbo].[AccountUpdate] 
   ON  [dbo].[ib_Account]
   AFTER UPDATE
	NOT FOR REPLICATION
AS 
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for trigger here
	UPDATE ib_Account
	SET UpdateDate = CASE WHEN UPDATE(UpdateDate) THEN UpdateDate ELSE GETDATE() END
		, UpdateUsername = CASE WHEN UPDATE(UpdateUsername) THEN UpdateUsername ELSE SUSER_SNAME() END
	WHERE AccountId IN (SELECT AccountID FROM Inserted)
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Report]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_Report]
(
[ReportId] [int] NOT NULL IDENTITY(1, 1),
[SiteId] [int] NULL,
[ReportType] [varchar] (50) NOT NULL,
[Priority] [smallint] NOT NULL CONSTRAINT [DF_ib_Report_Priority] DEFAULT ((100)),
[TargetReportId] [int] NULL,
[Status] [varchar] (50) NULL,
[Stage] [varchar] (512) NULL,
[Notes] [text] NULL,
[ErrorMessage] [varchar] (512) NULL,
[ErrorDetails] [text] NULL,
[URL] [varchar] (512) NULL,
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_ib_Report_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_ib_Report_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL,
[WebReportURL] [varchar] (256) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_ib_Report] on [dbo].[ib_Report]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Report] ADD CONSTRAINT [PK_ib_Report] PRIMARY KEY CLUSTERED  ([ReportId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_reportType_targetReportId] on [dbo].[ib_Report]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_reportType_targetReportId] ON [dbo].[ib_Report] ([ReportType], [TargetReportId]) INCLUDE ([ErrorMessage], [ReportId])
');

GO
EXECUTE ('PRINT N''Creating trigger [dbo].[ReportUpdate] on [dbo].[ib_Report]''
');

GO
EXECUTE ('
-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
create TRIGGER [dbo].[ReportUpdate] 
   ON  [dbo].[ib_Report]
   AFTER UPDATE
	NOT FOR REPLICATION
AS 
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for trigger here
	UPDATE ib_Report
	SET UpdateDate = CASE WHEN UPDATE(UpdateDate) THEN UpdateDate ELSE GETDATE() END
		, UpdateUsername = CASE WHEN UPDATE(UpdateUsername) THEN UpdateUsername ELSE SUSER_SNAME() END
	WHERE ReportId IN (SELECT ReportID FROM Inserted)
END

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_DataSourceExchange]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_DataSourceExchange]
(
[DataSourceExchangeId] [int] NOT NULL IDENTITY(1, 1),
[DataSourceId] [int] NOT NULL,
[ExchangeId] [int] NOT NULL,
[DataSourceExchangeCode] [varchar] (100) NULL,
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_DataSourceExchange_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_DataSourceExchange_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_DataSourceExchange] on [dbo].[ib_DataSourceExchange]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_DataSourceExchange] ADD CONSTRAINT [PK_DataSourceExchange] PRIMARY KEY CLUSTERED  ([DataSourceExchangeId])
');

GO
EXECUTE ('PRINT N''Creating index [AK_source_exchangeCode] on [dbo].[ib_DataSourceExchange]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_source_exchangeCode] ON [dbo].[ib_DataSourceExchange] ([DataSourceId], [DataSourceExchangeCode])
');

GO
EXECUTE ('PRINT N''Creating trigger [dbo].[DataSourceExchangeUpdate] on [dbo].[ib_DataSourceExchange]''
');

GO
EXECUTE ('
-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
create TRIGGER [dbo].[DataSourceExchangeUpdate] 
   ON  [dbo].[ib_DataSourceExchange]
   AFTER UPDATE
	NOT FOR REPLICATION
AS 
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for trigger here
	UPDATE ib_DataSourceExchange
	SET UpdateDate = CASE WHEN UPDATE(UpdateDate) THEN UpdateDate ELSE GETDATE() END
		, UpdateUsername = CASE WHEN UPDATE(UpdateUsername) THEN UpdateUsername ELSE SUSER_SNAME() END
	WHERE DataSourceExchangeId IN (SELECT DataSourceExchangeID FROM Inserted)
END

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_MatchCode]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_MatchCode]
(
[MatchCodeId] [int] NOT NULL IDENTITY(1, 1),
[TemplateId] [int] NOT NULL,
[MatchCode] [varchar] (100) NOT NULL,
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_ib_MatchCode_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_ib_MatchCode_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL,
[TemplateTypeClassId] [int] NULL,
[BrokerId] [int] NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_ib_MatchCode] on [dbo].[ib_MatchCode]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_MatchCode] ADD CONSTRAINT [PK_ib_MatchCode] PRIMARY KEY CLUSTERED  ([MatchCodeId])
');

GO
EXECUTE ('PRINT N''Creating index [AK_template_matchCode] on [dbo].[ib_MatchCode]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_template_matchCode] ON [dbo].[ib_MatchCode] ([TemplateId], [MatchCode])
');

GO
EXECUTE ('PRINT N''Creating [audit].[ib_MatchCodeHistory]''
');

GO
EXECUTE ('CREATE TABLE [audit].[ib_MatchCodeHistory]
(
[AuditId] [bigint] NOT NULL IDENTITY(1, 1),
[MatchCodeId] [int] NOT NULL,
[TemplateId] [int] NOT NULL,
[MatchCode] [varchar] (100) NOT NULL,
[CreateDate] [datetime] NOT NULL,
[CreateUsername] [varchar] (50) NOT NULL,
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL,
[TemplateTypeClassId] [int] NULL,
[BrokerId] [int] NULL,
[AuditAction] [char] (1) NOT NULL,
[AuditDateUtc] [datetime] NOT NULL CONSTRAINT [DF_ib_MatchCodeHistory_AuditDateUtc] DEFAULT (getutcdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_ib_MatchCodeHistory] on [audit].[ib_MatchCodeHistory]''
');

GO
EXECUTE ('ALTER TABLE [audit].[ib_MatchCodeHistory] ADD CONSTRAINT [PK_ib_MatchCodeHistory] PRIMARY KEY CLUSTERED  ([AuditId])
');

GO
EXECUTE ('PRINT N''Creating trigger [dbo].[tr_ib_MatchCode_Delete] on [dbo].[ib_MatchCode]''
');

GO
EXECUTE ('CREATE TRIGGER [dbo].[tr_ib_MatchCode_Delete] ON [dbo].[ib_MatchCode] FOR DELETE AS INSERT INTO audit.ib_MatchCodeHistory(MatchCodeId,TemplateId,MatchCode,CreateDate,CreateUsername,UpdateDate,UpdateUsername,TemplateTypeClassId,BrokerId,AuditAction) SELECT MatchCodeId,TemplateId,MatchCode,CreateDate,CreateUsername,UpdateDate,UpdateUsername,TemplateTypeClassId,BrokerId,''D'' FROM Deleted
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Position]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_Position]
(
[PositionId] [int] NOT NULL IDENTITY(1, 1),
[DataSourceId] [int] NOT NULL,
[ExchangeId] [int] NOT NULL,
[FirmId] [int] NOT NULL,
[AccountId] [int] NULL,
[AsOfDate] [datetime] NOT NULL,
[InstrumentId] [int] NOT NULL,
[Quantity] [decimal] (19, 4) NOT NULL,
[CurrencyId] [int] NOT NULL,
[MarketValue] [money] NULL,
[ExpiryYear] [smallint] NOT NULL,
[ExpiryMonth] [smallint] NOT NULL,
[ExpiryDay] [smallint] NULL,
[StrikePrice] [money] NULL,
[TrxTypeCode] [varchar] (25) NULL,
[OptionTypeCode] [varchar] (25) NULL,
[TempTableRecordId] [int] NOT NULL,
[ClassId] [int] NULL,
[LongQuantity] [decimal] (19, 4) NULL,
[ShortQuantity] [decimal] (19, 4) NULL,
[TradedLongQuantity] [decimal] (19, 4) NULL,
[TradedShortQuantity] [decimal] (19, 4) NULL,
[UseNetForCloseOut] [bit] NOT NULL CONSTRAINT [DF_ib_Position_UseNetForCloseout] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_Position_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_Position_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL,
[UTI] [varchar] (100) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_Position] on [dbo].[ib_Position]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Position] ADD CONSTRAINT [PK_Position] PRIMARY KEY CLUSTERED  ([PositionId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_account] on [dbo].[ib_Position]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_account] ON [dbo].[ib_Position] ([AccountId])
');

GO
EXECUTE ('PRINT N''Creating index [ix_date_datasource] on [dbo].[ib_Position]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [ix_date_datasource] ON [dbo].[ib_Position] ([AsOfDate], [DataSourceId]) INCLUDE ([CreateDate])
');

GO
EXECUTE ('PRINT N''Creating index [IX_for_imbalance_report] on [dbo].[ib_Position]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_for_imbalance_report] ON [dbo].[ib_Position] ([DataSourceId], [AsOfDate], [ExchangeId], [FirmId], [AccountId], [InstrumentId], [ExpiryYear], [ExpiryMonth], [ExpiryDay], [StrikePrice], [ClassId], [OptionTypeCode], [CurrencyId]) INCLUDE ([MarketValue], [Quantity])
');

GO
EXECUTE ('PRINT N''Creating index [IX_for_closeout_report] on [dbo].[ib_Position]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_for_closeout_report] ON [dbo].[ib_Position] ([DataSourceId], [AsOfDate], [ExchangeId], [FirmId], [AccountId], [InstrumentId], [ExpiryYear], [ExpiryMonth], [ExpiryDay], [UseNetForCloseOut], [StrikePrice], [ClassId], [OptionTypeCode]) INCLUDE ([LongQuantity], [ShortQuantity], [TradedLongQuantity], [TradedShortQuantity])
');

GO
EXECUTE ('PRINT N''Creating index [IX_ib_Position_FileRollback] on [dbo].[ib_Position]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_ib_Position_FileRollback] ON [dbo].[ib_Position] ([DataSourceId], [TempTableRecordId], [PositionId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_ib_Position_ImbalanceReportDrillDown] on [dbo].[ib_Position]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_ib_Position_ImbalanceReportDrillDown] ON [dbo].[ib_Position] ([ExchangeId], [InstrumentId], [CurrencyId], [ExpiryMonth], [ExpiryYear], [ExpiryDay], [AccountId], [ClassId], [PositionId], [FirmId], [DataSourceId], [AsOfDate], [Quantity], [LongQuantity], [ShortQuantity], [MarketValue]) INCLUDE ([OptionTypeCode], [StrikePrice])
');

GO
EXECUTE ('PRINT N''Creating index [IX_firm] on [dbo].[ib_Position]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_firm] ON [dbo].[ib_Position] ([FirmId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_instrument] on [dbo].[ib_Position]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_instrument] ON [dbo].[ib_Position] ([InstrumentId])
');

GO
EXECUTE ('PRINT N''Creating trigger [dbo].[PositionUpdate] on [dbo].[ib_Position]''
');

GO
EXECUTE ('-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE TRIGGER [dbo].[PositionUpdate] 
   ON  [dbo].[ib_Position]
   AFTER UPDATE
	NOT FOR REPLICATION
AS 
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for trigger here
	UPDATE ib_Position
	SET UpdateDate = CASE WHEN UPDATE(UpdateDate) THEN UpdateDate ELSE GETDATE() END
		, UpdateUsername = CASE WHEN UPDATE(UpdateUsername) THEN UpdateUsername ELSE SUSER_SNAME() END
	WHERE PositionId IN (SELECT PositionID FROM Inserted)
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_ConfigurationType]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_ConfigurationType]
(
[ConfigurationTypeId] [int] NOT NULL IDENTITY(1, 1),
[ConfigurationTypeCode] [varchar] (100) NOT NULL,
[ConfigurationTypeDescription] [varchar] (100) NULL,
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_ConfigurationType_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_ConfigurationType_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_ConfigurationType] on [dbo].[ib_ConfigurationType]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_ConfigurationType] ADD CONSTRAINT [PK_ConfigurationType] PRIMARY KEY CLUSTERED  ([ConfigurationTypeId])
');

GO
EXECUTE ('PRINT N''Adding constraints to [dbo].[ib_ConfigurationType]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_ConfigurationType] ADD CONSTRAINT [FK_ConfigurationTypeCode] UNIQUE NONCLUSTERED  ([ConfigurationTypeCode])
');

GO
EXECUTE ('PRINT N''Creating trigger [dbo].[ConfigurationTypeUpdate] on [dbo].[ib_ConfigurationType]''
');

GO
EXECUTE ('

CREATE TRIGGER [dbo].[ConfigurationTypeUpdate]
    ON [dbo].[ib_ConfigurationType]
   AFTER UPDATE
	NOT FOR REPLICATION
    AS 
    BEGIN
    	SET NOCOUNT ON

		-- Insert statements for trigger here
		UPDATE [ib_ConfigurationType]
		SET UpdateDate = CASE WHEN UPDATE(UpdateDate) THEN UpdateDate ELSE GETDATE() END
			, UpdateUsername = CASE WHEN UPDATE(UpdateUsername) THEN UpdateUsername ELSE SUSER_SNAME() END
		WHERE ConfigurationTypeId IN (SELECT ConfigurationTypeID FROM Inserted)
    END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_DataSourceConfiguration]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_DataSourceConfiguration]
(
[DataSourceConfigurationId] [int] NOT NULL IDENTITY(1, 1),
[ConfigurationTypeId] [int] NOT NULL,
[DataSourceId] [int] NOT NULL,
[ConfigValue] [varchar] (100) NULL,
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_DataSourceConfiguration_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_DataSourceConfiguration_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_DataSourceConfigurationId] on [dbo].[ib_DataSourceConfiguration]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_DataSourceConfiguration] ADD CONSTRAINT [PK_DataSourceConfigurationId] PRIMARY KEY CLUSTERED  ([DataSourceConfigurationId])
');

GO
EXECUTE ('PRINT N''Creating trigger [dbo].[DataSourceConfigurationUpdate] on [dbo].[ib_DataSourceConfiguration]''
');

GO
EXECUTE ('

CREATE TRIGGER [dbo].[DataSourceConfigurationUpdate]
    ON [dbo].[ib_DataSourceConfiguration]
   AFTER UPDATE
	NOT FOR REPLICATION
    AS 
    BEGIN
    	SET NOCOUNT ON

		-- Insert statements for trigger here
		UPDATE [ib_DataSourceConfiguration]
		SET UpdateDate = CASE WHEN UPDATE(UpdateDate) THEN UpdateDate ELSE GETDATE() END
			, UpdateUsername = CASE WHEN UPDATE(UpdateUsername) THEN UpdateUsername ELSE SUSER_SNAME() END
		WHERE DataSourceConfigurationId IN (SELECT DataSourceConfigurationID FROM Inserted)
    END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Fee]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_Fee]
(
[FeeId] [int] NOT NULL IDENTITY(1, 1),
[TrxId] [int] NOT NULL,
[FeeTypeId] [int] NOT NULL,
[CurrencyId] [int] NOT NULL,
[Amount] [decimal] (19, 6) NOT NULL,
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_ib_Fee_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_ib_Fee_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_ib_Fee] on [dbo].[ib_Fee]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Fee] ADD CONSTRAINT [PK_ib_Fee] PRIMARY KEY CLUSTERED  ([FeeId])
');

GO
EXECUTE ('PRINT N''Creating index [AK_trx_feetype] on [dbo].[ib_Fee]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_trx_feetype] ON [dbo].[ib_Fee] ([TrxId], [FeeTypeId])
');

GO
EXECUTE ('PRINT N''Creating trigger [dbo].[FeeUpdate] on [dbo].[ib_Fee]''
');

GO
EXECUTE ('
-- =============================================
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE TRIGGER [dbo].[FeeUpdate] 
   ON  [dbo].[ib_Fee]
   AFTER UPDATE
	NOT FOR REPLICATION
AS 
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for trigger here
	UPDATE ib_Fee
	SET UpdateDate = CASE WHEN UPDATE(UpdateDate) THEN UpdateDate ELSE GETDATE() END
		, UpdateUsername = CASE WHEN UPDATE(UpdateUsername) THEN UpdateUsername ELSE SUSER_SNAME() END
	WHERE FeeId IN (SELECT FeeID FROM Inserted)
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_DataSourceMapping]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_DataSourceMapping]
(
[DataSourceMappingId] [int] NOT NULL IDENTITY(1, 1),
[DataSourceId] [int] NOT NULL,
[DataSourceExchangeCode] [varchar] (100) NOT NULL,
[MappedDataSourceId] [int] NOT NULL,
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_ib_DataSourceMapping_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_ib_DataSourceMapping_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_ib_DataSourceMapping] on [dbo].[ib_DataSourceMapping]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_DataSourceMapping] ADD CONSTRAINT [PK_ib_DataSourceMapping] PRIMARY KEY CLUSTERED  ([DataSourceMappingId])
');

GO
EXECUTE ('PRINT N''Creating index [AK_datasource_exchange] on [dbo].[ib_DataSourceMapping]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_datasource_exchange] ON [dbo].[ib_DataSourceMapping] ([DataSourceId], [DataSourceExchangeCode])
');

GO
EXECUTE ('PRINT N''Creating trigger [dbo].[DataSourceMappingUpdate] on [dbo].[ib_DataSourceMapping]''
');

GO
EXECUTE ('
-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
create TRIGGER [dbo].[DataSourceMappingUpdate] 
   ON  [dbo].[ib_DataSourceMapping]
   AFTER UPDATE
	NOT FOR REPLICATION
AS 
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for trigger here
	UPDATE ib_DataSourceMapping
	SET UpdateDate = CASE WHEN UPDATE(UpdateDate) THEN UpdateDate ELSE GETDATE() END
		, UpdateUsername = CASE WHEN UPDATE(UpdateUsername) THEN UpdateUsername ELSE SUSER_SNAME() END
	WHERE DataSourceMappingId IN (SELECT DataSourceMappingID FROM Inserted)
END


');

GO
EXECUTE ('PRINT N''Creating [dbo].[aspnet_Membership]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[aspnet_Membership]
(
[ApplicationId] [uniqueidentifier] NOT NULL,
[UserId] [uniqueidentifier] NOT NULL,
[Password] [nvarchar] (128) NOT NULL,
[PasswordFormat] [int] NOT NULL CONSTRAINT [DF__aspnet_Me__Passw__677F4227] DEFAULT ((0)),
[PasswordSalt] [nvarchar] (128) NOT NULL,
[MobilePIN] [nvarchar] (16) NULL,
[Email] [nvarchar] (256) NULL,
[LoweredEmail] [nvarchar] (256) NULL,
[PasswordQuestion] [nvarchar] (256) NULL,
[PasswordAnswer] [nvarchar] (128) NULL,
[IsApproved] [bit] NOT NULL,
[IsLockedOut] [bit] NOT NULL,
[CreateDate] [datetime] NOT NULL,
[LastLoginDate] [datetime] NOT NULL,
[LastPasswordChangedDate] [datetime] NOT NULL,
[LastLockoutDate] [datetime] NOT NULL,
[FailedPasswordAttemptCount] [int] NOT NULL,
[FailedPasswordAttemptWindowStart] [datetime] NOT NULL,
[FailedPasswordAnswerAttemptCount] [int] NOT NULL,
[FailedPasswordAnswerAttemptWindowStart] [datetime] NOT NULL,
[Comment] [ntext] NULL
)
');

GO
EXECUTE ('PRINT N''Creating index [aspnet_Membership_index] on [dbo].[aspnet_Membership]''
');

GO
EXECUTE ('CREATE CLUSTERED INDEX [aspnet_Membership_index] ON [dbo].[aspnet_Membership] ([ApplicationId], [LoweredEmail])
');

GO
EXECUTE ('PRINT N''Creating primary key [PK__aspnet_Membershi__64A2D57C] on [dbo].[aspnet_Membership]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[aspnet_Membership] ADD CONSTRAINT [PK__aspnet_Membershi__64A2D57C] PRIMARY KEY NONCLUSTERED  ([UserId])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_PasswordHistory]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_PasswordHistory]
(
[PasswordHistoryId] [int] NOT NULL IDENTITY(1, 1),
[UserId] [uniqueidentifier] NOT NULL,
[Password] [nvarchar] (128) NOT NULL,
[PasswordSalt] [nvarchar] (128) NOT NULL,
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_PasswordHistory_CreateDate] DEFAULT (getdate()),
[CreateUsername] [nvarchar] (50) NOT NULL CONSTRAINT [DF_PasswordHistory_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [nvarchar] (50) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_PasswordHistory] on [dbo].[ib_PasswordHistory]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_PasswordHistory] ADD CONSTRAINT [PK_PasswordHistory] PRIMARY KEY CLUSTERED  ([PasswordHistoryId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_PasswordHistory_UC] on [dbo].[ib_PasswordHistory]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_PasswordHistory_UC] ON [dbo].[ib_PasswordHistory] ([UserId], [CreateDate] DESC)
');

GO
EXECUTE ('PRINT N''Creating trigger [dbo].[MembershipUpdate] on [dbo].[aspnet_Membership]''
');

GO
EXECUTE ('-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE TRIGGER [dbo].[MembershipUpdate] 
   ON  [dbo].[aspnet_Membership]
   FOR UPDATE
	NOT FOR REPLICATION
AS 
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for trigger here


IF NOT EXISTS(SELECT TOP(1) *
				FROM [ib_PasswordHistory] tempIns 
				INNER JOIN INSERTED ins ON tempIns.UserId = ins.UserId
				  AND tempIns.PasswordSalt = ins.PasswordSalt
				  AND tempIns.[Password] = ins.[Password]
				)

BEGIN
	INSERT INTO [dbo].[ib_PasswordHistory]
			   ([UserId]
			   ,[Password]
			   ,[PasswordSalt]
			   ,[CreateDate]
			   ,[CreateUsername]
			   ,[UpdateDate]
			   ,[UpdateUsername])
	SELECT	UserId, 
			[Password], 
			[PasswordSalt], 
			GETDATE(), 
			SUSER_SNAME(),
			NULL,
			NULL
	FROM INSERTED ins
	WHERE NOT EXISTS (	SELECT TOP(1) *
							FROM [ib_PasswordHistory] tempIns 
							WHERE tempIns.UserId = ins.UserId
							  AND tempIns.PasswordSalt = ins.PasswordSalt
							  AND tempIns.[Password] = ins.[Password]
							  )
END
ELSE
BEGIN
	UPDATE [dbo].[ib_PasswordHistory] SET UpdateDate = GETDATE(), UpdateUsername = SUSER_SNAME()
	FROM INSERTED ins
	INNER JOIN [ib_PasswordHistory] tempIns ON tempIns.UserId = ins.UserId 
		AND tempIns.PasswordSalt = ins.PasswordSalt
		AND tempIns.[Password] = ins.[Password]
END
END

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_CurrencyDataSource]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_CurrencyDataSource]
(
[CurrencyDataSourceId] [int] NOT NULL IDENTITY(1, 1),
[CurrencyId] [int] NOT NULL,
[DataSourceId] [int] NOT NULL,
[DataSourceCurrencyCode] [varchar] (100) NOT NULL,
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_CurrencyExchange_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_CurrencyExchange_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_CurrencyDataSource] on [dbo].[ib_CurrencyDataSource]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_CurrencyDataSource] ADD CONSTRAINT [PK_CurrencyDataSource] PRIMARY KEY CLUSTERED  ([CurrencyDataSourceId])
');

GO
EXECUTE ('PRINT N''Creating index [AK_CurrencyDataSource_code] on [dbo].[ib_CurrencyDataSource]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_CurrencyDataSource_code] ON [dbo].[ib_CurrencyDataSource] ([DataSourceId], [DataSourceCurrencyCode])
');

GO
EXECUTE ('PRINT N''Creating trigger [dbo].[CurrencyDataSourceUpdate] on [dbo].[ib_CurrencyDataSource]''
');

GO
EXECUTE ('
-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
create TRIGGER [dbo].[CurrencyDataSourceUpdate] 
   ON  [dbo].[ib_CurrencyDataSource]
   AFTER UPDATE
	NOT FOR REPLICATION
AS 
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for trigger here
	UPDATE ib_CurrencyDataSource
	SET UpdateDate = CASE WHEN UPDATE(UpdateDate) THEN UpdateDate ELSE GETDATE() END
		, UpdateUsername = CASE WHEN UPDATE(UpdateUsername) THEN UpdateUsername ELSE SUSER_SNAME() END
	WHERE CurrencyDataSourceId IN (SELECT CurrencyDataSourceID FROM Inserted)
END


');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_BaseDataSource]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_BaseDataSource]
(
[BaseDataSourceId] [int] NOT NULL IDENTITY(1, 1),
[BaseId] [int] NOT NULL,
[DataSourceId] [int] NOT NULL,
[DataSourceBaseCode] [varchar] (100) NOT NULL,
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_ib_BaseDataSource_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_ib_BaseDataSource_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_ib_BaseDataSource] on [dbo].[ib_BaseDataSource]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_BaseDataSource] ADD CONSTRAINT [PK_ib_BaseDataSource] PRIMARY KEY CLUSTERED  ([BaseDataSourceId])
');

GO
EXECUTE ('PRINT N''Creating index [AK_datasource_code] on [dbo].[ib_BaseDataSource]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_datasource_code] ON [dbo].[ib_BaseDataSource] ([DataSourceId], [DataSourceBaseCode])
');

GO
EXECUTE ('PRINT N''Creating trigger [dbo].[BaseDataSourceUpdate] on [dbo].[ib_BaseDataSource]''
');

GO
EXECUTE ('
-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
create TRIGGER [dbo].[BaseDataSourceUpdate] 
   ON  [dbo].[ib_BaseDataSource]
   AFTER UPDATE
	NOT FOR REPLICATION
AS 
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for trigger here
	UPDATE ib_BaseDataSource
	SET UpdateDate = CASE WHEN UPDATE(UpdateDate) THEN UpdateDate ELSE GETDATE() END
		, UpdateUsername = CASE WHEN UPDATE(UpdateUsername) THEN UpdateUsername ELSE SUSER_SNAME() END
	WHERE BaseDataSourceId IN (SELECT BaseDataSourceID FROM Inserted)
END



');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TemplateGroup]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_TemplateGroup]
(
[TemplateGroupId] [int] NOT NULL IDENTITY(1, 1),
[TemplateId] [int] NOT NULL,
[ExchangeId] [int] NULL,
[FirmId] [int] NULL,
[ClassId] [int] NULL,
[AccountId] [int] NULL,
[InstrumentId] [int] NULL,
[Description] [varchar] (100) NOT NULL,
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_TemplateGroup_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_TemplateGroup_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL,
[CurrencyId] [int] NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_TemplateGroup] on [dbo].[ib_TemplateGroup]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_TemplateGroup] ADD CONSTRAINT [PK_TemplateGroup] PRIMARY KEY CLUSTERED  ([TemplateGroupId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_nostro_main_page] on [dbo].[ib_TemplateGroup]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_nostro_main_page] ON [dbo].[ib_TemplateGroup] ([TemplateId], [AccountId], [CurrencyId], [Description])
');

GO
EXECUTE ('PRINT N''Creating index [AK_template_match_fields] on [dbo].[ib_TemplateGroup]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_template_match_fields] ON [dbo].[ib_TemplateGroup] ([TemplateId], [ExchangeId], [FirmId], [AccountId], [InstrumentId], [ClassId], [CurrencyId])
');

GO
EXECUTE ('PRINT N''Creating [audit].[ib_TemplateGroupHistory]''
');

GO
EXECUTE ('CREATE TABLE [audit].[ib_TemplateGroupHistory]
(
[AuditId] [bigint] NOT NULL IDENTITY(1, 1),
[TemplateGroupId] [int] NOT NULL,
[TemplateId] [int] NOT NULL,
[ExchangeId] [int] NULL,
[FirmId] [int] NULL,
[ClassId] [int] NULL,
[AccountId] [int] NULL,
[InstrumentId] [int] NULL,
[Description] [varchar] (100) NOT NULL,
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF__ib_Templa__Creat__1D20317C] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF__ib_Templa__Creat__1E1455B5] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL,
[CurrencyId] [int] NULL,
[AuditAction] [char] (1) NOT NULL,
[AuditDateUtc] [datetime] NOT NULL CONSTRAINT [DF__ib_Templa__Audit__1F0879EE] DEFAULT (getutcdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK__ib_Templ__A17F23988754FB7E] on [audit].[ib_TemplateGroupHistory]''
');

GO
EXECUTE ('ALTER TABLE [audit].[ib_TemplateGroupHistory] ADD CONSTRAINT [PK__ib_Templ__A17F23988754FB7E] PRIMARY KEY CLUSTERED  ([AuditId])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_MatchCode_AddAsNeeded]''
');

GO
EXECUTE ('

-- =============================================
-- Author:		Konrad
-- Create date: 26 Feb 09
-- Description:	Add MatchCode to the ib_MatchCode table if not exists
-- 29 Apr 2014  ED  EIB 25517 - trim code

CREATE PROC [dbo].[ib_MatchCode_AddAsNeeded]
	(
		@TemplateId         int,
		@Code				varchar(100),
		@CreateUsername		varchar(50)
	)

AS
SET NOCOUNT ON

	DECLARE	@OutPut			int
	SET @Code = LTRIM(RTRIM(@Code))
	SELECT @OutPut = mc.MatchCodeId
	FROM ib_MatchCode mc
	WHERE mc.MatchCode = @Code AND
		  mc.TemplateId = @TemplateId
	
	IF @OutPut IS NULL
	BEGIN
		INSERT INTO [dbo].[ib_MatchCode]
							(
								[MatchCode],
								[TemplateId],
								CreateUsername
							)
						VALUES
							(
								@Code,
								@TemplateId,
								@CreateUsername
							) 
	END
');

GO
EXECUTE ('PRINT N''Creating trigger [dbo].[TemplateGroupInsert] on [dbo].[ib_TemplateGroup]''
');

GO
EXECUTE ('CREATE TRIGGER [dbo].[TemplateGroupInsert] 
   ON  [dbo].[ib_TemplateGroup]
   AFTER INSERT
	NOT FOR REPLICATION
AS 
BEGIN
	--	24 Nov 2010		amk		MBAL-16391: bug fix - allow for multiple rows inserted
	--										(when it comes to adding match code records)

	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	DECLARE @TemplateId INT
	DECLARE	@Code VARCHAR(100)
	DECLARE	@CreateUserName VARCHAR(50)

    DECLARE newRecords CURSOR FORWARD_ONLY FOR
    SELECT TemplateId, [Description],CreateUsername
	FROM inserted

	OPEN newRecords

    FETCH newRecords INTO @TemplateId, @Code, @CreateUserName
    WHILE (@@FETCH_STATUS = 0)
    BEGIN
		EXEC ib_MatchCode_AddAsNeeded @TemplateId, @Code, @CreateUserName
	    FETCH newRecords INTO @TemplateId, @Code, @CreateUserName
    END

    CLOSE newRecords
    DEALLOCATE newRecords

    -- Insert statements for trigger here
	UPDATE ib_TemplateGroup
	SET UpdateDate = CASE WHEN UPDATE(UpdateDate) THEN UpdateDate ELSE GETDATE() END
		, UpdateUsername = CASE WHEN UPDATE(UpdateUsername) THEN UpdateUsername ELSE SUSER_SNAME() END
	WHERE TemplateGroupId IN (SELECT TemplateGroupID FROM Inserted)

	INSERT INTO audit.ib_TemplateGroupHistory(TemplateGroupId, TemplateId, ExchangeId, FirmId, ClassId, AccountId, InstrumentId, Description, CreateDate, CreateUsername, UpdateDate, UpdateUsername, CurrencyId,AuditAction) SELECT TemplateGroupId, TemplateId, ExchangeId, FirmId, ClassId, AccountId, InstrumentId, Description, CreateDate, CreateUsername, UpdateDate, UpdateUsername, CurrencyId,''I'' FROM Inserted;
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Equity]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_Equity]
(
[EquityId] [int] NOT NULL IDENTITY(1, 1),
[EquityHeaderId] [int] NOT NULL,
[InternalExternalCode] [char] (1) NOT NULL,
[OpenBalance] [decimal] (19, 6) NOT NULL,
[Commission] [decimal] (19, 6) NOT NULL,
[RealisedPL] [decimal] (19, 6) NOT NULL,
[OptionPremium] [decimal] (19, 6) NOT NULL,
[JournalCash] [decimal] (19, 6) NOT NULL,
[Adjustments] [decimal] (19, 6) NOT NULL,
[OpenTradeEquity] [decimal] (19, 6) NOT NULL,
[FuturesPL] [decimal] (19, 6) NOT NULL,
[OptionsPL] [decimal] (19, 6) NOT NULL,
[PendingCash] [decimal] (19, 6) NOT NULL CONSTRAINT [DF_ib_Equity_PendingCash] DEFAULT ((0)),
[OptionValueDiff] [decimal] (19, 6) NOT NULL CONSTRAINT [DF_ib_Equity_OptionValueDiff] DEFAULT ((0)),
[OpenOptionValue] [decimal] (19, 6) NOT NULL CONSTRAINT [DF_ib_Equity_OpenOptionValue] DEFAULT ((0)),
[Collateral] [decimal] (19, 6) NOT NULL,
[InitialMargin] [decimal] (19, 6) NOT NULL,
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_ib_Equity_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_ib_Equity_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL,
[Premium] [decimal] (19, 6) NOT NULL CONSTRAINT [DF_ib_Equity_Premium] DEFAULT ((0))
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_ib_Equity] on [dbo].[ib_Equity]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Equity] ADD CONSTRAINT [PK_ib_Equity] PRIMARY KEY CLUSTERED  ([EquityId])
');

GO
EXECUTE ('PRINT N''Creating index [AK_hdr_intext] on [dbo].[ib_Equity]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_hdr_intext] ON [dbo].[ib_Equity] ([EquityHeaderId], [InternalExternalCode])
');

GO
EXECUTE ('PRINT N''Creating trigger [dbo].[EquityUpdate] on [dbo].[ib_Equity]''
');

GO
EXECUTE ('-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
create TRIGGER [dbo].[EquityUpdate] 
   ON  [dbo].[ib_Equity]
   AFTER UPDATE
	NOT FOR REPLICATION
AS 
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for trigger here
	UPDATE ib_Equity
	SET UpdateDate = CASE WHEN UPDATE(UpdateDate) THEN UpdateDate ELSE GETDATE() END
		, UpdateUsername = CASE WHEN UPDATE(UpdateUsername) THEN UpdateUsername ELSE SUSER_SNAME() END
	WHERE EquityId IN (SELECT EquityID FROM Inserted)
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_CashReport]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_CashReport]
(
[CashReportId] [int] NOT NULL IDENTITY(1, 1),
[ImbalanceReportId] [int] NULL,
[TodaysDate] [datetime] NOT NULL,
[ProducedExportFiles] [bit] NOT NULL,
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_CashReport_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_CashReport_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_CashReport] on [dbo].[ib_CashReport]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_CashReport] ADD CONSTRAINT [PK_CashReport] PRIMARY KEY CLUSTERED  ([CashReportId])
');

GO
EXECUTE ('PRINT N''Creating trigger [dbo].[CashReportUpdate] on [dbo].[ib_CashReport]''
');

GO
EXECUTE ('CREATE TRIGGER [dbo].[CashReportUpdate]
    ON [dbo].[ib_CashReport]
   AFTER UPDATE
	NOT FOR REPLICATION
    AS 
    BEGIN
    	SET NOCOUNT ON

		-- Insert statements for trigger here
		UPDATE [ib_CashReport]
		SET UpdateDate = CASE WHEN UPDATE(UpdateDate) THEN UpdateDate ELSE GETDATE() END
			, UpdateUsername = CASE WHEN UPDATE(UpdateUsername) THEN UpdateUsername ELSE SUSER_SNAME() END
		WHERE CashReportId IN (SELECT CashReportID FROM Inserted)
    END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TrxType]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_TrxType]
(
[TrxTypeId] [int] NOT NULL IDENTITY(1, 1),
[DataSourceId] [int] NOT NULL,
[Code] [varchar] (100) NOT NULL,
[Description] [varchar] (100) NOT NULL,
[IsPosition] [bit] NOT NULL CONSTRAINT [DF_ib_TrxType_IsPosition] DEFAULT ((0)),
[IsPremium] [bit] NOT NULL CONSTRAINT [DF_ib_TrxType_IsPremium] DEFAULT ((0)),
[IsPandS] [bit] NOT NULL CONSTRAINT [DF_ib_TrxType_IsPandS] DEFAULT ((0)),
[IsPandL] [bit] NOT NULL CONSTRAINT [DF_ib_TrxType_IsPandL] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_ib_TrxType_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_ib_TrxType_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL,
[IsTrade] [bit] NULL CONSTRAINT [DF__ib_TrxTyp__IsTra__412625C3] DEFAULT ((0)),
[ExcludeFromTradeRec] [bit] NOT NULL CONSTRAINT [DF_ib_TrxType_ExcludeFromTradeRec] DEFAULT ((0)),
[IsCancellation] [bit] NOT NULL CONSTRAINT [DF_ib_TrxType_IsCancellation] DEFAULT ((0)),
[IsOptionMarketValue] [bit] NOT NULL CONSTRAINT [DF_ib_TrxType_IsOptionMarketValue] DEFAULT ((0)),
[IsAutoMatched] [bit] NOT NULL CONSTRAINT [DF__ib_TrxTyp__IsAut__421A49FC] DEFAULT ((0))
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_ib_TrxType] on [dbo].[ib_TrxType]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_TrxType] ADD CONSTRAINT [PK_ib_TrxType] PRIMARY KEY CLUSTERED  ([TrxTypeId])
');

GO
EXECUTE ('PRINT N''Creating index [AK_datasource_code] on [dbo].[ib_TrxType]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_datasource_code] ON [dbo].[ib_TrxType] ([DataSourceId], [Code])
');

GO
EXECUTE ('PRINT N''Creating index [AK_datasource_desc] on [dbo].[ib_TrxType]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_datasource_desc] ON [dbo].[ib_TrxType] ([DataSourceId], [Description])
');

GO
EXECUTE ('PRINT N''Creating trigger [dbo].[TrxTypeUpdate] on [dbo].[ib_TrxType]''
');

GO
EXECUTE ('-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
create TRIGGER [dbo].[TrxTypeUpdate] 
   ON  [dbo].[ib_TrxType]
   AFTER UPDATE
	NOT FOR REPLICATION
AS 
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for trigger here
	UPDATE ib_TrxType
	SET UpdateDate = CASE WHEN UPDATE(UpdateDate) THEN UpdateDate ELSE GETDATE() END
		, UpdateUsername = CASE WHEN UPDATE(UpdateUsername) THEN UpdateUsername ELSE SUSER_SNAME() END
	WHERE TrxTypeId IN (SELECT TrxTypeID FROM Inserted)
END
');

GO
EXECUTE ('PRINT N''Creating [admin].[AppVersion]''
');

GO
EXECUTE ('CREATE TABLE [admin].[AppVersion]
(
[AppVersionId] [int] NOT NULL IDENTITY(1, 1),
[VersionNumber] [varchar] (50) NOT NULL,
[ComponentCode] [varchar] (50) NOT NULL,
[ComponentName] [varchar] (200) NOT NULL,
[IsSolution] [bit] NOT NULL CONSTRAINT [DF_admin.Version_IsSolution] DEFAULT ((0)),
[IsAdapter] [bit] NOT NULL CONSTRAINT [DF_admin.Version_IsAdapter] DEFAULT ((0)),
[Notes] [varchar] (max) NULL,
[CreateDateTimeUtc] [smalldatetime] NOT NULL CONSTRAINT [DF_admin.Version_CreateDateTime] DEFAULT (getutcdate()),
[CreateUserName] [varchar] (100) NOT NULL CONSTRAINT [DF_admin.Version_CreateUserName] DEFAULT (suser_sname()),
[UpdateDateTimeUtc] [smalldatetime] NULL,
[UpdateUserName] [varchar] (100) NULL,
[ServerList] [varchar] (max) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_Version] on [admin].[AppVersion]''
');

GO
EXECUTE ('ALTER TABLE [admin].[AppVersion] ADD CONSTRAINT [PK_Version] PRIMARY KEY CLUSTERED  ([AppVersionId])
');

GO
EXECUTE ('PRINT N''Creating index [AK_ComponentCode] on [admin].[AppVersion]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_ComponentCode] ON [admin].[AppVersion] ([ComponentCode])
');

GO
EXECUTE ('PRINT N''Creating [audit].[AppVersionHistory]''
');

GO
EXECUTE ('CREATE TABLE [audit].[AppVersionHistory]
(
[AppVersionHistoryId] [int] NOT NULL IDENTITY(1, 1),
[AppVersionId] [int] NOT NULL,
[VersionNumber] [varchar] (50) NOT NULL,
[ComponentCode] [varchar] (50) NOT NULL,
[ComponentName] [varchar] (200) NOT NULL,
[IsSolution] [bit] NOT NULL,
[Notes] [varchar] (max) NULL,
[CreateDateTimeUtc] [smalldatetime] NOT NULL,
[CreateUserName] [varchar] (100) NOT NULL,
[UpdateDateTimeUtc] [smalldatetime] NULL,
[UpdateUserName] [varchar] (100) NULL,
[AuditDateTimeUtc] [varchar] (100) NOT NULL CONSTRAINT [DF_audit.Version_AuditDateTimeUtc] DEFAULT (getutcdate()),
[Action] [char] (1) NOT NULL,
[ServerList] [varchar] (max) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_Version_1] on [audit].[AppVersionHistory]''
');

GO
EXECUTE ('ALTER TABLE [audit].[AppVersionHistory] ADD CONSTRAINT [PK_Version_1] PRIMARY KEY CLUSTERED  ([AppVersionHistoryId])
');

GO
EXECUTE ('PRINT N''Creating trigger [admin].[AppVersion_Audit_Delete] on [admin].[AppVersion]''
');

GO
EXECUTE ('CREATE TRIGGER  [admin].[AppVersion_Audit_Delete]
ON [admin].[AppVersion]
AFTER DELETE
AS 
BEGIN 
	INSERT INTO audit.[AppVersionHistory] ([AppVersionId],[VersionNumber],[ComponentCode],[ComponentName],[IsSolution],[Notes],[CreateDateTimeUtc],[CreateUserName],[UpdateDateTimeUtc],[UpdateUserName], [Action],[ServerList])
	SELECT [AppVersionId],[VersionNumber],[ComponentCode],[ComponentName],[IsSolution],[Notes],[CreateDateTimeUtc],[CreateUserName],[UpdateDateTimeUtc],[UpdateUserName], ''D'',[ServerList] FROM DELETED

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_FeeType]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_FeeType]
(
[FeeTypeId] [int] NOT NULL IDENTITY(1, 1),
[Code] [varchar] (100) NOT NULL,
[Description] [varchar] (100) NOT NULL,
[IncludeInEquity] [bit] NOT NULL CONSTRAINT [DF_ib_FeeType_IncludeInEquity] DEFAULT ((1)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_ib_FeeType_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_ib_FeeType_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_ib_FeeType] on [dbo].[ib_FeeType]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_FeeType] ADD CONSTRAINT [PK_ib_FeeType] PRIMARY KEY CLUSTERED  ([FeeTypeId])
');

GO
EXECUTE ('PRINT N''Creating index [AK_code] on [dbo].[ib_FeeType]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_code] ON [dbo].[ib_FeeType] ([Code])
');

GO
EXECUTE ('PRINT N''Creating index [AK_desc] on [dbo].[ib_FeeType]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_desc] ON [dbo].[ib_FeeType] ([Description])
');

GO
EXECUTE ('PRINT N''Creating trigger [dbo].[FeeTypeUpdate] on [dbo].[ib_FeeType]''
');

GO
EXECUTE ('-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
create TRIGGER [dbo].[FeeTypeUpdate] 
   ON  [dbo].[ib_FeeType]
   AFTER UPDATE
	NOT FOR REPLICATION
AS 
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for trigger here
	UPDATE ib_FeeType
	SET UpdateDate = CASE WHEN UPDATE(UpdateDate) THEN UpdateDate ELSE GETDATE() END
		, UpdateUsername = CASE WHEN UPDATE(UpdateUsername) THEN UpdateUsername ELSE SUSER_SNAME() END
	WHERE FeeTypeId IN (SELECT FeeTypeID FROM Inserted)
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_DataSource]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_DataSource]
(
[DataSourceId] [int] NOT NULL IDENTITY(1, 1),
[Code] [varchar] (100) NOT NULL,
[Name] [varchar] (100) NOT NULL,
[DefaultCurrencyId] [int] NOT NULL,
[ProvidesVariation] [bit] NOT NULL CONSTRAINT [DF_ib_DataSource_ProvidesVariation] DEFAULT ((0)),
[DefaultStrikePriceDivisor] [decimal] (19, 6) NULL,
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_DataSource_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_DataSource_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL,
[IncludeDetailAccountInTradeReconciliation] [bit] NOT NULL CONSTRAINT [DF_DataSource_IncludeDetailAccountInTradeReconciliation] DEFAULT ((1)),
[UseTrxsForTradedOnDay] [bit] NOT NULL CONSTRAINT [DF_UseTrxsForTradedOnDay] DEFAULT ((0)),
[DoPositionsRealiseCash] [bit] NOT NULL CONSTRAINT [DF_DoPositionsRealiseCash] DEFAULT ((0)),
[DoExcludePremiumUpFrontInTradeRec] [bit] NOT NULL CONSTRAINT [DF_DoExcludePremiumUpFrontInTradeRec] DEFAULT ((0))
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_DataSource] on [dbo].[ib_DataSource]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_DataSource] ADD CONSTRAINT [PK_DataSource] PRIMARY KEY CLUSTERED  ([DataSourceId])
');

GO
EXECUTE ('PRINT N''Creating index [AK_code] on [dbo].[ib_DataSource]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_code] ON [dbo].[ib_DataSource] ([Code])
');

GO
EXECUTE ('PRINT N''Creating index [Ak_name] on [dbo].[ib_DataSource]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [Ak_name] ON [dbo].[ib_DataSource] ([Name])
');

GO
EXECUTE ('PRINT N''Creating trigger [dbo].[DataSourceUpdate] on [dbo].[ib_DataSource]''
');

GO
EXECUTE ('-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
create TRIGGER [dbo].[DataSourceUpdate] 
   ON  [dbo].[ib_DataSource]
   AFTER UPDATE
	NOT FOR REPLICATION
AS 
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for trigger here
	UPDATE ib_DataSource
	SET UpdateDate = CASE WHEN UPDATE(UpdateDate) THEN UpdateDate ELSE GETDATE() END
		, UpdateUsername = CASE WHEN UPDATE(UpdateUsername) THEN UpdateUsername ELSE SUSER_SNAME() END
	WHERE DataSourceId IN (SELECT DataSourceID FROM Inserted)
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_EquityHeader]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_EquityHeader]
(
[EquityHeaderId] [int] NOT NULL IDENTITY(1, 1),
[AsOfDate] [datetime] NOT NULL,
[TemplateId] [int] NOT NULL,
[CurrencyId] [int] NOT NULL,
[TemplateGroupDescription] [varchar] (100) NOT NULL,
[Section1SignOffDate] [datetime] NULL,
[Section1SignOffUser] [varchar] (50) NULL,
[Section2SignOffDate] [datetime] NULL,
[Section2SignOffUser] [varchar] (50) NULL,
[Section3SignOffDate] [datetime] NULL,
[Section3SignOffUser] [varchar] (50) NULL,
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_ib_EquityHeader_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_ib_EquityHeader_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_ib_EquityHeader] on [dbo].[ib_EquityHeader]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_EquityHeader] ADD CONSTRAINT [PK_ib_EquityHeader] PRIMARY KEY CLUSTERED  ([EquityHeaderId])
');

GO
EXECUTE ('PRINT N''Creating index [AK_full_key] on [dbo].[ib_EquityHeader]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_full_key] ON [dbo].[ib_EquityHeader] ([AsOfDate], [TemplateId], [CurrencyId], [TemplateGroupDescription])
');

GO
EXECUTE ('PRINT N''Creating trigger [dbo].[EquityHeaderUpdate] on [dbo].[ib_EquityHeader]''
');

GO
EXECUTE ('-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
create TRIGGER [dbo].[EquityHeaderUpdate] 
   ON  [dbo].[ib_EquityHeader]
   AFTER UPDATE
	NOT FOR REPLICATION
AS 
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for trigger here
	UPDATE ib_EquityHeader
	SET UpdateDate = CASE WHEN UPDATE(UpdateDate) THEN UpdateDate ELSE GETDATE() END
		, UpdateUsername = CASE WHEN UPDATE(UpdateUsername) THEN UpdateUsername ELSE SUSER_SNAME() END
	WHERE EquityHeaderId IN (SELECT EquityHeaderID FROM Inserted)
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Price]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_Price]
(
[PriceId] [int] NOT NULL IDENTITY(1, 1),
[AsOfDate] [datetime] NOT NULL,
[DataSourceId] [int] NOT NULL,
[ExchangeId] [int] NOT NULL,
[InstrumentId] [int] NOT NULL,
[CurrencyId] [int] NOT NULL,
[ExpiryYear] [smallint] NOT NULL,
[ExpiryMonth] [smallint] NOT NULL,
[ExpiryDay] [smallint] NULL,
[StrikePrice] [money] NULL,
[OptionTypeCode] [varchar] (25) NULL,
[ImportFileId] [int] NULL,
[SettlementPrice] [decimal] (24, 10) NOT NULL,
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_Price_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_Price_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_ib_Price] on [dbo].[ib_Price]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Price] ADD CONSTRAINT [PK_ib_Price] PRIMARY KEY CLUSTERED  ([PriceId])
');

GO
EXECUTE ('PRINT N''Adding constraints to [dbo].[ib_Price]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Price] ADD CONSTRAINT [AK_AsOfDate_DataSource_Exchange_Instrument_Currency_Expiry_Strike_OptionTypeCode] UNIQUE NONCLUSTERED  ([AsOfDate], [DataSourceId], [ExchangeId], [InstrumentId], [CurrencyId], [ExpiryYear], [ExpiryMonth], [ExpiryDay], [StrikePrice], [OptionTypeCode])
');

GO
EXECUTE ('PRINT N''Creating index [IX_ImportFile] on [dbo].[ib_Price]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_ImportFile] ON [dbo].[ib_Price] ([ImportFileId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_Instrument] on [dbo].[ib_Price]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_Instrument] ON [dbo].[ib_Price] ([InstrumentId])
');

GO
EXECUTE ('PRINT N''Creating trigger [dbo].[PriceUpdate] on [dbo].[ib_Price]''
');

GO
EXECUTE ('CREATE TRIGGER [dbo].[PriceUpdate]
    ON [dbo].[ib_Price]
    AFTER UPDATE
    NOT FOR REPLICATION
    AS BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for trigger here
	UPDATE ib_Price
	SET UpdateDate = CASE WHEN UPDATE(UpdateDate) THEN UpdateDate ELSE GETDATE() END
		, UpdateUsername = CASE WHEN UPDATE(UpdateUsername) THEN UpdateUsername ELSE SUSER_SNAME() END
	WHERE PriceId IN (SELECT PriceId FROM Inserted)
END


');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_FirmDataSource]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_FirmDataSource]
(
[FirmDataSourceId] [int] NOT NULL IDENTITY(1, 1),
[FirmId] [int] NOT NULL,
[DataSourceId] [int] NOT NULL,
[DataSourceFirmCode] [varchar] (100) NOT NULL,
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_FirmExchange_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_FirmExchange_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_FirmDataSource] on [dbo].[ib_FirmDataSource]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_FirmDataSource] ADD CONSTRAINT [PK_FirmDataSource] PRIMARY KEY CLUSTERED  ([FirmDataSourceId])
');

GO
EXECUTE ('PRINT N''Creating index [AK_FirmDataSource_code] on [dbo].[ib_FirmDataSource]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_FirmDataSource_code] ON [dbo].[ib_FirmDataSource] ([DataSourceId], [DataSourceFirmCode])
');

GO
EXECUTE ('PRINT N''Creating trigger [dbo].[FirmDataSourceUpdate] on [dbo].[ib_FirmDataSource]''
');

GO
EXECUTE ('
-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
create TRIGGER [dbo].[FirmDataSourceUpdate] 
   ON  [dbo].[ib_FirmDataSource]
   AFTER UPDATE
	NOT FOR REPLICATION
AS 
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for trigger here
	UPDATE ib_FirmDataSource
	SET UpdateDate = CASE WHEN UPDATE(UpdateDate) THEN UpdateDate ELSE GETDATE() END
		, UpdateUsername = CASE WHEN UPDATE(UpdateUsername) THEN UpdateUsername ELSE SUSER_SNAME() END
	WHERE FirmDataSourceId IN (SELECT FirmDataSourceID FROM Inserted)
END


');

GO
EXECUTE ('PRINT N''Creating trigger [dbo].[tr_ib_MatchCode_Insert] on [dbo].[ib_MatchCode]''
');

GO
EXECUTE ('CREATE TRIGGER [dbo].[tr_ib_MatchCode_Insert] ON [dbo].[ib_MatchCode] FOR INSERT AS INSERT INTO audit.ib_MatchCodeHistory(MatchCodeId,TemplateId,MatchCode,CreateDate,CreateUsername,UpdateDate,UpdateUsername,TemplateTypeClassId,BrokerId,AuditAction) SELECT MatchCodeId,TemplateId,MatchCode,CreateDate,CreateUsername,UpdateDate,UpdateUsername,TemplateTypeClassId,BrokerId,''I'' FROM Inserted
');

GO
EXECUTE ('PRINT N''Creating trigger [dbo].[tr_ib_MatchCode_Update] on [dbo].[ib_MatchCode]''
');

GO
EXECUTE ('CREATE TRIGGER [dbo].[tr_ib_MatchCode_Update] ON [dbo].[ib_MatchCode] FOR UPDATE AS INSERT INTO audit.ib_MatchCodeHistory(MatchCodeId,TemplateId,MatchCode,CreateDate,CreateUsername,UpdateDate,UpdateUsername,TemplateTypeClassId,BrokerId,AuditAction) SELECT MatchCodeId,TemplateId,MatchCode,CreateDate,CreateUsername,UpdateDate,UpdateUsername,TemplateTypeClassId,BrokerId,''U'' FROM Inserted
');

GO
EXECUTE ('PRINT N''Creating trigger [dbo].[TemplateGroupUpdate] on [dbo].[ib_TemplateGroup]''
');

GO
EXECUTE ('CREATE TRIGGER [dbo].[TemplateGroupUpdate] 
   ON  [dbo].[ib_TemplateGroup]
   AFTER UPDATE
	NOT FOR REPLICATION
AS 
BEGIN
	--	24 Nov 2010		amk		MBAL-16391: bug fix - allow for multiple rows updated
	--										(when it comes to adding match code records)

	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	DECLARE @TemplateId INT
	DECLARE	@Code VARCHAR(100)
	DECLARE	@UpdateUserName VARCHAR(50)

    DECLARE newRecords CURSOR FORWARD_ONLY FOR
    SELECT TemplateId, [Description], UpdateUsername
	FROM inserted

	OPEN newRecords

    FETCH newRecords INTO @TemplateId, @Code, @UpdateUserName
    WHILE (@@FETCH_STATUS = 0)
    BEGIN
		EXEC ib_MatchCode_AddAsNeeded @TemplateId, @Code, @UpdateUserName
	    FETCH newRecords INTO @TemplateId, @Code, @UpdateUserName
    END

    CLOSE newRecords
    DEALLOCATE newRecords

    -- Insert statements for trigger here
	UPDATE ib_TemplateGroup
	SET UpdateDate = CASE WHEN UPDATE(UpdateDate) THEN UpdateDate ELSE GETDATE() END
		, UpdateUsername = CASE WHEN UPDATE(UpdateUsername) THEN UpdateUsername ELSE SUSER_SNAME() END
	WHERE TemplateGroupId IN (SELECT TemplateGroupID FROM Inserted)

	INSERT INTO audit.ib_TemplateGroupHistory(TemplateGroupId, TemplateId, ExchangeId, FirmId, ClassId, AccountId, InstrumentId, Description, CreateDate, CreateUsername, UpdateDate, UpdateUsername, CurrencyId,AuditAction) SELECT TemplateGroupId, TemplateId, ExchangeId, FirmId, ClassId, AccountId, InstrumentId, Description, CreateDate, CreateUsername, UpdateDate, UpdateUsername, CurrencyId,''U'' FROM Inserted;
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Trx]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_Trx]
(
[TrxId] [int] NOT NULL IDENTITY(1, 1),
[DataSourceId] [int] NOT NULL,
[ExchangeId] [int] NOT NULL,
[FirmId] [int] NOT NULL,
[AccountId] [int] NULL,
[TrxDate] [datetime] NOT NULL,
[AsOfDate] [datetime] NOT NULL,
[InstrumentId] [int] NOT NULL,
[Quantity] [decimal] (19, 4) NOT NULL,
[CurrencyId] [int] NOT NULL,
[MarketValue] [decimal] (19, 4) NULL,
[Price] [decimal] (24, 10) NULL,
[ExpiryYear] [smallint] NOT NULL,
[ExpiryMonth] [smallint] NOT NULL,
[ExpiryDay] [smallint] NULL,
[StrikePrice] [money] NULL,
[TrxTypeCode] [varchar] (25) NULL,
[OptionTypeCode] [varchar] (25) NULL,
[TempTableRecordId] [int] NOT NULL,
[RelatedPosition_Id] [int] NULL,
[ClassId] [int] NULL,
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_Transaction_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_Transaction_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL,
[DetailAccountId] [int] NULL,
[QuantityLong] [int] NULL,
[QuantityShort] [int] NULL,
[MatchingAdjustmentId] [int] NULL,
[UTI] [varchar] (100) NULL,
[IsUnmatched] [bit] NOT NULL CONSTRAINT [DF__ib_Trx__IsUnmatc__4848249E] DEFAULT ((0))
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_Transaction] on [dbo].[ib_Trx]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Trx] ADD CONSTRAINT [PK_Transaction] PRIMARY KEY CLUSTERED  ([TrxId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_account] on [dbo].[ib_Trx]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_account] ON [dbo].[ib_Trx] ([AccountId])
');

GO
EXECUTE ('PRINT N''Creating index [ix_date_datasource] on [dbo].[ib_Trx]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [ix_date_datasource] ON [dbo].[ib_Trx] ([AsOfDate], [DataSourceId]) INCLUDE ([CreateDate])
');

GO
EXECUTE ('PRINT N''Creating index [IX_ib_Trx_FileRollback] on [dbo].[ib_Trx]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_ib_Trx_FileRollback] ON [dbo].[ib_Trx] ([DataSourceId], [TempTableRecordId], [TrxId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_ib_Trx_FileRollback_Selection] on [dbo].[ib_Trx]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_ib_Trx_FileRollback_Selection] ON [dbo].[ib_Trx] ([DataSourceId], [TrxId], [TempTableRecordId]) INCLUDE ([AsOfDate])
');

GO
EXECUTE ('PRINT N''Creating index [IX_ib_Trx_ImbalanceReportDrillDown] on [dbo].[ib_Trx]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_ib_Trx_ImbalanceReportDrillDown] ON [dbo].[ib_Trx] ([ExchangeId], [InstrumentId], [CurrencyId], [ExpiryMonth], [ExpiryYear], [ExpiryDay], [ClassId], [FirmId], [AccountId], [DataSourceId], [AsOfDate], [Quantity], [MarketValue]) INCLUDE ([OptionTypeCode], [Price], [StrikePrice], [TrxDate], [TrxTypeCode])
');

GO
EXECUTE ('PRINT N''Creating index [IX_trx_TypeCode] on [dbo].[ib_Trx]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_trx_TypeCode] ON [dbo].[ib_Trx] ([FirmId], [DataSourceId], [AsOfDate], [TrxTypeCode]) INCLUDE ([AccountId], [CurrencyId], [ExchangeId], [ExpiryDay], [ExpiryMonth], [ExpiryYear], [InstrumentId], [OptionTypeCode], [StrikePrice], [TrxId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_for_imbalance_report] on [dbo].[ib_Trx]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_for_imbalance_report] ON [dbo].[ib_Trx] ([FirmId], [ExchangeId], [AccountId], [InstrumentId], [CurrencyId], [ExpiryYear], [ExpiryMonth], [ExpiryDay], [StrikePrice], [OptionTypeCode], [AsOfDate], [TrxTypeCode], [DataSourceId], [ClassId]) INCLUDE ([MarketValue])
');

GO
EXECUTE ('PRINT N''Creating index [IX_instrument] on [dbo].[ib_Trx]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_instrument] ON [dbo].[ib_Trx] ([InstrumentId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_ib_Trx_MatchingAdjustmentId] on [dbo].[ib_Trx]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_ib_Trx_MatchingAdjustmentId] ON [dbo].[ib_Trx] ([MatchingAdjustmentId])
');

GO
EXECUTE ('PRINT N''Creating trigger [dbo].[TrxUpdate] on [dbo].[ib_Trx]''
');

GO
EXECUTE ('
-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE TRIGGER [dbo].[TrxUpdate] 
   ON  [dbo].[ib_Trx]
   AFTER UPDATE
	NOT FOR REPLICATION
AS 
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for trigger here
	UPDATE ib_Trx
	SET UpdateDate = CASE WHEN UPDATE(UpdateDate) THEN UpdateDate ELSE GETDATE() END
		, UpdateUsername = CASE WHEN UPDATE(UpdateUsername) THEN UpdateUsername ELSE SUSER_SNAME() END
	WHERE TrxId IN (SELECT TrxID FROM Inserted)
END

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Adjustment]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_Adjustment]
(
[AdjustmentId] [int] NOT NULL IDENTITY(1, 1),
[TemplateId] [int] NOT NULL,
[ExchangeId] [int] NOT NULL,
[InstrumentId] [int] NOT NULL,
[InternalExternalCode] [char] (1) NOT NULL,
[TradeDate] [datetime] NOT NULL,
[AdjustmentDate] [datetime] NOT NULL,
[Quantity] [decimal] (19, 4) NOT NULL,
[CurrencyId] [int] NOT NULL,
[ExpiryYear] [smallint] NOT NULL,
[ExpiryMonth] [smallint] NOT NULL,
[ExpiryDay] [smallint] NULL,
[StrikePrice] [decimal] (19, 4) NULL,
[TradePrice] [decimal] (24, 10) NOT NULL,
[SettlementPrice] [decimal] (24, 10) NOT NULL,
[OptionTypeCode] [varchar] (25) NULL,
[Value] [decimal] (19, 4) NOT NULL,
[PremiumValue] [decimal] (19, 6) NULL,
[OptionValue] [decimal] (19, 6) NULL,
[Description] [varchar] (4096) NULL,
[TemplateGroupId] [int] NULL,
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_ib_Adjustment_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_ib_Adjustment_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL,
[IsBuy] [bit] NULL,
[MatchCodeId] [int] NULL,
[AdjustmentHeaderId] [int] NULL,
[DataSourceId] [int] NULL,
[FirmId] [int] NULL,
[QuantityLong] [int] NULL,
[QuantityShort] [int] NULL,
[DetailAccountId] [int] NULL,
[AccountId] [int] NULL,
[ClassId] [int] NULL,
[AdjustmentStatusId] [int] NULL,
[AdjustmentReasonId] [int] NULL,
[TrxTypeCode] [varchar] (25) NULL,
[AdjustmentUserStatusId] [int] NULL,
[MatchingAdjustmentId] [int] NULL,
[ReplacesAdjustmentId] [int] NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_ib_Adjustment] on [dbo].[ib_Adjustment]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Adjustment] ADD CONSTRAINT [PK_ib_Adjustment] PRIMARY KEY CLUSTERED  ([AdjustmentId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_ib_Adjustment_AccountId] on [dbo].[ib_Adjustment]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_ib_Adjustment_AccountId] ON [dbo].[ib_Adjustment] ([AccountId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_adjustmentDate] on [dbo].[ib_Adjustment]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_adjustmentDate] ON [dbo].[ib_Adjustment] ([AdjustmentDate])
');

GO
EXECUTE ('PRINT N''Creating index [IX_AdjustmentHeader] on [dbo].[ib_Adjustment]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_AdjustmentHeader] ON [dbo].[ib_Adjustment] ([AdjustmentHeaderId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_ib_Adjustment_AdjustmentReasonId] on [dbo].[ib_Adjustment]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_ib_Adjustment_AdjustmentReasonId] ON [dbo].[ib_Adjustment] ([AdjustmentReasonId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_ib_Adjustment_AdjustmentStatusId] on [dbo].[ib_Adjustment]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_ib_Adjustment_AdjustmentStatusId] ON [dbo].[ib_Adjustment] ([AdjustmentStatusId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_ib_Adjustment_AdjustmentUserStatusId] on [dbo].[ib_Adjustment]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_ib_Adjustment_AdjustmentUserStatusId] ON [dbo].[ib_Adjustment] ([AdjustmentUserStatusId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_ib_Adjustment_ClassId] on [dbo].[ib_Adjustment]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_ib_Adjustment_ClassId] ON [dbo].[ib_Adjustment] ([ClassId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_currency] on [dbo].[ib_Adjustment]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_currency] ON [dbo].[ib_Adjustment] ([CurrencyId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_ib_Adjustment_DataSourceId] on [dbo].[ib_Adjustment]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_ib_Adjustment_DataSourceId] ON [dbo].[ib_Adjustment] ([DataSourceId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_ib_Adjustment_DetailAccountId] on [dbo].[ib_Adjustment]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_ib_Adjustment_DetailAccountId] ON [dbo].[ib_Adjustment] ([DetailAccountId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_ib_Adjustment_FirmId] on [dbo].[ib_Adjustment]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_ib_Adjustment_FirmId] ON [dbo].[ib_Adjustment] ([FirmId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_instrument] on [dbo].[ib_Adjustment]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_instrument] ON [dbo].[ib_Adjustment] ([InstrumentId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_matchingAdjustmentId] on [dbo].[ib_Adjustment]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_matchingAdjustmentId] ON [dbo].[ib_Adjustment] ([MatchingAdjustmentId]) INCLUDE ([AdjustmentId], [AdjustmentStatusId], [Description])
');

GO
EXECUTE ('PRINT N''Creating index [IX_template] on [dbo].[ib_Adjustment]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_template] ON [dbo].[ib_Adjustment] ([TemplateId])
');

GO
EXECUTE ('PRINT N''Creating trigger [dbo].[AdjustmentUpdate] on [dbo].[ib_Adjustment]''
');

GO
EXECUTE ('-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE TRIGGER [dbo].[AdjustmentUpdate] 
   ON  [dbo].[ib_Adjustment]
   AFTER UPDATE
	NOT FOR REPLICATION
AS 
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for trigger here
	UPDATE ib_Adjustment
	SET UpdateDate = CASE WHEN UPDATE(UpdateDate) THEN UpdateDate ELSE GETDATE() END
		, UpdateUsername = CASE WHEN UPDATE(UpdateUsername) THEN UpdateUsername ELSE SUSER_SNAME() END
	WHERE AdjustmentId IN (SELECT AdjustmentID FROM Inserted)
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Class]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_Class]
(
[ClassId] [int] NOT NULL IDENTITY(1, 1),
[Code] [varchar] (100) NOT NULL,
[Description] [varchar] (100) NOT NULL,
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_ib_Class_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_ib_Class_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_ib_Class] on [dbo].[ib_Class]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Class] ADD CONSTRAINT [PK_ib_Class] PRIMARY KEY CLUSTERED  ([ClassId])
');

GO
EXECUTE ('PRINT N''Creating index [AK_code] on [dbo].[ib_Class]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_code] ON [dbo].[ib_Class] ([Code])
');

GO
EXECUTE ('PRINT N''Creating index [AK_desc] on [dbo].[ib_Class]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_desc] ON [dbo].[ib_Class] ([Description])
');

GO
EXECUTE ('PRINT N''Creating trigger [dbo].[ClassUpdate] on [dbo].[ib_Class]''
');

GO
EXECUTE ('
-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
Create TRIGGER [dbo].[ClassUpdate] 
   ON  [dbo].[ib_Class]
   AFTER UPDATE
	NOT FOR REPLICATION
AS 
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for trigger here
	UPDATE ib_Class
	SET UpdateDate = CASE WHEN UPDATE(UpdateDate) THEN UpdateDate ELSE GETDATE() END
		, UpdateUsername = CASE WHEN UPDATE(UpdateUsername) THEN UpdateUsername ELSE SUSER_SNAME() END
	WHERE ClassId IN (SELECT ClassID FROM Inserted)
END


');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Firm]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_Firm]
(
[FirmId] [int] NOT NULL IDENTITY(1, 1),
[Code] [varchar] (100) NOT NULL,
[Name] [varchar] (100) NOT NULL,
[IsApproved] [bit] NOT NULL CONSTRAINT [DF_Firm_Approved] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_Firm_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_Firm_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_Firm] on [dbo].[ib_Firm]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Firm] ADD CONSTRAINT [PK_Firm] PRIMARY KEY CLUSTERED  ([FirmId])
');

GO
EXECUTE ('PRINT N''Creating index [AK_Firm_code] on [dbo].[ib_Firm]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_Firm_code] ON [dbo].[ib_Firm] ([Code])
');

GO
EXECUTE ('PRINT N''Creating index [AK_Firm_name] on [dbo].[ib_Firm]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_Firm_name] ON [dbo].[ib_Firm] ([Name])
');

GO
EXECUTE ('PRINT N''Creating trigger [dbo].[FirmUpdate] on [dbo].[ib_Firm]''
');

GO
EXECUTE ('

-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE TRIGGER [dbo].[FirmUpdate] 
   ON  [dbo].[ib_Firm]
   AFTER UPDATE
	NOT FOR REPLICATION
AS 
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for trigger here
	UPDATE ib_Firm
	SET UpdateDate = CASE WHEN UPDATE(UpdateDate) THEN UpdateDate ELSE GETDATE() END
		, UpdateUsername = CASE WHEN UPDATE(UpdateUsername) THEN UpdateUsername ELSE SUSER_SNAME() END
	WHERE FirmId IN (SELECT FirmID FROM Inserted)
END


');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Money]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_Money]
(
[MoneyId] [int] NOT NULL IDENTITY(1, 1),
[DataSourceId] [int] NOT NULL,
[AsOfDate] [datetime] NOT NULL,
[FirmId] [int] NOT NULL,
[OfficeCode] [varchar] (100) NOT NULL,
[AccountId] [int] NOT NULL,
[CurrencyId] [int] NOT NULL,
[LongOptionMarketValue] [decimal] (19, 6) NOT NULL,
[ShortOptionMarketValue] [decimal] (19, 6) NOT NULL,
[FuturesInitialMargin] [decimal] (19, 6) NOT NULL,
[EquitiesInitialMargin] [decimal] (19, 6) NOT NULL,
[MarginCollateralValue] [decimal] (19, 6) NOT NULL,
[PreviousAccountBalance] [decimal] (19, 6) NOT NULL,
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_ib_Money_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_ib_Money_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_ib_Money] on [dbo].[ib_Money]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Money] ADD CONSTRAINT [PK_ib_Money] PRIMARY KEY CLUSTERED  ([MoneyId])
');

GO
EXECUTE ('PRINT N''Creating trigger [dbo].[MoneyUpdate] on [dbo].[ib_Money]''
');

GO
EXECUTE ('-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
create TRIGGER [dbo].[MoneyUpdate] 
   ON  [dbo].[ib_Money]
   AFTER UPDATE
	NOT FOR REPLICATION
AS 
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for trigger here
	UPDATE ib_Money
	SET UpdateDate = CASE WHEN UPDATE(UpdateDate) THEN UpdateDate ELSE GETDATE() END
		, UpdateUsername = CASE WHEN UPDATE(UpdateUsername) THEN UpdateUsername ELSE SUSER_SNAME() END
	WHERE MoneyId IN (SELECT MoneyID FROM Inserted)
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_ImbalanceReportDetail]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_ImbalanceReportDetail]
(
[ImbalanceReportDetailId] [int] NOT NULL IDENTITY(1, 1),
[ImbalanceReportId] [int] NOT NULL,
[DataSourceId] [int] NULL,
[ExchangeId] [int] NOT NULL,
[FirmId] [int] NOT NULL,
[AccountId] [int] NULL,
[InstrumentId] [int] NOT NULL,
[ClassId] [int] NULL,
[ExpiryYear] [smallint] NOT NULL,
[ExpiryMonth] [smallint] NOT NULL,
[ExpiryDay] [smallint] NULL,
[OptionTypeCode] [varchar] (25) NULL,
[CurrencyId] [int] NOT NULL,
[StrikePrice] [decimal] (19, 4) NULL,
[Internal_YAdjOTE] [decimal] (19, 4) NOT NULL,
[Internal_YOTE] [decimal] (19, 4) NOT NULL,
[Internal_PandS] [decimal] (19, 4) NOT NULL,
[Internal_TAdjOTE] [decimal] (19, 4) NOT NULL,
[Internal_TOTE] [decimal] (19, 4) NOT NULL,
[Internal_Position] [decimal] (19, 4) NOT NULL,
[External_YAdjOTE] [decimal] (19, 4) NOT NULL,
[External_YOTE] [decimal] (19, 4) NOT NULL,
[External_PandS] [decimal] (19, 4) NOT NULL,
[External_TAdjOTE] [decimal] (19, 4) NOT NULL,
[External_TOTE] [decimal] (19, 4) NOT NULL,
[External_Position] [decimal] (19, 4) NOT NULL,
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_ib_ImbalanceReportDetail_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_ib_ImbalanceReportDetail_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL,
[PositionsRealisedCashId] [int] NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_ib_ImbalanceReportDetail] on [dbo].[ib_ImbalanceReportDetail]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_ImbalanceReportDetail] ADD CONSTRAINT [PK_ib_ImbalanceReportDetail] PRIMARY KEY CLUSTERED  ([ImbalanceReportDetailId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_ib_ImbalanceReportDetail_ImbalanceReportId] on [dbo].[ib_ImbalanceReportDetail]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_ib_ImbalanceReportDetail_ImbalanceReportId] ON [dbo].[ib_ImbalanceReportDetail] ([ImbalanceReportId])
');

GO
EXECUTE ('PRINT N''Creating index [AK_ReportDetail_FullKey] on [dbo].[ib_ImbalanceReportDetail]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_ReportDetail_FullKey] ON [dbo].[ib_ImbalanceReportDetail] ([ImbalanceReportId], [FirmId], [DataSourceId], [ExchangeId], [AccountId], [InstrumentId], [CurrencyId], [ExpiryYear], [ExpiryMonth], [ExpiryDay], [StrikePrice], [OptionTypeCode], [ClassId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_instrument] on [dbo].[ib_ImbalanceReportDetail]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_instrument] ON [dbo].[ib_ImbalanceReportDetail] ([InstrumentId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_ib_ImbalanceReportDetail_ImbalanceReportDrillDown] on [dbo].[ib_ImbalanceReportDetail]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_ib_ImbalanceReportDetail_ImbalanceReportDrillDown] ON [dbo].[ib_ImbalanceReportDetail] ([InstrumentId], [ImbalanceReportId], [FirmId], [DataSourceId], [ExchangeId], [CurrencyId], [ExpiryMonth], [ExpiryYear], [ImbalanceReportDetailId], [ExpiryDay], [AccountId], [ClassId]) INCLUDE ([OptionTypeCode], [StrikePrice])
');

GO
EXECUTE ('PRINT N''Creating trigger [dbo].[ImbalanceReportDetailUpdate] on [dbo].[ib_ImbalanceReportDetail]''
');

GO
EXECUTE ('
-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
create TRIGGER [dbo].[ImbalanceReportDetailUpdate] 
   ON  [dbo].[ib_ImbalanceReportDetail]
   AFTER UPDATE
	NOT FOR REPLICATION
AS 
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for trigger here
	UPDATE ib_ImbalanceReportDetail
	SET UpdateDate = CASE WHEN UPDATE(UpdateDate) THEN UpdateDate ELSE GETDATE() END
		, UpdateUsername = CASE WHEN UPDATE(UpdateUsername) THEN UpdateUsername ELSE SUSER_SNAME() END
	WHERE ImbalanceReportDetailId IN (SELECT ImbalanceReportDetailID FROM Inserted)
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_SiteTemplate]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_SiteTemplate]
(
[SiteTemplateId] [int] NOT NULL IDENTITY(1, 1),
[SiteId] [int] NOT NULL,
[TemplateId] [int] NOT NULL,
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_ib_SiteTemplate_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_ib_SiteTemplate_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_ib_SiteTemplate] on [dbo].[ib_SiteTemplate]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_SiteTemplate] ADD CONSTRAINT [PK_ib_SiteTemplate] PRIMARY KEY CLUSTERED  ([SiteTemplateId])
');

GO
EXECUTE ('PRINT N''Creating index [AK_site_template] on [dbo].[ib_SiteTemplate]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_site_template] ON [dbo].[ib_SiteTemplate] ([SiteId], [TemplateId])
');

GO
EXECUTE ('PRINT N''Creating trigger [dbo].[SiteTemplateUpdate] on [dbo].[ib_SiteTemplate]''
');

GO
EXECUTE ('
-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
create TRIGGER [dbo].[SiteTemplateUpdate] 
   ON  [dbo].[ib_SiteTemplate]
   AFTER UPDATE
	NOT FOR REPLICATION
AS 
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for trigger here
	UPDATE ib_SiteTemplate
	SET UpdateDate = CASE WHEN UPDATE(UpdateDate) THEN UpdateDate ELSE GETDATE() END
		, UpdateUsername = CASE WHEN UPDATE(UpdateUsername) THEN UpdateUsername ELSE SUSER_SNAME() END
	WHERE SiteTemplateId IN (SELECT SiteTemplateID FROM Inserted)
END



');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_EquityCash]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_EquityCash]
(
[EquityCashId] [int] NOT NULL IDENTITY(1, 1),
[EquityHeaderId] [int] NOT NULL,
[InternalExternalCode] [char] (1) NOT NULL,
[SortOrder] [int] NOT NULL CONSTRAINT [DF_ib_EquityCash_SortOrder] DEFAULT ((100)),
[Amount] [decimal] (19, 6) NOT NULL,
[Description] [varchar] (255) NOT NULL,
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_ib_EquityCash_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_ib_EquityCash_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_ib_EquityCash] on [dbo].[ib_EquityCash]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_EquityCash] ADD CONSTRAINT [PK_ib_EquityCash] PRIMARY KEY CLUSTERED  ([EquityCashId])
');

GO
EXECUTE ('PRINT N''Creating trigger [dbo].[EquityCash] on [dbo].[ib_EquityCash]''
');

GO
EXECUTE ('
-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
create TRIGGER [dbo].[EquityCash] 
   ON  [dbo].[ib_EquityCash]
   AFTER UPDATE
	NOT FOR REPLICATION
AS 
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for trigger here
	UPDATE ib_EquityCash
	SET UpdateDate = CASE WHEN UPDATE(UpdateDate) THEN UpdateDate ELSE GETDATE() END
		, UpdateUsername = CASE WHEN UPDATE(UpdateUsername) THEN UpdateUsername ELSE SUSER_SNAME() END
	WHERE EquityCashId IN (SELECT EquityCashID FROM Inserted)
END



');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_SiteUser]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_SiteUser]
(
[SiteUserId] [int] NOT NULL IDENTITY(1, 1),
[SiteId] [int] NOT NULL,
[UserId] [uniqueidentifier] NOT NULL,
[IsPrimary] [bit] NOT NULL CONSTRAINT [DF_SiteUser_IsPrimary] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_SiteUser_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_SiteUser_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_SiteUser] on [dbo].[ib_SiteUser]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_SiteUser] ADD CONSTRAINT [PK_SiteUser] PRIMARY KEY CLUSTERED  ([SiteUserId])
');

GO
EXECUTE ('PRINT N''Creating index [AK_site_user] on [dbo].[ib_SiteUser]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_site_user] ON [dbo].[ib_SiteUser] ([SiteId], [UserId])
');

GO
EXECUTE ('PRINT N''Creating trigger [dbo].[SiteUserUpdate] on [dbo].[ib_SiteUser]''
');

GO
EXECUTE ('
-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
create TRIGGER [dbo].[SiteUserUpdate] 
   ON  [dbo].[ib_SiteUser]
   AFTER UPDATE
	NOT FOR REPLICATION
AS 
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for trigger here
	UPDATE ib_SiteUser
	SET UpdateDate = CASE WHEN UPDATE(UpdateDate) THEN UpdateDate ELSE GETDATE() END
		, UpdateUsername = CASE WHEN UPDATE(UpdateUsername) THEN UpdateUsername ELSE SUSER_SNAME() END
	WHERE SiteUserId IN (SELECT SiteUserID FROM Inserted)
END

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Nostro]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_Nostro]
(
[NostroId] [int] NOT NULL IDENTITY(1, 1),
[ValueDate] [datetime] NOT NULL,
[TransDate] [datetime] NOT NULL,
[Amount] [decimal] (18, 4) NOT NULL,
[TransactionType] [varchar] (4) NOT NULL,
[InternalReference] [varchar] (16) NULL,
[ExternalReference] [varchar] (16) NULL,
[Narrative] [varchar] (512) NULL,
[AccountId] [int] NOT NULL,
[CurrencyId] [int] NOT NULL,
[DataSourceId] [int] NOT NULL,
[TempTableRecordId] [int] NOT NULL,
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_ib_Nostro_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_ib_Nostro_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL,
[NostroBalancingItemId] [int] NULL,
[DepartmentId] [int] NULL,
[Notes] [varchar] (512) NULL,
[NostroMatchId] [int] NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_ib_Nostro] on [dbo].[ib_Nostro]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Nostro] ADD CONSTRAINT [PK_ib_Nostro] PRIMARY KEY CLUSTERED  ([NostroId])
');

GO
EXECUTE ('PRINT N''Creating index [ix_account] on [dbo].[ib_Nostro]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [ix_account] ON [dbo].[ib_Nostro] ([AccountId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_nostro_home_page] on [dbo].[ib_Nostro]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_nostro_home_page] ON [dbo].[ib_Nostro] ([CurrencyId], [NostroId], [AccountId], [DataSourceId]) INCLUDE ([Amount])
');

GO
EXECUTE ('PRINT N''Creating index [ix_nostroBalancingItem] on [dbo].[ib_Nostro]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [ix_nostroBalancingItem] ON [dbo].[ib_Nostro] ([NostroBalancingItemId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_ib_Nostro_NostroMatchId] on [dbo].[ib_Nostro]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_ib_Nostro_NostroMatchId] ON [dbo].[ib_Nostro] ([NostroMatchId], [CurrencyId], [AccountId], [DataSourceId]) INCLUDE ([Amount])
');

GO
EXECUTE ('PRINT N''Creating index [ix_transdate] on [dbo].[ib_Nostro]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [ix_transdate] ON [dbo].[ib_Nostro] ([TransDate])
');

GO
EXECUTE ('PRINT N''Creating index [ix_valuedate] on [dbo].[ib_Nostro]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [ix_valuedate] ON [dbo].[ib_Nostro] ([ValueDate])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Nostro_NotesHistory]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_Nostro_NotesHistory]
(
[NostroNotesHistoryId] [int] NOT NULL IDENTITY(1, 1),
[NostroId] [int] NOT NULL,
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_ib_Nostro_NotesHistory_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_ib_Nostro_NotesHistory_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL,
[DepartmentId] [int] NULL CONSTRAINT [DF__ib_Nostro__Depar__3F3DDD51] DEFAULT (NULL),
[Notes] [varchar] (512) NULL CONSTRAINT [DF__ib_Nostro__Notes__4032018A] DEFAULT (NULL)
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_ib_Nostro_NotesHistory] on [dbo].[ib_Nostro_NotesHistory]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Nostro_NotesHistory] ADD CONSTRAINT [PK_ib_Nostro_NotesHistory] PRIMARY KEY CLUSTERED  ([NostroNotesHistoryId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_ib_Nostro_NostroId] on [dbo].[ib_Nostro_NotesHistory]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_ib_Nostro_NostroId] ON [dbo].[ib_Nostro_NotesHistory] ([NostroId])
');

GO
EXECUTE ('PRINT N''Creating trigger [dbo].[ib_Nostro_UpdateNotesHistory] on [dbo].[ib_Nostro]''
');

GO
EXECUTE ('
CREATE TRIGGER [dbo].[ib_Nostro_UpdateNotesHistory]
ON [dbo].[ib_Nostro]
FOR UPDATE, INSERT
AS

-- Description:		This trigger updates the ib_Nostro_NotesHistory table, adding a new entry
--					whenever the notes field of the ib_Nostro table is updated
-- 
--	04 Sep 2009		AAJM	Creation
--  08 Sep 2009		AAJM	Add section for INSERT and fix not inserting when deleted IS NULL

BEGIN

SET NOCOUNT ON

-- Determine the type of operation
	DECLARE @OperationType nchar(1)
	SET @OperationType=''I''
	
	IF EXISTS(SELECT 1 FROM INSERTED) AND EXISTS(SELECT 1 FROM DELETED)
		SET @OperationType=''U''
	ELSE IF EXISTS(SELECT 1 FROM DELETED)
		SET @OperationType=''D''
	
	IF @OperationType = ''U''
		BEGIN
	
			INSERT INTO [dbo].[ib_Nostro_NotesHistory]
				    ([NostroId]
				     ,[CreateDate]
				     ,[CreateUsername]
				     ,[DepartmentId]
					 ,[Notes])
				 SELECT
					i.NostroId,
					i.UpdateDate,
					i.UpdateUsername,
					i.DepartmentId,
					i.Notes
				FROM INSERTED i 
				LEFT JOIN DELETED d
				ON i.NostroId = d.NostroId
				WHERE i.Notes IS NOT NULL
					  AND (i.Notes <> ISNULL(d.Notes,''''))
				
		END
	ELSE IF @OperationType = ''I''
		BEGIN
			INSERT INTO [dbo].[ib_Nostro_NotesHistory]
				    ([NostroId]
				     ,[CreateDate]
				     ,[CreateUsername]
				     ,[DepartmentId]
					 ,[Notes])
				 SELECT
					i.NostroId,
					i.CreateDate,
					i.CreateUsername,
					i.DepartmentId,
					i.Notes
				FROM INSERTED i 
				WHERE i.Notes IS NOT NULL
		END
END

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_ImportSettings]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_ImportSettings]
(
[ImportSettingsId] [int] NOT NULL IDENTITY(1, 1),
[DataSourceId] [int] NOT NULL,
[FileType] [varchar] (100) NOT NULL,
[StartFromDate] [datetime] NULL,
[StartFromDaysBack] [int] NOT NULL CONSTRAINT [DF_ib_ImportSettings_StartFromDaysBack] DEFAULT ((3)),
[LastUpdateImported] [datetime] NULL,
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_ib_ImportSettings_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_ib_ImportSettings_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_ib_ImportSettings] on [dbo].[ib_ImportSettings]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_ImportSettings] ADD CONSTRAINT [PK_ib_ImportSettings] PRIMARY KEY CLUSTERED  ([ImportSettingsId])
');

GO
EXECUTE ('PRINT N''Creating index [AK_datasource_filetype] on [dbo].[ib_ImportSettings]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_datasource_filetype] ON [dbo].[ib_ImportSettings] ([DataSourceId], [FileType])
');

GO
EXECUTE ('PRINT N''Creating trigger [dbo].[ImportSettingsUpdate] on [dbo].[ib_ImportSettings]''
');

GO
EXECUTE ('-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
create TRIGGER [dbo].[ImportSettingsUpdate] 
   ON  [dbo].[ib_ImportSettings]
   AFTER UPDATE
	NOT FOR REPLICATION
AS 
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for trigger here
	UPDATE ib_ImportSettings
	SET UpdateDate = CASE WHEN UPDATE(UpdateDate) THEN UpdateDate ELSE GETDATE() END
		, UpdateUsername = CASE WHEN UPDATE(UpdateUsername) THEN UpdateUsername ELSE SUSER_SNAME() END
	WHERE ImportSettingsId IN (SELECT ImportSettingsId FROM Inserted)
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_CashReportSummary]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_CashReportSummary]
(
[CashReportSummaryId] [int] NOT NULL IDENTITY(1, 1),
[ImbalanceReportId] [int] NOT NULL,
[CashReportId] [int] NOT NULL,
[MatchCodeId] [int] NOT NULL,
[DatasourceId] [int] NOT NULL,
[ExchangeId] [int] NOT NULL,
[CurrencyId] [int] NOT NULL,
[InstrumentTypeId] [int] NOT NULL,
[Internal_TOTE] [decimal] (19, 4) NOT NULL,
[Internal_PandS] [decimal] (19, 4) NOT NULL,
[Internal_AdjOTE] [decimal] (19, 4) NOT NULL,
[Internal_AdjSegNon] [decimal] (19, 4) NOT NULL,
[External_TOTE] [decimal] (19, 4) NOT NULL,
[External_PandS] [decimal] (19, 4) NOT NULL,
[External_AdjOTE] [decimal] (19, 4) NOT NULL,
[External_AdjSegNon] [decimal] (19, 4) NOT NULL,
[Difference] [decimal] (19, 4) NOT NULL,
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_CashReportSummary_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_CashReportSummary_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL,
[External_YOTE] [decimal] (19, 4) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_CashReportSummary] on [dbo].[ib_CashReportSummary]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_CashReportSummary] ADD CONSTRAINT [PK_CashReportSummary] PRIMARY KEY CLUSTERED  ([CashReportSummaryId])
');

GO
EXECUTE ('PRINT N''Creating trigger [dbo].[CashReportSummaryUpdate] on [dbo].[ib_CashReportSummary]''
');

GO
EXECUTE ('CREATE TRIGGER [dbo].[CashReportSummaryUpdate]
    ON [dbo].[ib_CashReportSummary]
   AFTER UPDATE
	NOT FOR REPLICATION
    AS 
    BEGIN
    	SET NOCOUNT ON

		-- Insert statements for trigger here
		UPDATE [ib_CashReportSummary]
		SET UpdateDate = CASE WHEN UPDATE(UpdateDate) THEN UpdateDate ELSE GETDATE() END
			, UpdateUsername = CASE WHEN UPDATE(UpdateUsername) THEN UpdateUsername ELSE SUSER_SNAME() END
		WHERE CashReportSummaryId IN (SELECT CashReportSummaryID FROM Inserted)
    END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TemplateType]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_TemplateType]
(
[TemplateTypeId] [int] NOT NULL IDENTITY(1, 1),
[Code] [varchar] (50) NOT NULL,
[Name] [varchar] (100) NOT NULL,
[IsActive] [bit] NOT NULL CONSTRAINT [DF_TemplateType_IsActive] DEFAULT ((1)),
[SortOrder] [int] NOT NULL CONSTRAINT [DF_TemplateType_SortOrder] DEFAULT ((100)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_TemplateType_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_TemplateType_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL,
[IsAutomatchEnabled] [bit] NOT NULL CONSTRAINT [DF_ib_TemplateType_IsAutomatchEnabled] DEFAULT ((0))
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_TemplateType] on [dbo].[ib_TemplateType]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_TemplateType] ADD CONSTRAINT [PK_TemplateType] PRIMARY KEY CLUSTERED  ([TemplateTypeId])
');

GO
EXECUTE ('PRINT N''Adding constraints to [dbo].[ib_TemplateType]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_TemplateType] ADD CONSTRAINT [AK_TemplateType_Code] UNIQUE NONCLUSTERED  ([Code])
');

GO
EXECUTE ('PRINT N''Adding constraints to [dbo].[ib_TemplateType]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_TemplateType] ADD CONSTRAINT [AK_TemplateType_name] UNIQUE NONCLUSTERED  ([Name])
');

GO
EXECUTE ('PRINT N''Creating trigger [dbo].[TemplateTypeUpdate] on [dbo].[ib_TemplateType]''
');

GO
EXECUTE ('CREATE TRIGGER [dbo].[TemplateTypeUpdate]
    ON [dbo].[ib_TemplateType]
   AFTER UPDATE
	NOT FOR REPLICATION
AS 
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for trigger here
	UPDATE ib_TemplateType
	SET UpdateDate = CASE WHEN UPDATE(UpdateDate) THEN UpdateDate ELSE GETDATE() END
		, UpdateUsername = CASE WHEN UPDATE(UpdateUsername) THEN UpdateUsername ELSE SUSER_SNAME() END
	WHERE TemplateTypeId IN (SELECT TemplateTypeID FROM Inserted)
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TemplateTypeClass]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_TemplateTypeClass]
(
[TemplateTypeClassId] [int] NOT NULL IDENTITY(1, 1),
[TemplateTypeId] [int] NOT NULL,
[Code] [varchar] (50) NOT NULL,
[Name] [varchar] (100) NOT NULL,
[IsActive] [bit] NOT NULL CONSTRAINT [DF_TemplateTypeClass_IsActive] DEFAULT ((1)),
[SortOrder] [int] NOT NULL CONSTRAINT [DF_TemplateTypeClass_SortOrder] DEFAULT ((100)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_TemplateTypeClass_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_TemplateTypeClass_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_TemplateTypeClass] on [dbo].[ib_TemplateTypeClass]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_TemplateTypeClass] ADD CONSTRAINT [PK_TemplateTypeClass] PRIMARY KEY CLUSTERED  ([TemplateTypeClassId])
');

GO
EXECUTE ('PRINT N''Adding constraints to [dbo].[ib_TemplateTypeClass]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_TemplateTypeClass] ADD CONSTRAINT [AK_TemplateTypeClass_TemplateType_Code] UNIQUE NONCLUSTERED  ([TemplateTypeId], [Code])
');

GO
EXECUTE ('PRINT N''Adding constraints to [dbo].[ib_TemplateTypeClass]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_TemplateTypeClass] ADD CONSTRAINT [AK_TemplateTypeClass_TemplateType_Name] UNIQUE NONCLUSTERED  ([TemplateTypeId], [Name])
');

GO
EXECUTE ('PRINT N''Creating trigger [dbo].[TemplateTypeClassUpdate] on [dbo].[ib_TemplateTypeClass]''
');

GO
EXECUTE ('CREATE TRIGGER [dbo].[TemplateTypeClassUpdate]
    ON [dbo].[ib_TemplateTypeClass]
   AFTER UPDATE
	NOT FOR REPLICATION
AS 
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for trigger here
	UPDATE ib_TemplateTypeClass
	SET UpdateDate = CASE WHEN UPDATE(UpdateDate) THEN UpdateDate ELSE GETDATE() END
		, UpdateUsername = CASE WHEN UPDATE(UpdateUsername) THEN UpdateUsername ELSE SUSER_SNAME() END
	WHERE TemplateTypeClassId IN (SELECT TemplateTypeClassID FROM Inserted)
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_ImportFile]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_ImportFile]
(
[ImportFileId] [int] NOT NULL IDENTITY(1, 1),
[Filename] [varchar] (255) NOT NULL,
[DataSourceId] [int] NOT NULL,
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_ib_ImportFile_CreateDate] DEFAULT (getdate()),
[CreateUserName] [varchar] (50) NOT NULL CONSTRAINT [DF_ib_ImportFile_CreateUserName] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL,
[AsOfDate] [datetime] NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_ib_ImportFile] on [dbo].[ib_ImportFile]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_ImportFile] ADD CONSTRAINT [PK_ib_ImportFile] PRIMARY KEY CLUSTERED  ([ImportFileId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_DataSource_AsOfDate] on [dbo].[ib_ImportFile]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_DataSource_AsOfDate] ON [dbo].[ib_ImportFile] ([DataSourceId], [AsOfDate])
');

GO
EXECUTE ('PRINT N''Creating index [IX_DataSource_Filename] on [dbo].[ib_ImportFile]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_DataSource_Filename] ON [dbo].[ib_ImportFile] ([DataSourceId], [Filename])
');

GO
EXECUTE ('PRINT N''Creating index [IX_for_rollback_display] on [dbo].[ib_ImportFile]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_for_rollback_display] ON [dbo].[ib_ImportFile] ([DataSourceId], [ImportFileId], [Filename]) INCLUDE ([AsOfDate])
');

GO
EXECUTE ('PRINT N''Creating trigger [dbo].[ImportFileUpdate] on [dbo].[ib_ImportFile]''
');

GO
EXECUTE ('-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE TRIGGER [dbo].[ImportFileUpdate] 
   ON  [dbo].[ib_ImportFile]
   AFTER UPDATE
	NOT FOR REPLICATION
AS 
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for trigger here
	UPDATE ib_ImportFile
	SET UpdateDate = CASE WHEN UPDATE(UpdateDate) THEN UpdateDate ELSE GETDATE() END
		, UpdateUsername = CASE WHEN UPDATE(UpdateUsername) THEN UpdateUsername ELSE SUSER_SNAME() END
	WHERE ImportFileId IN (SELECT ImportFileId FROM Inserted)
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TemplateCompare]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_TemplateCompare]
(
[TemplateCompareId] [int] NOT NULL IDENTITY(1, 1),
[TemplateId] [int] NOT NULL,
[DataSourceId] [int] NOT NULL,
[FirmId] [int] NOT NULL,
[InternalExternalCode] [char] (1) NOT NULL,
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_TemplateCompare_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_TemplateCompare_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_TemplateCompare] on [dbo].[ib_TemplateCompare]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_TemplateCompare] ADD CONSTRAINT [PK_TemplateCompare] PRIMARY KEY CLUSTERED  ([TemplateCompareId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_nostro_main_page] on [dbo].[ib_TemplateCompare]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_nostro_main_page] ON [dbo].[ib_TemplateCompare] ([DataSourceId], [FirmId], [TemplateId])
');

GO
EXECUTE ('PRINT N''Creating index [Ak_template_dataSource] on [dbo].[ib_TemplateCompare]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [Ak_template_dataSource] ON [dbo].[ib_TemplateCompare] ([TemplateId], [FirmId], [DataSourceId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_TemplateCompare_InternalExternalCode] on [dbo].[ib_TemplateCompare]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_TemplateCompare_InternalExternalCode] ON [dbo].[ib_TemplateCompare] ([TemplateId], [FirmId], [InternalExternalCode])
');

GO
EXECUTE ('PRINT N''Creating trigger [dbo].[TemplateCompareUpdate] on [dbo].[ib_TemplateCompare]''
');

GO
EXECUTE ('
-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
create TRIGGER [dbo].[TemplateCompareUpdate] 
   ON  [dbo].[ib_TemplateCompare]
   AFTER UPDATE
	NOT FOR REPLICATION
AS 
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for trigger here
	UPDATE ib_TemplateCompare
	SET UpdateDate = CASE WHEN UPDATE(UpdateDate) THEN UpdateDate ELSE GETDATE() END
		, UpdateUsername = CASE WHEN UPDATE(UpdateUsername) THEN UpdateUsername ELSE SUSER_SNAME() END
	WHERE TemplateCompareId IN (SELECT TemplateCompareID FROM Inserted)
END

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_InstrumentDetail]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_InstrumentDetail]
(
[InstrumentDetailId] [int] NOT NULL IDENTITY(1, 1),
[InstrumentId] [int] NOT NULL,
[ExpiryYear] [smallint] NOT NULL,
[ExpiryMonth] [smallint] NOT NULL,
[ExpiryDay] [smallint] NULL,
[StrikePrice] [decimal] (19, 4) NULL,
[OptionTypeCode] [varchar] (25) NULL,
[AsOfDate] [datetime] NOT NULL,
[SettlementPrice] [decimal] (24, 10) NOT NULL,
[CurrencyId] [int] NOT NULL,
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_ib_InstrumentDetail_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_ib_InstrumentDetail_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_ib_InstrumentDetail] on [dbo].[ib_InstrumentDetail]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_InstrumentDetail] ADD CONSTRAINT [PK_ib_InstrumentDetail] PRIMARY KEY CLUSTERED  ([InstrumentDetailId])
');

GO
EXECUTE ('PRINT N''Creating index [AK_full] on [dbo].[ib_InstrumentDetail]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_full] ON [dbo].[ib_InstrumentDetail] ([InstrumentId], [AsOfDate], [StrikePrice], [ExpiryYear], [ExpiryMonth], [ExpiryDay], [OptionTypeCode])
');

GO
EXECUTE ('PRINT N''Creating trigger [dbo].[InstrumentDetailUpdate] on [dbo].[ib_InstrumentDetail]''
');

GO
EXECUTE ('
-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE TRIGGER [dbo].[InstrumentDetailUpdate] 
   ON  [dbo].[ib_InstrumentDetail]
   AFTER UPDATE
	NOT FOR REPLICATION
AS 
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for trigger here
	UPDATE ib_InstrumentDetail
	SET UpdateDate = CASE WHEN UPDATE(UpdateDate) THEN UpdateDate ELSE GETDATE() END
		, UpdateUsername = CASE WHEN UPDATE(UpdateUsername) THEN UpdateUsername ELSE SUSER_SNAME() END
	WHERE InstrumentDetailId IN (SELECT InstrumentDetailID FROM Inserted)
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Base]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_Base]
(
[BaseId] [int] NOT NULL IDENTITY(1, 1),
[Code] [varchar] (100) NOT NULL,
[Base] [int] NOT NULL,
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_ib_Base_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_ib_Base_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL,
[Name] [varchar] (100) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_ib_Base] on [dbo].[ib_Base]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Base] ADD CONSTRAINT [PK_ib_Base] PRIMARY KEY CLUSTERED  ([BaseId])
');

GO
EXECUTE ('PRINT N''Creating index [AK_code] on [dbo].[ib_Base]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_code] ON [dbo].[ib_Base] ([Code])
');

GO
EXECUTE ('PRINT N''Creating trigger [dbo].[BaseUpdate] on [dbo].[ib_Base]''
');

GO
EXECUTE ('
-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
Create TRIGGER [dbo].[BaseUpdate] 
   ON  [dbo].[ib_Base]
   AFTER UPDATE
	NOT FOR REPLICATION
AS 
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for trigger here
	UPDATE ib_Base
	SET UpdateDate = CASE WHEN UPDATE(UpdateDate) THEN UpdateDate ELSE GETDATE() END
		, UpdateUsername = CASE WHEN UPDATE(UpdateUsername) THEN UpdateUsername ELSE SUSER_SNAME() END
	WHERE BaseId IN (SELECT BaseID FROM Inserted)
END


');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Exchange]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_Exchange]
(
[ExchangeId] [int] NOT NULL IDENTITY(1, 1),
[Code] [varchar] (25) NOT NULL,
[Name] [varchar] (50) NOT NULL,
[RunBalanceReport] [bit] NOT NULL CONSTRAINT [DF_Exchange_Balance] DEFAULT ((1)),
[RunCloseOutReport] [bit] NOT NULL CONSTRAINT [DF_Exchange_CloseOutReport] DEFAULT ((1)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_Exchange_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_Exchange_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL,
[RunTradeLevelReconciliation] [bit] NOT NULL CONSTRAINT [DF_Exchange_TradeRec] DEFAULT ((1))
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_Exchange] on [dbo].[ib_Exchange]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Exchange] ADD CONSTRAINT [PK_Exchange] PRIMARY KEY CLUSTERED  ([ExchangeId])
');

GO
EXECUTE ('PRINT N''Creating index [AK_Exchange_code] on [dbo].[ib_Exchange]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_Exchange_code] ON [dbo].[ib_Exchange] ([Code])
');

GO
EXECUTE ('PRINT N''Creating index [AK_Exchange_name] on [dbo].[ib_Exchange]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_Exchange_name] ON [dbo].[ib_Exchange] ([Name])
');

GO
EXECUTE ('PRINT N''Creating trigger [dbo].[ExchangeUpdate] on [dbo].[ib_Exchange]''
');

GO
EXECUTE ('
-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE TRIGGER [dbo].[ExchangeUpdate] 
   ON  [dbo].[ib_Exchange]
   AFTER UPDATE
	NOT FOR REPLICATION
AS 
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for trigger here
	UPDATE ib_Exchange
	SET UpdateDate = CASE WHEN UPDATE(UpdateDate) THEN UpdateDate ELSE GETDATE() END
		, UpdateUsername = CASE WHEN UPDATE(UpdateUsername) THEN UpdateUsername ELSE SUSER_SNAME() END
	WHERE ExchangeId IN (SELECT ExchangeID FROM Inserted)
END


');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Template]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_Template]
(
[TemplateId] [int] NOT NULL IDENTITY(1, 1),
[TypeCode] [varchar] (50) NOT NULL,
[Description] [varchar] (100) NOT NULL,
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_ib_Template_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_ib_Template_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_ib_Template] on [dbo].[ib_Template]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Template] ADD CONSTRAINT [PK_ib_Template] PRIMARY KEY CLUSTERED  ([TemplateId])
');

GO
EXECUTE ('PRINT N''Creating index [AK_type_desc] on [dbo].[ib_Template]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_type_desc] ON [dbo].[ib_Template] ([TypeCode], [Description])
');

GO
EXECUTE ('PRINT N''Creating trigger [dbo].[TemplateUpdate] on [dbo].[ib_Template]''
');

GO
EXECUTE ('
-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE TRIGGER [dbo].[TemplateUpdate] 
   ON  [dbo].[ib_Template]
   AFTER UPDATE
	NOT FOR REPLICATION
AS 
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for trigger here
	UPDATE ib_Template
	SET UpdateDate = CASE WHEN UPDATE(UpdateDate) THEN UpdateDate ELSE GETDATE() END
		, UpdateUsername = CASE WHEN UPDATE(UpdateUsername) THEN UpdateUsername ELSE SUSER_SNAME() END
	WHERE TemplateId IN (SELECT TemplateID FROM Inserted)
END


');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_PriceReport]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_PriceReport]
(
[PriceReportId] [int] NOT NULL IDENTITY(1, 1),
[TemplateId] [int] NOT NULL,
[TodaysDate] [datetime] NOT NULL,
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_PriceReport_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_PriceReport_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_PriceReport] on [dbo].[ib_PriceReport]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_PriceReport] ADD CONSTRAINT [PK_PriceReport] PRIMARY KEY CLUSTERED  ([PriceReportId])
');

GO
EXECUTE ('PRINT N''Creating trigger [dbo].[PriceReportUpdate] on [dbo].[ib_PriceReport]''
');

GO
EXECUTE ('CREATE TRIGGER [dbo].[PriceReportUpdate]
    ON [dbo].[ib_PriceReport]
   AFTER UPDATE
	NOT FOR REPLICATION
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for trigger here
	UPDATE ib_PriceReport
	SET UpdateDate = CASE WHEN UPDATE(UpdateDate) THEN UpdateDate ELSE GETDATE() END
		, UpdateUsername = CASE WHEN UPDATE(UpdateUsername) THEN UpdateUsername ELSE SUSER_SNAME() END
	WHERE PriceReportId IN (SELECT PriceReportId FROM Inserted)
END
');

GO
EXECUTE ('PRINT N''Creating trigger [dbo].[tr_ib_TemplateGroup_Delete] on [dbo].[ib_TemplateGroup]''
');

GO
EXECUTE ('CREATE TRIGGER [dbo].[tr_ib_TemplateGroup_Delete] ON [dbo].[ib_TemplateGroup] FOR DELETE AS INSERT INTO audit.ib_TemplateGroupHistory(TemplateGroupId, TemplateId, ExchangeId, FirmId, ClassId, AccountId, InstrumentId, Description, CreateDate, CreateUsername, UpdateDate, UpdateUsername, CurrencyId,AuditAction) SELECT TemplateGroupId, TemplateId, ExchangeId, FirmId, ClassId, AccountId, InstrumentId, Description, CreateDate, CreateUsername, UpdateDate, UpdateUsername, CurrencyId,''D'' FROM Deleted;
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_PriceReportSummary]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_PriceReportSummary]
(
[PriceReportSummaryId] [int] NOT NULL IDENTITY(1, 1),
[PriceReportId] [int] NOT NULL,
[ExchangeId] [int] NOT NULL,
[ExchangeCode] [nvarchar] (50) NOT NULL,
[CurrencyId] [int] NOT NULL,
[CurrencyCode] [nvarchar] (50) NOT NULL,
[InstrumentId] [int] NOT NULL,
[InstrumentCode] [nvarchar] (50) NOT NULL,
[ExpiryDay] [int] NOT NULL,
[ExpiryMonth] [int] NOT NULL,
[ExpiryYear] [int] NOT NULL,
[PutCall] [nvarchar] (5) NULL,
[StrikePrice] [decimal] (19, 4) NULL,
[Internal_DataSourceId] [int] NULL,
[Internal_DataSourceCode] [nvarchar] (50) NULL,
[Internal_SettlementPrice] [decimal] (24, 10) NULL,
[Internal_PriceId] [int] NULL,
[External_DataSourceId] [int] NULL,
[External_DataSourceCode] [nvarchar] (50) NULL,
[External_SettlementPrice] [decimal] (24, 10) NULL,
[External_PriceId] [int] NULL,
[Variation] [decimal] (24, 10) NOT NULL,
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_PriceReportSummary_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_PriceReportSummary_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_PriceReportSummary] on [dbo].[ib_PriceReportSummary]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_PriceReportSummary] ADD CONSTRAINT [PK_PriceReportSummary] PRIMARY KEY CLUSTERED  ([PriceReportSummaryId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_PriceReportSummary_PriceReport] on [dbo].[ib_PriceReportSummary]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_PriceReportSummary_PriceReport] ON [dbo].[ib_PriceReportSummary] ([PriceReportId])
');

GO
EXECUTE ('PRINT N''Adding constraints to [dbo].[ib_PriceReportSummary]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_PriceReportSummary] ADD CONSTRAINT [AK_PriceReportSummary_Main] UNIQUE NONCLUSTERED  ([PriceReportId], [ExchangeId], [CurrencyId], [InstrumentId], [ExpiryDay], [ExpiryMonth], [ExpiryYear], [PutCall], [StrikePrice], [External_DataSourceId])
');

GO
EXECUTE ('PRINT N''Creating trigger [dbo].[PriceReportSummary] on [dbo].[ib_PriceReportSummary]''
');

GO
EXECUTE ('CREATE TRIGGER [dbo].[PriceReportSummary]
    ON [dbo].[ib_PriceReportSummary]
   AFTER UPDATE
	NOT FOR REPLICATION
AS 
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for trigger here
	UPDATE ib_PriceReportSummary
	SET UpdateDate = CASE WHEN UPDATE(UpdateDate) THEN UpdateDate ELSE GETDATE() END
		, UpdateUsername = CASE WHEN UPDATE(UpdateUsername) THEN UpdateUsername ELSE SUSER_SNAME() END
	WHERE PriceReportSummaryId IN (SELECT PriceReportSummaryId FROM Inserted)
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[eib_StagingFile]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[eib_StagingFile]
(
[StagingFileId] [int] NOT NULL IDENTITY(1, 1),
[Path] [nvarchar] (255) NOT NULL,
[AdapterId] [int] NOT NULL,
[Status] [int] NOT NULL,
[RecordCount] [int] NOT NULL,
[AsOfDate] [datetime] NOT NULL,
[DataSourceId] [int] NOT NULL,
[LoadDate] [datetime] NOT NULL,
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_eib_StagingFile_CreateDate] DEFAULT (getdate()),
[UpdateDate] [datetime] NOT NULL CONSTRAINT [DF_eib_StagingFile_UpdateDate] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_eib_StagingFile] on [dbo].[eib_StagingFile]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[eib_StagingFile] ADD CONSTRAINT [PK_eib_StagingFile] PRIMARY KEY CLUSTERED  ([StagingFileId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_eib_StagingFile_DataSourceId] on [dbo].[eib_StagingFile]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_eib_StagingFile_DataSourceId] ON [dbo].[eib_StagingFile] ([DataSourceId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_eib_StagingFile_Path] on [dbo].[eib_StagingFile]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_eib_StagingFile_Path] ON [dbo].[eib_StagingFile] ([Path])
');

GO
EXECUTE ('PRINT N''Creating index [IX_eib_StagingFile_Status] on [dbo].[eib_StagingFile]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_eib_StagingFile_Status] ON [dbo].[eib_StagingFile] ([Status])
');

GO
EXECUTE ('PRINT N''Creating trigger [dbo].[StagingFileUpdate] on [dbo].[eib_StagingFile]''
');

GO
EXECUTE ('
CREATE TRIGGER [dbo].[StagingFileUpdate]
	ON [dbo].[eib_StagingFile]
	AFTER UPDATE
	NOT FOR REPLICATION
AS

SET NOCOUNT ON
DECLARE @StagingFileId INT
SELECT @StagingFileId = [i].[StagingFileId]
FROM [inserted] i
UPDATE [dbo].[eib_StagingFile]
SET [UpdateDate] = GETDATE()
WHERE [StagingFileId] = @StagingFileId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_InstrumentTypeDataSource]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_InstrumentTypeDataSource]
(
[InstrumentTypeDataSourceId] [int] NOT NULL IDENTITY(1, 1),
[InstrumentTypeId] [int] NOT NULL,
[DataSourceId] [int] NOT NULL,
[DataSourceInstrumentTypeCode] [varchar] (100) NOT NULL,
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_ib_InstrumentTypeExchange_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_ib_InstrumentTypeExchange_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_ib_InstrumentTypeDataSource] on [dbo].[ib_InstrumentTypeDataSource]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_InstrumentTypeDataSource] ADD CONSTRAINT [PK_ib_InstrumentTypeDataSource] PRIMARY KEY CLUSTERED  ([InstrumentTypeDataSourceId])
');

GO
EXECUTE ('PRINT N''Creating index [AK_ib_InstrumentTypeDataSource_code] on [dbo].[ib_InstrumentTypeDataSource]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_ib_InstrumentTypeDataSource_code] ON [dbo].[ib_InstrumentTypeDataSource] ([DataSourceId], [DataSourceInstrumentTypeCode])
');

GO
EXECUTE ('PRINT N''Creating index [AK_ib_InstrumentTypeDataSource] on [dbo].[ib_InstrumentTypeDataSource]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_ib_InstrumentTypeDataSource] ON [dbo].[ib_InstrumentTypeDataSource] ([InstrumentTypeId], [DataSourceId])
');

GO
EXECUTE ('PRINT N''Creating trigger [dbo].[InstrumentTypeDataSourceUpdate] on [dbo].[ib_InstrumentTypeDataSource]''
');

GO
EXECUTE ('
-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
create TRIGGER [dbo].[InstrumentTypeDataSourceUpdate] 
   ON  [dbo].[ib_InstrumentTypeDataSource]
   AFTER UPDATE
	NOT FOR REPLICATION
AS 
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for trigger here
	UPDATE ib_InstrumentTypeDataSource
	SET UpdateDate = CASE WHEN UPDATE(UpdateDate) THEN UpdateDate ELSE GETDATE() END
		, UpdateUsername = CASE WHEN UPDATE(UpdateUsername) THEN UpdateUsername ELSE SUSER_SNAME() END
	WHERE InstrumentTypeDataSourceId IN (SELECT InstrumentTypeDataSourceID FROM Inserted)
END


');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_InstrumentDataSource]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_InstrumentDataSource]
(
[InstrumentDataSourceId] [int] NOT NULL IDENTITY(1, 1),
[InstrumentId] [int] NOT NULL,
[DataSourceId] [int] NOT NULL,
[DataSourceInstrumentCode] [varchar] (100) NOT NULL,
[CurrencyId] [int] NULL,
[MarketValueDivisor] [decimal] (19, 4) NOT NULL CONSTRAINT [DF_ib_InstrumentDataSource_MarketValueDivisor] DEFAULT ((1)),
[StrikePriceDivisor] [decimal] (19, 4) NULL,
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_InstrumentExchange_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_InstrumentExchange_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL,
[PriceDivisor] [decimal] (19, 4) NULL,
[BaseId] [int] NULL,
[RunCloseOutReport] [bit] NOT NULL CONSTRAINT [DF_InstrumentDataSource_CloseOutReport] DEFAULT ((0))
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_InstrumentDataSource] on [dbo].[ib_InstrumentDataSource]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_InstrumentDataSource] ADD CONSTRAINT [PK_InstrumentDataSource] PRIMARY KEY CLUSTERED  ([InstrumentDataSourceId])
');

GO
EXECUTE ('PRINT N''Creating index [AK_InstrumentDataSource_code] on [dbo].[ib_InstrumentDataSource]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_InstrumentDataSource_code] ON [dbo].[ib_InstrumentDataSource] ([DataSourceId], [DataSourceInstrumentCode])
');

GO
EXECUTE ('PRINT N''Creating index [IX_InstrumentDataSource] on [dbo].[ib_InstrumentDataSource]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_InstrumentDataSource] ON [dbo].[ib_InstrumentDataSource] ([DataSourceId], [InstrumentId])
');

GO
EXECUTE ('PRINT N''Creating trigger [dbo].[InstrumentDataSourceUpdate] on [dbo].[ib_InstrumentDataSource]''
');

GO
EXECUTE ('
-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
create TRIGGER [dbo].[InstrumentDataSourceUpdate] 
   ON  [dbo].[ib_InstrumentDataSource]
   AFTER UPDATE
	NOT FOR REPLICATION
AS 
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for trigger here
	UPDATE ib_InstrumentDataSource
	SET UpdateDate = CASE WHEN UPDATE(UpdateDate) THEN UpdateDate ELSE GETDATE() END
		, UpdateUsername = CASE WHEN UPDATE(UpdateUsername) THEN UpdateUsername ELSE SUSER_SNAME() END
	WHERE InstrumentDataSourceId IN (SELECT InstrumentDataSourceID FROM Inserted)
END

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Broker]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_Broker]
(
[BrokerId] [int] NOT NULL IDENTITY(1, 1),
[Code] [varchar] (50) NOT NULL,
[UserCode] [varchar] (50) NOT NULL,
[Name] [varchar] (100) NOT NULL,
[DatasourceId] [int] NOT NULL,
[IsActive] [bit] NOT NULL CONSTRAINT [DF_ib_Broker_IsActive] DEFAULT ((1)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_ib_Broker_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_ib_Broker_CreateUserName] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_ib_Broker] on [dbo].[ib_Broker]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Broker] ADD CONSTRAINT [PK_ib_Broker] PRIMARY KEY CLUSTERED  ([BrokerId])
');

GO
EXECUTE ('PRINT N''Adding constraints to [dbo].[ib_Broker]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Broker] ADD CONSTRAINT [AK_ib_Broker_Code] UNIQUE NONCLUSTERED  ([Code])
');

GO
EXECUTE ('PRINT N''Adding constraints to [dbo].[ib_Broker]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Broker] ADD CONSTRAINT [AK_ib_Broker_DataSource] UNIQUE NONCLUSTERED  ([DatasourceId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_ib_Broker_DataSource] on [dbo].[ib_Broker]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_ib_Broker_DataSource] ON [dbo].[ib_Broker] ([DatasourceId])
');

GO
EXECUTE ('PRINT N''Adding constraints to [dbo].[ib_Broker]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Broker] ADD CONSTRAINT [AK_ib_Broker_Name] UNIQUE NONCLUSTERED  ([Name])
');

GO
EXECUTE ('PRINT N''Creating trigger [dbo].[BrokerUpdate] on [dbo].[ib_Broker]''
');

GO
EXECUTE ('CREATE TRIGGER [dbo].[BrokerUpdate]
    ON [dbo].[ib_Broker]
   AFTER UPDATE
	NOT FOR REPLICATION
    AS 
    BEGIN
    	SET NOCOUNT ON

		-- Insert statements for trigger here
		UPDATE [ib_Broker]
		SET UpdateDate = CASE WHEN UPDATE(UpdateDate) THEN UpdateDate ELSE GETDATE() END
			, UpdateUsername = CASE WHEN UPDATE(UpdateUsername) THEN UpdateUsername ELSE SUSER_SNAME() END
		WHERE BrokerId IN (SELECT BrokerID FROM Inserted)
    END
');

GO
EXECUTE ('PRINT N''Creating trigger [admin].[AppVersion_Audit_Insert] on [admin].[AppVersion]''
');

GO
EXECUTE ('CREATE TRIGGER  [admin].[AppVersion_Audit_Insert]
ON [admin].[AppVersion]
AFTER INSERT
AS 
BEGIN 
	INSERT INTO audit.[AppVersionHistory] ([AppVersionId],[VersionNumber],[ComponentCode],[ComponentName],[IsSolution],[Notes],[CreateDateTimeUtc],[CreateUserName],[UpdateDateTimeUtc],[UpdateUserName], [Action],[ServerList])
	SELECT [AppVersionId],[VersionNumber],[ComponentCode],[ComponentName],[IsSolution],[Notes],[CreateDateTimeUtc],[CreateUserName],[UpdateDateTimeUtc],[UpdateUserName], ''I'', [ServerList] FROM INSERTED

END
');

GO
EXECUTE ('PRINT N''Creating trigger [admin].[AppVersion_Audit_Update] on [admin].[AppVersion]''
');

GO
EXECUTE ('
CREATE TRIGGER  [admin].[AppVersion_Audit_Update]
ON [admin].[AppVersion]
AFTER UPDATE
AS 
BEGIN 
	INSERT INTO audit.[AppVersionHistory] ([AppVersionId],[VersionNumber],[ComponentCode],[ComponentName],[IsSolution],[Notes],[CreateDateTimeUtc],[CreateUserName],[UpdateDateTimeUtc],[UpdateUserName], [Action],[ServerList])
	SELECT [AppVersionId],[VersionNumber],[ComponentCode],[ComponentName],[IsSolution],[Notes],[CreateDateTimeUtc],[CreateUserName],[UpdateDateTimeUtc],[UpdateUserName], ''U'', [Serverlist] FROM INSERTED

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[aspnet_Applications]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[aspnet_Applications]
(
[ApplicationName] [nvarchar] (256) NOT NULL,
[LoweredApplicationName] [nvarchar] (256) NOT NULL,
[ApplicationId] [uniqueidentifier] NOT NULL CONSTRAINT [DF__aspnet_Ap__Appli__52842541] DEFAULT (newid()),
[Description] [nvarchar] (256) NULL
)
');

GO
EXECUTE ('PRINT N''Creating index [aspnet_Applications_Index] on [dbo].[aspnet_Applications]''
');

GO
EXECUTE ('CREATE CLUSTERED INDEX [aspnet_Applications_Index] ON [dbo].[aspnet_Applications] ([LoweredApplicationName])
');

GO
EXECUTE ('PRINT N''Creating primary key [PK__aspnet_Applicati__4FA7B896] on [dbo].[aspnet_Applications]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[aspnet_Applications] ADD CONSTRAINT [PK__aspnet_Applicati__4FA7B896] PRIMARY KEY NONCLUSTERED  ([ApplicationId])
');

GO
EXECUTE ('PRINT N''Adding constraints to [dbo].[aspnet_Applications]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[aspnet_Applications] ADD CONSTRAINT [UQ__aspnet_Applicati__51900108] UNIQUE NONCLUSTERED  ([ApplicationName])
');

GO
EXECUTE ('PRINT N''Adding constraints to [dbo].[aspnet_Applications]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[aspnet_Applications] ADD CONSTRAINT [UQ__aspnet_Applicati__509BDCCF] UNIQUE NONCLUSTERED  ([LoweredApplicationName])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[aspnet_Users]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[aspnet_Users]
(
[ApplicationId] [uniqueidentifier] NOT NULL,
[UserId] [uniqueidentifier] NOT NULL CONSTRAINT [DF__aspnet_Us__UserI__5654B625] DEFAULT (newid()),
[UserName] [nvarchar] (256) NOT NULL,
[LoweredUserName] [nvarchar] (256) NOT NULL,
[MobileAlias] [nvarchar] (16) NULL CONSTRAINT [DF__aspnet_Us__Mobil__5748DA5E] DEFAULT (NULL),
[IsAnonymous] [bit] NOT NULL CONSTRAINT [DF__aspnet_Us__IsAno__583CFE97] DEFAULT ((0)),
[LastActivityDate] [datetime] NOT NULL
)
');

GO
EXECUTE ('PRINT N''Creating index [aspnet_Users_Index] on [dbo].[aspnet_Users]''
');

GO
EXECUTE ('CREATE UNIQUE CLUSTERED INDEX [aspnet_Users_Index] ON [dbo].[aspnet_Users] ([ApplicationId], [LoweredUserName])
');

GO
EXECUTE ('PRINT N''Creating primary key [PK__aspnet_Users__546C6DB3] on [dbo].[aspnet_Users]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[aspnet_Users] ADD CONSTRAINT [PK__aspnet_Users__546C6DB3] PRIMARY KEY NONCLUSTERED  ([UserId])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[aspnet_Paths]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[aspnet_Paths]
(
[ApplicationId] [uniqueidentifier] NOT NULL,
[PathId] [uniqueidentifier] NOT NULL CONSTRAINT [DF__aspnet_Pa__PathI__18227982] DEFAULT (newid()),
[Path] [nvarchar] (256) NOT NULL,
[LoweredPath] [nvarchar] (256) NOT NULL
)
');

GO
EXECUTE ('PRINT N''Creating index [aspnet_Paths_index] on [dbo].[aspnet_Paths]''
');

GO
EXECUTE ('CREATE UNIQUE CLUSTERED INDEX [aspnet_Paths_index] ON [dbo].[aspnet_Paths] ([ApplicationId], [LoweredPath])
');

GO
EXECUTE ('PRINT N''Creating primary key [PK__aspnet_Paths__163A3110] on [dbo].[aspnet_Paths]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[aspnet_Paths] ADD CONSTRAINT [PK__aspnet_Paths__163A3110] PRIMARY KEY NONCLUSTERED  ([PathId])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[aspnet_PersonalizationAllUsers]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[aspnet_PersonalizationAllUsers]
(
[PathId] [uniqueidentifier] NOT NULL,
[PageSettings] [image] NOT NULL,
[LastUpdatedDate] [datetime] NOT NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK__aspnet_Personali__1BF30A66] on [dbo].[aspnet_PersonalizationAllUsers]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[aspnet_PersonalizationAllUsers] ADD CONSTRAINT [PK__aspnet_Personali__1BF30A66] PRIMARY KEY CLUSTERED  ([PathId])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[aspnet_PersonalizationPerUser]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[aspnet_PersonalizationPerUser]
(
[Id] [uniqueidentifier] NOT NULL CONSTRAINT [DF__aspnet_Perso__Id__1FC39B4A] DEFAULT (newid()),
[PathId] [uniqueidentifier] NULL,
[UserId] [uniqueidentifier] NULL,
[PageSettings] [image] NOT NULL,
[LastUpdatedDate] [datetime] NOT NULL
)
');

GO
EXECUTE ('PRINT N''Creating index [aspnet_PersonalizationPerUser_index1] on [dbo].[aspnet_PersonalizationPerUser]''
');

GO
EXECUTE ('CREATE UNIQUE CLUSTERED INDEX [aspnet_PersonalizationPerUser_index1] ON [dbo].[aspnet_PersonalizationPerUser] ([PathId], [UserId])
');

GO
EXECUTE ('PRINT N''Creating primary key [PK__aspnet_Personali__1ECF7711] on [dbo].[aspnet_PersonalizationPerUser]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[aspnet_PersonalizationPerUser] ADD CONSTRAINT [PK__aspnet_Personali__1ECF7711] PRIMARY KEY NONCLUSTERED  ([Id])
');

GO
EXECUTE ('PRINT N''Creating index [aspnet_PersonalizationPerUser_ncindex2] on [dbo].[aspnet_PersonalizationPerUser]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [aspnet_PersonalizationPerUser_ncindex2] ON [dbo].[aspnet_PersonalizationPerUser] ([UserId], [PathId])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[aspnet_Profile]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[aspnet_Profile]
(
[UserId] [uniqueidentifier] NOT NULL,
[PropertyNames] [ntext] NOT NULL,
[PropertyValuesString] [ntext] NOT NULL,
[PropertyValuesBinary] [image] NOT NULL,
[LastUpdatedDate] [datetime] NOT NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK__aspnet_Profile__799DF262] on [dbo].[aspnet_Profile]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[aspnet_Profile] ADD CONSTRAINT [PK__aspnet_Profile__799DF262] PRIMARY KEY CLUSTERED  ([UserId])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[aspnet_Roles]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[aspnet_Roles]
(
[ApplicationId] [uniqueidentifier] NOT NULL,
[RoleId] [uniqueidentifier] NOT NULL CONSTRAINT [DF__aspnet_Ro__RoleI__050FA50E] DEFAULT (newid()),
[RoleName] [nvarchar] (256) NOT NULL,
[LoweredRoleName] [nvarchar] (256) NOT NULL,
[Description] [nvarchar] (256) NULL
)
');

GO
EXECUTE ('PRINT N''Creating index [aspnet_Roles_index1] on [dbo].[aspnet_Roles]''
');

GO
EXECUTE ('CREATE UNIQUE CLUSTERED INDEX [aspnet_Roles_index1] ON [dbo].[aspnet_Roles] ([ApplicationId], [LoweredRoleName])
');

GO
EXECUTE ('PRINT N''Creating primary key [PK__aspnet_Roles__03275C9C] on [dbo].[aspnet_Roles]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[aspnet_Roles] ADD CONSTRAINT [PK__aspnet_Roles__03275C9C] PRIMARY KEY NONCLUSTERED  ([RoleId])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[aspnet_UsersInRoles]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[aspnet_UsersInRoles]
(
[UserId] [uniqueidentifier] NOT NULL,
[RoleId] [uniqueidentifier] NOT NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK__aspnet_UsersInRo__06F7ED80] on [dbo].[aspnet_UsersInRoles]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[aspnet_UsersInRoles] ADD CONSTRAINT [PK__aspnet_UsersInRo__06F7ED80] PRIMARY KEY CLUSTERED  ([UserId], [RoleId])
');

GO
EXECUTE ('PRINT N''Creating index [aspnet_UsersInRoles_index] on [dbo].[aspnet_UsersInRoles]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [aspnet_UsersInRoles_index] ON [dbo].[aspnet_UsersInRoles] ([RoleId])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_AdjustmentHeader]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_AdjustmentHeader]
(
[AdjustmentHeaderId] [int] NOT NULL IDENTITY(1, 1),
[AdjustmentTypeId] [int] NOT NULL,
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_AdjustmentHeader_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_AdjustmentHeader_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL,
[PriceId] [int] NULL,
[SettlementPriceAdjustment] [decimal] (24, 10) NULL,
[AdjustmentStatusId] [int] NULL,
[AdjustmentReasonId] [int] NULL,
[Description] [varchar] (4096) NULL,
[AdjustmentUserStatusId] [int] NULL,
[TradeReconciliationSummaryId] [int] NULL,
[RolledForwardFromAdjustmentHeaderId] [int] NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_AdjustmentHeader] on [dbo].[ib_AdjustmentHeader]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_AdjustmentHeader] ADD CONSTRAINT [PK_AdjustmentHeader] PRIMARY KEY CLUSTERED  ([AdjustmentHeaderId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_ib_AdjustmentHeader_AdjustmentReasonId] on [dbo].[ib_AdjustmentHeader]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_ib_AdjustmentHeader_AdjustmentReasonId] ON [dbo].[ib_AdjustmentHeader] ([AdjustmentReasonId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_ib_AdjustmentHeader_AdjustmentStatusId] on [dbo].[ib_AdjustmentHeader]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_ib_AdjustmentHeader_AdjustmentStatusId] ON [dbo].[ib_AdjustmentHeader] ([AdjustmentStatusId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_ib_AdjustmentHeader_AdjustmentTypeId] on [dbo].[ib_AdjustmentHeader]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_ib_AdjustmentHeader_AdjustmentTypeId] ON [dbo].[ib_AdjustmentHeader] ([AdjustmentTypeId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_ib_AdjustmentHeader_AdjustmentUserStatusId] on [dbo].[ib_AdjustmentHeader]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_ib_AdjustmentHeader_AdjustmentUserStatusId] ON [dbo].[ib_AdjustmentHeader] ([AdjustmentUserStatusId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_ib_AdjustmentHeader_PriceId] on [dbo].[ib_AdjustmentHeader]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_ib_AdjustmentHeader_PriceId] ON [dbo].[ib_AdjustmentHeader] ([PriceId])
');

GO
EXECUTE ('PRINT N''Creating index [ IX_ib_AdjustmentHeader_TradeReconciliationSummaryId] on [dbo].[ib_AdjustmentHeader]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [ IX_ib_AdjustmentHeader_TradeReconciliationSummaryId] ON [dbo].[ib_AdjustmentHeader] ([TradeReconciliationSummaryId])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_AdjustmentReason]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_AdjustmentReason]
(
[AdjustmentReasonId] [int] NOT NULL IDENTITY(1, 1),
[Code] [varchar] (100) NOT NULL,
[Description] [varchar] (100) NOT NULL,
[IsActive] [bit] NOT NULL CONSTRAINT [DF_AdjustmentReason_IsActive] DEFAULT ((1)),
[SortOrder] [int] NOT NULL CONSTRAINT [DF_AdjustmentReason_SortOrder] DEFAULT ((100)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_AdjustmentReason_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_AdjustmentReason_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_AdjustmentReason] on [dbo].[ib_AdjustmentReason]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_AdjustmentReason] ADD CONSTRAINT [PK_AdjustmentReason] PRIMARY KEY CLUSTERED  ([AdjustmentReasonId])
');

GO
EXECUTE ('PRINT N''Creating index [AK_AdjustmentReason_Code] on [dbo].[ib_AdjustmentReason]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_AdjustmentReason_Code] ON [dbo].[ib_AdjustmentReason] ([Code])
');

GO
EXECUTE ('PRINT N''Creating index [AK_AdjustmentReason_Description] on [dbo].[ib_AdjustmentReason]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_AdjustmentReason_Description] ON [dbo].[ib_AdjustmentReason] ([Description])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_AdjustmentStatus]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_AdjustmentStatus]
(
[AdjustmentStatusId] [int] NOT NULL IDENTITY(1, 1),
[Code] [varchar] (100) NOT NULL,
[Description] [varchar] (100) NOT NULL,
[IsActive] [bit] NOT NULL CONSTRAINT [DF_AdjustmentStatus_IsActive] DEFAULT ((1)),
[SortOrder] [int] NOT NULL CONSTRAINT [DF_AdjustmentStatus_SortOrder] DEFAULT ((100)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_AdjustmentStatus_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_AdjustmentStatus_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_AdjustmentStatus] on [dbo].[ib_AdjustmentStatus]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_AdjustmentStatus] ADD CONSTRAINT [PK_AdjustmentStatus] PRIMARY KEY CLUSTERED  ([AdjustmentStatusId])
');

GO
EXECUTE ('PRINT N''Creating index [AK_AdjustmentStatus_Code] on [dbo].[ib_AdjustmentStatus]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_AdjustmentStatus_Code] ON [dbo].[ib_AdjustmentStatus] ([Code])
');

GO
EXECUTE ('PRINT N''Creating index [AK_AdjustmentStatus_Description] on [dbo].[ib_AdjustmentStatus]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_AdjustmentStatus_Description] ON [dbo].[ib_AdjustmentStatus] ([Description])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_AdjustmentUserStatus]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_AdjustmentUserStatus]
(
[AdjustmentUserStatusId] [int] NOT NULL IDENTITY(1, 1),
[Code] [varchar] (100) NOT NULL,
[Description] [varchar] (100) NOT NULL,
[IsActive] [bit] NOT NULL CONSTRAINT [DF_AdjustmentUserStatus_IsActive] DEFAULT ((1)),
[SortOrder] [int] NOT NULL CONSTRAINT [DF_AdjustmentUserStatus_SortOrder] DEFAULT ((100)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_AdjustmentUserStatus_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_AdjustmentUserStatus_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_AdjustmentUserStatus] on [dbo].[ib_AdjustmentUserStatus]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_AdjustmentUserStatus] ADD CONSTRAINT [PK_AdjustmentUserStatus] PRIMARY KEY CLUSTERED  ([AdjustmentUserStatusId])
');

GO
EXECUTE ('PRINT N''Creating index [AK_AdjustmentUserStatus_Code] on [dbo].[ib_AdjustmentUserStatus]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_AdjustmentUserStatus_Code] ON [dbo].[ib_AdjustmentUserStatus] ([Code])
');

GO
EXECUTE ('PRINT N''Creating index [AK_AdjustmentUserStatus_Description] on [dbo].[ib_AdjustmentUserStatus]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_AdjustmentUserStatus_Description] ON [dbo].[ib_AdjustmentUserStatus] ([Description])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_AdjustmentType]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_AdjustmentType]
(
[AdjustmentTypeId] [int] NOT NULL IDENTITY(1, 1),
[Code] [varchar] (100) NOT NULL,
[Description] [varchar] (100) NOT NULL,
[IsActive] [bit] NOT NULL CONSTRAINT [DF_AdjustmentType_IsActive] DEFAULT ((1)),
[SortOrder] [int] NOT NULL CONSTRAINT [DF_AdjustmentType_SortOrder] DEFAULT ((100)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_AdjustmentType_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_AdjustmentType_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_AdjustmentType] on [dbo].[ib_AdjustmentType]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_AdjustmentType] ADD CONSTRAINT [PK_AdjustmentType] PRIMARY KEY CLUSTERED  ([AdjustmentTypeId])
');

GO
EXECUTE ('PRINT N''Creating index [AK_AdjustmentType_Code] on [dbo].[ib_AdjustmentType]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_AdjustmentType_Code] ON [dbo].[ib_AdjustmentType] ([Code])
');

GO
EXECUTE ('PRINT N''Creating index [AK_AdjustmentType_Description] on [dbo].[ib_AdjustmentType]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_AdjustmentType_Description] ON [dbo].[ib_AdjustmentType] ([Description])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ReceiveLocation]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ReceiveLocation]
(
[ReceiveLocationSysId] [tinyint] NOT NULL IDENTITY(1, 1),
[ReceiveLocationName] [varchar] (255) NOT NULL,
[PackageSysId] [tinyint] NOT NULL,
[FileMask] [varchar] (50) NOT NULL,
[InputFolder] [varchar] (255) NOT NULL,
[OutputFolder] [varchar] (255) NOT NULL,
[ErrorFolder] [varchar] (255) NOT NULL,
[DataSourceId] [int] NOT NULL,
[Priority] [tinyint] NULL,
[IsActive] [bit] NOT NULL CONSTRAINT [DF_ReceiveLocation_IsActive] DEFAULT ((1)),
[IsRunning] [bit] NOT NULL CONSTRAINT [DF_ReceiveLocation_IsRunning] DEFAULT ((0)),
[CreateDateTimeUtc] [smalldatetime] NOT NULL CONSTRAINT [DF_ReceiveLocation_CreateDateTimeUtc] DEFAULT (getutcdate()),
[CreateUsername] [varchar] (100) NOT NULL CONSTRAINT [DF_ReceiveLocation_CreateUserName] DEFAULT (suser_sname()),
[UpdateDateTimeUtc] [smalldatetime] NULL,
[UpdateUsername] [varchar] (100) NULL,
[DeleteDateTimeUtc] [smalldatetime] NULL,
[DeleteUsername] [varchar] (100) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_ReceiveLocation] on [dbo].[ReceiveLocation]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ReceiveLocation] ADD CONSTRAINT [PK_ReceiveLocation] PRIMARY KEY CLUSTERED  ([ReceiveLocationSysId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_Package] on [dbo].[ReceiveLocation]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_Package] ON [dbo].[ReceiveLocation] ([PackageSysId]) INCLUDE ([DataSourceId], [ErrorFolder], [FileMask], [InputFolder], [IsActive], [OutputFolder])
');

GO
EXECUTE ('PRINT N''Creating index [AK_Package_Folder_FileMask] on [dbo].[ReceiveLocation]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_Package_Folder_FileMask] ON [dbo].[ReceiveLocation] ([PackageSysId], [InputFolder], [FileMask], [OutputFolder], [ErrorFolder])
');

GO
EXECUTE ('PRINT N''Creating index [AK_ReceiveLocationName] on [dbo].[ReceiveLocation]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_ReceiveLocationName] ON [dbo].[ReceiveLocation] ([ReceiveLocationName])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_CloseOutReport]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_CloseOutReport]
(
[CloseOutReportId] [int] NOT NULL IDENTITY(1, 1),
[TemplateId] [int] NOT NULL,
[Date] [datetime] NOT NULL,
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_ib_CloseOutReport_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_ib_CloseOutReport_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_ib_CloseOutReport] on [dbo].[ib_CloseOutReport]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_CloseOutReport] ADD CONSTRAINT [PK_ib_CloseOutReport] PRIMARY KEY CLUSTERED  ([CloseOutReportId])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_CloseOutReportDetail]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_CloseOutReportDetail]
(
[CloseOutReportDetailId] [int] NOT NULL IDENTITY(1, 1),
[CloseOutReportId] [int] NOT NULL,
[ExchangeId] [int] NOT NULL,
[InstrumentId] [int] NOT NULL,
[FirmId] [int] NOT NULL,
[AccountId] [int] NULL,
[ClassId] [int] NULL,
[ExpiryYear] [smallint] NOT NULL,
[ExpiryMonth] [smallint] NOT NULL,
[ExpiryDay] [smallint] NULL,
[InstrumentTypeId] [int] NOT NULL,
[OptionTypeCode] [varchar] (25) NULL,
[StrikePrice] [decimal] (19, 4) NULL,
[UseNetForCloseOut] [bit] NOT NULL,
[TradedBought] [decimal] (19, 4) NOT NULL,
[TradedSold] [decimal] (19, 4) NOT NULL,
[InternalLong] [decimal] (19, 4) NOT NULL,
[InternalShort] [decimal] (19, 4) NOT NULL,
[ExternalLong] [decimal] (19, 4) NOT NULL,
[ExternalShort] [decimal] (19, 4) NOT NULL,
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_ib_CloseOutReportDetail_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_ib_CloseOutReportDetail_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL,
[SourceMatchCodeId] [int] NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_ib_CloseOutReportDetail] on [dbo].[ib_CloseOutReportDetail]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_CloseOutReportDetail] ADD CONSTRAINT [PK_ib_CloseOutReportDetail] PRIMARY KEY CLUSTERED  ([CloseOutReportDetailId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_all_key_fields] on [dbo].[ib_CloseOutReportDetail]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_all_key_fields] ON [dbo].[ib_CloseOutReportDetail] ([CloseOutReportId], [FirmId], [AccountId], [ExchangeId], [InstrumentId], [ExpiryYear], [ExpiryMonth], [ExpiryDay], [UseNetForCloseOut], [StrikePrice], [ClassId], [OptionTypeCode], [CloseOutReportDetailId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_instrument] on [dbo].[ib_CloseOutReportDetail]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_instrument] ON [dbo].[ib_CloseOutReportDetail] ([InstrumentId])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_CloseOutReportSummary]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_CloseOutReportSummary]
(
[CloseOutReportSummaryId] [int] NOT NULL IDENTITY(1, 1),
[CloseOutReportId] [int] NOT NULL,
[ExchangeId] [int] NOT NULL,
[InstrumentId] [int] NOT NULL,
[ExpiryYear] [smallint] NOT NULL,
[ExpiryMonth] [smallint] NOT NULL,
[ExpiryDay] [smallint] NULL,
[InstrumentTypeId] [int] NOT NULL,
[OptionTypeCode] [varchar] (25) NULL,
[StrikePrice] [decimal] (19, 4) NULL,
[UseNetForCloseOut] [bit] NOT NULL,
[TradedBought] [decimal] (19, 4) NOT NULL,
[TradedSold] [decimal] (19, 4) NOT NULL,
[InternalLong] [decimal] (19, 4) NOT NULL,
[InternalShort] [decimal] (19, 4) NOT NULL,
[ExternalLong] [decimal] (19, 4) NOT NULL,
[ExternalShort] [decimal] (19, 4) NOT NULL,
[CloseOutLong] [decimal] (19, 4) NOT NULL,
[CloseOutShort] [decimal] (19, 4) NOT NULL,
[Imbalance] [decimal] (19, 4) NOT NULL,
[Description] [varchar] (100) NOT NULL,
[ExchangeCode] [varchar] (50) NOT NULL,
[InstrumentTypeCode] [varchar] (100) NOT NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_ib_CloseOutReportSummary] on [dbo].[ib_CloseOutReportSummary]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_CloseOutReportSummary] ADD CONSTRAINT [PK_ib_CloseOutReportSummary] PRIMARY KEY CLUSTERED  ([CloseOutReportSummaryId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_instrument] on [dbo].[ib_CloseOutReportSummary]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_instrument] ON [dbo].[ib_CloseOutReportSummary] ([InstrumentId])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_DataType]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_DataType]
(
[DataTypeId] [int] NOT NULL IDENTITY(1, 1),
[Code] [varchar] (100) NOT NULL,
[Description] [varchar] (100) NOT NULL,
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_ib_DataType_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_ib_DataType_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_ib_DataType] on [dbo].[ib_DataType]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_DataType] ADD CONSTRAINT [PK_ib_DataType] PRIMARY KEY CLUSTERED  ([DataTypeId])
');

GO
EXECUTE ('PRINT N''Creating index [AK_code] on [dbo].[ib_DataType]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_code] ON [dbo].[ib_DataType] ([Code])
');

GO
EXECUTE ('PRINT N''Creating index [AK_desc] on [dbo].[ib_DataType]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_desc] ON [dbo].[ib_DataType] ([Description])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Field]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_Field]
(
[FieldId] [int] NOT NULL IDENTITY(1, 1),
[Code] [varchar] (100) NOT NULL,
[Description] [varchar] (100) NOT NULL,
[ShortDescription] [varchar] (15) NOT NULL,
[DataTypeId] [int] NOT NULL,
[CanBeMatchedToAnotherField] [bit] NOT NULL CONSTRAINT [DF_ib_Field_CanBeMatchedToAnotherField] DEFAULT ((0)),
[SortOrder] [smallint] NOT NULL CONSTRAINT [DF_ib_Field_SortOrder] DEFAULT ((100)),
[IsActive] [bit] NOT NULL CONSTRAINT [DF_ib_Field_IsActive] DEFAULT ((1)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_ib_Field_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_ib_Field_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_ib_Field] on [dbo].[ib_Field]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Field] ADD CONSTRAINT [PK_ib_Field] PRIMARY KEY CLUSTERED  ([FieldId])
');

GO
EXECUTE ('PRINT N''Creating index [AK_code] on [dbo].[ib_Field]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_code] ON [dbo].[ib_Field] ([Code])
');

GO
EXECUTE ('PRINT N''Creating index [AK_desc] on [dbo].[ib_Field]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_desc] ON [dbo].[ib_Field] ([Description])
');

GO
EXECUTE ('PRINT N''Creating index [AK_shortDesc] on [dbo].[ib_Field]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_shortDesc] ON [dbo].[ib_Field] ([ShortDescription])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[PositionsRealisedCash]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[PositionsRealisedCash]
(
[PositionsRealisedCashId] [int] NOT NULL IDENTITY(1, 1),
[AsOfDate] [date] NOT NULL,
[AccountId] [int] NOT NULL,
[Product] [varchar] (5) NULL,
[CurrencyId] [int] NOT NULL,
[Contract] [varchar] (5) NULL,
[PromptDate] [date] NULL,
[Strike] [money] NULL,
[IsCall] [bit] NOT NULL,
[TransactionValue] [money] NOT NULL,
[DataSourceId] [int] NOT NULL,
[ExchangeId] [int] NOT NULL,
[FirmId] [int] NOT NULL,
[InstrumentTypeCode] [char] (1) NOT NULL,
[InstrumentCode] [varchar] (100) NOT NULL,
[InstrumentId] [int] NULL,
[TempTableRecordId] [int] NULL,
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF__Positions__Creat__5E3765BD] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF__Positions__Creat__5F2B89F6] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_PositionsRealisedCashId] on [dbo].[PositionsRealisedCash]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[PositionsRealisedCash] ADD CONSTRAINT [PK_PositionsRealisedCashId] PRIMARY KEY CLUSTERED  ([PositionsRealisedCashId])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_ImbalanceReportSummary]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_ImbalanceReportSummary]
(
[ImbalanceReportSummaryId] [int] NOT NULL IDENTITY(1, 1),
[ImbalanceReportId] [int] NOT NULL,
[ExchangeId] [int] NOT NULL,
[InstrumentId] [int] NOT NULL,
[ExpiryYear] [smallint] NOT NULL,
[ExpiryMonth] [smallint] NOT NULL,
[ExpiryDay] [smallint] NULL,
[OptionTypeCode] [varchar] (25) NULL,
[CurrencyId] [int] NOT NULL,
[StrikePrice] [decimal] (19, 4) NULL,
[Internal_YAdjOTE] [decimal] (19, 4) NOT NULL,
[Internal_YOTE] [decimal] (19, 4) NOT NULL,
[Internal_PandS] [decimal] (19, 4) NOT NULL,
[Internal_TAdjOTE] [decimal] (19, 4) NOT NULL,
[Internal_TOTE] [decimal] (19, 4) NOT NULL,
[Internal_Position] [decimal] (19, 4) NOT NULL,
[External_YAdjOTE] [decimal] (19, 4) NOT NULL,
[External_YOTE] [decimal] (19, 4) NOT NULL,
[External_PandS] [decimal] (19, 4) NOT NULL,
[External_TAdjOTE] [decimal] (19, 4) NOT NULL,
[External_TOTE] [decimal] (19, 4) NOT NULL,
[External_Position] [decimal] (19, 4) NOT NULL,
[Lots] [decimal] (19, 4) NOT NULL,
[Variation] [decimal] (19, 4) NOT NULL,
[Description] [varchar] (100) NOT NULL,
[Exchange] [varchar] (50) NOT NULL,
[Currency] [varchar] (100) NOT NULL,
[Instrument] [varchar] (100) NOT NULL,
[UpdateDate] [datetime] NULL,
[Notes] [varchar] (4000) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_ib_ImbalanceReportSummary] on [dbo].[ib_ImbalanceReportSummary]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_ImbalanceReportSummary] ADD CONSTRAINT [PK_ib_ImbalanceReportSummary] PRIMARY KEY CLUSTERED  ([ImbalanceReportSummaryId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_currency] on [dbo].[ib_ImbalanceReportSummary]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_currency] ON [dbo].[ib_ImbalanceReportSummary] ([CurrencyId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_ib_ImbalanceReportSummary_Description] on [dbo].[ib_ImbalanceReportSummary]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_ib_ImbalanceReportSummary_Description] ON [dbo].[ib_ImbalanceReportSummary] ([Description])
');

GO
EXECUTE ('PRINT N''Creating index [IX_ib_ImbalanceReportSummary_ImbalanceReportId] on [dbo].[ib_ImbalanceReportSummary]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_ib_ImbalanceReportSummary_ImbalanceReportId] ON [dbo].[ib_ImbalanceReportSummary] ([ImbalanceReportId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_instrument] on [dbo].[ib_ImbalanceReportSummary]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_instrument] ON [dbo].[ib_ImbalanceReportSummary] ([InstrumentId])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_NostroBalancingItem]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_NostroBalancingItem]
(
[NostroBalancingItemId] [int] NOT NULL IDENTITY(1, 1),
[GroupNumber] [int] NOT NULL,
[AmountPayments] [decimal] (18, 4) NULL CONSTRAINT [DF__ib_Nostro__Amoun__38DA2D2E] DEFAULT ((0)),
[AmountReceipts] [decimal] (18, 4) NULL CONSTRAINT [DF__ib_Nostro__Amoun__39CE5167] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_ib_NostroBalancingItem_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_ib_NostroBalancingItem_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_ib_NostroBalancingItem] on [dbo].[ib_NostroBalancingItem]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_NostroBalancingItem] ADD CONSTRAINT [PK_ib_NostroBalancingItem] PRIMARY KEY CLUSTERED  ([NostroBalancingItemId])
');

GO
EXECUTE ('PRINT N''Creating index [AK_Group] on [dbo].[ib_NostroBalancingItem]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_Group] ON [dbo].[ib_NostroBalancingItem] ([GroupNumber])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_NostroMatch]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_NostroMatch]
(
[NostroMatchId] [int] NOT NULL IDENTITY(1, 1),
[GroupNumber] [int] NOT NULL,
[NostroId] [int] NOT NULL,
[NostroMatchTypeId] [int] NOT NULL,
[Comments] [varchar] (1024) NULL,
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_ib_NostroMatch_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_ib_NostroMatch_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL,
[RuleId] [int] NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_ib_NostroMatch] on [dbo].[ib_NostroMatch]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_NostroMatch] ADD CONSTRAINT [PK_ib_NostroMatch] PRIMARY KEY CLUSTERED  ([NostroMatchId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_ib_NostroMatch_CreateDate] on [dbo].[ib_NostroMatch]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_ib_NostroMatch_CreateDate] ON [dbo].[ib_NostroMatch] ([CreateDate])
');

GO
EXECUTE ('PRINT N''Creating index [IX_Group_Nostro] on [dbo].[ib_NostroMatch]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_Group_Nostro] ON [dbo].[ib_NostroMatch] ([GroupNumber], [NostroId])
');

GO
EXECUTE ('PRINT N''Creating index [AK_Nostro] on [dbo].[ib_NostroMatch]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_Nostro] ON [dbo].[ib_NostroMatch] ([NostroId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_MatchType] on [dbo].[ib_NostroMatch]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_MatchType] ON [dbo].[ib_NostroMatch] ([NostroMatchTypeId])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Department]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_Department]
(
[DepartmentId] [int] NOT NULL IDENTITY(1, 1),
[Code] [varchar] (100) NOT NULL,
[Description] [varchar] (100) NOT NULL,
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_ib_Department_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_ib_Department_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_ib_Department] on [dbo].[ib_Department]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Department] ADD CONSTRAINT [PK_ib_Department] PRIMARY KEY CLUSTERED  ([DepartmentId])
');

GO
EXECUTE ('PRINT N''Creating index [AK_Department_Code] on [dbo].[ib_Department]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_Department_Code] ON [dbo].[ib_Department] ([Code])
');

GO
EXECUTE ('PRINT N''Creating index [AK_Department_Description] on [dbo].[ib_Department]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_Department_Description] ON [dbo].[ib_Department] ([Description])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Rule]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_Rule]
(
[RuleId] [int] NOT NULL IDENTITY(1, 1),
[RuleTypeId] [int] NOT NULL,
[TemplateId] [int] NOT NULL,
[RuleNumber] [int] NOT NULL,
[Name] [varchar] (100) NOT NULL,
[Description] [varchar] (255) NULL,
[MatchCountTypeId] [int] NOT NULL,
[ToleranceTypeId] [int] NOT NULL,
[Tolerance] [decimal] (18, 4) NOT NULL CONSTRAINT [DF_ib_Rule_Tolerance] DEFAULT ((0)),
[IsEnabled] [bit] NOT NULL CONSTRAINT [DF_ib_Rule_IsEnabled] DEFAULT ((1)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_ib_Rule_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_ib_Rule_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL,
[IsActive] [bit] NOT NULL CONSTRAINT [DF_ib_Rule_IsActive] DEFAULT ((1))
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_ib_Rule] on [dbo].[ib_Rule]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Rule] ADD CONSTRAINT [PK_ib_Rule] PRIMARY KEY CLUSTERED  ([RuleId])
');

GO
EXECUTE ('PRINT N''Creating index [AK_name] on [dbo].[ib_Rule]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_name] ON [dbo].[ib_Rule] ([Name])
');

GO
EXECUTE ('PRINT N''Creating index [AK_number] on [dbo].[ib_Rule]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_number] ON [dbo].[ib_Rule] ([RuleNumber])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Operator]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_Operator]
(
[OperatorId] [int] NOT NULL IDENTITY(1, 1),
[Code] [varchar] (50) NOT NULL,
[Description] [varchar] (50) NOT NULL,
[ShortDescription] [varchar] (15) NOT NULL,
[DataTypeId] [int] NOT NULL,
[RequiresField2] [bit] NOT NULL CONSTRAINT [DF_ib_Operator_RequiresField2] DEFAULT ((0)),
[SortOrder] [smallint] NOT NULL CONSTRAINT [DF_ib_Operator_SortOrder] DEFAULT ((100)),
[IsActive] [bit] NOT NULL CONSTRAINT [DF_ib_Operator_IsActive] DEFAULT ((1)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_ib_Operator_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_ib_Operator_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_ib_Operator] on [dbo].[ib_Operator]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Operator] ADD CONSTRAINT [PK_ib_Operator] PRIMARY KEY CLUSTERED  ([OperatorId])
');

GO
EXECUTE ('PRINT N''Creating index [AK_code] on [dbo].[ib_Operator]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_code] ON [dbo].[ib_Operator] ([Code])
');

GO
EXECUTE ('PRINT N''Creating index [AK_desc] on [dbo].[ib_Operator]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_desc] ON [dbo].[ib_Operator] ([Description])
');

GO
EXECUTE ('PRINT N''Creating index [AK_shortDesc] on [dbo].[ib_Operator]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_shortDesc] ON [dbo].[ib_Operator] ([ShortDescription])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_PeoplesoftBalancesLog]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_PeoplesoftBalancesLog]
(
[PeoplesoftBalancesLogId] [int] NOT NULL IDENTITY(1, 1),
[AccountId] [int] NOT NULL,
[CurrencyId] [int] NOT NULL,
[OpenBalance] [money] NOT NULL,
[ClosingBalance] [money] NOT NULL,
[NostroBalance] [money] NULL,
[Filename] [varchar] (512) NOT NULL,
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_ib_PeoplesoftBalancesLog_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_ib_PeoplesoftBalancesLog_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_ib_PeoplesoftBalancesLog] on [dbo].[ib_PeoplesoftBalancesLog]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_PeoplesoftBalancesLog] ADD CONSTRAINT [PK_ib_PeoplesoftBalancesLog] PRIMARY KEY CLUSTERED  ([PeoplesoftBalancesLogId])
');

GO
EXECUTE ('PRINT N''Creating index [ix_PeoplesoftBalancesLog_AccountId] on [dbo].[ib_PeoplesoftBalancesLog]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [ix_PeoplesoftBalancesLog_AccountId] ON [dbo].[ib_PeoplesoftBalancesLog] ([AccountId])
');

GO
EXECUTE ('PRINT N''Creating index [ix_PeoplesoftBalancesLog_CurrencyId] on [dbo].[ib_PeoplesoftBalancesLog]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [ix_PeoplesoftBalancesLog_CurrencyId] ON [dbo].[ib_PeoplesoftBalancesLog] ([CurrencyId])
');

GO
EXECUTE ('PRINT N''Creating index [ix_PeoplesoftBalancesLog_Filename] on [dbo].[ib_PeoplesoftBalancesLog]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [ix_PeoplesoftBalancesLog_Filename] ON [dbo].[ib_PeoplesoftBalancesLog] ([Filename])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_QueueStatus]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_QueueStatus]
(
[QueueStatusId] [int] NOT NULL,
[Name] [nchar] (20) NULL,
[Code] [nvarchar] (10) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK__tmp_ms_x__851F09C6874467BF] on [dbo].[ib_QueueStatus]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_QueueStatus] ADD CONSTRAINT [PK__tmp_ms_x__851F09C6874467BF] PRIMARY KEY CLUSTERED  ([QueueStatusId])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_QueueItem]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_QueueItem]
(
[QueueItemId] [int] NOT NULL IDENTITY(1, 1),
[StatusId] [int] NOT NULL,
[DisplayMessage] [nvarchar] (150) NULL,
[ErrorMessage] [nvarchar] (max) NULL,
[CompletedOn] [datetime] NULL,
[ScheduledStart] [datetime] NOT NULL,
[ScheduledTaskId] [int] NULL,
[SiteId] [int] NULL,
[TemplateId] [int] NULL,
[TaskTypeId] [int] NULL,
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_ib_QueueItem_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_ib_QueueItem_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_ib_QueueItem] on [dbo].[ib_QueueItem]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_QueueItem] ADD CONSTRAINT [PK_ib_QueueItem] PRIMARY KEY CLUSTERED  ([QueueItemId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_General_QueueItem] on [dbo].[ib_QueueItem]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_General_QueueItem] ON [dbo].[ib_QueueItem] ([StatusId], [ScheduledStart]) INCLUDE ([DisplayMessage], [QueueItemId], [ScheduledTaskId], [SiteId], [TaskTypeId], [TemplateId])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_ScheduledTask]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_ScheduledTask]
(
[ScheduledTaskId] [int] NOT NULL IDENTITY(1, 1),
[Name] [nvarchar] (50) NOT NULL,
[Description] [nvarchar] (200) NULL,
[TaskTypeId] [int] NOT NULL,
[RunAtSpecificDay] [smallint] NULL,
[Frequency] [smallint] NULL,
[NextRun] [datetime] NULL,
[LastRun] [datetime] NULL,
[IsActive] [bit] NOT NULL,
[CreateUsername] [nvarchar] (50) NULL,
[UpdateUsername] [nvarchar] (50) NULL,
[SiteId] [int] NULL,
[TemplateId] [int] NULL,
[CreateDate] [datetime] NULL CONSTRAINT [DF_ib_ScheduledTask_CreateDate] DEFAULT (getdate()),
[UpdateDate] [datetime] NULL CONSTRAINT [DF_ib_ScheduledTask_UpdateDate] DEFAULT (getdate()),
[RunAtTime] [datetime] NOT NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_ib_ScheduledTask] on [dbo].[ib_ScheduledTask]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_ScheduledTask] ADD CONSTRAINT [PK_ib_ScheduledTask] PRIMARY KEY CLUSTERED  ([ScheduledTaskId])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TaskType]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_TaskType]
(
[TaskTypeId] [int] NOT NULL IDENTITY(1, 1),
[Code] [nvarchar] (50) NOT NULL,
[Name] [nvarchar] (150) NOT NULL,
[Description] [nvarchar] (400) NULL,
[IsActive] [bit] NOT NULL,
[CreateUsername] [nvarchar] (50) NULL,
[UpdateUsername] [nvarchar] (50) NULL,
[AssemblyId] [int] NOT NULL,
[TypeName] [nvarchar] (50) NOT NULL,
[CreateDate] [datetime] NULL CONSTRAINT [DF_ib_TaskType_CreateDate] DEFAULT (getdate()),
[UpdateDate] [datetime] NULL CONSTRAINT [DF_ib_TaskType_UpdateDate] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_ib_TaskType] on [dbo].[ib_TaskType]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_TaskType] ADD CONSTRAINT [PK_ib_TaskType] PRIMARY KEY CLUSTERED  ([TaskTypeId])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_QueueLog]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_QueueLog]
(
[Message] [nvarchar] (500) NULL,
[Level] [int] NULL,
[Category] [int] NULL,
[QueueItemId] [int] NULL,
[QueueLogId] [int] NOT NULL IDENTITY(1, 1),
[CreatedOn] [datetime] NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK__tmp_ms_x__D4EB4686C907186B] on [dbo].[ib_QueueLog]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_QueueLog] ADD CONSTRAINT [PK__tmp_ms_x__D4EB4686C907186B] PRIMARY KEY CLUSTERED  ([QueueLogId])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_MatchCountType]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_MatchCountType]
(
[MatchCountTypeId] [int] NOT NULL IDENTITY(1, 1),
[Code] [varchar] (100) NOT NULL,
[Description] [varchar] (100) NOT NULL,
[ShortDescription] [varchar] (15) NOT NULL,
[SortOrder] [smallint] NOT NULL CONSTRAINT [DF_ib_MatchCountType_SortOrder] DEFAULT ((100)),
[IsActive] [bit] NOT NULL CONSTRAINT [DF_ib_MatchCountType_IsActive] DEFAULT ((1)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_ib_MatchCountType_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_ib_MatchCountType_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_ib_MatchCountType] on [dbo].[ib_MatchCountType]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_MatchCountType] ADD CONSTRAINT [PK_ib_MatchCountType] PRIMARY KEY CLUSTERED  ([MatchCountTypeId])
');

GO
EXECUTE ('PRINT N''Creating index [AK_code] on [dbo].[ib_MatchCountType]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_code] ON [dbo].[ib_MatchCountType] ([Code])
');

GO
EXECUTE ('PRINT N''Creating index [AK_desc] on [dbo].[ib_MatchCountType]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_desc] ON [dbo].[ib_MatchCountType] ([Description])
');

GO
EXECUTE ('PRINT N''Creating index [AK_shortDesc] on [dbo].[ib_MatchCountType]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_shortDesc] ON [dbo].[ib_MatchCountType] ([ShortDescription])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_RuleType]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_RuleType]
(
[RuleTypeId] [int] NOT NULL IDENTITY(1, 1),
[Code] [varchar] (100) NOT NULL,
[Description] [varchar] (100) NOT NULL,
[TemplateTypeId] [int] NOT NULL,
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_ib_RuleType_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_ib_RuleType_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_ib_RuleType] on [dbo].[ib_RuleType]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_RuleType] ADD CONSTRAINT [PK_ib_RuleType] PRIMARY KEY CLUSTERED  ([RuleTypeId])
');

GO
EXECUTE ('PRINT N''Creating index [AK_code] on [dbo].[ib_RuleType]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_code] ON [dbo].[ib_RuleType] ([Code])
');

GO
EXECUTE ('PRINT N''Creating index [AK_desc] on [dbo].[ib_RuleType]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_desc] ON [dbo].[ib_RuleType] ([Description])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_ToleranceType]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_ToleranceType]
(
[ToleranceTypeId] [int] NOT NULL IDENTITY(1, 1),
[Code] [varchar] (100) NOT NULL,
[Description] [varchar] (100) NOT NULL,
[ShortDescription] [varchar] (15) NOT NULL,
[RequiresToleranceValue] [bit] NOT NULL CONSTRAINT [DF_ib_ToleranceType_RequiresToleranceValue] DEFAULT ((0)),
[SortOrder] [smallint] NOT NULL CONSTRAINT [DF_ib_ToleranceType_SortOrder] DEFAULT ((100)),
[IsActive] [bit] NOT NULL CONSTRAINT [DF_ib_ToleranceType_IsActive] DEFAULT ((1)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_ib_ToleranceType_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_ib_ToleranceType_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_ib_ToleranceType] on [dbo].[ib_ToleranceType]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_ToleranceType] ADD CONSTRAINT [PK_ib_ToleranceType] PRIMARY KEY CLUSTERED  ([ToleranceTypeId])
');

GO
EXECUTE ('PRINT N''Creating index [AK_code] on [dbo].[ib_ToleranceType]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_code] ON [dbo].[ib_ToleranceType] ([Code])
');

GO
EXECUTE ('PRINT N''Creating index [AK_desc] on [dbo].[ib_ToleranceType]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_desc] ON [dbo].[ib_ToleranceType] ([Description])
');

GO
EXECUTE ('PRINT N''Creating index [AK_shortDesc] on [dbo].[ib_ToleranceType]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_shortDesc] ON [dbo].[ib_ToleranceType] ([ShortDescription])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_RuleCondition]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_RuleCondition]
(
[RuleConditionId] [int] NOT NULL IDENTITY(1, 1),
[RuleId] [int] NOT NULL,
[Description] [varchar] (255) NULL,
[InternalExternalCode] [char] (1) NOT NULL,
[Field1Id] [int] NOT NULL,
[OperatorId] [int] NOT NULL,
[Field2Id] [int] NULL,
[Value] [varchar] (255) NULL,
[IsEnabled] [bit] NOT NULL CONSTRAINT [DF_ib_RuleCondition_IsEnabled] DEFAULT ((1)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_ib_RuleCondition_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_ib_RuleCondition_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_ib_RuleCondition] on [dbo].[ib_RuleCondition]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_RuleCondition] ADD CONSTRAINT [PK_ib_RuleCondition] PRIMARY KEY CLUSTERED  ([RuleConditionId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_rule] on [dbo].[ib_RuleCondition]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_rule] ON [dbo].[ib_RuleCondition] ([RuleId])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_RuleMatchCode]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_RuleMatchCode]
(
[RuleMatchCodeId] [int] NOT NULL IDENTITY(1, 1),
[RuleId] [int] NOT NULL,
[MatchCodeId] [int] NOT NULL,
[SequenceNumber] [smallint] NOT NULL,
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_ib_RuleMatchCode_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_ib_RuleMatchCode_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_ib_RuleMatchCode] on [dbo].[ib_RuleMatchCode]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_RuleMatchCode] ADD CONSTRAINT [PK_ib_RuleMatchCode] PRIMARY KEY CLUSTERED  ([RuleMatchCodeId])
');

GO
EXECUTE ('PRINT N''Creating index [AK_rule_matchCode] on [dbo].[ib_RuleMatchCode]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_rule_matchCode] ON [dbo].[ib_RuleMatchCode] ([RuleId], [MatchCodeId])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_SwiftStatement]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_SwiftStatement]
(
[SwiftStatementId] [int] NOT NULL IDENTITY(1, 1),
[AccountId] [int] NOT NULL,
[StatementNumber] [int] NOT NULL,
[StatementSequenceNumber] [int] NOT NULL,
[BalanceDate] [datetime] NOT NULL,
[CurrencyId] [int] NOT NULL,
[OpenBalance] [money] NOT NULL,
[TotalOfLineItemAmounts] [money] NOT NULL,
[ClosingBalance] [money] NOT NULL,
[NostroClosingBalance] [money] NULL,
[Filename] [varchar] (512) NOT NULL,
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_ib_SwiftStatement_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_ib_SwiftStatement_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL,
[IsLastInSequence] [bit] NOT NULL CONSTRAINT [DF_ib_SwiftStatement_IsLastInSequence] DEFAULT ((0)),
[IsMissReplacement] [bit] NOT NULL CONSTRAINT [DF_ib_SwiftStatement_IsMissReplacement] DEFAULT ((0)),
[GapNostroId] [int] NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_ib_SwiftStatement] on [dbo].[ib_SwiftStatement]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_SwiftStatement] ADD CONSTRAINT [PK_ib_SwiftStatement] PRIMARY KEY CLUSTERED  ([SwiftStatementId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_AccountId] on [dbo].[ib_SwiftStatement]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_AccountId] ON [dbo].[ib_SwiftStatement] ([AccountId]) WITH (ALLOW_PAGE_LOCKS=OFF)
');

GO
EXECUTE ('PRINT N''Creating index [IX_Account_StatmNo_StatmSeq] on [dbo].[ib_SwiftStatement]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [IX_Account_StatmNo_StatmSeq] ON [dbo].[ib_SwiftStatement] ([AccountId], [StatementNumber], [StatementSequenceNumber])
');

GO
EXECUTE ('PRINT N''Creating index [IX_BalanceDate] on [dbo].[ib_SwiftStatement]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_BalanceDate] ON [dbo].[ib_SwiftStatement] ([BalanceDate])
');

GO
EXECUTE ('PRINT N''Creating index [IX_CurrencyId] on [dbo].[ib_SwiftStatement]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_CurrencyId] ON [dbo].[ib_SwiftStatement] ([CurrencyId]) WITH (ALLOW_PAGE_LOCKS=OFF)
');

GO
EXECUTE ('PRINT N''Creating index [IX_ib_SwiftStatement_GapNostroId] on [dbo].[ib_SwiftStatement]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_ib_SwiftStatement_GapNostroId] ON [dbo].[ib_SwiftStatement] ([GapNostroId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_StatmNo_StatmSeq] on [dbo].[ib_SwiftStatement]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_StatmNo_StatmSeq] ON [dbo].[ib_SwiftStatement] ([StatementNumber], [StatementSequenceNumber]) INCLUDE ([SwiftStatementId], [TotalOfLineItemAmounts])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Assembly]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_Assembly]
(
[AssemblyId] [int] NOT NULL IDENTITY(1, 1),
[FullName] [nvarchar] (300) NOT NULL,
[CreateUsername] [nvarchar] (50) NULL,
[UpdateUsername] [nvarchar] (50) NULL,
[Bin] [varbinary] (max) NULL,
[ShortName] [nvarchar] (50) NOT NULL,
[CreateDate] [datetime] NULL CONSTRAINT [DF_ib_Assembly_CreateDate] DEFAULT (getdate()),
[UpdateDate] [datetime] NULL CONSTRAINT [DF_ib_Assembly_UpdateDate] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_ib_Assembly] on [dbo].[ib_Assembly]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Assembly] ADD CONSTRAINT [PK_ib_Assembly] PRIMARY KEY CLUSTERED  ([AssemblyId])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TradeReconciliation]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_TradeReconciliation]
(
[TradeReconciliationId] [int] NOT NULL IDENTITY(1, 1),
[TemplateId] [int] NOT NULL,
[Today] [datetime] NOT NULL,
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_ib_TradeReconciliation_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_ib_TradeReconciliation_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_ib_TradeReconciliation] on [dbo].[ib_TradeReconciliation]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_TradeReconciliation] ADD CONSTRAINT [PK_ib_TradeReconciliation] PRIMARY KEY CLUSTERED  ([TradeReconciliationId])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TradeReconciliationDetail]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_TradeReconciliationDetail]
(
[TradeReconciliationDetailId] [int] NOT NULL IDENTITY(1, 1),
[TradeReconciliationId] [int] NOT NULL,
[MatchCode] [varchar] (100) NOT NULL,
[TrxId] [int] NULL,
[ExchangeId] [int] NOT NULL,
[FirmId] [int] NULL,
[AccountId] [int] NULL,
[DetailAccountId] [int] NULL,
[InstrumentId] [int] NOT NULL,
[ClassId] [int] NULL,
[ExpiryYear] [smallint] NOT NULL,
[ExpiryMonth] [smallint] NOT NULL,
[ExpiryDay] [smallint] NULL,
[OptionTypeCode] [varchar] (25) NULL,
[CurrencyId] [int] NOT NULL,
[StrikePrice] [decimal] (19, 4) NULL,
[TradePrice] [decimal] (24, 10) NOT NULL,
[InternalLong] [int] NOT NULL,
[InternalShort] [int] NOT NULL,
[ExternalLong] [int] NOT NULL,
[ExternalShort] [int] NOT NULL,
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_ib_TradeReconciliationDetail_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_ib_TradeReconciliationDetail_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL,
[IsMatched] [bit] NULL,
[MatchingTradeReconciliationDetailId] [int] NULL,
[InternalExternalCode] [char] (1) NULL,
[DataSourceId] [int] NULL,
[TrxDate] [datetime] NULL,
[TrxTypeCode] [varchar] (25) NULL,
[AdjustmentId] [int] NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_ib_TradeReconciliationDetail] on [dbo].[ib_TradeReconciliationDetail]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_TradeReconciliationDetail] ADD CONSTRAINT [PK_ib_TradeReconciliationDetail] PRIMARY KEY CLUSTERED  ([TradeReconciliationDetailId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_ib_TradeReconciliationDetail_AdjustmentId] on [dbo].[ib_TradeReconciliationDetail]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_ib_TradeReconciliationDetail_AdjustmentId] ON [dbo].[ib_TradeReconciliationDetail] ([AdjustmentId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_TradeReconciliationDetail_Performance2] on [dbo].[ib_TradeReconciliationDetail]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_TradeReconciliationDetail_Performance2] ON [dbo].[ib_TradeReconciliationDetail] ([FirmId], [ExchangeId], [AccountId], [InstrumentId], [TradeReconciliationId], [TradeReconciliationDetailId]) INCLUDE ([ClassId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_instrument] on [dbo].[ib_TradeReconciliationDetail]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_instrument] ON [dbo].[ib_TradeReconciliationDetail] ([InstrumentId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_TradeReconciliationDetail_MatchCode] on [dbo].[ib_TradeReconciliationDetail]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_TradeReconciliationDetail_MatchCode] ON [dbo].[ib_TradeReconciliationDetail] ([MatchCode]) INCLUDE ([TradeReconciliationDetailId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_TradeReconciliationDetail_Performance3] on [dbo].[ib_TradeReconciliationDetail]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_TradeReconciliationDetail_Performance3] ON [dbo].[ib_TradeReconciliationDetail] ([TradeReconciliationId], [ExchangeId], [MatchCode], [CurrencyId], [InstrumentId], [ExpiryMonth], [ExpiryYear], [ExpiryDay], [OptionTypeCode], [StrikePrice], [TradePrice]) INCLUDE ([ExternalLong], [ExternalShort], [InternalLong], [InternalShort])
');

GO
EXECUTE ('PRINT N''Creating index [IX_TradeReconciliationDetail_Performance4] on [dbo].[ib_TradeReconciliationDetail]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_TradeReconciliationDetail_Performance4] ON [dbo].[ib_TradeReconciliationDetail] ([TradeReconciliationId], [FirmId], [ClassId], [AccountId]) INCLUDE ([ExchangeId], [InstrumentId], [TradeReconciliationDetailId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_TradeReconciliationDetail_Performance1] on [dbo].[ib_TradeReconciliationDetail]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_TradeReconciliationDetail_Performance1] ON [dbo].[ib_TradeReconciliationDetail] ([TradeReconciliationId], [FirmId], [TradeReconciliationDetailId], [TrxId]) INCLUDE ([AccountId], [ClassId], [ExchangeId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_ib_TradeReconciliationDetail_TradeReconciliationDetailId_IsMatched] on [dbo].[ib_TradeReconciliationDetail]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_ib_TradeReconciliationDetail_TradeReconciliationDetailId_IsMatched] ON [dbo].[ib_TradeReconciliationDetail] ([TradeReconciliationId], [IsMatched]) INCLUDE ([CurrencyId], [DetailAccountId], [ExchangeId], [ExpiryDay], [ExpiryMonth], [ExpiryYear], [ExternalLong], [ExternalShort], [InstrumentId], [InternalLong], [InternalShort], [MatchCode], [OptionTypeCode], [StrikePrice], [TradePrice], [TradeReconciliationDetailId], [TrxId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_ib_TradeReconciliationDetail_FileRollback] on [dbo].[ib_TradeReconciliationDetail]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_ib_TradeReconciliationDetail_FileRollback] ON [dbo].[ib_TradeReconciliationDetail] ([TrxId])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TradeReconciliationSummary]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_TradeReconciliationSummary]
(
[TradeReconciliationSummaryId] [int] NOT NULL IDENTITY(1, 1),
[TradeReconciliationId] [int] NOT NULL,
[ExchangeId] [int] NOT NULL,
[MatchCode] [varchar] (100) NOT NULL,
[CurrencyId] [int] NOT NULL,
[InstrumentId] [int] NOT NULL,
[ExpiryYear] [smallint] NOT NULL,
[ExpiryMonth] [smallint] NOT NULL,
[ExpiryDay] [smallint] NULL,
[OptionTypeCode] [varchar] (25) NULL,
[StrikePrice] [decimal] (19, 4) NULL,
[TradePrice] [decimal] (24, 10) NOT NULL,
[TotalInternalLong] [int] NOT NULL,
[TotalInternalShort] [int] NOT NULL,
[TotalExternalLong] [int] NOT NULL,
[TotalExternalShort] [int] NOT NULL,
[DifferenceLong] [int] NOT NULL,
[DifferenceShort] [int] NOT NULL,
[Exchange] [varchar] (50) NOT NULL,
[Currency] [varchar] (100) NOT NULL,
[Instrument] [varchar] (100) NOT NULL,
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_ib_TradeReconciliationSummary_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_ib_TradeReconciliationSummary_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_ib_TradeReconciliationSummary] on [dbo].[ib_TradeReconciliationSummary]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_TradeReconciliationSummary] ADD CONSTRAINT [PK_ib_TradeReconciliationSummary] PRIMARY KEY CLUSTERED  ([TradeReconciliationSummaryId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_TradeReconciliationSummary_Performance1] on [dbo].[ib_TradeReconciliationSummary]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_TradeReconciliationSummary_Performance1] ON [dbo].[ib_TradeReconciliationSummary] ([TradeReconciliationId], [ExchangeId], [InstrumentId], [CurrencyId], [TradeReconciliationSummaryId]) INCLUDE ([TotalExternalLong], [TotalExternalShort], [TotalInternalLong], [TotalInternalShort])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_AccessRight]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_AccessRight]
(
[AccessRightId] [int] NOT NULL IDENTITY(1, 1),
[Code] [varchar] (100) NOT NULL,
[Description] [varchar] (100) NOT NULL,
[IsActive] [bit] NOT NULL CONSTRAINT [DF_AccessRight_IsActive] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_AccessRight_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_AccessRight_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_AccessRight] on [dbo].[ib_AccessRight]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_AccessRight] ADD CONSTRAINT [PK_AccessRight] PRIMARY KEY CLUSTERED  ([AccessRightId])
');

GO
EXECUTE ('PRINT N''Creating index [AK_AccessRight_Code] on [dbo].[ib_AccessRight]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_AccessRight_Code] ON [dbo].[ib_AccessRight] ([Code])
');

GO
EXECUTE ('PRINT N''Creating index [AK_AccessRight_Description] on [dbo].[ib_AccessRight]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_AccessRight_Description] ON [dbo].[ib_AccessRight] ([Description])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_UserMatchCodeAccess]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_UserMatchCodeAccess]
(
[UserMatchCodeAccessId] [int] NOT NULL IDENTITY(1, 1),
[UserId] [uniqueidentifier] NOT NULL,
[MatchCodeId] [int] NOT NULL,
[AccessRightId] [int] NOT NULL,
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_UserMatchCodeAccess_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_UserMatchCodeAccess_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_UserMatchCodeAccess] on [dbo].[ib_UserMatchCodeAccess]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_UserMatchCodeAccess] ADD CONSTRAINT [PK_UserMatchCodeAccess] PRIMARY KEY CLUSTERED  ([UserMatchCodeAccessId])
');

GO
EXECUTE ('PRINT N''Creating index [AK_User_MatchCode] on [dbo].[ib_UserMatchCodeAccess]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_User_MatchCode] ON [dbo].[ib_UserMatchCodeAccess] ([UserId], [MatchCodeId])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_ImportMonitor]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_ImportMonitor]
(
[ImportMonitorId] [int] NOT NULL IDENTITY(1, 1),
[DataSourceId] [int] NOT NULL,
[Filename] [varchar] (255) NOT NULL,
[Message] [varchar] (500) NOT NULL,
[Status] [varchar] (10) NOT NULL,
[CreateDate] [datetime] NOT NULL,
[CreateUserName] [varchar] (50) NOT NULL,
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_ImportMonitor] on [dbo].[ib_ImportMonitor]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_ImportMonitor] ADD CONSTRAINT [PK_ImportMonitor] PRIMARY KEY CLUSTERED  ([ImportMonitorId])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[LogStatus]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[LogStatus]
(
[LogStatusSysId] [tinyint] NOT NULL IDENTITY(1, 1),
[LogStatusName] [varchar] (100) NOT NULL,
[IsActive] [bit] NOT NULL CONSTRAINT [DF_LogStatus_IsActive] DEFAULT ((1)),
[CreateDateTimeUtc] [smalldatetime] NOT NULL CONSTRAINT [DF_LogStatus_CreateDateTimeUtc] DEFAULT (getutcdate()),
[CreateUsername] [varchar] (100) NOT NULL CONSTRAINT [DF_LogStatus_CreateUsername] DEFAULT (suser_sname()),
[UpdateDateTimeUtc] [smalldatetime] NULL,
[UpdateUsername] [varchar] (100) NULL,
[DeleteDateTimeUtc] [smalldatetime] NULL,
[DeleteUsername] [varchar] (100) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_LogStatus] on [dbo].[LogStatus]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[LogStatus] ADD CONSTRAINT [PK_LogStatus] PRIMARY KEY CLUSTERED  ([LogStatusSysId])
');

GO
EXECUTE ('PRINT N''Creating index [AK_LogStatusName] on [dbo].[LogStatus]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_LogStatusName] ON [dbo].[LogStatus] ([LogStatusName])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[Log]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[Log]
(
[LogSysId] [int] NOT NULL IDENTITY(1, 1),
[ReceiveLocationSysId] [tinyint] NULL,
[FileName] [varchar] (512) NOT NULL,
[RunId] [tinyint] NULL,
[StepSysId] [tinyint] NULL,
[Message] [varchar] (255) NULL,
[LogStatusSysId] [tinyint] NULL,
[Exception] [varchar] (max) NULL,
[CreateDateTimeUtc] [datetime] NOT NULL CONSTRAINT [DF_Log_CreateDateTimeUtc] DEFAULT (getutcdate()),
[CreateUsername] [varchar] (100) NOT NULL CONSTRAINT [DF_Log_CreateUsername] DEFAULT (suser_sname()),
[IsComplete] [bit] NOT NULL CONSTRAINT [DF__Log__IsComplete__2FFB99C1] DEFAULT ((0))
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_Log] on [dbo].[Log]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[Log] ADD CONSTRAINT [PK_Log] PRIMARY KEY CLUSTERED  ([LogSysId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_CreateDateTimeUtc] on [dbo].[Log]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_CreateDateTimeUtc] ON [dbo].[Log] ([CreateDateTimeUtc] DESC)
');

GO
EXECUTE ('PRINT N''Creating index [IX_Log_ReceiveLocationSYsId_FileName_RunId_Message] on [dbo].[Log]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_Log_ReceiveLocationSYsId_FileName_RunId_Message] ON [dbo].[Log] ([ReceiveLocationSysId], [FileName], [RunId], [Message])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_NostroBalance]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_NostroBalance]
(
[NostroBalanceId] [int] NOT NULL IDENTITY(1, 1),
[MatchCodeId] [int] NOT NULL,
[BalanceDate] [datetime] NOT NULL,
[InternalBalance] [decimal] (18, 4) NOT NULL,
[ExternalBalance] [decimal] (18, 4) NOT NULL,
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_ib_NostroBalance_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_ib_NostroBalance_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_ib_NostroBalance] on [dbo].[ib_NostroBalance]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_NostroBalance] ADD CONSTRAINT [PK_ib_NostroBalance] PRIMARY KEY CLUSTERED  ([NostroBalanceId])
');

GO
EXECUTE ('PRINT N''Creating index [AK_matchCode_balanceDate] on [dbo].[ib_NostroBalance]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_matchCode_balanceDate] ON [dbo].[ib_NostroBalance] ([MatchCodeId], [BalanceDate])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_NostroMatchType]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_NostroMatchType]
(
[NostroMatchTypeId] [int] NOT NULL IDENTITY(1, 1),
[Code] [varchar] (100) NOT NULL,
[Desc] [varchar] (100) NOT NULL,
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_ib_NostroMatchType_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_ib_NostroMatchType_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_ib_NostroMatchType] on [dbo].[ib_NostroMatchType]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_NostroMatchType] ADD CONSTRAINT [PK_ib_NostroMatchType] PRIMARY KEY CLUSTERED  ([NostroMatchTypeId])
');

GO
EXECUTE ('PRINT N''Creating index [AK_Code] on [dbo].[ib_NostroMatchType]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_Code] ON [dbo].[ib_NostroMatchType] ([Code])
');

GO
EXECUTE ('PRINT N''Creating index [AK_Desc] on [dbo].[ib_NostroMatchType]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_Desc] ON [dbo].[ib_NostroMatchType] ([Desc])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[Package]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[Package]
(
[PackageSysId] [tinyint] NOT NULL IDENTITY(1, 1),
[PackageCode] [varchar] (10) NOT NULL,
[PackageName] [nvarchar] (100) NOT NULL,
[SSISPackagePath] [varchar] (300) NOT NULL,
[ProjectName] [varchar] (200) NOT NULL,
[JobName] [varchar] (100) NOT NULL,
[IsActive] [bit] NOT NULL CONSTRAINT [DF_Package_IsActive] DEFAULT ((1)),
[CreateDateTimeUtc] [smalldatetime] NOT NULL CONSTRAINT [DF_Package_CreateDateTimeUtc] DEFAULT (getutcdate()),
[CreateUsername] [varchar] (100) NOT NULL CONSTRAINT [DF_Package_CreateUserName] DEFAULT (suser_sname()),
[UpdateDateTimeUtc] [smalldatetime] NULL,
[UpdateUsername] [varchar] (100) NULL,
[DeleteDateTimeUtc] [smalldatetime] NULL,
[DeleteUsername] [varchar] (100) NULL,
[IsMisc] [bit] NOT NULL CONSTRAINT [DF__Package__IsMisc__493C48D7] DEFAULT ((0))
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_Package] on [dbo].[Package]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[Package] ADD CONSTRAINT [PK_Package] PRIMARY KEY CLUSTERED  ([PackageSysId])
');

GO
EXECUTE ('PRINT N''Creating index [PackageCode] on [dbo].[Package]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [PackageCode] ON [dbo].[Package] ([PackageCode])
');

GO
EXECUTE ('PRINT N''Creating [security].[Feature]''
');

GO
EXECUTE ('CREATE TABLE [security].[Feature]
(
[FeatureId] [int] NOT NULL IDENTITY(1, 1),
[FeatureCode] [varchar] (20) NOT NULL,
[FeatureName] [nvarchar] (50) NOT NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK__Feature__82230BC9E35A3449] on [security].[Feature]''
');

GO
EXECUTE ('ALTER TABLE [security].[Feature] ADD CONSTRAINT [PK__Feature__82230BC9E35A3449] PRIMARY KEY CLUSTERED  ([FeatureId])
');

GO
EXECUTE ('PRINT N''Creating index [AK_Feature_FeatureCode] on [security].[Feature]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_Feature_FeatureCode] ON [security].[Feature] ([FeatureCode]) INCLUDE ([FeatureName])
');

GO
EXECUTE ('PRINT N''Creating index [AK_Feature_FeatureName] on [security].[Feature]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_Feature_FeatureName] ON [security].[Feature] ([FeatureName]) INCLUDE ([FeatureCode])
');

GO
EXECUTE ('PRINT N''Creating [security].[RoleFeature]''
');

GO
EXECUTE ('CREATE TABLE [security].[RoleFeature]
(
[RoleFeatureId] [int] NOT NULL IDENTITY(1, 1),
[RoleId] [uniqueidentifier] NOT NULL,
[FeatureId] [int] NOT NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK__RoleFeat__0CA024414BD6E683] on [security].[RoleFeature]''
');

GO
EXECUTE ('ALTER TABLE [security].[RoleFeature] ADD CONSTRAINT [PK__RoleFeat__0CA024414BD6E683] PRIMARY KEY CLUSTERED  ([RoleFeatureId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_aspnet_RoleFeature_RoleIdFeatureId] on [security].[RoleFeature]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [IX_aspnet_RoleFeature_RoleIdFeatureId] ON [security].[RoleFeature] ([RoleId], [FeatureId])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[Step]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[Step]
(
[StepSysId] [tinyint] NOT NULL IDENTITY(1, 1),
[StepName] [varchar] (50) NOT NULL,
[IsActive] [bit] NOT NULL CONSTRAINT [DF_Step_IsActive] DEFAULT ((1)),
[CreateDateTimeUtc] [smalldatetime] NOT NULL CONSTRAINT [DF_Step_CreateDateTimeUtc] DEFAULT (getutcdate()),
[CreateUsername] [varchar] (100) NOT NULL CONSTRAINT [DF_Step_CreateUsername] DEFAULT (suser_sname()),
[UpdateDateTimeUtc] [smalldatetime] NULL,
[UpdateUsername] [varchar] (100) NULL,
[DeleteDateTimeUtc] [smalldatetime] NULL,
[DeleteUsername] [varchar] (100) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_Step] on [dbo].[Step]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[Step] ADD CONSTRAINT [PK_Step] PRIMARY KEY CLUSTERED  ([StepSysId])
');

GO
EXECUTE ('PRINT N''Creating index [AK_StepName] on [dbo].[Step]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_StepName] ON [dbo].[Step] ([StepName])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_SwiftStatementSeed]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_SwiftStatementSeed]
(
[SwiftStatementSeedId] [int] NOT NULL IDENTITY(1, 1),
[AccountId] [int] NOT NULL,
[StatementNumberSeed] [int] NOT NULL,
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_SwiftStatementSeed_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_SwiftStatementSeed_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_SwiftStatementSeed] on [dbo].[ib_SwiftStatementSeed]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_SwiftStatementSeed] ADD CONSTRAINT [PK_SwiftStatementSeed] PRIMARY KEY CLUSTERED  ([SwiftStatementSeedId])
');

GO
EXECUTE ('PRINT N''Creating index [AK_SwiftStatementSeed_AccountId] on [dbo].[ib_SwiftStatementSeed]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_SwiftStatementSeed_AccountId] ON [dbo].[ib_SwiftStatementSeed] ([AccountId])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[is_GRealizedProfitLossDetails]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[is_GRealizedProfitLossDetails]
(
[GRealizedProfitLossDetailsId] [int] NOT NULL IDENTITY(1, 1),
[CorporationCode] [varchar] (4) NULL,
[PrincipalBrokerageID] [varchar] (1) NULL,
[OfficeCode] [varchar] (4) NULL,
[ACNumber] [varchar] (10) NULL,
[RecordID] [varchar] (2) NULL,
[BaseDate] [datetime] NULL,
[CalculationDate] [datetime] NULL,
[CalculationStartTime] [datetime] NULL,
[CalculationDateStartTime] [datetime] NULL,
[TradeDate] [datetime] NULL,
[ExecutingMarketCode] [varchar] (2) NULL,
[FuturesSubId] [varchar] (3) NULL,
[DerivativesCode] [varchar] (10) NULL,
[CompanyCode] [varchar] (7) NULL,
[SeriesNo] [varchar] (4) NULL,
[SubCode] [varchar] (2) NULL,
[BuySellIdClose] [varchar] (1) NULL,
[CancellationDateId] [varchar] (1) NULL,
[InputDate] [datetime] NULL,
[CancellationInputDate] [datetime] NULL,
[TradeCodeClose] [varchar] (2) NULL,
[OptionIdClose] [varchar] (1) NULL,
[TradeNoClose] [varchar] (5) NULL,
[TradeSubNoClose] [varchar] (3) NULL,
[AutomaticExerciseAllotmentId] [varchar] (1) NULL,
[TradeDateOpen] [datetime] NULL,
[BuySellIdOpen] [varchar] (1) NULL,
[TradeCodeOpen] [varchar] (2) NULL,
[OptionIdOpen] [varchar] (1) NULL,
[TradeNoOpen] [varchar] (5) NULL,
[TradeSubNoOpen] [varchar] (3) NULL,
[ContractMonth] [varchar] (7) NULL,
[StrikePrice] [decimal] (11, 4) NULL,
[Quantity] [int] NULL,
[PriceOpen] [decimal] (11, 4) NULL,
[PriceClose] [decimal] (11, 4) NULL,
[ExecutionAmountOpen] [decimal] (15, 0) NULL,
[ExecutionAmountClose] [decimal] (15, 0) NULL,
[RealizedPLAmountGrossSign] [varchar] (1) NULL,
[RealizedPLAmountGross] [decimal] (15, 0) NULL,
[RealizedPLAmountGrossSigned] [decimal] (15, 0) NULL,
[CommissionOpen] [decimal] (15, 0) NULL,
[CommissionClose] [decimal] (15, 0) NULL,
[ConsumptionTaxOpen] [decimal] (15, 0) NULL,
[ConsumptionTaxClose] [decimal] (15, 0) NULL,
[ExchangeTaxOpen] [decimal] (15, 0) NULL,
[ExchangeTaxClose] [decimal] (15, 0) NULL,
[RealizedAmountNetSign] [varchar] (1) NULL,
[RealizedAmountNet] [decimal] (15, 0) NULL,
[RealizedAmountNetSigned] [decimal] (15, 0) NULL,
[SettlementPrice] [decimal] (15, 0) NULL,
[NumberOfStockSharesPerOption] [int] NULL,
[FullSeriesNo] [varchar] (4) NULL,
[CustomerNameAbbreviated] [varchar] (35) NULL,
[SecurityNameEnglish] [varchar] (28) NULL,
[SecurityNameKana] [varchar] (24) NULL,
[TradeSubCodeOpen] [varchar] (1) NULL,
[TradeSubCodeClose] [varchar] (1) NULL,
[TransactionDateOpen] [datetime] NULL,
[TransactionDateClose] [datetime] NULL,
[CostPaymentMethod] [varchar] (1) NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_is_GRealizedProfitLossDetails_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_GRealizedProfitLossDetails_CreationDate] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_GRealizedProfitLossDetails] on [dbo].[is_GRealizedProfitLossDetails]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[is_GRealizedProfitLossDetails] ADD CONSTRAINT [PK_GRealizedProfitLossDetails] PRIMARY KEY CLUSTERED  ([GRealizedProfitLossDetailsId])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[is_GRealizedProfitLossDetails_Add]''
');

GO
EXECUTE ('


/*
<Details>
<Summary>Inserts an item into the GRealizedProfitLossDetails table</Summary>
<Created author="laurentiu.macovei" date="04/05/2006 16:33:05" />
</Details>
*/
CREATE PROCEDURE [dbo].[is_GRealizedProfitLossDetails_Add]
	@CorporationCode varchar(4) = NULL,
	@PrincipalBrokerageID varchar(1) = NULL,
	@OfficeCode varchar(4) = NULL,
	@ACNumber varchar(10) = NULL,
	@RecordID varchar(2) = NULL,
	@BaseDate datetime = NULL,
	@CalculationDate datetime = NULL,
	@CalculationStartTime datetime = NULL,
	@TradeDate datetime = NULL,
	@ExecutingMarketCode varchar(2) = NULL,
	@FuturesSubId varchar(3) = NULL,
	@DerivativesCode varchar(10) = NULL,
	@CompanyCode varchar(7) = NULL,
	@SeriesNo varchar(4) = NULL,
	@SubCode varchar(2) = NULL,
	@BuySellIdClose varchar(1) = NULL,
	@CancellationDateId varchar(1) = NULL,
	@InputDate datetime = NULL,
	@CancellationInputDate datetime = NULL,
	@TradeCodeClose varchar(2) = NULL,
	@OptionIdClose varchar(1) = NULL,
	@TradeNoClose varchar(5) = NULL,
	@TradeSubNoClose varchar(3) = NULL,
	@AutomaticExerciseAllotmentId varchar(1) = NULL,
	@TradeDateOpen datetime = NULL,
	@BuySellIdOpen varchar(1) = NULL,
	@TradeCodeOpen varchar(2) = NULL,
	@OptionIdOpen varchar(1) = NULL,
	@TradeNoOpen varchar(5) = NULL,
	@TradeSubNoOpen varchar(3) = NULL,
	@ContractMonth varchar(7) = NULL,
	@StrikePrice decimal(11,4) = NULL,
	@Quantity int = NULL,
	@PriceOpen decimal(11,4) = NULL,
	@PriceClose decimal(11,4) = NULL,
	@ExecutionAmountOpen decimal(15,0) = NULL,
	@ExecutionAmountClose decimal(15,0) = NULL,
	@RealizedPLAmountGrossSign varchar(1) = NULL,
	@RealizedPLAmountGross decimal(15,0) = NULL,
	@CommissionOpen decimal(15,0) = NULL,
	@CommissionClose decimal(15,0) = NULL,
	@ConsumptionTaxOpen decimal(15,0) = NULL,
	@ConsumptionTaxClose decimal(15,0) = NULL,
	@ExchangeTaxOpen decimal(15,0) = NULL,
	@ExchangeTaxClose decimal(15,0) = NULL,
	@RealizedAmountNetSign varchar(1) = NULL,
	@RealizedAmountNet decimal(15,0) = NULL,
	@SettlementPrice decimal(15,0) = NULL,
	@NumberOfStockSharesPerOption int = NULL,
	@FullSeriesNo varchar(4) = NULL,
	@CustomerNameAbbreviated varchar(35) = NULL,
	@SecurityNameEnglish varchar(28) = NULL,
	@SecurityNameKana varchar(24) = NULL,
	@TradeSubCodeOpen varchar(1) = NULL,
	@TradeSubCodeClose varchar(1) = NULL,
	@TransactionDateOpen datetime = NULL,
	@TransactionDateClose datetime = NULL,
	@CostPaymentMethod varchar(1) = NULL
AS
SET NOCOUNT ON

SET NOCOUNT OFF

	DECLARE @CalculationDateStartTime		DATETIME
	DECLARE @RealizedPLAmountGrossSigned	DECIMAL(15,0)
	DECLARE @RealizedPLAmountNetSigned		DECIMAL(15,0)


	IF @BaseDate = ''01/01/1900 00:00:00'' 
		SET @BaseDate = NULL

	IF @CalculationDate = ''01/01/1900 00:00:00'' 
		SET @CalculationDate = NULL

	IF @CalculationStartTime = ''01/01/1900 00:00:00'' 
		SET @CalculationStartTime = NULL

	IF @TradeDate = ''01/01/1900 00:00:00'' 
		SET @TradeDate = NULL

	IF @InputDate = ''01/01/1900 00:00:00'' 
		SET @InputDate = NULL

	IF @CancellationInputDate = ''01/01/1900 00:00:00'' 
		SET @CancellationInputDate = NULL

	IF @TradeDateOpen = ''01/01/1900 00:00:00'' 
		SET @TradeDateOpen = NULL

	IF @TransactionDateOpen = ''01/01/1900 00:00:00'' 
		SET @TransactionDateOpen = NULL

	IF @TransactionDateClose = ''01/01/1900 00:00:00'' 
		SET @TransactionDateClose = NULL

	IF @RealizedPLAmountGrossSign = ''-'' 
		SET @RealizedPLAmountGrossSigned = @RealizedPLAmountGross * -1
	ELSE
		SET @RealizedPLAmountGrossSigned = @RealizedPLAmountGross

	IF @RealizedAmountNetSign = ''-'' 
		SET @RealizedPLAmountNetSigned = @RealizedAmountNet * -1
	ELSE
		SET @RealizedPLAmountNetSigned = @RealizedAmountNet

	SET @CalculationDateStartTime = CONVERT(DATETIME,CONVERT(VARCHAR(12), CONVERT(DATETIME,@CalculationDate,112)) + '' '' + CONVERT(VARCHAR(8),RIGHT(@CalculationStartTime,8)))

	INSERT INTO is_GRealizedProfitLossDetails 
		(
			[CorporationCode], 
			[PrincipalBrokerageID], 
			[OfficeCode], 
			[ACNumber], 
			[RecordID], 
			[BaseDate], 
			[CalculationDate], 
			[CalculationStartTime],
			[CalculationDateStartTime], 
			[TradeDate], 
			[ExecutingMarketCode], 
			[FuturesSubId], 
			[DerivativesCode], 
			[CompanyCode], 
			[SeriesNo], 
			[SubCode], 
			[BuySellIdClose], 
			[CancellationDateId], 
			[InputDate], 
			[CancellationInputDate], 
			[TradeCodeClose], 
			[OptionIdClose], 
			[TradeNoClose], 
			[TradeSubNoClose], 
			[AutomaticExerciseAllotmentId], 
			[TradeDateOpen], 
			[BuySellIdOpen], 
			[TradeCodeOpen], 
			[OptionIdOpen], 
			[TradeNoOpen], 
			[TradeSubNoOpen], 
			[ContractMonth], 
			[StrikePrice], 
			[Quantity], 
			[PriceOpen], 
			[PriceClose], 
			[ExecutionAmountOpen], 
			[ExecutionAmountClose], 
			[RealizedPLAmountGrossSign], 
			[RealizedPLAmountGross],
			[RealizedPLAmountGrossSigned],
			[CommissionOpen], 
			[CommissionClose], 
			[ConsumptionTaxOpen], 
			[ConsumptionTaxClose], 
			[ExchangeTaxOpen], 
			[ExchangeTaxClose], 
			[RealizedAmountNetSign], 
			[RealizedAmountNet],
			[RealizedAmountNetSigned], 
			[SettlementPrice], 
			[NumberOfStockSharesPerOption], 
			[FullSeriesNo], 
			[CustomerNameAbbreviated], 
			[SecurityNameEnglish], 
			[SecurityNameKana], 
			[TradeSubCodeOpen], 
			[TradeSubCodeClose], 
			[TransactionDateOpen], 
			[TransactionDateClose], 
			[CostPaymentMethod]
		)
 
	VALUES
		(
			@CorporationCode, 
			@PrincipalBrokerageID, 
			@OfficeCode, 
			@ACNumber, 
			@RecordID, 
			@BaseDate, 
			@CalculationDate, 
			@CalculationStartTime,
			@CalculationDateStartTime, 
			@TradeDate, 
			@ExecutingMarketCode, 
			@FuturesSubId, 
			@DerivativesCode, 
			@CompanyCode, 
			@SeriesNo, 
			@SubCode, 
			@BuySellIdClose, 
			@CancellationDateId, 
			@InputDate, 
			@CancellationInputDate, 
			@TradeCodeClose, 
			@OptionIdClose, 
			@TradeNoClose, 
			@TradeSubNoClose, 
			@AutomaticExerciseAllotmentId, 
			@TradeDateOpen, 
			@BuySellIdOpen, 
			@TradeCodeOpen, 
			@OptionIdOpen, 
			@TradeNoOpen, 
			@TradeSubNoOpen, 
			@ContractMonth, 
			@StrikePrice, 
			@Quantity, 
			@PriceOpen, 
			@PriceClose, 
			@ExecutionAmountOpen, 
			@ExecutionAmountClose, 
			@RealizedPLAmountGrossSign, 
			@RealizedPLAmountGross,
			@RealizedPLAmountGrossSigned, 
			@CommissionOpen, 
			@CommissionClose, 
			@ConsumptionTaxOpen, 
			@ConsumptionTaxClose, 
			@ExchangeTaxOpen, 
			@ExchangeTaxClose, 
			@RealizedAmountNetSign, 
			@RealizedAmountNet,
			@RealizedPLAmountNetSigned, 
			@SettlementPrice, 
			@NumberOfStockSharesPerOption, 
			@FullSeriesNo, 
			@CustomerNameAbbreviated, 
			@SecurityNameEnglish, 
			@SecurityNameKana, 
			@TradeSubCodeOpen, 
			@TradeSubCodeClose, 
			@TransactionDateOpen, 
			@TransactionDateClose, 
			@CostPaymentMethod
		);

Return Scope_Identity()
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Rule_ChangeRuleOrder]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Rule_ChangeRuleOrder]
	@matchCode int, 
	@ruleId int,
	@targetRuleId int
AS
SET NOCOUNT ON
	DECLARE @targetSequenceNumber INT
	DECLARE @sequenceNumber INT
	DECLARE @rmcId INT
	DECLARE @targetRmcId INT
	
	SELECT 
		@rmcId = 
			RMC.RuleMatchCodeId
		,@sequenceNumber = 
			RMC.SequenceNumber
	FROM
		ib_Rule R
	INNER JOIN
		ib_RuleMatchCode RMC ON RMC.RuleId = R.RuleId AND RMC.MatchCodeId = @matchCode
	WHERE
		R.RuleId = @ruleId	
		
	SELECT 
		@targetRmcId = RMC.RuleMatchCodeId
		,@targetSequenceNumber = RMC.SequenceNumber
	FROM
		ib_Rule R
	INNER JOIN
		ib_RuleMatchCode RMC ON RMC.RuleId = R.RuleId AND RMC.MatchCodeId = @matchCode
	WHERE
		@targetRuleId = R.RuleId
		
	IF (@targetSequenceNumber = @sequenceNumber)
	BEGIN
		SET @targetSequenceNumber = @targetSequenceNumber + 1
	END
		
	UPDATE ib_RuleMatchCode SET SequenceNumber = @targetSequenceNumber WHERE RuleMatchCodeId = @rmcId
	
	UPDATE ib_RuleMatchCode SET SequenceNumber = @sequenceNumber WHERE RuleMatchCodeId = @targetRmcId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Instrument_GetInstrumentById]''
');

GO
EXECUTE ('   /*
<details>
 <summary> Selectes an instrument from the ib_Instrument table by its id</summary>
 <created author="Laurentiu Macovei" Date="Tuesday, 12 September 2006 9:34PM GMT" /> 
</details>
*/
CREATE PROCEDURE [dbo].[ib_Instrument_GetInstrumentById]
(
	@InstrumentId int
)
AS
SET NOCOUNT ON

SELECT i.[InstrumentId]
      ,i.[InstrumentTypeId]
	  ,it.[Name] as InstrumentTypeName
	  ,it.[Code] as InstrumentTypeCode
      ,i.[Code]
      ,i.[Name]
      ,i.[IsApproved]
      ,i.[LotSize]
      ,i.[TickSize]
      ,i.[BaseId]
	  ,b.[Code] as BaseCode
      ,i.[CreateDate]
      ,i.[CreateUsername]
      ,i.[UpdateDate]
      ,i.[UpdateUsername]
  FROM [dbo].[ib_Instrument] i
INNER JOIN [dbo].[ib_InstrumentType] it ON it.[InstrumentTypeId] = i.[InstrumentTypeId]
LEFT JOIN [dbo].[ib_Base] b ON b.[BaseId] = i.[BaseId]
WHERE i.InstrumentId = @InstrumentId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[udf_OnLoad_ExpiryDate_Get_Day]''
');

GO
EXECUTE ('
-- =============================================
-- Author:		Konrad
-- Create date: 20.05.09
-- Description:	Returns Variation
-- =============================================
CREATE FUNCTION [dbo].[udf_OnLoad_ExpiryDate_Get_Day] 
(
	@ExpYear smallint = null,
	@ExpMonth smallint = null,
	@ExpDay smallint = null
)
RETURNS smallint
AS
BEGIN

	DECLARE @NewExpDay smallint 
	DECLARE @TempDate  datetime
	DECLARE @TempExpMonth varchar(2)
    	
	IF @ExpDay IS NULL SET @ExpDay = 0

	SET @NewExpDay = @ExpDay
		
	IF (@ExpYear IS NOT NULL) AND (@ExpMonth IS NOT NULL) AND (@ExpDay = 0)
	   BEGIN 

		IF @ExpYear < 100 SET @ExpYear = 2000 + @ExpYear
		
		IF (@ExpMonth > 0) AND (@ExpMonth < 13)
			BEGIN

				IF @ExpMonth < 10 SET @TempExpMonth	= ''0'' + CAST(@ExpMonth as varchar(8))			
				ELSE SET @TempExpMonth = CAST(@ExpMonth as varchar(8))

				IF @ExpYear < 100 
						SET @TempDate = CONVERT(datetime,CAST(@ExpYear as varchar(8)) + @TempExpMonth + ''01'',12)
	
				ELSE IF (@ExpYear > 1900) AND (@ExpYear < 10000) 
						SET @TempDate = CONVERT(datetime,CAST(@ExpYear as varchar(8)) + @TempExpMonth + ''01'',112)

				SET @TempDate = DATEADD(dd,-1,DATEADD(mm,1,@TempDate))

				SET @NewExpDay = DATEPART(dd,@TempDate)
        	
			END
	   END	

	RETURN @NewExpDay

END




');

GO
EXECUTE ('PRINT N''Creating [dbo].[udf_GetDefaultStrikePriceDivisor]''
');

GO
EXECUTE ('-- =============================================
-- Author:		Alister McLeod
-- Create date: 22 July 2009
-- Description:	Return the Default Strike Price Divisor for all loads and
--				the Admin->Instruments routine

-- History
-- 15 Jan 2013	MBAL-22631 Remove the code that sets the Default Strike Price divisor
--				for LCH to 1000. This should be in the DataSource table.
--				Keep rule for Exchange LCE on LCH Datasource for future (in case there
--				there is a new LCH DataSource).  Add rule for LCE exchange for LIFFE DataSource.
--				This issue RENAMED the old LCH DataSource to LIFFE.
-- =============================================

CREATE FUNCTION [dbo].[udf_GetDefaultStrikePriceDivisor]
(
	@DataSourceId INT,
	@ExchangeId INT = NULL
)
RETURNS DECIMAL(19,6)
AS
BEGIN

	DECLARE @DefaultStrikePriceDivisor DECIMAL(19,6)
	
	IF (@ExchangeId IS NOT NULL)
	BEGIN
		-------------------------------------------------------------------
		-- (Start) Exchange Specific Rules
		
		DECLARE @ExchangeCode VARCHAR(25)
		SELECT @ExchangeCode = [Code] FROM ib_Exchange WHERE ExchangeId = @ExchangeId

		
		-- LCH
		DECLARE @LCHDataSourceId INT
		
		SELECT	@LCHDataSourceId = DataSourceId 
			FROM [dbo].[ib_DataSource] 
			WHERE [Code] = ''LCH''
			
		IF (@DataSourceId = @LCHDataSourceId)
		BEGIN								
			IF @ExchangeCode = ''LCE''
				SET @DefaultStrikePriceDivisor = 100						
		END
		
		
		-- LIFFE
		DECLARE @LIFFEDataSourceId INT
		
		SELECT	@LIFFEDataSourceId = DataSourceId 
			FROM [dbo].[ib_DataSource] 
			WHERE [Code] = ''LIFFE''
			
		IF (@DataSourceId = @LIFFEDataSourceId)
		BEGIN								
			IF @ExchangeCode = ''LCE''
				SET @DefaultStrikePriceDivisor = 100						
		END
		
		-- (End) Exchange Specific Settings
		-------------------------------------------------------------------
	END

	IF (@DefaultStrikePriceDivisor = NULL) -- If already set, do not continue
	BEGIN
		-- Retrieve Default Strike Price Divisor for DataSource
		
		DECLARE @DefaultDataSourceSPD DECIMAL(19,6)
		
		SELECT	@DefaultDataSourceSPD = [DefaultStrikePriceDivisor]
		FROM	[dbo].[ib_DataSource]
		WHERE	[DataSourceId] = @DataSourceId
 
		IF @DefaultDataSourceSPD IS NOT NULL
			SET @DefaultStrikePriceDivisor = @DefaultDataSourceSPD
			
	END

	-- Finally
	
	IF ISNUMERIC(@DefaultStrikePriceDivisor)<> 1 OR @DefaultStrikePriceDivisor = 0
		BEGIN
			SET @DefaultStrikePriceDivisor = 1
		END	
		
RETURN @DefaultStrikePriceDivisor

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[udf_GetDatePart]''
');

GO
EXECUTE ('
CREATE FUNCTION [dbo].[udf_GetDatePart]
(
	@date DATETIME
)
RETURNS DATETIME
AS
-- Description: Return the Date portion of the DateTime provided

-- 31 Jul 2009		AAJM	Creation

BEGIN
	
RETURN CAST(FLOOR(CAST(@date AS FLOAT))AS DATETIME)

END

');

GO
EXECUTE ('PRINT N''Creating [dbo].[GetFilenameWithoutExtension]''
');

GO
EXECUTE ('CREATE FUNCTION [dbo].[GetFilenameWithoutExtension]
(@FullFilename VARCHAR (512))
RETURNS VARCHAR (512)
AS
BEGIN
	--	04 Jan 2011		amk		Creation (MBAL-17212)
	--	06 Jan 2011		amk		Implement code review suggestion: allow for more than one period in filename
	--  07 Apr 2011		AAJM	Increase storage size of filename parameter to match filenames in system

	DECLARE @ReverseFullFilename VARCHAR(512)
	SET @ReverseFullFilename = REVERSE(@FullFilename)

	DECLARE @ReversePeriodPosition INT
	SET @ReversePeriodPosition = CHARINDEX(''.'', @ReverseFullFilename)

	DECLARE @FilenameWithoutExtension VARCHAR(512)
	IF @ReversePeriodPosition = 0	-- no period, just return the whole thing
		SET @FilenameWithoutExtension = @FullFilename
	ELSE
	BEGIN
		DECLARE @ReverseFilenameWithoutExtension VARCHAR(512)
		SET @ReverseFilenameWithoutExtension = RIGHT(@ReverseFullFilename, LEN(@ReverseFullFilename) 
			- @ReversePeriodPosition)
		SET @FilenameWithoutExtension = REVERSE(@ReverseFilenameWithoutExtension)
	END
	
	RETURN @FilenameWithoutExtension
END


');

GO
EXECUTE ('PRINT N''Creating [dbo].[TryParseYYYYMMDDFromEndOfFilename]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[TryParseYYYYMMDDFromEndOfFilename]
(
	@FileName VARCHAR(512)
	, @ReturnDate DATETIME OUTPUT
)
AS
SET NOCOUNT ON
-- Description:	Return date from filename where date is last item before file extension
-- and the filename must be in format YYMMDD
--
-- 06 Apr 2011	AAJM	Creation
-- 18 May 2011	AAJM	Update to accept century

BEGIN
	
	SET @ReturnDate = NULL
	
	DECLARE @FileNameWithoutExtension VARCHAR(512)
	SET @FileNameWithoutExtension = [dbo].[GetFilenameWithoutExtension](@FileName)

	DECLARE @DateChr VARCHAR(8)
	SET @DateChr = RIGHT(@FileNameWithoutExtension, 8)

	BEGIN TRY
		
		SET @ReturnDate = CONVERT(DATETIME, @DateChr, 112)		
	
	END TRY
	BEGIN CATCH
		-- Can''t parse, therefore return null
	END CATCH
	
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[sp_RethrowError]''
');

GO
EXECUTE ('/*
<details>
 <summary>Rethrows the previous exception</summary>
 <created author="Laurentiu Macovei" Date="Friday, 15 September 2006 7:32AM GMT" /> 
</details>
*/
create PROCEDURE [dbo].[sp_RethrowError]
@Message varchar(1000) = NULL
AS
SET NOCOUNT ON

	DECLARE @ErrorMessage varchar(4000) 
	DECLARE @ErrorNumber int
	DECLARE @ErrorSeverity int
	DECLARE @ErrorState int
	DECLARE @ErrorProcedure varchar(200)
	DECLARE @ErrorLine int

	SET @ErrorMessage = ERROR_MESSAGE()
	IF @Message IS NOT NULL  
		SET @ErrorMessage = @Message + ''
Details:
''+@ErrorMessage
	SET @ErrorNumber = ERROR_NUMBER()
    SET @ErrorSeverity = ERROR_SEVERITY()
    SET @ErrorState = ERROR_STATE()
    SET @ErrorProcedure = ERROR_PROCEDURE()
    SET @ErrorLine = ERROR_LINE()

	RAISERROR
        (
        @ErrorMessage,
        @ErrorSeverity,
        1,
        @ErrorNumber,    -- parameter: original error number.
        @ErrorSeverity,  -- parameter: original error severity.
        @ErrorState,     -- parameter: original error state.
        @ErrorProcedure, -- parameter: original error procedure name.
        @ErrorLine       -- parameter: original error line number.
        );
');

GO
EXECUTE ('PRINT N''Creating [stage].[RosenthalCollinsPosition]''
');

GO
EXECUTE ('CREATE TABLE [stage].[RosenthalCollinsPosition]
(
[RosenthalCollinsPositionId] [int] NOT NULL IDENTITY(1, 1),
[PRECID] [varchar] (1) NULL,
[PFIRM] [varchar] (1) NULL,
[POFFIC] [varchar] (3) NULL,
[PACCT] [varchar] (5) NULL,
[PCTYM] [varchar] (6) NULL,
[PSBCUS] [varchar] (2) NULL,
[PSTYPE] [varchar] (2) NULL,
[PSUBTY] [varchar] (1) NULL,
[PSTYP2] [varchar] (1) NULL,
[PSTRIK] [varchar] (15) NULL,
[PEXPDT] [varchar] (9) NULL,
[PSUBAC] [varchar] (10) NULL,
[PTDATE] [varchar] (9) NULL,
[PTPRIC] [varchar] (15) NULL,
[PBS] [varchar] (1) NULL,
[PBROKR] [varchar] (2) NULL,
[PTRACE] [varchar] (10) NULL,
[PICODE] [varchar] (3) NULL,
[PREFNO] [varchar] (12) NULL,
[PCLASS] [varchar] (1) NULL,
[PSUBCL] [varchar] (1) NULL,
[PQTY] [varchar] (15) NULL,
[PPRTQ] [varchar] (15) NULL,
[PSDSC1] [varchar] (30) NULL,
[PMKVAL] [varchar] (15) NULL,
[PSDATE] [varchar] (9) NULL,
[PEXCH] [varchar] (2) NULL,
[PFC] [varchar] (2) NULL,
[PTYPE] [varchar] (1) NULL,
[PSYMBL] [varchar] (6) NULL,
[PSUBEX] [varchar] (1) NULL,
[PPRTPR] [varchar] (11) NULL,
[PCLOSE] [varchar] (15) NULL,
[PPRCDT] [varchar] (9) NULL,
[PPRTCP] [varchar] (11) NULL,
[PPRICE] [varchar] (12) NULL,
[PCURSY] [varchar] (3) NULL,
[PGROSS] [varchar] (15) NULL,
[FileName] [varchar] (512) NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_RosenthalCollinsPosition_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_RosenthalCollinsPosition_CreateDate] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_RosenthalCollinsPosition] on [stage].[RosenthalCollinsPosition]''
');

GO
EXECUTE ('ALTER TABLE [stage].[RosenthalCollinsPosition] ADD CONSTRAINT [PK_RosenthalCollinsPosition] PRIMARY KEY CLUSTERED  ([RosenthalCollinsPositionId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_RosenthalCollins_Filename] on [stage].[RosenthalCollinsPosition]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_RosenthalCollins_Filename] ON [stage].[RosenthalCollinsPosition] ([LoadState], [FileName])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[Log_Insert]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[Log_Insert]
	(
		@ReceiveLocationSysId INT,
		@FileName VARCHAR(255),
		@StepName VARCHAR(50),
		@Message VARCHAR(255),
		@LogStatusName VARCHAR(100),
		@Exception VARCHAR(MAX),
		@RunId INT,
		@IsComplete BIT = 0,
		@CheckExistingException BIT = 0
	)
AS
-- =============================================
-- Author:		damiane
-- Create date: 30 Sep 2013
-- Description:	add items to log table
-- History:
-- 09 Jan 2014     ED      EIB 25004 - Add IsComplete
-- 15 Jan 2014     ED      EIB 25052 - Insert only if message not already inserted for same file/runId/receiveLocation
-- 20 Jun 2014     ED      EIB 25757 - It should check if exception, not message
-- =============================================

BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	DECLARE @StepSysId INT, @LogStatusSysId INT
	
	SET @StepSysId = (SELECT StepSysId FROM dbo.Step WHERE StepName = @StepName AND IsActive = 1)

	SET @LogStatusSysId = (SELECT LogStatusSysId FROM dbo.LogStatus WHERE LogStatusName = @LogStatusName AND IsActive = 1)

	IF @RunId = 0 
		SET @RunId = ISNULL((SELECT MAX(RunId) + 1 FROM [Log] (NOLOCK) WHERE FileName = @FileName), 1)

	IF NOT EXISTS(SELECT @ReceiveLocationSysId FROM [Log]  (NOLOCK)
			WHERE ReceiveLocationSysId = @ReceiveLocationSysId AND FileName = @FileName AND RunId = @RunId 
				AND ((@CheckExistingException = 1 AND @Exception!='''' AND Exception = @Exception) OR @CheckExistingException = 0 AND Message = @Message)
			)
		INSERT INTO [dbo].[Log] (ReceiveLocationSysId, FileName, RunId, StepSysId, Message, LogStatusSysId, Exception, IsComplete)
					VALUES(@ReceiveLocationSysId, @FileName, @RunId, @StepSysId, @Message, @LogStatusSysId, @Exception, @IsComplete)
	
	SELECT @RunId AS RunId

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[Config]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[Config]
(
[ConfigId] [int] NOT NULL IDENTITY(1, 1),
[Key] [nvarchar] (50) NOT NULL,
[Value] [nvarchar] (2000) NOT NULL,
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_Configuration_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_Configuration_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_Config] on [dbo].[Config]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[Config] ADD CONSTRAINT [PK_Config] PRIMARY KEY CLUSTERED  ([ConfigId])
');

GO
EXECUTE ('PRINT N''Creating index [AK_Config_Key] on [dbo].[Config]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_Config_Key] ON [dbo].[Config] ([Key])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[Load_IsFileTooOld]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[Load_IsFileTooOld]
	 @DataSourceId INT
	 ,@LocationPath VARCHAR(100)
	 ,@AsOfDate DATETIME
	 ,@IsAcceptable BIT OUTPUT
	 ,@ReceiveLocationSysId INT
	 ,@RunId INT

AS
BEGIN
	-- =============================================
	-- Author:		daviesr
	-- Create date: 2nd Jan 2014
	-- Description:	Checks the date of the file is not older than acceptable.
	-- Modification History
	--
	-- [date-dd/MM/yyyy]	[name]	[description]
	-- 08/01/2013           ED      EIB 24695 - write also to Log table
	-- 09 Jan 2014		    ED      EIB 25004 - remove importLog table and use Log table
	-- 15 Jan 2014		    ED      EIB 25059 - fix dates formating to be dd MMM yyyy
	-- 25 Apr 2014		    ED      EIB 25473 - raise error if file is too old and mark temp records as LoadState=3
	-- =============================================
	
	SET NOCOUNT ON;

	DECLARE @DaysOldAcceptable INT
	DECLARE @MinDateAcceptable DATETIME

	SET @IsAcceptable = 1
	SET @DaysOldAcceptable = CONVERT(INT, (SELECT [Value] FROM dbo.Config WHERE [Key] = ''ImportFileAgeDays''))
	SET @MinDateAcceptable = DATEADD(day, 0-@DaysOldAcceptable, GETDATE())
	SET @MinDateAcceptable = DATEADD(dd, DATEDIFF(dd, 0, @MinDateAcceptable), 0) --get date without time

	IF (@AsOfDate < @MinDateAcceptable)
	BEGIN
		--log that the date is less than acceptable
		SET @IsAcceptable = 0
		DECLARE @Message VARCHAR(100)
		SET @Message = ''The file cannot be imported as it is older than '' + CONVERT(VARCHAR(11), @MinDateAcceptable, 106) + '' ('' + CONVERT(VARCHAR(11), @DaysOldAcceptable)  + '' days old) with a date of '' + CONVERT(VARCHAR(11), @AsOfDate, 106) + ''.''
		
		EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Staged'', @Message, ''Error'', '''', @RunId
	END
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[udf_ConvertToBase10]''
');

GO
EXECUTE ('CREATE FUNCTION [dbo].[udf_ConvertToBase10]
(
	@FractionValue DECIMAL(24, 10)
	, @Base INT
)
RETURNS DECIMAL(24, 10)
AS
BEGIN
	--	23 Apr 2010		amk		Creation
	-- Declare the return variable here
	--  29 Jun 2010     ED MBAL 15702 - ignore base 10, because it does not need conversion
	DECLARE @Base10Value DECIMAL(24, 10)

	IF @Base IS NULL OR @Base = 10
		SET @Base10Value = @FractionValue
	ELSE
		SET @Base10Value = (@FractionValue - FLOOR(@FractionValue)) * 100 * (1.0 / @Base) 
				+ FLOOR(@FractionValue)
	
	-- Return the result of the function
	RETURN @Base10Value

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Price_Add]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Price_Add]
	@AsOfDate			DATETIME		
	, @DataSourceId		INT				
	, @ExchangeId		INT				
	, @InstrumentId		INT				
	, @CurrencyId		INT				
	, @ExpiryYear		SMALLINT		
	, @ExpiryMonth		SMALLINT		
	, @ExpiryDay		SMALLINT	
	, @StrikePrice		MONEY		= NULL	
	, @OptionTypeCode	VARCHAR(25)	= NULL
	, @ImportFileId		INT			= NULL		
	, @SettlementPrice	DECIMAL(24,10)			
AS

BEGIN

	--	21 Apr 2010		AAJM	Creation
	--  23 Apr 2010		AAJM	MBAL-15416 Increase size of SettlementPrice field

	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
		
		DECLARE @CurrentDate DATETIME
		SET @CurrentDate = GETDATE()	
		
		DECLARE @CreateUsername VARCHAR(50)
		SET @CreateUsername = SUSER_SNAME()
		
		INSERT INTO [dbo].[ib_Price]
				([AsOfDate]
				,[DataSourceId]
				,[ExchangeId]
				,[InstrumentId]
				,[CurrencyId]
			    ,[ExpiryYear]
			    ,[ExpiryMonth]
				,[ExpiryDay]
				,[StrikePrice]
				,[OptionTypeCode]
				,[ImportFileId]
				,[SettlementPrice]
				,[CreateDate]
				,[CreateUsername]
				,[UpdateDate]
				,[UpdateUsername])
			VALUES
				(
				@AsOfDate
				, @DataSourceId	
				, @ExchangeId
				, @InstrumentId
				, @CurrencyId
				, @ExpiryYear
				, @ExpiryMonth
				, @ExpiryDay	
				, @StrikePrice
				, @OptionTypeCode
				, @ImportFileId	
				, @SettlementPrice
				, @CurrentDate
				, @CreateUsername
				, NULL
				, NULL
				)
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Price_AddIfNeeded]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Price_AddIfNeeded]
	@AsOfDate				DATETIME
	, @DataSourceId			INT		
	, @ExchangeId			INT
	, @InstrumentId			INT
	, @CurrencyId			INT
	, @ExpiryYear			SMALLINT
	, @ExpiryMonth			SMALLINT
	, @ExpiryDay			SMALLINT
	, @StrikePrice			MONEY		= NULL
	, @OptionTypeCode		VARCHAR(25) = NULL
	, @ImportFileId			INT
	, @SettlementPrice		DECIMAL(24,10)
AS
BEGIN
	--	21 Apr 2010		AAJM	Creation
	--  23 Apr 2010		AAJM	MBAL-15416 Increase size of SettlementPrice field

	-- SET NOCOUNT ON added to prevent extra result SETs from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
				
		IF NOT EXISTS (
				SELECT 1
				FROM ib_Price p
				WHERE AsOfDate = @AsOfDate
					AND p.DataSourceId = @DataSourceId
					AND p.ExchangeId = @ExchangeId
					AND p.InstrumentId = @InstrumentId
					AND p.CurrencyId = @CurrencyId
					AND p.ExpiryYear = @ExpiryYear
					AND p.ExpiryMonth = @ExpiryMonth
					AND (p.ExpiryDay = @ExpiryDay OR (p.ExpiryDay IS NULL AND @ExpiryDay IS NULL))
					AND (p.StrikePrice = @StrikePrice OR (p.StrikePrice IS NULL AND @StrikePrice IS NULL))
					AND (p.OptionTypeCode = @OptionTypeCode OR (p.OptionTypeCode IS NULL AND @OptionTypeCode IS NULL))
				)
				
			BEGIN
			
			EXEC ib_Price_Add 
				@AsOfDate
				, @DataSourceId
				, @ExchangeId
				, @InstrumentId
				, @CurrencyId
				, @ExpiryYear
				, @ExpiryMonth
				, @ExpiryDay
				, @StrikePrice
				, @OptionTypeCode
				, @ImportFileId
				, @SettlementPrice
			
			END
		
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Price_AddFromPositionLoad]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Price_AddFromPositionLoad]
	@PositionId				INT
	, @ImportFileId			INT
	, @SettlementPrice		DECIMAL(24,10)
	, @Base					INT = NULL
AS
--	21 Apr 2010		AAJM	Creation
--  23 Apr 2010		AAJM	MBAL-15416 Increase size of SettlementPrice field
--	26 Apr 2010		amk		MBAL-15240 Take in base too so can handle fractional price
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
	IF (@PositionId IS NOT NULL AND @SettlementPrice IS NOT NULL)
	BEGIN
			DECLARE @AsOfDate		DATETIME
			DECLARE @DataSourceId	INT
			DECLARE @ExchangeId		INT
			DECLARE @InstrumentId	INT
			DECLARE @CurrencyId		INT
			DECLARE @ExpiryYear		INT
			DECLARE @ExpiryMonth	INT
			DECLARE @ExpiryDay		INT
			DECLARE @OptionTypeCode	NVARCHAR(25)
			DECLARE @StrikePrice	MONEY

			SELECT @DataSourceId = DataSourceId
					, @ExchangeId = ExchangeId
					, @InstrumentId = InstrumentId
					, @CurrencyId = CurrencyId
					, @AsOfDate = AsOfDate
					, @ExpiryYear = ExpiryYear
					, @ExpiryMonth = ExpiryMonth
					, @ExpiryDay = ExpiryDay
					, @StrikePrice = StrikePrice
					, @OptionTypeCode = OptionTypeCode
			FROM ib_Position 
			WHERE PositionId = @PositionId
			
			SET @StrikePrice = CASE
									WHEN (@OptionTypeCode IN (''P'',''C''))
										THEN @StrikePrice
										ELSE NULL
									END

			-- udf will automatically cater for null base - no need to worry
			SET @SettlementPrice = dbo.udf_ConvertToBase10(@SettlementPrice, @Base)

			EXEC ib_Price_AddIfNeeded 
				@AsOfDate
				, @DataSourceId
				, @ExchangeId
				, @InstrumentId
				, @CurrencyId
				, @ExpiryYear
				, @ExpiryMonth
				, @ExpiryDay
				, @StrikePrice
				, @OptionTypeCode
				, @ImportFileId
				, @SettlementPrice
			
	END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Position_Add]''
');

GO
EXECUTE ('-- =============================================
-- Author:		McQuien
-- Create date: 27 Jun 2006
-- Description:	Insert into the ib_Position table
-- Revision History:
--  25 Jul 2006		amk		Remove time from AsOfDate
--	06 Aug 2006		amk		Quantity size changed from 18,10 to 19,4
--	15 Aug 2006		amk		Only allow restricted set of OptionTypeCode''s
--  16 Jan 2007		LM		Added extra field @UseNetForCloseOut
--  23 Jun 2014		ED      EIB 25761 - add UTI column
--  08 Dec 2014		ED      EIB 26286 - Change StrikePrice decimals from 4 to 6
-- =============================================

CREATE proc [dbo].[ib_Position_Add]
	(
	@DataSourceId			int,
	@ExchangeId				int,
	@FirmId					int,
	@AccountId				int,
	@AsOfDate				datetime,
	@InstrumentId			int,
	@Quantity				decimal(19,4),
	@CurrencyId				int,
	@MarketValue			decimal(19,4),
	@ExpYr					smallint,
	@ExpMth					smallint,
	@ExpDay					smallint,
	@StrikePrice			decimal(19,6),
	@TrxTypeCode			varchar(25),
	@OptionTypeCode			varchar(25),
	@SourceId				int,
	@PositionId				int output,
	@LongQuantity			decimal(19,4) = Null,
	@ShortQuantity			decimal(19,4) = Null,
	@TradedLongQuantity		decimal(19,4) = Null,
	@TradedShortQuantity	decimal(19,4) = Null,
	@ClassId				int = Null,
	@UseNetForCloseOut		bit = 0,
	@UTI					varchar(100) = NULL
	)
as
SET NOCOUNT ON

	-- remove time part from AsOfDate
	DECLARE @AsOfDateNoTime DATETIME
	SET @AsOfDateNoTime = CAST(CONVERT(CHAR(10), @AsOfDate, 101) AS DATETIME)

	-- check option type code
	SET @OptionTypeCode = RTRIM(LTRIM(@OptionTypeCode))
	IF @OptionTypeCode <> ''P'' AND @OptionTypeCode <> ''C''
		SET @OptionTypeCode = ''''

	insert into ib_position (DataSourceId,ExchangeId,FirmId,AccountId,AsOfDate,InstrumentId,Quantity,CurrencyId,MarketValue,ExpiryYear,ExpiryMonth,ExpiryDay,StrikePrice,TrxTypeCode,OptionTypeCode,TempTableRecordId, LongQuantity, ShortQuantity, TradedLongQuantity, TradedShortQuantity, ClassId, UseNetForCloseOut, UTI  )
	values(@DataSourceId,@ExchangeId,@FirmId,@AccountId,@AsOfDateNoTime,@InstrumentId,@Quantity,@CurrencyId,@MarketValue,@ExpYr,@ExpMth,@ExpDay,@StrikePrice,@TrxTypeCode,@OptionTypeCode,@SourceId, @LongQuantity, @ShortQuantity, @TradedLongQuantity, @TradedShortQuantity, @ClassId, @UseNetForCloseOut, @UTI)

	select @PositionId = scope_identity()
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_InstrumentTypeDataSource_GetByCode]''
');

GO
EXECUTE ('
-- =============================================
-- Author:		McQuien
-- Create date: 29 Jun 2006
-- Description:	Retrieve Instrument type id

CREATE proc [dbo].[ib_InstrumentTypeDataSource_GetByCode]
@DataSourceId int,
@Code varchar(100),
@InstrumentTypeId int output

as
SET NOCOUNT ON

select @InstrumentTypeId = InstrumentTypeId 
from ib_InstrumentTypeDataSource
where DataSourceInstrumentTypeCode = @Code
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_InstrumentTypeDataSource_Add]''
');

GO
EXECUTE (' /*
<details>
 <summary>Adds an instrument type data source into the ib_InstrumentTypeDataSource table</summary>
 <created author="Bruce McQuien" Date=" 28 July 2006" /> 
 <updated author="Laurentiu Macovei" Date=" Sunday, 10 September 2006 2:26PM GMT" /> 
</details>
*/
CREATE PROCEDURE [dbo].[ib_InstrumentTypeDataSource_Add]
(
	@InstrumentTypeId int,
    @DataSourceId int,
    @DataSourceInstrumentTypeCode varchar(100),
    @CreateUsername varchar(50),
	@@InstrumentTypeDataSourceId int OUTPUT
)
AS
SET NOCOUNT ON

INSERT INTO [dbo].[ib_InstrumentTypeDataSource]
           ([InstrumentTypeId]
           ,[DataSourceId]
           ,[DataSourceInstrumentTypeCode]
           ,[CreateUsername])
     VALUES
           (@InstrumentTypeId,
            @DataSourceId, 
            @DataSourceInstrumentTypeCode,
            @CreateUsername)

SELECT @@InstrumentTypeDataSourceId = Scope_Identity()
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_InstrumentType_Update_Code]''
');

GO
EXECUTE ('/*
Programmer:  Lee Manifold
Date:        14 Sept 2006
Description: Changes the guid values in code and name to a more user-friendly value
*/
CREATE proc [dbo].[ib_InstrumentType_Update_Code]
	(
	@InstrumentTypeId int
	)
AS
SET NOCOUNT ON
	
	UPDATE	[dbo].[ib_InstrumentType]
	SET		[Code] = ''AutoGenerated'' + CAST(@InstrumentTypeId AS VARCHAR),
			[Name] = ''AutoGenerated'' + CAST(@InstrumentTypeId AS VARCHAR)
	WHERE	InstrumentTypeId = @InstrumentTypeId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_InstrumentType_Add]''
');

GO
EXECUTE (' /*
<details>
 <summary>Adds an instrument type into the ib_InstrumentType table</summary>
 <created author="Laurentiu Macovei" Date=" Sunday, 10 September 2006 2:26PM GMT" /> 
</details>
*/
CREATE PROCEDURE [dbo].[ib_InstrumentType_Add]
(
	@Code varchar(100),
	@Name varchar(100),
    @CreateUsername varchar(50),
	@@InstrumentTypeId int OUTPUT
)
AS
SET NOCOUNT ON
 
INSERT INTO [dbo].[ib_InstrumentType]
           ([Code]
           ,[Name]
           ,[CreateUsername])
     VALUES
           (@Code,
            @Name,
            @CreateUsername)

SELECT @@InstrumentTypeId = Scope_Identity()
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_InstrumentTypeDataSource_AddAsNeeded]''
');

GO
EXECUTE ('/*
The ib_InstrumentType_AddAsNeeded involves the ib_InstrumentTypeDataSource_AddAsNeeded which will 
produce a recursive sp.  The code below seems to work, but need to clarify with Krip
that the business logic is satisfied. LM

History
Date			Author	Desc
16 Oct 2006		LM		Added SET @User = suser_sname()	

*/
CREATE proc [dbo].[ib_InstrumentTypeDataSource_AddAsNeeded]
	@DataSourceId int,
	@Code varchar(100),
	@Name varchar(100)

	AS
SET NOCOUNT ON

	DECLARE @InstrumentTypeId	int
	DECLARE @returnvalue		int 
	DECLARE	@output				int
	DECLARE @GUID				varchar(50)	
	DECLARE @User				varchar(50)

	SET @GUID = NewId()
	SET @User = suser_sname()
	--PRINT ''Error here!''
	EXEC @returnvalue = [dbo].[ib_instrumenttype_add] @GUID, @GUID, @User,@output output
	SELECT @InstrumentTypeId = @output

	EXEC [dbo].[ib_InstrumentType_Update_Code] @InstrumentTypeId

	EXEC ib_InstrumentTypeDataSource_Add @InstrumentTypeId,@DataSourceId,@Code, @User, @InstrumentTypeId
	SELECT @InstrumentTypeId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_InstrumentType_AddAsNeeded]''
');

GO
EXECUTE ('
-- =============================================
-- Author:		McQuien
-- Create date: 29 Jun 2006
-- Description:	Retrieve Instrument type id

CREATE proc [dbo].[ib_InstrumentType_AddAsNeeded]
	(
	@DataSourceId		int,
	@Code				varchar(100),
	@InstrumentTypeId	int output
	)
AS
SET NOCOUNT ON

	DECLARE @ReturnValue	int
	DECLARE	@OutPut			int  

	EXEC @ReturnValue= [dbo].[ib_InstrumentTypeDataSource_GetByCode] @DataSourceId,@Code,@OutPut output	
	SET @InstrumentTypeId = @OutPut
	
	IF @InstrumentTypeId IS NULL
	BEGIN
		EXEC [dbo].[ib_InstrumentTypeDataSource_AddAsNeeded] @DataSourceId,@Code,@Code
		SELECT	@InstrumentTypeId = instrumenttypeid 
		FROM	[dbo].[ib_InstrumenttypeDataSource]
		WHERE	DataSourceInstrumentTypeCode = @Code
		AND		DataSourceId = @DataSourceId
	END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_InstrumentDataSource_GetByCode]''
');

GO
EXECUTE ('

-- =============================================
-- Author:		McQuien
-- Create date: 28 Jun 2006
-- Description:	Retrieve Instrument id

CREATE proc [dbo].[ib_InstrumentDataSource_GetByCode]
	(
	@DataSourceId int,
	@Code varchar(25),
	@InstrumentId int output,
	@CurrencyId int output
	)

AS
SET NOCOUNT ON

	SELECT	@InstrumentId = InstrumentId ,
			@CurrencyId = Currencyid

	FROM	[dbo].[ib_InstrumentDataSource]
	
	WHERE	DataSourceInstrumentCode = @Code
	AND		DataSourceId = @DataSourceId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_InstrumentDataSource_CheckForDuplicate]''
');

GO
EXECUTE ('
 /*
<details>
	<summary>
		Checks for the duplicate instrument data sources with same code or description. 
		The duplicates are considered if the count of the code or the description is greater than zero (0) for 
		the non-matching instrumentId
	</summary>
	<created author="laurentiu.macovei" date="Thu, 14 Sep 2006 18:04:19 GMT"/>
	<updated author="anil.kripalani" date="31 Jan 2007">
		remove unique check on instrument + datasource (the db already dropped this unique index a while ago)
	</updated>
		<updated author="Alister McLeod" date="18 Oct 2011">
		Reinstate constraint on only one DataSourceInstrumentCode per Instrument Datasource combination.
	</updated>
</details>
*/
CREATE PROCEDURE [dbo].[ib_InstrumentDataSource_CheckForDuplicate]
	(
	@InstrumentId int,
	@DataSourceId int,
	@DataSourceInstrumentCode varchar(100),
	@InstrumentDataSourceId int
	)
AS
SET NOCOUNT ON

	DECLARE @Count int
	DECLARE @InstrumentCode varchar(100)
	DECLARE @ExistingInstrumentDataSourceCode varchar(100)
	DECLARE @DataSourceCode varchar(100)

	SET @Count = 0 

	SELECT TOP 1 @Count = 1, @ExistingInstrumentDataSourceCode = ids.DataSourceInstrumentCode, @DataSourceCode = ds.Code
	FROM [dbo].[ib_InstrumentDataSource] ids
	INNER JOIN [dbo].[ib_DataSource] ds 
		ON ids.DataSourceId = ds.DataSourceId
	WHERE ids.InstrumentId = @InstrumentId AND ids.DataSourceId = @DataSourceId
		AND (ids.InstrumentDataSourceId <> @InstrumentDataSourceId)

IF @Count > 0
	RAISERROR (N''A Data Source Instrument Code (''''%s'''') already exists for Data Source (''''%s''''). Please specify a different Data Source, or edit the existing record.'', 16, 2, @ExistingInstrumentDataSourceCode, @DataSourceCode)
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_InstrumentDataSource_Add]''
');

GO
EXECUTE ('/*
<details>
 <summary>Adds a instrument data source into the ib_InstrumentDataSource table</summary>
 <created author="Bruce McQuien" Date="28 July 2006" /> 
 <updated author="Laurentiu Macovei" Date="Sunday 10 September 2006 1:11PM GMT" />
 <updated author="Lee Manifold" Date="Friday 22 September 2006 " />
 <updated author="Lee Manifold" Date="Monday 16 October 2006 " description="Added Null as default for @StrikePriceDivisor" />
 <updated author="Anil Kripalani" Date="31 Jan 2007">
	Don''t allow zero for strike price divisor
 </updated>
 <updated author="LM" Date="2 Feb 2007">
	Added Default value of NULL for CurrencyId
 </updated>
 <updated author="Anil Kripalani" Date="29 Oct 2009">
	Don''t allow zero for strike price divisor
 </updated>
  <updated author="Alister McLeod" Date="26 Apr 2010">
	Add BaseId which will now be stored on InstrumentDataSource
 </updated>
</details>
*/
CREATE PROCEDURE [dbo].[ib_InstrumentDataSource_Add]
	(
		@InstrumentId int,
		@DataSourceId int,
		@DataSourceInstrumentCode varchar(100),
		@CurrencyId int	= NULL,
		@MarketValueDivisor decimal(19,4) = 1,
		@StrikePriceDivisor decimal(19,4) = NULL,
		@CreateUsername varchar(50)=NULL,
		@@InstrumentDataSourceId int OUTPUT, 
		@PriceDivisor decimal(19,4) = NULL,
		@BaseId	INT = NULL,
		@RunCloseOutReport BIT = 0
	)
AS
SET NOCOUNT ON

	BEGIN TRY

		IF @CurrencyId = -1 SET @CurrencyId = NULL

		IF @CreateUsername IS NULL
			BEGIN
				SET @CreateUsername = (suser_sname())
			END 

		IF @StrikePriceDivisor = 0
			SET @StrikePriceDivisor = NULL

		IF @PriceDivisor = 0
			SET @PriceDivisor = NULL

		--check for duplicates 
		EXEC [dbo].[ib_InstrumentDataSource_CheckForDuplicate] @InstrumentId, @DataSourceId, @DataSourceInstrumentCode, -1

		INSERT INTO [dbo].[ib_InstrumentDataSource]
				   ([InstrumentId]
				   ,[DataSourceId]
				   ,[DataSourceInstrumentCode]
				   ,[CurrencyId]
				   ,[MarketValueDivisor]
				   ,[StrikePriceDivisor]	
				   ,[CreateUsername]
				   ,[PriceDivisor]
				   ,[BaseId]
				   ,[RunCloseOutReport]
					)
			 VALUES
				   (@InstrumentId, 
					@DataSourceId, 
					@DataSourceInstrumentCode,
					@CurrencyId, 
					@MarketValueDivisor,
					@StrikePriceDivisor,
					@CreateUsername,
					@PriceDivisor,
					@BaseId,
					@RunCloseOutReport
					)

		SELECT @@InstrumentDataSourceId = Scope_Identity()

	END TRY
	BEGIN CATCH
		EXEC [dbo].[sp_RethrowError]
	END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Instrument_Update_Code]''
');

GO
EXECUTE ('


/*
Programmer:  McQuien
Date:        03/07/06
Description: Changes the guid values in code and name to a more user-friendly value
*/
-- Revision History
--
-- 01.05.09 Konrad Changed the way the autogenerated instruments have their code and name marked.

CREATE proc [dbo].[ib_Instrument_Update_Code]

	@InstrumentId int,
	@DataSourceCode varchar(100)=NULL,
	@InstrumentName varchar(100)	

as
SET NOCOUNT ON

IF @DataSourceCode IS NOT NULL
   SET @InstrumentName = @DataSourceCode + '' '' + @InstrumentName

update ib_Instrument
set code = ''AG '' + cast(@InstrumentId as varchar),
name = @InstrumentName
where instrumentid = @InstrumentId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Instrument_CheckForDuplicate]''
');

GO
EXECUTE ('
  /*
<details>
 <summary>
	Checks for the duplicate bases with same code. 
</summary>
 <created author="Laurentiu Macovei" Date="Thursday, 14 September 2006 15:59PM GMT" /> 
<updated author="Emilian Damian" Date="9 Feb 2007" /> 
currency->instrument
</details>

-- 07 Oct 2014  ED  EIB 26072 - only check active instruments
*/
CREATE PROCEDURE [dbo].[ib_Instrument_CheckForDuplicate]
	(
	@Code			varchar(100),
	@InstrumentId	int
	)
AS
SET NOCOUNT ON

	DECLARE @Count int

	SELECT	TOP 1 @Count = 1
	FROM	[dbo].[ib_Instrument] c
	WHERE	[Code] = @Code
	AND		[InstrumentID] <> @InstrumentId
	AND		IsActive = 1

	IF @Count > 0
		RAISERROR (N''There is already another instrument with same code (%s). Please specify other code!'', 11, 1, @Code)
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Instrument_Add]''
');

GO
EXECUTE (' /*
<details>
 <summary>Adds an instrument into the ib_Instrument table</summary>
 <created author="Laurentiu Macovei" Date="Sunday, 10 September 2006 9:26PM GMT" /> 
</details>
 Date			Author				Description
 30 Jan 2007	LM					Added extra field PriceTypeCode.  Default to Null so old 
									references to the sp do not break. 
*/
CREATE PROCEDURE [dbo].[ib_Instrument_Add]
	(
	@InstrumentTypeId	int,
	@Code				varchar(100),
	@Name				varchar(100),
	@IsApproved			bit,
	@LotSize			decimal(24,10) = NULL,
	@TickSize			decimal(24,10) = NULL,
	@BaseId				int = NULL,
	@CreateUsername		varchar(50)= NULL,
	@@InstrumentId		int OUTPUT,
	@PriceTypeCode		varchar(50) = NULL	
	)
AS
SET NOCOUNT ON

	BEGIN TRY
	--check for duplicates 

		IF @CreateUsername IS NULL 
			SET @CreateUsername = (suser_sname())


		EXEC [dbo].[ib_Instrument_CheckForDuplicate] @Code, -1

		INSERT INTO [dbo].[ib_Instrument]
				   (
					[InstrumentTypeId],
					[Code],
					[Name],
					[IsApproved],
					[LotSize],
					[TickSize],
					[BaseId],
					[PriceTypeCode],
					[CreateUsername] 
					)
			 VALUES
				   (
					@InstrumentTypeId,
				    @Code, 
					@Name, 
					@IsApproved, 
					@LotSize, 
					@TickSize,
					@BaseId,
					@PriceTypeCode,
					@CreateUsername
				    )

		SELECT @@InstrumentId = Scope_Identity()

	END TRY
	BEGIN CATCH
		EXEC [dbo].[sp_RethrowError]
	END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_InstrumentDataSource_AddAsNeeded]''
');

GO
EXECUTE ('




/*
Programmer:  McQuien
Date:        28/06/06
Description: Inserts value into InstrumentExchange,Instrument, and InstrumentType if lookup fails

Date		Author		Desc
21 Sep 2006	LM			Passed in parameters to [ib_InstrumentDataSource_Add] as 
						named parameters.
*/
-- Revision History
--
-- 01.05.09 Konrad Changed the way the autogenerated instruments have their code and name marked.

CREATE proc [dbo].[ib_InstrumentDataSource_AddAsNeeded]
	(
	@DataSourceId		int,
	@InstrumentTypeId	int,
	@Code				varchar(25),
	@Name				varchar(50),
	@CurrencyId			int,
	@IsApproved			bit
	)
AS
SET NOCOUNT ON

	DECLARE @InstrumentId	int
	DECLARE @GUID			varchar(50)
	DECLARE @DataSourceCode varchar(100)

	SET @GUID = newId()

	DECLARE @returnvalue	int 
	DECLARE	@output			int

	--EXEC @returnvalue = [dbo].[ib_Instrument_Add] @InstrumentTypeId,@GUID,@GUID,@IsApproved,@output output
	EXEC @returnvalue = [dbo].[ib_Instrument_Add]
		@InstrumentTypeId = @InstrumentTypeId,
		@Code= @GUID,
		@Name = @GUID,
		@IsApproved = @IsApproved,
		@@InstrumentId = @output output


	SET @InstrumentId = @output

	SELECT @DataSourceCode=Code From ib_DataSource WHERE DataSourceId = @DataSourceId

	EXEC [dbo].[ib_Instrument_Update_Code] @InstrumentId,@DataSourceCode,@Code

	/*
	insert into ib_InstrumentDataSource(instrumentid,DataSourceId,DataSourceInstrumentCode,currencyid)
	values(@InstrumentId,@DataSourceId,@Code,@CurrencyId)
	*/

	--EXEC [dbo].[ib_InstrumentDataSource_Add] @InstrumentId,@DataSourceId,@Code,@CurrencyId
	EXEC [dbo].[ib_InstrumentDataSource_Add]
		@InstrumentId = @InstrumentId,
		@DataSourceId = @DataSourceId,
		@DataSourceInstrumentCode = @Code,
		@CurrencyId = @CurrencyId,
		@@InstrumentDataSourceId = @output output

	SELECT @output
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Instrument_AddAsNeeded]''
');

GO
EXECUTE ('

-- =============================================
-- Author:		McQuien
-- Create date: 28 Jun 2006
-- Description:	Retrieve Instrument id

CREATE proc [dbo].[ib_Instrument_AddAsNeeded]
	(
	@DataSourceId		int,
	@InstrumentTypeId	int,
	@Code				varchar(25),
	@CurrencyId			int,
	@InstrumentId		int output,
	@CurrencyIdOut		int output
	)

as
SET NOCOUNT ON

	--	16 Aug 2006		amk		Bug Fix: Put "output" after currency argument on InstrDataS GetByCode call

	DECLARE @ReturnValue	int
	DECLARE	@OutPut			int
	DECLARE	@OutPut2		int  

	EXEC @ReturnValue= [ib_InstrumentDataSource_GetByCode] @DataSourceId,@Code,@OutPut output,@OutPut2 output
	SET @InstrumentId = @OutPut
	SET @CurrencyIdOut = @OutPut2
	
	IF @InstrumentId IS NULL
	BEGIN
		EXEC ib_InstrumentDataSource_AddAsNeeded @DataSourceId,@InstrumentTypeId,@Code,@Code,@CurrencyId,0
		SELECT	@InstrumentId = instrumentid,
				@CurrencyId = CurrencyId 
		FROM	[dbo].[ib_InstrumentDataSource]
		WHERE	DataSourceInstrumentCode = @Code
		AND		DataSourceId = @DataSourceId
	END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_FirmDataSource_GetByCode]''
');

GO
EXECUTE ('-- =============================================
-- Author:		McQuien
-- Create date: 28 Jun 2006
-- Description:	Retrieve Firm id

CREATE proc [dbo].[ib_FirmDataSource_GetByCode]
@DataSourceId int,
@Code varchar(25),
@FirmId int output

as
SET NOCOUNT ON

select @FirmId = FirmId 
from ib_FirmDataSource
where DataSourceFirmCode = @Code
and DataSourceId = @DataSourceId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_FirmDataSource_CheckForDuplicate]''
');

GO
SET ANSI_NULLS OFF

GO
EXECUTE (' /*
<details>
 <summary>
	Checks for the duplicate firm data sources with same code or description. 
	The duplicates are considered if the count of the code or the description is greater than zero (0) for 
	the non-matching firmId
</summary>
    <created author="laurentiu.macovei" date="Sun, 24 Sep 2006 15:25:52 GMT"/>
	<updated author="Anil Kripalani" Date="28 November 2006" >Remove one of the dupe checks</updated>
</details>
*/
CREATE PROCEDURE [dbo].[ib_FirmDataSource_CheckForDuplicate]
@FirmId int,
@DataSourceId int,
@DataSourceFirmCode varchar(100),
@FirmDataSourceId int
AS
SET NOCOUNT ON

DECLARE @Count int
DECLARE @FirmCode varchar(100)
DECLARE @DataSourceCode varchar(100)

SET @Count = 0 
SELECT TOP 1 @Count = 1, @DataSourceCode = ds.Code
	FROM [dbo].[ib_FirmDataSource] ids
	INNER JOIN [dbo].[ib_DataSource] ds 
		ON ids.DataSourceId = ds.DataSourceId
	WHERE ids.DataSourceFirmCode = @DataSourceFirmCode
		AND ids.DataSourceId = @DataSourceId
		AND ids.FirmDataSourceId <> @FirmDataSourceId
IF @Count > 0
	RAISERROR (N''There is already another Firm Data Source with same Data Source Firm Code (%s) and same Data Source (%s). Please specify other Data Source or other Data Source Firm Code!'', 11, 1, @DataSourceFirmCode, @DataSourceCode)
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_FirmDataSource_Add]''
');

GO
SET ANSI_NULLS ON

GO
EXECUTE (' /*
<details>
 <summary>Adds a firm data source into the ib_FirmDataSource table</summary>
 <created author="Laurentiu Macovei" Date=" Sunday, 10 September 2006 9:26PM GMT" /> 
 <updated author="Laurentiu Macovei" Date=" Sunday, 24 September 2006 3:40PM GMT"> 
	Added check for duplicate feature
 </updated>
</details>
*/
CREATE PROCEDURE  [dbo].[ib_FirmDataSource_Add]
(
	@FirmId int,
    @DataSourceId int,
    @DataSourceFirmCode varchar(100),
    @CreateUsername varchar(50),
	@@FirmDataSourceId int OUTPUT
)
AS
SET NOCOUNT ON

BEGIN TRY
--check for duplicates 
EXEC [dbo].[ib_FirmDataSource_CheckForDuplicate] @FirmId, @DataSourceId, @DataSourceFirmCode, -1

INSERT INTO [dbo].[ib_FirmDataSource]
           ([FirmId]
           ,[DataSourceId]
           ,[DataSourceFirmCode]
           ,[CreateUsername])
     VALUES
           (@FirmId,
            @DataSourceId,
            @DataSourceFirmCode,
            @CreateUsername)

SELECT @@FirmDataSourceId = Scope_Identity()
END TRY
BEGIN CATCH
	EXEC [dbo].[sp_RethrowError]
END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Firm_Update_Code]''
');

GO
EXECUTE ('CREATE proc [dbo].[ib_Firm_Update_Code]
/*
Programmer:  McQuien
Date:        03/07/06
Description: Changes the guid values in code and name to a more user-friendly value
*/
@FirmId int

as
SET NOCOUNT ON

update ib_Firm
set code = ''AutoGenerated'' + cast(@FirmId as varchar),
name = ''AutoGenerated'' + cast(@FirmId as varchar)
where firmid = @FirmId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Firm_CheckForDuplicate]''
');

GO
SET ANSI_NULLS OFF

GO
EXECUTE ('  /*
<details>
 <summary>
	Checks for the duplicate firms with same code or name. 
</summary>
   <created author="laurentiu.macovei" date="Sun, 24 Sep 2006 15:38:06 GMT"/>
</details>
*/
CREATE PROCEDURE [dbo].[ib_Firm_CheckForDuplicate]
@Code varchar(100),
@Name varchar(100),
@FirmId int
AS
SET NOCOUNT ON

DECLARE @Count int

SELECT TOP 1 @Count = 1
	FROM [dbo].[ib_Firm] c
	WHERE Code = @Code
		AND FirmID <> @FirmId

IF @Count > 0
	RAISERROR (N''There is already another Firm with same code (%s). Please specify other code!'', 11, 1, @Code)

SET @Count = 0

SELECT TOP 1 @Count = 1
	FROM [dbo].[ib_Firm] c
	WHERE Name = @Name
		AND FirmID <> @FirmId

IF @Count > 0
	RAISERROR (N''There is already another Firm with same name (%s). Please specify other name!'', 11, 1, @Name)
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Firm_Add]''
');

GO
SET ANSI_NULLS ON

GO
EXECUTE (' /*
<details>
 <summary>Adds a firm into the ib_Firm table</summary>
 <created author="McQuien" Date=" 28 June 2006" /> 
 <updated author="Laurentiu Macovei" Date=" Sunday, 10 September 2006 9:26PM GMT" /> 
 <updated author="Laurentiu Macovei" Date=" Sunday, 24 September 2006 3:40PM GMT"> 
	Added check for duplicate feature
 </updated>
</details>
*/
CREATE PROCEDURE [dbo].[ib_Firm_Add]
(
	@Code varchar(100),
    @Name varchar(100),
    @IsApproved bit,
    @CreateUsername varchar(50),
	@@FirmId int OUTPUT
)
AS
SET NOCOUNT ON
BEGIN TRY
--check for duplicates 
EXEC [dbo].[ib_Firm_CheckForDuplicate] @Code, @Name, -1

INSERT INTO [dbo].[ib_Firm]
           ([Code]
           ,[Name]
           ,[IsApproved]
           ,[CreateUsername])
     VALUES
           (@Code,
            @Name,
            @IsApproved,
            @CreateUsername)

SELECT @@FirmId = Scope_Identity()
END TRY
BEGIN CATCH
	EXEC [dbo].[sp_RethrowError]
END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_FirmDataSource_AddAsNeeded]''
');

GO
EXECUTE ('/*
Programmer:  McQuien
Date:        28/06/06
Description: Inserts value into FirmExchange and Firm if lookup fails

History
Date		Author	Comments
====		======	========
13 Sep 2006	LM		Added ib_FirmDataSource_Add to the sp instead of
					inline code.	
17 Oct 2006 LM		1. Added @User to comply with changes in ib_Firm_Add + ib_FirmDataSource_Add
					2. Added FirmId as an Output parameter.
*/
CREATE proc [dbo].[ib_FirmDataSource_AddAsNeeded]
	(
	@DataSourceId	int,
	@Code			varchar(25),
	@Name			varchar(50),
	@IsApproved		bit
	)
AS
SET NOCOUNT ON

	DECLARE @FirmId					int
	DECLARE @GUID					varchar(50)
	DECLARE @ib_FirmDataSourceId	int
	DECLARE @output					int 
	DECLARE	@returnvalue			int
	DECLARE @User					varchar(50)

	SET @GUID = newId()
	SET @User = (suser_sname())

	EXEC @returnvalue = [dbo].[ib_firm_add] @GUID,@GUID,@IsApproved, @User,@output output
	SET @FirmId = @output

	EXEC [dbo].[ib_Firm_Update_Code] @FirmId

	EXEC @ReturnValue = [dbo].[ib_FirmDataSource_Add] @FirmId,@DataSourceId,@Code, @User, @Output output		
	SET @ib_FirmDataSourceId = @output
	SELECT @ib_FirmDataSourceId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Firm_AddAsNeeded]''
');

GO
EXECUTE ('
/* =============================================
	 Author:		McQuien
	Create date: 28 Jun 2006
	Description:	Retrieve Firm id
	History
	Date		Author	Desc
	17 Oct 2006	LM		Added functionality to handle output parameter for ib_FirmDataSource_AddAsNeeded

*/
CREATE proc [dbo].[ib_Firm_AddAsNeeded]
@DataSourceId int,
@Code varchar(100),
@FirmId Int Output

as
SET NOCOUNT ON

declare @ReturnValue	int
declare @OutPut			int  


exec @ReturnValue= [ib_FirmDataSource_GetByCode] @DataSourceId,@Code,@OutPut output	
set @FirmId = @OutPut


if @FirmId is null
begin
	exec ib_FirmDataSource_AddAsNeeded @DataSourceId,@Code,@Code,0
end

select @FirmId = firmid 
from ib_FirmDataSource
where DataSourceFirmCode = @Code
and DataSourceId = @DataSourceId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_DataSourceExchange_GetByCode]''
');

GO
EXECUTE ('





CREATE proc [dbo].[ib_DataSourceExchange_GetByCode]
@DataSourceId int,
@Code varchar(25),
@ExchangeId int output

as
SET NOCOUNT ON

select @ExchangeId = ExchangeId 
from ib_DataSourceExchange
where DataSourceExchangeCode = @Code
and DataSourceId = @DataSourceId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_CurrencyDataSource_GetByCode]''
');

GO
EXECUTE ('
-- =============================================
-- Author:		McQuien
-- Create date: 28 Jun 2006
-- Description:	Retrieve Currency id

CREATE proc [dbo].[ib_CurrencyDataSource_GetByCode]
	(
	@DataSourceId int,
	@Code varchar(25),
	@CurrencyId int output
	)

AS
SET NOCOUNT ON

	SELECT	@CurrencyId = [CurrencyId] 
	FROM	[dbo].[ib_CurrencyDataSource]
	WHERE	[DataSourceCurrencyCode] = @Code
	AND		[DataSourceId] = @DataSourceId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_CurrencyDataSource_CheckForDuplicate]''
');

GO
EXECUTE (' /*
<details>
 <summary>
	Checks for the duplicate currency data sources with same code or description. 
	The duplicates are considered if the count of the code or the description is greater than zero (0) for 
	the non-matching currencyId
</summary>
 <created author="Laurentiu Macovei" Date="Wednesday, 6 September 2006 2:12AM GMT" /> 
 <updated author="Anil Kripalani" Date="28 November 2006" >Remove one of the dupe checks</updated>
</details>
*/
CREATE PROCEDURE [dbo].[ib_CurrencyDataSource_CheckForDuplicate]
@CurrencyId int,
@DataSourceId int,
@DataSourceCurrencyCode varchar(100),
@CurrencyDataSourceId int
AS
SET NOCOUNT ON

DECLARE @Count int
DECLARE @CurrencyCode varchar(100)
DECLARE @DataSourceCode varchar(100)

SET @Count = 0 
SELECT TOP 1 @Count = 1, @DataSourceCode = ds.Code
	FROM [dbo].[ib_CurrencyDataSource] cds
	INNER JOIN [dbo].[ib_DataSource] ds 
		ON cds.DataSourceId = ds.DataSourceId
	WHERE cds.DataSourceCurrencyCode = @DataSourceCurrencyCode
		AND cds.DataSourceId = @DataSourceId
		AND cds.CurrencyDataSourceId <> @CurrencyDataSourceId
IF @Count > 0
	RAISERROR (N''There is already another currency data source with same Data Source Currency Code (%s) and same Data Source (%s). Please specify other Data Source or other Data Source Currency Code!'', 11, 1, @DataSourceCurrencyCode, @DataSourceCode)
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_CurrencyDataSource_Add]''
');

GO
EXECUTE ('
 /*
<details>
 <summary>Adds a currency data source into the ib_CurrencyDataSource table</summary>
 <created author="Laurentiu Macovei" Date="Friday, 8 September 2006 22:52 GMT" /> 
</details>
*/
CREATE PROCEDURE [dbo].[ib_CurrencyDataSource_Add]
(
	@CurrencyId int,
    @DataSourceId int,
    @DataSourceCurrencyCode varchar(100),
    @CreateUsername varchar(50)= NULL,
	@@CurrencyDataSourceId int OUTPUT
)
AS 
SET NOCOUNT ON


BEGIN TRY

IF @CreateUsername IS NULL
	BEGIN
		SET @CreateUsername = suser_sname()
	END

--check for duplicates 
EXEC [dbo].[ib_CurrencyDataSource_CheckForDuplicate] @CurrencyId, @DataSourceId, @DataSourceCurrencyCode, -1


INSERT INTO [dbo].[ib_CurrencyDataSource]
           ([CurrencyId]
           ,[DataSourceId]
           ,[DataSourceCurrencyCode]
           ,[CreateUsername])
     VALUES
           (@CurrencyId,
           @DataSourceId,
           @DataSourceCurrencyCode,
           @CreateUsername)

SELECT @@CurrencyDataSourceId = Scope_Identity()
END TRY
BEGIN CATCH
	EXEC [dbo].[sp_RethrowError]
END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Currency_Update_Code]''
');

GO
EXECUTE ('
/*
Programmer:  McQuien
Date:        03/07/06
Description: Changes the guid values in code and name to a more user-friendly value
*/
CREATE proc [dbo].[ib_Currency_Update_Code]
	(
	@CurrencyId int
	)
AS
SET NOCOUNT ON

	UPDATE	[dbo].[ib_Currency]
	SET		[code]			= ''AutoGenerated'' + cast(@CurrencyId as varchar),
			[description]	= ''AutoGenerated'' + cast(@CurrencyId as varchar)
	WHERE	[currencyid]	= @CurrencyId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Currency_CheckForDuplicate]''
');

GO
EXECUTE (' /*
<details>
 <summary>
	Checks for the duplicate currencies with same code or description. 
	The duplicates are considered if the count of the code or the description is greater than zero (0) for 
	the non-matching currencyId
</summary>
 <created author="Laurentiu Macovei" Date="Wednesday, 6 September 2006 3:35AM GMT" /> 
</details>
-- 23 Apr 2014	ED	EIB 25500 - only check for active ones
*/
create PROCEDURE [dbo].[ib_Currency_CheckForDuplicate]
@Code varchar(100),
@Description varchar(100),
@CurrencyId int
AS
SET NOCOUNT ON

DECLARE @Count int

SELECT TOP 1 @Count = 1
	FROM [dbo].[ib_Currency] c
	WHERE Code = @Code
		AND CurrencyID <> @CurrencyId AND IsActive = 1

IF @Count > 0
	RAISERROR (N''There is already another currency with same code (%s). Please specify other code!'', 11, 1, @Code)

SET @Count = 0
SELECT TOP 1 @Count = 1
	FROM [dbo].[ib_Currency] c
	WHERE Description = @Description
		AND CurrencyID <> @CurrencyId AND IsActive = 1

IF @Count > 0
	RAISERROR (N''There is already another currency with same description (%s). Please specify other description!'', 11, 1, @Description)
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Currency_Add]''
');

GO
EXECUTE (' /*
<details>
 <summary>Adds a currency into the ib_Currency table</summary>
 <created author="Laurentiu Macovei" Date=" Wednesday, 6 September 2006 2:26AM GMT" /> 
</details>
*/
CREATE PROCEDURE [dbo].[ib_Currency_Add]
	@Code varchar(100),
	@Description varchar(100),
	@IsApproved varchar(200),
	@CreateUsername varchar(50)= NULL,
	@@CurrencyId int OUTPUT
AS
SET NOCOUNT ON

	BEGIN TRY

		IF @CreateUserName IS NULL
			BEGIN
				SET @CreateUserName = suser_sname()
			END
		--check for duplicates 
		EXEC [dbo].[ib_Currency_CheckForDuplicate] @Code, @Description, -1

		INSERT INTO [dbo].[ib_Currency]
				   ([Code]
				   ,[Description]
				   ,[IsApproved]
				   ,[CreateUsername])
			 VALUES
				   (@Code
				   ,@Description
				   ,@IsApproved
				   ,@CreateUsername)
			

		SELECT @@CurrencyID = Scope_Identity()

	END TRY
	BEGIN CATCH
		EXEC [dbo].[sp_RethrowError]
	END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_CurrencyDataSource_AddAsNeeded]''
');

GO
EXECUTE ('/*
Programmer:  McQuien
Date:        28/06/06
Description: Inserts value into FirmExchange and Firm if lookup fails
*/
CREATE proc [dbo].[ib_CurrencyDataSource_AddAsNeeded]
	(
	@DataSourceId int,
	@Code varchar(25),
	@Name varchar(50),
	@IsApproved bit
	)

	as
SET NOCOUNT ON

	declare @CurrencyId				int
	declare @GUID					varchar(50)
	declare @CurrencyDataSourceId	int
	declare @returnvalue			int 
	declare	@output					int

	set @GUID = newid()

	--exec @returnvalue = ib_Currency_Add @GUID,@GUID,@IsApproved,@output output
	exec	@returnvalue = [dbo].[ib_Currency_Add]	
			@Code = @GUID,
			@Description = @GUID,
			@IsApproved = @IsApproved,
			@@CurrencyId = @output OUTPUT

	set @CurrencyId = @output

	exec [dbo].[ib_Currency_Update_Code] @CurrencyId

	exec	@returnvalue = [dbo].[ib_CurrencyDataSource_Add] 
			@CurrencyId = @CurrencyId,
			@DataSourceId = @DataSourceId,
			@DataSourceCurrencyCode = @Code,
			@@CurrencyDataSourceId = @output output

			set @CurrencyDataSourceId = @output
			select @CurrencyDataSourceId


	--delete once testing is complete
	--insert into ib_CurrencyDataSource(currencyid,datasourceid,datasourcecurrencycode)
	--values(@CurrencyId,@DataSourceId,@Code)
	--select scope_identity()
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Currency_AddAsNeeded]''
');

GO
EXECUTE ('

-- =============================================
-- Author:		McQuien
-- Create date: 28 Jun 2006
-- Description:	Retrieve currency id

CREATE proc [dbo].[ib_Currency_AddAsNeeded]
@DataSourceId int,
@Code varchar(25),
@CurrencyId int output

as
SET NOCOUNT ON

declare @ReturnValue int,@OutPut int  
exec @ReturnValue= [ib_CurrencyDataSource_GetByCode] @DataSourceId,@Code,@OutPut output	
set @CurrencyId = @OutPut

if @CurrencyId is null
begin
	exec [dbo].[ib_CurrencyDataSource_AddAsNeeded] @DataSourceId,@Code,@Code,0
	select @CurrencyId = Currencyid 
	from ib_CurrencyDataSource
	where DataSourceCurrencyCode = @Code
		and DataSourceId = @DataSourceId
end
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Account_GetByCode]''
');

GO
EXECUTE ('

CREATE proc [dbo].[ib_Account_GetByCode]
@Code varchar(25),
@FirmId int,
@AccountId int output,
@ClassId int output,
@IsImported bit = NULL output

as
SET NOCOUNT ON
-- =============================================
-- Author:		McQuien
-- Create date: 28 Jun 2006
-- Description:	Retrieve Account id

-- Revision History:

--	26 Jan 2007		amk		Bug Fix: Use FirmId in lookup
--  09 June 2009    Konrad  Added retrieval of ClassId
--  28 Apr 2010		AAJM	Return IsImported from Account table
-- =============================================

select @AccountId = accountid, @ClassId = classid, @IsImported = IsImported
from ib_Account
where code = @Code
	and FirmId = @FirmId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Account_Add]''
');

GO
EXECUTE ('CREATE proc [dbo].[ib_Account_Add]
(
	@FirmId				int,
	@Code				varchar(100),
	@Name				varchar(50),
	@IsApproved			bit = 0,
	@ClassId            int = NULL,
	@CreateUsername		varchar(50)= NULL,
	@ParentAccountId	int = NULL,
	@@AccountId			int = NULL OUTPUT,
	@IsImported			BIT = 1,
	@FamilyCode			varchar(100)= NULL,
	@IsOmnibus          BIT = 0
)
AS
SET NOCOUNT ON
/*
Programmer:  McQuien
Date:        28/06/06
Description: Inserts value into Account if lookup fails

History

Date		Author			Description
26 Jan 2007	LM				Added extra parameter @ParentAccountId, with default of null, this should
							be compatable with the older 4 parameter sp calls.

*/
-- Revision History
--
-- 11.06.2009	Konrad	Added ClassId and CreateUsername to the Insert parameters.
-- 16.06.2009	Konrad	Fixed @@AccountId default value to null
-- 06.10.2009	amk		Add check on error to see if account already exists to prevent error
-- 27.04.2010	AAJM	MBAL-15315 Add IsImported flag
-- 04.08.2010	amk		MBAL-16349 change default of isimported flag to 1
-- 01.05.2012	ed		MBAL-20400 add FamilyCode and IsOmnibus

	BEGIN TRY
		IF @CreateUsername IS NULL 
			SET @CreateUsername = (suser_sname())

		insert into ib_Account 
		(
			[FirmId],
			[Code],
			[Name],
			[Isapproved],
			[ClassId],
			[CreateUsername],
			[ParentAccountId],
			[IsImported],
			[FamilyCode],
			[IsOmnibus]
		)
		values 
		(
			@FirmId,
			@Code,
			@Name,
			@IsApproved,
			@ClassId,	
			@CreateUsername,
			@ParentAccountId,
			@IsImported,
			@FamilyCode,
			@IsOmnibus
		)

		SELECT @@AccountId = SCOPE_IDENTITY()
	END TRY
	BEGIN CATCH
		-- Could be account already exists so let''s try and retrieve it
		SELECT @@AccountId = AccountId
		FROM ib_Account a
		WHERE a.FirmId = @FirmId
			AND a.Code = @Code

		IF @@ROWCOUNT = 0
			EXEC [dbo].[sp_RethrowError]
	END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Account_AddAsNeeded]''
');

GO
EXECUTE ('


CREATE proc [dbo].[ib_Account_AddAsNeeded]
	(
	@Code		varchar(100),
	@FirmId		int,
	@AccountId	int output,
	@ClassId    int = null output,
	@Name		varchar(50) = Null,
	@IsImported bit = null output
	)
AS
SET NOCOUNT ON

-- =============================================
-- Author:		McQuien
-- Create date: 28 Jun 2006
-- Description:	Retrieve Account id
--
--	History
--	Date			Name		Desc
--	28 Jan 07		LM			Added extra Parameter @Name
--	29 Jan 07		amk			Bug Fix: query at end needs to include firm
--  09 June 2009    Konrad		Added retrieval of ClassId
--  16 June 2009    Konrad		@ClassId default value set to null so data types not using it can retrieve Accounts.
--  27 Apr 2010		AAJM		MBAL-15315 Return IsImported from Account via optional output
--								parameter

-- =============================================
	DECLARE @ReturnValue int
	EXEC @ReturnValue= [ib_Account_GetByCode] @Code,@FirmId,@AccountId output, @ClassId output, @IsImported output	


	IF @AccountId IS NULL
	BEGIN
		SET @Name = ISNULL(@Name,@Code)
		EXEC [dbo].[ib_Account_Add] @FirmId,@Code,@Name,0
		SELECT @AccountId = AccountId, @IsImported = [IsImported]
		FROM ib_Account
		WHERE code = @Code
			AND FirmId = @FirmId
	END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[_ib_DataSource_GetByCodeForOutput]''
');

GO
EXECUTE ('
-- =============================================
-- Author:		McQuien
-- Create date: 28 Jun 2006
-- Description:	Retrieve Exchange id

CREATE proc [dbo].[_ib_DataSource_GetByCodeForOutput]
	(	
	@Code				varchar(25),
	@DataSourceId		int output,
	@DefaultCurrencyId	int output
	)
AS
SET NOCOUNT ON

	SELECT	@DataSourceId		= [a].[DataSourceId],
			@DefaultCurrencyId	= [a].[DefaultCurrencyId]

	FROM	[dbo].[ib_DataSource] AS [a]
	WHERE	[a].[Code] = @Code
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Position_Load]''
');

GO
EXECUTE ('/*
Programmer:  Bruce McQuien
Date: 07/07/2006

Purpose:  This stored proc will accept the parameters passed to it from any 
datasource, perform the necessary lookups, and then insert a record in the #
ib_position table, and a record in the ib_trx table.

Revision History:

06 Aug 2006		amk		Quantity size changed from 18,10 to 19,4
08 Aug 2006		amk		1) Bug Fix: Firm code should not be just 3; same with instrument code
						2) Bug Fix: Account code should not be just 1!
						3) Bug Fix: Exchange code should not be just 4!
09 Aug 2006		amk		Take in currency code too and process it
16 Jan 2007		LM		Added extra field @UseNetForCloseOut as per Suretrack issue 2696.
09 June 2009    Konrad  Retrieve ClassId in same step as AccountId
22 Apr 2010		AAJM	MBAL-14741 Return PositionId as output parameter
23 Apr 2010		AAJM	MBAL-15416 Increase size of Price field
28 Apr 2010		AAJM	MBAL-15315 Only import if Account.IsImported = true
09 Jan 2014		ED		EIB 25004 - remove importLog table and use Log table
17 Apr 2014		ED      EIB 25498 - log exchange not found as warning
23 Jun 2014		ED      EIB 25761 - add UTI column
08 Dec 2014		ED      EIB 26286 - Change StrikePrice decimals from 4 to 6
*/
CREATE proc [dbo].[ib_Position_Load]
	(
	@DataSourceCd			varchar(100),
	@ExchangeCd				varchar(25),
	@FirmCd					varchar(100),
	@AccountCd				varchar(100),
	@AsOfDate				datetime,
	@InstrumentCd			varchar(100),
	@Quantity				decimal(19,4),
	@MarketValue			decimal(19,4),
	@ExpYr					smallint,
	@ExpMth					smallint,
	@ExpDay					smallint,
	@StrikePrice			decimal(19,6),
	@TrxTypeCd				varchar(25),
	@OptionTypeCd			varchar(25),
	@TrxDate				datetime,
	@Price					decimal(24,10),
	@TempTableRecordId		int,
	@InstrumentTypeCd		varchar(100),
	@LocationPath			varchar(100) = NULL,
	@CurrencyCd				varchar(100) = NULL ,
	@LongQuantity			decimal(19,4) = NULL, 
	@ShortQuantity			decimal(19,4) = NULL, 
	@TradedLongQuantity		decimal(19,4) = NULL, 
	@TradedShortQuantity	decimal(19,4) = NULL,
	@ClassId				int = NULL,
	@UseNetForCloseOut		bit = 0,
	@PositionId				INT OUTPUT,
	@ReceiveLocationSysId   INT,
	@RunId                  INT,
	@UTI					VARCHAR(100) = NULL
	)
as
SET NOCOUNT ON


	declare @ReturnValue int,@OutPut int,@OutPut2 int
	declare @DataSourceId int
	declare @DefaultCurrencyId int
	declare @Code varchar(100)
	set @Code = @DataSourceCd
	exec @ReturnValue= [_ib_DataSource_GetByCodeForOutput] @Code,@OutPut output,@Output2 output
	set @DataSourceId = @OutPut
	set @DefaultCurrencyId = @Output2
	set @OutPut = null
	declare @ExchangeId int
	set @Code = @ExchangeCd
	--PRINT ''@DataSourceId''
	--PRINT @DataSourceId
	--PRINT ''@ExchangeCd''
	--PRINT @Code
	exec @ReturnValue = ib_DataSourceExchange_GetByCode @DataSourceId,@Code,@Output output
	set @ExchangeId = @OutPut

	--if no exchange found then quit here.
	if @ExchangeId is null 
		begin
		declare @now datetime
		declare @user varchar(100)
		declare @logmsg varchar(100)
		set @user = suser_sname()
		set @now = getdate()
		set @logmsg = ''Exchange Code Not Found for ib_Position_Load run for code: '' + ISNULL(@ExchangeCd, ''NULL'')
		EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @logmsg, ''Warning'', @TempTableRecordId, @RunId
		end
	else
		begin

		set @Output = null
		declare @InstrumentTypeId int
		set @Code = @InstrumentTypeCd

		exec @ReturnValue = ib_Instrumenttype_AddAsNeeded @DataSourceId,@Code,@OutPut output
		set @InstrumentTypeId = @OutPut
		
		set @Output = null
		declare @FirmId int
		set @Code = @FirmCd

		exec @ReturnValue= [ib_Firm_AddAsNeeded] @DataSourceId,@Code,@OutPut output	
		set @FirmId = @OutPut

		set @Output = null
		set	@OutPut2 = null
		declare @AccountId int
		set @Code = @AccountCd
		
		DECLARE @IsImported BIT
		SET @IsImported = NULL
		
		exec @ReturnValue= [ib_Account_AddAsNeeded] @Code,@FirmId,@OutPut output,@OutPut2 output, @IsImported = @IsImported OUTPUT	
		set @AccountId = @OutPut
	
		IF (@IsImported = 1)
		BEGIN
			if @ClassId is null 
					set @ClassId = @OutPut2
	
			set @Output = null
			declare @CurrencyId int
	
			if @CurrencyCd is not Null
			begin
				exec @ReturnValue = [ib_Currency_AddAsNeeded] @DataSourceId, @CurrencyCd, @Output output
				set @CurrencyId = @Output
			end
	
			set @Output2 = null
			set @Output = null
			declare @InstrumentId int
			set @Code = @InstrumentCd
			exec @ReturnValue= [ib_Instrument_AddAsNeeded] @DataSourceId,@InstrumentTypeId,@Code,@CurrencyId,@OutPut output,@OutPut2 output	
			set @InstrumentId = @OutPut
			if @CurrencyId is null
			begin
				if @Output2 is null
					set @CurrencyId = @DefaultCurrencyId	
				else
					set @CurrencyId = @Output2
			end

			--now inserting into the ib_Position table.

			set @Output = null
			exec @ReturnValue=ib_Position_Add @DataSourceId,@ExchangeId,@FirmId,@AccountId,@AsOfDate,@InstrumentId,@Quantity,@CurrencyId,@MarketValue,@ExpYr,@ExpMth,@ExpDay,@StrikePrice,@TrxTypeCd,@OptionTypeCd,@TempTableRecordId,@OutPut output, @LongQuantity , @ShortQuantity, @TradedLongQuantity,	@TradedShortQuantity,   @ClassId, @UseNetForCloseOut, @UTI
			set @PositionId=@OutPut	
		
		END -- IF @IsImported = 1
	end
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_ImportFile_Add]''
');

GO
EXECUTE ('-- =============================================
-- Author:		Lee Manifold
-- Create date: 12 Dec 2006
-- Description:	Inserts a record into the ib_ImportFile table and
--				returns the pk of the table.
-- History:
-- 22 Apr 2010	Return ImportFileId as output parameter and add DataSourceId
-- =============================================
CREATE PROCEDURE [dbo].[ib_ImportFile_Add]
	(
	@DataSourceId	INT
	, @FileName		varchar(255)
	, @ImportFileId    INT output

	)
AS
SET NOCOUNT ON

	BEGIN TRY
		INSERT INTO [dbo].[ib_ImportFile]
				   (
				    [DataSourceId]
					, [FileName]
					)
			 VALUES
				   (
				   @DataSourceId
					, @FileName
					)
		
		SELECT @ImportFileId = scope_identity()
			
	END TRY
	BEGIN CATCH
		EXEC [dbo].[sp_RethrowError]
	END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_GMI_GetDataSource]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_GMI_GetDataSource]
	(
		@FilePath VARCHAR(100),
		@DataSourceCd VARCHAR(50) OUTPUT
	)
AS
-- Description:	Pulls back a datasource code from a filename parameter for gmi
--
-- 07 Nov 2006	LM		Creation
-- 07 Dec 2006	LM		Changed Asiafut to Asafut	
-- 11 Mar 2010	AAJM	Added Citibank and ADM
-- 04 Jan 2011	amk		MBAL-17213: new ADM2 data source
-- 06 Apr 2011	AAJM	Add new Credit Suisse data source
-- 22 Jun 2011	AAJM	Add new CSNA (Credit Suisse New York) data source

	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
	SET @DataSourceCd =			
		CASE 		
			WHEN UPPER(@FilePath) LIKE (''%ASAFUT%'') THEN		
				''Asafut''
			WHEN UPPER(@FilePath) LIKE (''%USAFUT%'') THEN
				''USAfut''
			WHEN UPPER(@FilePath) LIKE (''%EURFUT%'') THEN
				''Eurfut''
			WHEN UPPER(@FilePath) LIKE (''%AUSFUT%'') THEN
				''Ausfut''
			WHEN UPPER(@FilePath) LIKE (''%CITIBANK%'') THEN
				''Citibank''
			WHEN UPPER(@FilePath) LIKE (''%ADM2%'') THEN
				''ADM2''
			WHEN UPPER(@FilePath) LIKE (''%ADM%'') THEN
				''ADM''
			WHEN UPPER(@FilePath) LIKE (''%CSA%'') THEN
				''CSA''
			WHEN UPPER(@FilePath) LIKE (''%CSNA%'') THEN
				''CSNA''
			WHEN UPPER(@FilePath) LIKE (''%MNA%'') THEN
				''GMI MNA''
			ELSE
				''Not Found''
		END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[HasFileBeenLoaded]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[HasFileBeenLoaded] 
	@FileName VARCHAR(512),
    @DataSourceId INT
AS
SET NOCOUNT ON
BEGIN
	--	04 Nov 2009		amk		Creation
	--	21 May 2010		amk		MBAL-15566: don''t lock importlog table to prevent deadlocks
	--	09 Jan 2014		ED		EIB 25004 - remove importLog table and use Log table

	DECLARE @FileAlreadyLoaded BIT
	SET @FileAlreadyLoaded = 0
	
	--if we have a complete run for it
	IF EXISTS(SELECT TOP 1 LogStatusSysId FROM Log l (NOLOCK)
				INNER JOIN ReceiveLocation rl ON rl.ReceiveLocationSysId = l.ReceiveLocationSysId
				WHERE 
				    [FileName] = @FileName 
					AND rl.DataSourceId = @DataSourceId
					AND YEAR(l.CreateDateTimeUtc) = YEAR(GETDATE())
					AND IsComplete = 1
					)
	BEGIN
		SET @FileAlreadyLoaded = 1
	END

	RETURN @FileAlreadyLoaded 

END
');

GO
EXECUTE ('PRINT N''Creating [stage].[RosenthalCollinsPosition_Load]''
');

GO
EXECUTE ('CREATE PROCEDURE [stage].[RosenthalCollinsPosition_Load]
	(
		@LocationPath VARCHAR(100)
		,@ReceiveLocationSysId INT
		,@RunId INT
	)
AS
SET NOCOUNT ON

-- Description:	This stored procedure pulls data from the RosenthalCollinsPosition staging
-- table and inserts it into ib_Position
-- Whilst iterating through the records in RosenthalCollinsPosition, all 
-- of these inserts are wrapped in a transaction so that any failure causes
-- the changes to not commit.

-- 16 Jan 2019	KIR	Creation based on ib credit suisse load (IBAL12)
BEGIN

	DECLARE @Message			VARCHAR(1024)
	DECLARE @AddCount			INT
	SET @AddCount = 0
					
	DECLARE @DataSourceCode VARCHAR(100)

	--Set the Datasource	
	EXEC [ib_GMI_GetDataSource] @LocationPath, @DataSourceCode OUTPUT

	DECLARE @Output INT
	DECLARE @Output2 INT
	DECLARE @ReturnValue INT
	DECLARE @DataSourceId INT

	IF @LocationPath IS NULL SET @LocationPath = @DataSourceCode
	EXEC @ReturnValue= [_ib_DataSource_GetByCodeForOutput] @DataSourceCode, @OutPut output, @Output2 output
	SET @DataSourceId = @Output

	-- Duplicate file check										
	DECLARE @IsFileAlreadyLoaded INT
	EXEC @IsFileALreadyLoaded = HasFileBeenLoaded @LocationPath, @DataSourceId

	IF @IsFileAlreadyLoaded = 1
	BEGIN
		UPDATE [RosenthalCollinsPosition]
		SET LoadState = 3
		WHERE LoadState = 1
			AND FileName = @LocationPath		
		RETURN
	END
	
	-- Set AsOfDate from Filename
	DECLARE @AsOfDate DATETIME
	EXEC [dbo].[TryParseYYYYMMDDFromEndOfFilename] @LocationPath, @AsOfDate OUTPUT
	
	--rd - make sure the As Of Date is not older than acceptable
	DECLARE @IsAcceptable bit
	EXECUTE [dbo].[Load_IsFileTooOld] @DataSourceId,@LocationPath,@AsOfDate,@IsAcceptable OUTPUT, @ReceiveLocationSysId, @RunId
	IF (@IsAcceptable = 0)
	BEGIN
		UPDATE [RosenthalCollinsPosition] SET [LoadState] = 3 WHERE [Filename] = @LocationPath
		RAISERROR (''File is too old.'', 18, 0)
		RETURN 0
	END

	-- Store ImportFile record to be associated with Settlement Price load
	DECLARE @ImportFileId INT
	EXEC ib_ImportFile_Add @DataSourceId, @LocationPath, @ImportFileId output
	
	--Gets the defaultStrikePriceDivisor
	DECLARE	@DefaultStrikePriceDivisor	DECIMAL(19,6)
	SET @DefaultStrikePriceDivisor = [dbo].[udf_GetDefaultStrikePriceDivisor](@DataSourceId, NULL)
	
	IF OBJECT_ID(''tempdb..#tempRCGP'') IS NOT NULL 
		DROP TABLE #tempRCGP
		
	CREATE TABLE #tempRCGP
	(
		RosenthalCollinsPositionId		INT
		, FirmCode					VARCHAR(1)
		, Account					VARCHAR(5)
		, Currency					VARCHAR(3)
		, AsOfDateChr				VARCHAR(9)
		, Exchange					VARCHAR(2)
		, SubExchange				VARCHAR(1)
		, Instrument_Code			VARCHAR(2)
		, QuantityChr				VARCHAR(15)
		, BuySell					VARCHAR(1)
		, MarketValueChr			VARCHAR(15)
		, ContractYearMonth			VARCHAR(6)
		, ContractDay				VARCHAR(2)
		, StrikePriceChr			VARCHAR(15)
		, TrxTypeCode				VARCHAR(1)
		, OptionTypeCode			VARCHAR(1)
		, SettlementPriceChr		VARCHAR(15)
		, InstrumentType			VARCHAR(1)
	)

	INSERT INTO #tempRCGP
	(
		RosenthalCollinsPositionId
		, FirmCode
		, Account
		, Currency
		, AsOfDateChr
		, Exchange
		, SubExchange
		, Instrument_Code
		, QuantityChr
		, BuySell
		, MarketValueChr
		, ContractYearMonth
		, ContractDay
		, StrikePriceChr
		, TrxTypeCode
		, OptionTypeCode
		, SettlementPriceChr
		, InstrumentType
	)
	SELECT 	
		[RosenthalCollinsPositionID]
		, [PFIRM]
		, LTRIM(RTRIM([PACCT]))
		, LTRIM(RTRIM([PCURSY]))
		, [PPRCDT]
		, LTRIM(RTRIM([PEXCH]))
		, LTRIM(RTRIM([PSUBEX]))
		, LTRIM(RTRIM([PFC]))
		, [PQTY]
		, [PBS]
		, [PMKVAL]
		, [PCTYM]
		, [PSBCUS]
		, [PSTRIK]
		, [PRECID]
		, [PSUBTY]
		, [PCLOSE]
		, [PSUBTY]
	FROM [stage].[RosenthalCollinsPosition]
	WHERE LoadState = 1
		AND [Filename] = @LocationPath
		AND [PRECID]=''P'' -- Only Positions

	SET XACT_ABORT ON 

	BEGIN TRAN T1

		-- BizTalk''s SQL Adapter uses more restrictive read serializable
		-- so this is necessary to relax it to something that is default
		-- and perfectly acceptable!
		SET TRANSACTION ISOLATION LEVEL READ COMMITTED

		BEGIN TRY
		
			DECLARE @RosenthalCollinsPositionID	INT
			DECLARE @FirmCode					VARCHAR(1)
			DECLARE @Account					VARCHAR(5)
			DECLARE @Currency					VARCHAR(3)
			DECLARE @AsOfDateChr				VARCHAR(9)
			DECLARE @ExchangeCode				VARCHAR(2)
			DECLARE @SubExchangeCode			VARCHAR(1)
			DECLARE @InstrumentCode				VARCHAR(2)
			DECLARE @QuantityChr				VARCHAR(15)
			DECLARE @BuySell					VARCHAR(1)
			DECLARE @MarketValueChr				VARCHAR(15)
			DECLARE @ContractYearMonth			VARCHAR(6)
			DECLARE @ContractDay				VARCHAR(2)
			DECLARE @StrikePriceChr				VARCHAR(15)
			DECLARE @TrxTypeCode				VARCHAR(1)
			DECLARE @OptionTypeCode				VARCHAR(1)
			DECLARE @SettlementPriceChr			VARCHAR(15)
			DECLARE @InstrumentType				VARCHAR(1)

			DECLARE pos_cursor CURSOR FOR
			SELECT	RosenthalCollinsPositionId
				    , FirmCode
					, Account
					, Currency
					, AsOfDateChr
					, Exchange
					, SubExchange
					, Instrument_Code
					, QuantityChr
					, BuySell
					, MarketValueChr
					, ContractYearMonth
					, ContractDay
					, StrikePriceChr
					, TrxTypeCode
					, OptionTypeCode
					, SettlementPriceChr
					, InstrumentType
			FROM	#tempRCGP

			OPEN pos_cursor

			FETCH NEXT FROM pos_cursor
			INTO 
					@RosenthalCollinsPositionID
					, @FirmCode
					, @Account
					, @Currency
					, @AsOfDateChr
					, @ExchangeCode
					, @SubExchangeCode
					, @InstrumentCode
					, @QuantityChr
					, @BuySell
					, @MarketValueChr
					, @ContractYearMonth
					, @ContractDay
					, @StrikePriceChr
					, @TrxTypeCode
					, @OptionTypeCode
					, @SettlementPriceChr
					, @InstrumentType

				-- Check @@FETCH_STATUS to see IF there are any more rows to fetch.
				WHILE @@FETCH_STATUS = 0
				BEGIN
					DECLARE		@AccountCd				VARCHAR(100)
					DECLARE		@ExchangeCd				VARCHAR(25)
					DECLARE		@AsOfDateFromRecord		DATETIME
					DECLARE		@InstrumentCd			VARCHAR(100)
					DECLARE		@Quantity				DECIMAL(19,4)
					DECLARE		@MarketValueDec			DECIMAL(19,4)
					DECLARE		@ExpYr					SMALLINT
					DECLARE		@ExpMth					SMALLINT
					DECLARE		@ExpDay					SMALLINT
					DECLARE		@StrikePrice			DECIMAL(19,4)
					DECLARE		@PriceDivisor			DECIMAL(19,4)
					DECLARE		@StrikePriceDivisor		DECIMAL(19,4)
					DECLARE		@MarketValueDivisor		DECIMAL(19,4)
					DECLARE		@SettlementPrice		DECIMAL(24,10)
					DECLARE		@TrxTypeCd				VARCHAR(25)
					DECLARE		@TrxDate				DATETIME
					DECLARE		@InstrumentTypeCd		VARCHAR(100)
					DECLARE     @ErrorMessageForRecord	VARCHAR(1024)
					DECLARE		@ErrorSeverity			INT
					DECLARE		@ErrorState				INT
					DECLARE		@QuantityLong			DECIMAL(19,4)
					DECLARE		@QuantityShort			DECIMAL(19,4)
					DECLARE		@SignedQuantity			DECIMAL(19,4)
					
					-- Temporary variables
                    DECLARE     @TempDate DATETIME
					DECLARE 	@Code VARCHAR(100), @Code2 VARCHAR(100)
					
			SET @AccountCd = @Account
			SET	@ExchangeCd = @ExchangeCode + ISNULL(@SubExchangeCode, '''')
		
			-- Set ExpiryDate
			SET @ExpYr = LEFT(@ContractYearMonth, 4)
			SET @ExpMth = RIGHT(@ContractYearMonth, 2)
			
			SET @ContractDay = LTRIM(RTRIM(@ContractDay))
			
			IF NULLIF(@ContractDay,'''') IS NULL OR @ContractDay = ''0''
				BEGIN
					-- Get the last day of the month
					SET @ExpDay = dbo.udf_OnLoad_ExpiryDate_Get_Day(@ExpYr,@ExpMth,@ContractDay)
				END
			ELSE
				SET @ExpDay = CAST(@ContractDay AS SMALLINT)
		
			-- Set InstrumentTypeCd
			IF @InstrumentType IN (''P'', ''C'')
				SET @InstrumentTypeCd = ''O''
			ELSE -- It will be blank
				SET @InstrumentTypeCd = ''F''
			
			-- We prefix the Instruments with the IntrumentTypeCode
			SET @InstrumentCd = @InstrumentTypeCd + ''_'' + @ExchangeCd + ''_'' + @InstrumentCode

			-- Get Divisors						
			SET @StrikePriceDivisor = NULL
			SET	@PriceDivisor = NULL
			SET	@MarketValueDivisor = NULL
								
			SELECT @StrikePriceDivisor = ids.StrikePriceDivisor
					, @PriceDivisor = ids.PriceDivisor
					, @MarketValueDivisor = ids.MarketValueDivisor
			FROM [dbo].[ib_InstrumentDataSource] ids
			WHERE ids.DataSourceId = @DataSourceId
				AND ids.DataSourceInstrumentCode = @InstrumentCd
					
			-- Set Settlement Price				
			IF @PriceDivisor IS NULL 
				SET @PriceDivisor = 1				

			SET @SettlementPrice = CONVERT(DECIMAL(24,10), @SettlementPriceChr) / @PriceDivisor
			
			-- Set StrikePrice
			SET @StrikePrice = NULL
			
			IF @StrikePriceDivisor IS NULL
				BEGIN
					SET @StrikePrice = CAST(@StrikePriceChr AS DECIMAL(19,4)) / ISNULL(@DefaultStrikePriceDivisor, 1)
				END
			ELSE
				BEGIN
					SET @StrikePrice = CAST(@StrikePriceChr AS DECIMAL(19,4)) / @StrikePriceDivisor
				END			
			
			-- Set TrxTypeCd
			SET @TrxTypeCd = ''POSITION''
						
			-- Set Quantity 
			SET @Quantity = 0
			SET @QuantityLong = 0
			SET @QuantityShort = 0
			
			SET @Quantity = CONVERT(DECIMAL(19,4), @QuantityChr)
			
			SET @SignedQuantity = @Quantity
							
			-- Set QuantityLong
			IF (@BuySell = ''1'')
				BEGIN
					SET @QuantityLong = @Quantity
				END
			ELSE
					SET @QuantityLong = 0
								
			-- Set QuantityShort
			IF (@BuySell = ''2'')
				BEGIN
					SET @QuantityShort = @Quantity
					SET @SignedQuantity = @Quantity * (-1)
				END	
			ELSE
				SET @QuantityShort = 0
				
				
			-- Set Market Value
			IF @MarketValueDivisor IS NULL 
				SET @MarketValueDivisor = 1
			
			SET @MarketValueDec = CONVERT(DECIMAL(19,4), @MarketValueChr) / @MarketValueDivisor

			-- TrxDate
			SET @TrxDate = GETDATE()  -- This is not actually used

			SET @AsOfDateFromRecord = CONVERT(DATETIME, @AsOfDateChr, 112)
			
			-- Now check that the file AsOfDate matches that of the record
			
			IF (@AsOfDateFromRecord IS NULL OR @AsOfDate <> [dbo].[udf_GetDatePart](@AsOfDateFromRecord))
				BEGIN
				
					SET @ErrorMessageForRecord = ''AsOfDate on Position record does not match AsOfDate from Filename''
					EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @ErrorMessageForRecord, ''Success'', @RosenthalCollinsPositionID, @RunId
				END
			
			DECLARE @PositionId INT
			SET @PositionId = NULL
			
			EXEC [ib_Position_Load]
			@DataSourceCode			
			, @ExchangeCd
			, @FirmCode -- Firm will be added if not present					
			, @AccountCd				
			, @AsOfDate				
			, @InstrumentCd			
			, @SignedQuantity			
			, @MarketValueDec			
			, @ExpYr					
			, @ExpMth					
			, @ExpDay	
			, @StrikePrice			
			, @TrxTypeCd				
			, @OptionTypeCode	
			, @TrxDate 			
			, @SettlementPrice -- This value is NOT actually used in the ib_Position_Load Stored Procedure, should be removed ?			
			, @RosenthalCollinsPositionID
			, @InstrumentTypeCd		
			, @LocationPath
			, @Currency
			, @LongQuantity = @QuantityLong
			, @ShortQuantity = @QuantityShort
			, @PositionId = @PositionId output
			, @ReceiveLocationSysId = @ReceiveLocationSysId
			, @RunId = @RunId
			
			-- Add Settlement Price											
			EXEC ib_Price_AddFromPositionLoad
				@PositionId
				, @ImportFileId
				, @SettlementPrice 	
				
			--flip processed flag in source table.
			UPDATE [RosenthalCollinsPosition] 
			WITH (ROWLOCK)
			SET [LoadState] = 2
			WHERE [RosenthalCollinsPositionID] = @RosenthalCollinsPositionID 
				AND [LoadState] = 1
				
			SET @AddCount = @AddCount + 1

			FETCH NEXT FROM pos_cursor
			INTO 
					@RosenthalCollinsPositionID
					, @FirmCode
					, @Account
					, @Currency
					, @AsOfDateChr
					, @ExchangeCode
					, @SubExchangeCode
					, @InstrumentCode
					, @QuantityChr
					, @BuySell
					, @MarketValueChr
					, @ContractYearMonth
					, @ContractDay
					, @StrikePriceChr
					, @TrxTypeCode
					, @OptionTypeCode
					, @SettlementPriceChr
					, @InstrumentType
		END
			
			CLOSE pos_cursor
			DEALLOCATE pos_cursor

			SET @Message = @DataSourceCode + '' position loader ended ('' 
				+ CONVERT(VARCHAR(10), @AddCount) + '' added)'' 
		
			EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @Message, ''Success'', '''', @RunId
			
			UPDATE ib_ImportFile
			SET AsOfDate = @AsOfDate
			WHERE ImportFileId = @ImportFileId
			
		COMMIT TRAN T1

	DROP TABLE #tempRCGP
	
	END TRY
	BEGIN CATCH 

		IF XACT_STATE() = -1 
			ROLLBACK TRANSACTION
	
		SET @Message = @DataSourceCode + '' position loader failed'' 		
		
		EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @Message, ''Error'', '''', @RunId
		
		EXEC [dbo].[sp_RethrowError]
		
	END CATCH 

	SET XACT_ABORT OFF
	
END

RETURN 0
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_CashReport_CreateReportRecord]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_CashReport_CreateReportRecord]
	@TodaysDate DATETIME,
	@ProduceExportFile BIT = 0,
	@Username VARCHAR(100)
AS
SET NOCOUNT ON
BEGIN

INSERT INTO [dbo].[ib_CashReport] (TodaysDate, [ProducedExportFiles],[CreateUsername])
VALUES (@TodaysDate, @ProduceExportFile, @Username)

SELECT SCOPE_IDENTITY()

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Broker_Delete]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Broker_Delete]
@BrokerId int
AS
SET NOCOUNT ON

BEGIN TRY
DELETE FROM ib_Broker
	WHERE BrokerId =  @BrokerId
END TRY
BEGIN CATCH
	EXEC [dbo].[sp_RethrowError] ''Broker is currently in use!''	
END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[aspnet_UsersInRoles_GetRolesForUser]''
');

GO
SET QUOTED_IDENTIFIER OFF

GO
EXECUTE ('
CREATE PROCEDURE [dbo].[aspnet_UsersInRoles_GetRolesForUser]
    @ApplicationName  nvarchar(256),
    @UserName         nvarchar(256)
AS
SET NOCOUNT ON
BEGIN
    DECLARE @ApplicationId uniqueidentifier
    SELECT  @ApplicationId = NULL
    SELECT  @ApplicationId = ApplicationId FROM aspnet_Applications WHERE LOWER(@ApplicationName) = LoweredApplicationName
    IF (@ApplicationId IS NULL)
        RETURN(1)
    DECLARE @UserId uniqueidentifier
    SELECT  @UserId = NULL

    SELECT  @UserId = UserId
    FROM    dbo.aspnet_Users
    WHERE   LoweredUserName = LOWER(@UserName) AND ApplicationId = @ApplicationId

    IF (@UserId IS NULL)
        RETURN(1)

    SELECT r.RoleName
    FROM   dbo.aspnet_Roles r, dbo.aspnet_UsersInRoles ur
    WHERE  r.RoleId = ur.RoleId AND r.ApplicationId = @ApplicationId AND ur.UserId = @UserId
    ORDER BY r.RoleName
    RETURN (0)
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[is_GReceiptPaymentDetails]''
');

GO
SET QUOTED_IDENTIFIER ON

GO
EXECUTE ('CREATE TABLE [dbo].[is_GReceiptPaymentDetails]
(
[GReceiptPaymentDetailsId] [int] NOT NULL IDENTITY(1, 1),
[CorporationCode] [varchar] (4) NULL,
[PrincipalBrokerageId] [varchar] (1) NULL,
[OfficeCode] [varchar] (4) NULL,
[ACNo] [varchar] (10) NULL,
[RecordId] [varchar] (2) NULL,
[BaseDate] [datetime] NULL,
[CalculationDate] [datetime] NULL,
[CalculationStartTime] [datetime] NULL,
[CalculationDateStartTime] [datetime] NULL,
[MarginId] [varchar] (2) NULL,
[Currency] [varchar] (3) NULL,
[PostingDate] [datetime] NULL,
[ReceiptPaymentNo] [varchar] (5) NULL,
[ReceiptPaymentType] [varchar] (1) NULL,
[ReceiptPaymentId] [varchar] (1) NULL,
[CancellationId] [varchar] (1) NULL,
[MovementAmount] [decimal] (15, 0) NULL,
[InputDate] [datetime] NULL,
[InternalBankCode] [varchar] (3) NULL,
[CheckNo] [varchar] (6) NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_is_GReceiptPaymentDetails_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NULL CONSTRAINT [DF_GReceiptPaymentDetails_CreationDate] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_GReceiptPaymentDetails] on [dbo].[is_GReceiptPaymentDetails]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[is_GReceiptPaymentDetails] ADD CONSTRAINT [PK_GReceiptPaymentDetails] PRIMARY KEY CLUSTERED  ([GReceiptPaymentDetailsId])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[is_GReceiptPaymentDetails_Add]''
');

GO
EXECUTE ('

/*
<Details>
<Summary>Inserts an item into the GReceiptPaymentDetails table</Summary>
<Created author="laurentiu.macovei" date="04/05/2006 16:33:05" />
</Details>
*/
CREATE PROCEDURE [dbo].[is_GReceiptPaymentDetails_Add]
	@CorporationCode varchar(4) = NULL,
	@PrincipalBrokerageId varchar(1) = NULL,
	@OfficeCode varchar(4) = NULL,
	@ACNo varchar(10) = NULL,
	@RecordId varchar(2) = NULL,
	@BaseDate datetime = NULL,
	@CalculationDate datetime = NULL,
	@CalculationStartTime datetime = NULL,
	@MarginId varchar(2) = NULL,
	@Currency varchar(3) = NULL,
	@PostingDate datetime = NULL,
	@ReceiptPaymentNo varchar(5) = NULL,
	@ReceiptPaymentType varchar(1) = NULL,
	@ReceiptPaymentId varchar(1) = NULL,
	@CancellationId varchar(1) = NULL,
	@MovementAmount decimal(15,0) = NULL,
	@InputDate datetime = NULL,
	@InternalBankCode varchar(3) = NULL,
	@CheckNo varchar(6) = NULL
AS
SET NOCOUNT ON

SET NOCOUNT OFF

	DECLARE	@CalculationDateStartTime DATETIME

	IF @BaseDate = ''01/01/1900 00:00:00'' 
		SET @BaseDate = NULL

	IF @CalculationDate = ''01/01/1900 00:00:00'' 
		SET @CalculationDate = NULL

	IF @CalculationStartTime = ''01/01/1900 00:00:00'' 
		SET @CalculationStartTime = NULL

	IF @PostingDate = ''01/01/1900 00:00:00'' 
		SET @PostingDate = NULL

	IF @InputDate = ''01/01/1900 00:00:00'' 
		SET @InputDate = NULL

	SET @CalculationDateStartTime = CONVERT(DATETIME,CONVERT(VARCHAR(12), CONVERT(DATETIME,@CalculationDate,112)) + '' '' + CONVERT(VARCHAR(8),RIGHT(@CalculationStartTime,8)))

	INSERT INTO is_GReceiptPaymentDetails 
		(
			[CorporationCode], 
			[PrincipalBrokerageId], 
			[OfficeCode], 
			[ACNo], 
			[RecordId], 
			[BaseDate], 
			[CalculationDate], 
			[CalculationStartTime],
			[CalculationDateStartTime], 
			[MarginId], 
			[Currency], 
			[PostingDate], 
			[ReceiptPaymentNo], 
			[ReceiptPaymentType], 
			[ReceiptPaymentId], 
			[CancellationId], 
			[MovementAmount], 
			[InputDate], 
			[InternalBankCode], 
			[CheckNo]
		) 
					
	VALUES
		(
			@CorporationCode, 
			@PrincipalBrokerageId, 
			@OfficeCode, 
			@ACNo, 
			@RecordId, 
			@BaseDate, 
			@CalculationDate, 
			@CalculationStartTime,
			@CalculationDateStartTime, 
			@MarginId, 
			@Currency, 
			@PostingDate, 
			@ReceiptPaymentNo, 
			@ReceiptPaymentType, 
			@ReceiptPaymentId, 
			@CancellationId, 
			@MovementAmount, 
			@InputDate, 
			@InternalBankCode, 
			@CheckNo
		);

Return Scope_Identity()
');

GO
EXECUTE ('PRINT N''Creating [dbo].[vw_aspnet_Profiles]''
');

GO
SET QUOTED_IDENTIFIER OFF

GO
EXECUTE ('
  CREATE VIEW [dbo].[vw_aspnet_Profiles]
  AS SELECT [dbo].[aspnet_Profile].[UserId], [dbo].[aspnet_Profile].[LastUpdatedDate],
      [DataSize]=  DATALENGTH([dbo].[aspnet_Profile].[PropertyNames])
                 + DATALENGTH([dbo].[aspnet_Profile].[PropertyValuesString])
                 + DATALENGTH([dbo].[aspnet_Profile].[PropertyValuesBinary])
  FROM [dbo].[aspnet_Profile]
  
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Rule_Delete]''
');

GO
SET QUOTED_IDENTIFIER ON

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Rule_Delete]
(
	@RuleId int 
)
AS
SET NOCOUNT ON

-- hard delete, is obsolete after issue 19110
/*
	DELETE FROM ib_RuleMatchCode WHERE RuleId = @RuleId
	DELETE FROM ib_RuleCondition WHERE RuleId = @RuleId
	DELETE FROM [dbo].[ib_Rule] WHERE RuleId = @RuleId
*/
	DECLARE @Name NVARCHAR(250)
	
	SELECT @Name = Name 
	FROM ib_Rule
	WHERE RuleId = @RuleId

	DECLARE @obsoleteSuffix NVARCHAR(100)
	
	SET @obsoleteSuffix = '' (obsolete ''+CONVERT(NVARCHAR(50),GETDATE(), 113)+'')'';

	UPDATE 
		ib_Rule
	SET 
		Name = LEFT (Name, 100 - len(@obsoleteSuffix)) + @obsoleteSuffix
		, IsActive = 0
	WHERE 
		RuleId = @RuleId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Instrument_GetInstrumentIdByName]''
');

GO
EXECUTE ('


/*
<details>
	<summary>Returns the instrument name for a specific instrumentId</summary>
	<created author="Laurentiu Macovei" Date="Thursday, 31 august 2006, 13:00PM GMT" />	
	<updated author="Emilian Damian" Date = "8 Feb 2007">
	added code to return part
    </updated>
</details>
*/
CREATE PROCEDURE [dbo].[ib_Instrument_GetInstrumentIdByName]
@InstrumentName varchar(100)
AS
SET NOCOUNT ON
/*
SELECT InstrumentId 
	FROM ib_Instrument 
	WHERE Name = @InstrumentName
*/
DECLARE @Name nvarchar(1000)
DECLARE @Code nvarchar(1000)
if CHARINDEX(''['',@InstrumentName)>0
BEGIN
SET @Name = SUBSTRING(@InstrumentName,0, CHARINDEX(''['',@InstrumentName)-1)
SET @Code = SUBSTRING(@InstrumentName,CHARINDEX(''['',@InstrumentName)+2, 
			LEN(@InstrumentName)-CHARINDEX(''['',@InstrumentName)-2)
SELECT [InstrumentId]
	FROM ib_Instrument 
	WHERE ltrim(rtrim([Name])) = @Name
	AND ltrim(rtrim([Code])) = @Code
END
ELSE
SELECT [InstrumentId]
	FROM ib_Instrument 
	WHERE [Name] = @InstrumentName
');

GO
EXECUTE ('PRINT N''Creating [stage].[RosenthalCollinsTrade]''
');

GO
EXECUTE ('CREATE TABLE [stage].[RosenthalCollinsTrade]
(
[RosenthalCollinsTradeId] [int] NOT NULL IDENTITY(1, 1),
[PRECID] [varchar] (1) NULL,
[PFIRM] [varchar] (1) NULL,
[POFFIC] [varchar] (3) NULL,
[PACCT] [varchar] (5) NULL,
[PCTYM] [varchar] (6) NULL,
[PSBCUS] [varchar] (2) NULL,
[PSTYPE] [varchar] (2) NULL,
[PSUBTY] [varchar] (1) NULL,
[PSTYP2] [varchar] (1) NULL,
[PSTRIK] [varchar] (15) NULL,
[PEXPDT] [varchar] (9) NULL,
[PSUBAC] [varchar] (10) NULL,
[PTDATE] [varchar] (9) NULL,
[PTPRIC] [varchar] (15) NULL,
[PBS] [varchar] (1) NULL,
[PBROKR] [varchar] (2) NULL,
[PTRACE] [varchar] (10) NULL,
[PICODE] [varchar] (3) NULL,
[PREFNO] [varchar] (12) NULL,
[PCLASS] [varchar] (1) NULL,
[PSUBCL] [varchar] (1) NULL,
[PQTY] [varchar] (15) NULL,
[PPRTQ] [varchar] (15) NULL,
[PSDSC1] [varchar] (30) NULL,
[PMKVAL] [varchar] (15) NULL,
[PSDATE] [varchar] (8) NULL,
[PEXCH] [varchar] (2) NULL,
[PFC] [varchar] (2) NULL,
[PTYPE] [varchar] (1) NULL,
[PSYMBL] [varchar] (6) NULL,
[PSUBEX] [varchar] (1) NULL,
[PPRTPR] [varchar] (11) NULL,
[PCLOSE] [varchar] (15) NULL,
[PPRCDT] [varchar] (9) NULL,
[PPRTCP] [varchar] (11) NULL,
[PPRICE] [varchar] (12) NULL,
[PCURSY] [varchar] (3) NULL,
[PGROSS] [varchar] (15) NULL,
[FileName] [varchar] (512) NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_RosenthalCollins_Transaction_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_RosenthalCollins_Transaction_CreateDate] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_RosenthalCollins_Transaction] on [stage].[RosenthalCollinsTrade]''
');

GO
EXECUTE ('ALTER TABLE [stage].[RosenthalCollinsTrade] ADD CONSTRAINT [PK_RosenthalCollins_Transaction] PRIMARY KEY CLUSTERED  ([RosenthalCollinsTradeId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_RosenthalCollins_LoadState_Filename] on [stage].[RosenthalCollinsTrade]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_RosenthalCollins_LoadState_Filename] ON [stage].[RosenthalCollinsTrade] ([LoadState], [FileName])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[udf_GetMarexFirmId]''
');

GO
EXECUTE ('-- =============================================
-- Author:		Alister McLeod
-- Create date: 20 July 2009
-- Description:	Return the Marex Firm Id from Configuration Settings

-- History
-- 22 Jul 2009	AAJM	Fix logic to get MarexFirmCode
-- =============================================
CREATE FUNCTION [dbo].[udf_GetMarexFirmId]
(
	
)
RETURNS INT
AS
BEGIN
	DECLARE @MarexFirmCode VARCHAR(100)
	
	SELECT	@MarexFirmCode = [Value] 
	FROM	[dbo].[Config]
	WHERE	[Key] = ''MarexFirmCode''

	DECLARE @MarexFirmId INT
	SELECT @MarexFirmId = FirmId FROM dbo.ib_Firm WHERE Code = @MarexFirmCode

RETURN @MarexFirmId

END

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Trx_Add]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Trx_Add]
	(
	@DataSourceId int,
	@ExchangeId int,
	@FirmId int,
	@AccountId int,
	@DetailAccountId int,
	@TrxDate datetime,
	@AsOfDate datetime,
	@InstrumentId int,
	@Quantity decimal(18,10),
	@CurrencyId int,
	@Price decimal(24,10),
	@ExpYr smallint,
	@ExpMth smallint,
	@ExpDay smallint,
	@StrikePrice decimal(19,6),
	@TrxTypeCode varchar(25),
	@OptionTypeCode varchar(25),
	@SourceId int,
	@PositionId int,
	@LocationPath varchar(100)=Null,
	@MarketValue decimal(19,4)=Null,
	@ClassId		int = NULL,
	@TrxId			int = NULL Output,
	@QuantityLong	int = NULL,
	@QuantityShort	int = NULL,
	@UTI		            VARCHAR(100) = NULL
	)
as
SET NOCOUNT ON
/*
	23/04/2010	amk		MBAL-15240: more decimals for price
	05/08/2010	amk		MBAL-16404: bug fix: convert null quantity to zero
	20 Jun 2014	ED	EIB 25759 - add UTI
	08 Dec 2014	ED  EIB 26286 - Change StrikePrice decimals from 4 to 6
*/
	-- remove time part from AsOfDate
	DECLARE @AsOfDateNoTime DATETIME
	SET @AsOfDateNoTime = CAST(CONVERT(CHAR(10), @AsOfDate, 101) AS DATETIME)

	-- check option type code
	SET @OptionTypeCode = RTRIM(LTRIM(@OptionTypeCode))
	IF @OptionTypeCode <> ''P'' AND @OptionTypeCode <> ''C''
		SET @OptionTypeCode = ''''
		
	IF @Quantity IS NULL
		SET @Quantity = 0

	DECLARE @IsUnmatched BIT = 0

	IF @UTI IS NOT NULL AND SUBSTRING(@UTI, 19, 3) = ''TBC''
		SET @IsUnmatched = 1
	
	--IBAL27 - exclude premium up-front options from P&L calculation
	DECLARE @InstrumentTypeCode VARCHAR(1), @DoExcludePremiumUpFrontInTradeRec BIT
	SET @InstrumentTypeCode = (SELECT it.Code FROM ib_Instrument i JOIN ib_InstrumentType it ON i.InstrumentTypeId = it.InstrumentTypeId WHERE i.InstrumentId = @InstrumentId)
	SET @DoExcludePremiumUpFrontInTradeRec = (SELECT DoExcludePremiumUpFrontInTradeRec FROM ib_DataSource WHERE DataSourceId = @DataSourceId)

	IF (@DoExcludePremiumUpFrontInTradeRec = 1 AND @InstrumentTypeCode = ''P'' AND (@TrxTypeCode = ''P'' OR @TrxTypeCode = ''Q''))
		SET @MarketValue = 0

	insert into ib_Trx (DataSourceId,ExchangeId,FirmId,AccountId,DetailAccountId,TrxDate,AsOfDate,InstrumentId,Quantity,CurrencyId,Price,ExpiryYear,ExpiryMonth,ExpiryDay,StrikePrice,TrxTypeCode,OptionTypeCode,TempTableRecordId,RelatedPosition_Id,MarketValue, ClassId, QuantityLong, QuantityShort, UTI, IsUnmatched)
	values(@DataSourceId,@ExchangeId,@FirmId,@AccountId,@DetailAccountId,@TrxDate,@AsOfDateNoTime,@InstrumentId,@Quantity,@CurrencyId,@Price,@ExpYr,@ExpMth,@ExpDay,@StrikePrice,@TrxTypeCode,@OptionTypeCode,@SourceId,@PositionId,@MarketValue, @ClassId, @QuantityLong, @QuantityShort, @UTI, @IsUnmatched)

	select @TrxId = scope_identity()
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Trx_Load]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Trx_Load]

	@DataSourceCd		varchar(100),
	@ExchangeCd			varchar(25),
	@FirmCd				varchar(100),
	@AccountCd			varchar(100),
	@DetailAccountCd	varchar(100) = NULL, 
	@InstrumentCd		varchar(100),
	@ExpYr				smallint,
	@ExpMth				smallint,
	@ExpDay				smallint,
	@StrikePrice		decimal(19,6),
	@TrxTypeCd			varchar(25),
	@OptionTypeCd		varchar(25),
	@Quantity			decimal(19,4),
	@TrxDate			datetime,
	@Price				decimal(24,10),
	@TempTableRecordId	int,
	@InstrumentTypeCd	varchar(25),
	@AsOfDate			datetime,
	@LocationPath		varchar(100) = NULL,
	@MarketValue		decimal(19,4) = NULL,
	@CurrencyCd			varchar(100) = NULL, 
	@ClassId			int = NULL,
	@TrxId				int = NULL	Output,
	@MarexFirmId		int = NULL, 
	@QuantityLong		int = NULL,	
	@QuantityShort		int = NULL,
	@ReceiveLocationSysId   INT,
	@RunId                  INT,
	@UTI		            VARCHAR(100) = NULL
as
SET NOCOUNT ON

/*
Programmer:  Bruce McQuien
Date: 07/07/2006

Purpose:  This stored proc will accept the parameters passed to it from any 
datasource, perform the necessary lookups, and then insert a record in the #
ib_position table, and a record in the ib_trx table.

08 Aug 2006		amk		1) Bug Fix: Firm code should not be just 3; same with instrument code
						2) Bug Fix: Account code should not be just 1!
						3) Bug Fix: Exchange code should not be just 3!
09 Aug 2006		amk		1) New MarketValue parameter
				amk		2) Take in currency code too and process it

09 June 2009    Konrad  Retrieve ClassId in same step as AccountId

16 Jul 2009		AAJM	Added DetailAccountCd to save as DetailAccountId - see MBAL-12454
21 Jul 2009		AAJM	Add MarexFirmId to ensure correct DetailAccountId is obtained
28 Jul 2009		AAJM	Add QuantityLong and QuantityShort - see MBAL-12623
23 Apr 2010		AAJM	MBAL-15416 Increase size of Price field
27 Apr 2010		AAJM	MBAL-15315 Only import if account flag IsImported = true
09 Jan 2014     ED      EIB 25004 - remove importLog table and use Log table
17 Apr 2014		ED      EIB 25498 - log exchange not found as warning
20 Jun 2014		ED		EIB 25759 - add UTI
08 Dec 2014		ED      EIB 26286 - Change StrikePrice decimals from 4 to 6
*/

	declare @ReturnValue int,@OutPut int,@OutPut2 int 
	declare @DataSourceId int
	declare @DefaultCurrencyId int
	declare @Code varchar(100)
	set @Code = @DataSourceCd
	exec @ReturnValue= [_ib_DataSource_GetByCodeForOutput] @Code,@OutPut output,@OutPut2 output	
	set @DataSourceId = @OutPut
	set @DefaultCurrencyId = @Output2		

	set @OutPut = null
	declare @ExchangeId int
	set @Code = @ExchangeCd
	exec @ReturnValue = ib_DataSourceExchange_GetByCode @DataSourceId,@Code,@Output output
	set @ExchangeId = @OutPut

	--if no exchange found then quit here.
	if @ExchangeId is null 
		begin
		declare @now datetime
		declare @user varchar(100)
		declare @logmsg varchar(100)
		set @user = suser_sname()
		set @now = getdate()
		set @logmsg = ''Exchange Code Not Found for ib_Trx_Load run for code: '' + ISNULL(@ExchangeCd,'''')
		EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @logmsg, ''Warning'', @TempTableRecordId, @RunId
		end
	else
		begin
		set @Output = null
		declare @InstrumentTypeId int
		set @Code = @InstrumentTypeCd
		exec @ReturnValue = ib_Instrumenttype_AddAsNeeded @DataSourceId,@Code,@OutPut output
		set @InstrumentTypeId = @OutPut
		set @Output = null
		declare @FirmId int
		set @Code = @FirmCd
		exec @ReturnValue= [ib_Firm_AddAsNeeded] @DataSourceId,@Code,@OutPut output	
		set @FirmId = @OutPut
	
		set @Output = null
		set	@OutPut2 = null
		declare @AccountId int
		set @Code = @AccountCd
		declare @IsImported BIT
		SET @IsImported = null
		
		exec @ReturnValue= [ib_Account_AddAsNeeded] @Code,@FirmId,@OutPut output,@OutPut2 output, @IsImported = @IsImported OUTPUT	
		set @AccountId = @OutPut
        			
		IF (@IsImported = 1)
		BEGIN
		
			if @ClassId is null 
					set @ClassId = @OutPut2

			DECLARE @DetailAccountId INT
			SET @DetailAccountId = NULL
	
			IF (@DetailAccountCd IS NOT NULL)
			BEGIN
				IF (@MarexFirmId IS NULL)
					SET @MarexFirmId = [dbo].[udf_GetMarexFirmId]()
				
				set @Output = null
				set @Code = @DetailAccountCd
				exec @ReturnValue= [ib_Account_AddAsNeeded] @Code,@MarexFirmId,@OutPut output		
				set @DetailAccountId = @OutPut
			END
		
			set @Output = null
			declare @CurrencyId int

			if @CurrencyCd is not Null
			begin
				exec @ReturnValue = [ib_Currency_AddAsNeeded] @DataSourceId, @CurrencyCd, @Output output
				set @CurrencyId = @Output
			end

			set @Output = null
			set @Output2 = null
			declare @InstrumentId int	
			set @Code = @InstrumentCd
			exec @ReturnValue= [ib_Instrument_AddAsNeeded] @DataSourceId,@InstrumentTypeId,@Code,@CurrencyId,@Output output,@Output2 output	
			set @InstrumentId = @Output
			if @CurrencyId is null
			begin
				if @Output2 is null
					set @CurrencyId = @DefaultCurrencyId	
				else
					set @CurrencyId = @Output2
			end

			--now inserting into the ib_Trx table.
			exec ib_Trx_Add @DataSourceId,@ExchangeId,@FirmId,@AccountId,@DetailAccountId,@TrxDate,@AsOfDate,@InstrumentId,@Quantity,@CurrencyId,@Price,@ExpYr,@ExpMth,@ExpDay,@StrikePrice,@TrxTypeCd,@OptionTypeCd,@TempTableRecordId,null, null, @MarketValue, @ClassId, @TrxId Output, @QuantityLong, @QuantityShort, @UTI

		END -- End if IsImported
END
');

GO
EXECUTE ('PRINT N''Creating [stage].[RosenthalCollinsTrade_Load]''
');

GO
EXECUTE ('CREATE PROCEDURE [stage].[RosenthalCollinsTrade_Load] 
	-- Add the parameters for the stored procedure here
	(
		@LocationPath VARCHAR(100)
		,@ReceiveLocationSysId INT
		,@RunId INT
	)
AS
SET NOCOUNT ON

-- Description:	This stored procedure pulls data from the RosenthalCollinsTrade staging
-- table and inserts it into ib_Trx
-- Whilst iterating through the records in RosenthalCollinsTrade, all 
-- of these inserts are wrapped in a transaction so that any failure causes
-- the changes to not commit.

-- 17 Jan 2019	KIR	Creation based on ib credit suisse load (IBAL12)
-- 06 Feb 2019	KIR	Set MarketValue to zero for TrxType P (IBAL25)
-- 07 Feb 2019	KIR	Undo setting MarketValue to zero for TrxType P (IBAL25)

BEGIN

	DECLARE @Message			VARCHAR(1024)
	DECLARE @AddCount			INT
	SET @AddCount = 0
		
	DECLARE @DataSourceCode VARCHAR(100)

	--Set the Datasource	
	EXEC [ib_GMI_GetDataSource] @LocationPath, @DataSourceCode OUTPUT 

	DECLARE @Output INT
	DECLARE @Output2 INT
	DECLARE @ReturnValue INT
	DECLARE @DataSourceId INT

	IF @LocationPath IS NULL SET @LocationPath = @DataSourceCode
	EXEC @ReturnValue = [_ib_DataSource_GetByCodeForOutput] @DataSourceCode, @OutPut output, @Output2 output
	SET @DataSourceId = @Output

	-- Duplicate file check										
	DECLARE @IsFileAlreadyLoaded INT
	EXEC @IsFileALreadyLoaded = HasFileBeenLoaded @LocationPath, @DataSourceId

	IF @IsFileAlreadyLoaded = 1
	BEGIN
		UPDATE [RosenthalCollinsTrade]
		SET LoadState = 3
		WHERE LoadState = 1
			AND FileName = @LocationPath		
		RETURN
	END
	
	-- Set AsOfDate from Filename
	DECLARE @AsOfDate DATETIME
	EXEC [dbo].[TryParseYYYYMMDDFromEndOfFilename] @LocationPath, @AsOfDate OUTPUT
	
	--rd - make sure the As Of Date is not older than acceptable
	DECLARE @IsAcceptable bit
	EXECUTE [dbo].[Load_IsFileTooOld] @DataSourceId,@LocationPath,@AsOfDate,@IsAcceptable OUTPUT, @ReceiveLocationSysId, @RunId
	IF (@IsAcceptable = 0)
	BEGIN
		UPDATE [RosenthalCollinsTrade] SET [LoadState] = 3 WHERE [Filename] = @LocationPath
		RAISERROR (''File is too old.'', 18, 0)
		RETURN 0
	END

	-- Store ImportFile record
	DECLARE @ImportFileId INT
	EXEC ib_ImportFile_Add @DataSourceId, @LocationPath, @ImportFileId output
	
	--Gets the defaultStrikePriceDivisor
	DECLARE	@DefaultStrikePriceDivisor	DECIMAL(19,6)
	SET @DefaultStrikePriceDivisor = [dbo].[udf_GetDefaultStrikePriceDivisor](@DataSourceId, NULL)
	
	IF OBJECT_ID(''tempdb..#tempRCGT'') IS NOT NULL 
	DROP TABLE #tempRCGT
		
	CREATE TABLE #tempRCGT
	(
		RosenthalCollinsTradeID		INT
		, FirmCode					VARCHAR(1)
		, Account					VARCHAR(5)
		, Currency					VARCHAR(3)
		, TrxDateChr				VARCHAR(9)
		, Exchange					VARCHAR(2)
		, SubExchange				VARCHAR(1)
		, Instrument_Code			VARCHAR(2)
		, QuantityChr				VARCHAR(15)
		, BuySell					VARCHAR(1)
		, MarketValueChr			VARCHAR(15)
		, PriceChr					VARCHAR(15)
		, ContractYearMonth			VARCHAR(6)
		, ContractDay				VARCHAR(2)
		, StrikePriceChr			VARCHAR(15)
		, TrxTypeCode				VARCHAR(1)
		, OptionTypeCode			VARCHAR(1)
		, InstrumentType			VARCHAR(1)
	)

	INSERT INTO #tempRCGT
	(
		RosenthalCollinsTradeID
		, FirmCode
		, Account
		, Currency
		, TrxDateChr	
		, Exchange
		, SubExchange
		, Instrument_Code
		, QuantityChr
		, BuySell
		, MarketValueChr
		, PriceChr
		, ContractYearMonth
		, ContractDay
		, StrikePriceChr
		, TrxTypeCode
		, OptionTypeCode
		, InstrumentType
	)
	SELECT 	
		[RosenthalCollinsTradeID]
		, [PFIRM]
		, LTRIM(RTRIM([PACCT]))
		, LTRIM(RTRIM([PCURSY]))
		, [PTDATE]
		, LTRIM(RTRIM([PEXCH]))
		, LTRIM(RTRIM([PSUBEX]))
		, LTRIM(RTRIM([PFC]))
		, [PPRTQ]
		, [PBS]
		, [PGROSS]
		, [PTPRIC]
		, [PCTYM]
		, [PSBCUS]
		, [PSTRIK]
		, [PRECID]
		, [PSUBTY]
		, [PSUBTY]
	FROM [stage].[RosenthalCollinsTrade]
	WHERE LoadState = 1
		AND [Filename] = @LocationPath
		AND [PRECID] IN (''T'',''A'',''B'',''E'',''J'',''L'',''P'',''Q'',''R'',''S'',''U'',''V'',''X'',''Y'',''Z'')
		AND NOT ([PRECID] = ''A'' AND [PPRTPR] = '''')
	SET XACT_ABORT ON 

	BEGIN TRAN T1

		-- BizTalk''s SQL Adapter uses more restrictive read serializable
		-- so this is necessary to relax it to something that is default
		-- and perfectly acceptable!
		SET TRANSACTION ISOLATION LEVEL READ COMMITTED

		BEGIN TRY

			DECLARE @RosenthalCollinsTradeID	INT
			DECLARE @FirmCode					VARCHAR(1)
			DECLARE @Account					VARCHAR(5)
			DECLARE @Currency					VARCHAR(3)
			DECLARE @TrxDateChr					VARCHAR(9)
			DECLARE @ExchangeCode				VARCHAR(2)
			DECLARE @SubExchangeCode			VARCHAR(1)
			DECLARE @InstrumentCode				VARCHAR(2)
			DECLARE @QuantityChr				VARCHAR(15)
			DECLARE @BuySell					VARCHAR(1)
			DECLARE @MarketValueChr				VARCHAR(15)
			DECLARE @PriceChr					VARCHAR(15)
			DECLARE @ContractYearMonth			VARCHAR(6)
			DECLARE @ContractDay				VARCHAR(2)
			DECLARE @StrikePriceChr				VARCHAR(15)
			DECLARE @TrxTypeCode				VARCHAR(1)
			DECLARE @OptionTypeCode				VARCHAR(1)
			DECLARE @InstrumentType				VARCHAR(1)

			DECLARE trx_cursor CURSOR FOR
			SELECT RosenthalCollinsTradeID
					, FirmCode
					, Account
					, Currency
					, TrxDateChr
					, Exchange
					, SubExchange
					, Instrument_Code
					, QuantityChr
					, BuySell
					, MarketValueChr
					, PriceChr
					, ContractYearMonth
					, ContractDay
					, StrikePriceChr
					, TrxTypeCode
					, OptionTypeCode
					, InstrumentType
			FROM #tempRCGT

			OPEN trx_cursor

			FETCH NEXT FROM trx_cursor
			INTO 
					@RosenthalCollinsTradeID
					, @FirmCode
					, @Account
					, @Currency
					, @TrxDateChr
					, @ExchangeCode
					, @SubExchangeCode
					, @InstrumentCode
					, @QuantityChr
					, @BuySell
					, @MarketValueChr
					, @PriceChr
					, @ContractYearMonth
					, @ContractDay
					, @StrikePriceChr
					, @TrxTypeCode
					, @OptionTypeCode
					, @InstrumentType

				-- Check @@FETCH_STATUS to see IF there are any more rows to fetch.
				WHILE @@FETCH_STATUS = 0
				BEGIN
					DECLARE		@AccountCd				VARCHAR(100)
					DECLARE		@ExchangeCd				VARCHAR(25)
					DECLARE		@InstrumentCd			VARCHAR(100)
					DECLARE		@Quantity				DECIMAL(19,4)
					DECLARE		@MarketValueDec			DECIMAL(19,4)
					DECLARE		@ExpYr					SMALLINT
					DECLARE		@ExpMth					SMALLINT
					DECLARE		@ExpDay					SMALLINT
					DECLARE		@StrikePrice			DECIMAL(19,4)
					DECLARE		@PriceDivisor			DECIMAL(19,4)
					DECLARE		@StrikePriceDivisor		DECIMAL(19,4)
					DECLARE		@MarketValueDivisor		DECIMAL(19,4)
					DECLARE		@Price					DECIMAL(24,10)
					DECLARE		@TrxDate				DATETIME
					DECLARE		@InstrumentTypeCd		VARCHAR(100)
					DECLARE     @ErrorMessageForRecord	VARCHAR(1024)
					DECLARE		@ErrorSeverity			INT
					DECLARE		@ErrorState				INT
					DECLARE		@QuantityLong			DECIMAL(19,4)
					DECLARE		@QuantityShort			DECIMAL(19,4)
					DECLARE		@SignedQuantity			DECIMAL(19,4)
					
					-- Temporary variables
                    DECLARE     @TempDate DATETIME
					DECLARE 	@Code VARCHAR(100), @Code2 VARCHAR(100)
					
			SET @AccountCd = @Account
			SET	@ExchangeCd = @ExchangeCode + ISNULL(@SubExchangeCode, '''')
					
			-- Set ExpiryDate
			SET @ExpYr = LEFT(@ContractYearMonth, 4)
			SET @ExpMth = RIGHT(@ContractYearMonth, 2)
			
			SET @ContractDay = LTRIM(RTRIM(@ContractDay))
			
			IF NULLIF(@ContractDay,'''') IS NULL OR @ContractDay = ''0''
				BEGIN
					-- Get the last day of the month
					SET @ExpDay = dbo.udf_OnLoad_ExpiryDate_Get_Day(@ExpYr,@ExpMth,@ContractDay)
				END
			ELSE
				SET @ExpDay = CAST(@ContractDay AS SMALLINT)
				
			-- Set InstrumentTypeCd
			IF @InstrumentType IN (''P'', ''C'')
				SET @InstrumentTypeCd = ''O''
			ELSE -- It will be blank
				SET @InstrumentTypeCd = ''F''
	

			-- We prefix the Instruments with the IntrumentTypeCode
			SET @InstrumentCd = @InstrumentTypeCd + ''_'' + @ExchangeCd + ''_'' + @InstrumentCode

			-- Get Divisors						
			SET @StrikePriceDivisor = NULL
			SET	@PriceDivisor = NULL
			SET	@MarketValueDivisor = NULL
								
			SELECT @StrikePriceDivisor = ids.StrikePriceDivisor
					, @PriceDivisor = ids.PriceDivisor
					, @MarketValueDivisor = ids.MarketValueDivisor
			FROM [dbo].[ib_InstrumentDataSource] ids
			WHERE ids.DataSourceId = @DataSourceId
				AND ids.DataSourceInstrumentCode = @InstrumentCd

			-- Set Price				
			IF @PriceDivisor IS NULL 
				SET @PriceDivisor = 1				

			SET @Price = CONVERT(DECIMAL(24,10), @PriceChr) / @PriceDivisor
			
			-- Adjust Price for other Trx Types
			IF (UPPER(@TrxTypeCode) = ''X'')
				SET @Price = 0
					
			-- Set StrikePrice
			SET @StrikePrice = NULL
			
			IF @StrikePriceDivisor IS NULL
				BEGIN
					SET @StrikePrice = CAST(@StrikePriceChr AS DECIMAL(19,4)) / ISNULL(@DefaultStrikePriceDivisor, 1)
				END
			ELSE
				BEGIN
					SET @StrikePrice = CAST(@StrikePriceChr AS DECIMAL(19,4)) / @StrikePriceDivisor
				END			
				
			-- Set Quantity 
			SET @Quantity = 0
			SET @QuantityLong = 0
			SET @QuantityShort = 0
			
			-- Set Quantity (throw an error if not convertible)
			
			SET @Quantity = CONVERT(DECIMAL(19,4), @QuantityChr)
			
			SET @SignedQuantity = @Quantity
						
			-- Set QuantityLong
			IF (@BuySell = ''1'')
				BEGIN
					SET @QuantityLong = @Quantity
				END
			ELSE
					SET @QuantityLong = 0
								
			-- Set QuantityShort
			IF (@BuySell = ''2'')
				BEGIN
					SET @QuantityShort = @Quantity
					SET @SignedQuantity = @Quantity * (-1)
				END	
			ELSE
				SET @QuantityShort = 0
				
			-- X and E Transactions should have a negative quantity
				IF (UPPER(@TrxTypeCode) = ''X'' OR UPPER(@TrxTypeCode) = ''E'')
				BEGIN
					SET @SignedQuantity = @SignedQuantity * (-1)					
					SET @QuantityLong = @QuantityLong * (-1)
					SET @QuantityShort = @QuantityShort * (-1)
				END
				
			-- Set Market Value
			IF @MarketValueDivisor IS NULL 
				SET @MarketValueDivisor = 1
			
			SET @MarketValueDec = CONVERT(DECIMAL(19,4), @MarketValueChr) / @MarketValueDivisor

			-- TrxDate
			SET @TrxDate = CONVERT(DATETIME, @TrxDateChr, 112)
					
			EXEC [ib_Trx_Load]
				@DataSourceCode			
				, @ExchangeCd				
				, @FirmCode -- Firm will be added if not present					
				, @AccountCd	
				, NULL -- DetailAccountCd		
				, @InstrumentCd			
				, @ExpYr					
				, @ExpMth 					
				, @ExpDay 					
				, @StrikePrice			
				, @TrxTypeCode				
				, @OptionTypeCode
				, @SignedQuantity			
				, @TrxDate				
				, @Price 
				, @RosenthalCollinsTradeID
				, @InstrumentTypeCd
				, @AsOfDate		
				, @LocationPath
				, @MarketValueDec
				, @Currency
				, @QuantityLong = @QuantityLong 
				, @QuantityShort = @QuantityShort
				, @ReceiveLocationSysId = @ReceiveLocationSysId
				, @RunId = @RunId
			
			--flip processed flag in source table.
			UPDATE [RosenthalCollinsTrade]
			WITH (ROWLOCK)
			SET [LoadState] = 2
			WHERE [RosenthalCollinsTradeId] = @RosenthalCollinsTradeID
				AND [LoadState] = 1

			SET @AddCount = @AddCount + 1
			
			FETCH NEXT FROM trx_cursor
			INTO 
					@RosenthalCollinsTradeID
					, @FirmCode
					, @Account
					, @Currency
					, @TrxDateChr
					, @ExchangeCode
					, @SubExchangeCode
					, @InstrumentCode
					, @QuantityChr
					, @BuySell
					, @MarketValueChr
					, @PriceChr
					, @ContractYearMonth
					, @ContractDay
					, @StrikePriceChr
					, @TrxTypeCode
					, @OptionTypeCode
					, @InstrumentType
		END
			
		CLOSE trx_cursor
		DEALLOCATE trx_cursor

			-- Now update state of any left-over temporary transaction records
			-- so there are no ''left-overs''
			UPDATE [RosenthalCollinsTrade]
			WITH (ROWLOCK)
			SET [LoadState] = 2
			WHERE [LoadState] = 1 AND [FileName] = @LocationPath

			SET @Message = @DataSourceCode + '' transaction loader ended ('' 
			+ CONVERT(VARCHAR(10), @AddCount) + '' added)'' 
		
			EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @Message, ''Success'', '''', @RunId

			UPDATE ib_ImportFile
			SET AsOfDate = @AsOfDate
			WHERE ImportFileId = @ImportFileId
			
		COMMIT TRAN T1

		DROP TABLE #tempRCGT
	
	END TRY
	BEGIN CATCH 

		IF XACT_STATE() = -1 
			ROLLBACK TRANSACTION
	
		SET @Message = @DataSourceCode + '' transaction loader failed'' 		
		EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @Message, ''Error'', '''', @RunId
	
		EXEC [dbo].[sp_RethrowError]
		
	END CATCH 

	SET XACT_ABORT OFF

END

RETURN 0
');

GO
EXECUTE ('PRINT N''Creating [dbo].[vw_ib_CashReport_BrokerData]''
');

GO
EXECUTE ('CREATE VIEW [dbo].[vw_ib_CashReport_BrokerData]
	AS 

--	8 Apr 2008	amk		MBAL-15158: need more than just broker data:
--						need to collect corresponding internal data
-- 27 Apr 2010	AAJM	MBAL-15392 Add broker code to Matchcode and include on Cash Report
-- 13 Aug 2010	amk		MBAL-16453 Include cheque adjustments
-- 25 Nov 2010	amk		MBAL-17069 1) good measure to only include brokers that have IsActive flag set
--								   2) when checking match codes in subquery only look at datasources 
--								      that are external on template

SELECT crs.DataSourceId AS DataSourceId
		, ISNULL(b.Code,''-'') AS BrokerName
		, curr.CurrencyId AS CurrencyId
		, curr.[Code] AS CurrencyCode
		, curr.[Description] AS CurrencyName
		, ttc.TemplateTypeClassId AS TemplateTypeClassId
		, ttc.[Code] AS TemplateTypeClassCode
		, mc.MatchCode AS MatchCode
		, ttc.[Name] AS TemplateTypeClassName
		, instrType.[Code] AS InstrumentTypeCode
		, instrType.[Name] AS InstrumentTypeName
		, SUM(crs.[Internal_TOTE]) AS [Internal_TOTE]
		, SUM(crs.[Internal_PandS]) AS [Internal_PandS]
		, SUM(crs.[Internal_AdjOTE]) AS [Internal_AdjOTE]
		, SUM(crs.[Internal_AdjSegNon]) AS [Internal_AdjSegNon]  -- This has no Value YET! We will need to source this from somewhere eventually when we know where to get it from.
		, SUM(crs.[External_TOTE]) AS [External_TOTE]
		, SUM(crs.[External_PandS]) AS [External_PandS]
		, SUM(crs.[External_AdjOTE]) AS [External_AdjOTE]
		, SUM(crs.[External_AdjSegNon]) AS [External_AdjSegNon]  -- This has no Value YET! We will need to source this from somewhere eventually when we know where to get it from.
		, SUM(crs.[Difference]) AS [Difference]
		, crs.CashReportId
		, instrType.InstrumentTypeId
		, mc.MatchCodeId
		, cr.TodaysDate
		-- include cheque adjustments
		, (SELECT SUM(value) 
			FROM ib_Adjustment a
				JOIN ib_AdjustmentHeader h ON h.AdjustmentHeaderId = a.AdjustmentHeaderId
				JOIN ib_AdjustmentType at ON at.AdjustmentTypeId = h.AdjustmentTypeId
				JOIN ib_Instrument i ON i.InstrumentId = a.InstrumentId
				JOIN ib_InstrumentType it ON it.InstrumentTypeId = i.InstrumentTypeId
			WHERE at.Code = ''CQ''
				AND i.InstrumentTypeId = instrType.InstrumentTypeId
				AND a.DataSourceId = crs.DataSourceId
				AND a.CurrencyId = curr.CurrencyId
				AND a.MatchCodeId = mc.MatchCodeId
				AND a.AdjustmentDate = cr.TodaysDate
			) AS cheque_adj
FROM ib_CashReportSummary crs
	INNER JOIN ib_Currency curr ON curr.CurrencyId = crs.CurrencyId
	INNER JOIN ib_InstrumentType instrType ON instrType.InstrumentTypeId = crs.InstrumentTypeId
	INNER JOIN ib_MatchCode mc ON mc.MatchCodeId = crs.MatchCodeId
	LEFT JOIN ib_TemplateTypeClass ttc ON ttc.TemplateTypeClassId = mc.TemplateTypeClassId
	LEFT JOIN ib_Broker b ON mc.BrokerId = b.BrokerId
	INNER JOIN ib_DataSource ds ON ds.DataSourceId = crs.DataSourceId
	INNER JOIN ib_ImbalanceReport ir ON ir.ImbalanceReportId = crs.ImbalanceReportId
	INNER JOIN ib_CashReport cr ON cr.CashReportId = crs.CashReportId
WHERE mc.MatchCodeId IN (
--						first attempt was to get match codes from cash report summary itself
--						where broker is data source.  This can miss some data: it will not
--						get match codes where external side is all zero''s and internal side
--						has figures.  So for that reason must get the match codes from the
--						template itself.  Connection is quite loose (through account and firm)
--						but it seems to work.
						SELECT mc2.matchcodeid
						FROM ib_account a
							JOIN ib_templatecompare tc ON tc.firmid = a.firmid
							JOIN ib_broker b ON b.datasourceid = tc.datasourceid
							JOIN ib_templategroup tg ON tg.accountid = a.accountid AND tg.templateid = tc.templateid
							JOIN ib_matchcode mc2 ON mc2.templateid = tg.templateid AND mc2.matchcode = tg.description
						WHERE tc.templateid = ir.templateid
							AND b.IsActive = 1
							AND tc.InternalExternalCode = ''E''
						)
GROUP BY 
	crs.CashReportId
	, crs.DataSourceId
	, curr.CurrencyId
	, curr.[Code]
	, curr.[Description]
	, ttc.[Code]
	, mc.MatchCode
	, b.Code
	, ttc.TemplateTypeClassId
	, ttc.[Name]
	, instrType.[Code]
	, instrType.[Name]
	, instrType.InstrumentTypeId
	, mc.MatchCodeId
	, cr.TodaysDate
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_CashReport_FileExportForBroker]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_CashReport_FileExportForBroker]
	@CashReportId int 
	, @ReportId int -- Used for updating status
AS
SET NOCOUNT ON
BEGIN

-- 24 Mar 2010		AlisterM	Creation
-- 26 Mar 2010		AlisterM	Implement Select Statement
-- 16 Apr 2010		AlisterM	MBAL-15286 Ensure N/S not Non-Seg/Seg
-- 13 Aug 2010		amk			MBAL-16448 Put F in 4th col & remove second value col (ExternalOTE)
--								MBAL-16453 Include cheque adjustments
-- 31 Aug 2010		amk			MBAL-16553 tweaks to cheque and corrections

SELECT BrokerName AS Broker
	, CurrencyCode AS Currency
	, TemplateTypeClassCode AS AccountType
	, ''F'' AS TradeType -- Trade Type not used
	, [Internal_TOTE] + [Internal_AdjOTE] - [External_AdjOTE] AS AdjustedOTE
	, cheque_adj * -1 AS ChequeAmounts
	, [Internal_AdjOTE] - [External_AdjOTE] - ISNULL(cheque_adj, 0) AS Corrections
	, [Internal_AdjOTE]
	, [External_AdjOTE]
FROM(
	SELECT 
		vwbd.BrokerName,
		vwbd.CurrencyCode,
		vwbd.TemplateTypeClassId,
		vwbd.TemplateTypeClassCode,
		vwbd.TemplateTypeClassName,
		SUM(vwbd.[Internal_TOTE]) AS [Internal_TOTE],
		SUM(vwbd.[Internal_PandS]) AS [Internal_PandS],
		SUM(vwbd.[Internal_AdjOTE]) AS [Internal_AdjOTE],
		SUM(vwbd.[Internal_AdjSegNon]) AS [Internal_AdjSegNon],  -- This has no Value YET! We will need to source this from somewhere eventually when we know where to get it from.
		SUM(vwbd.[External_TOTE]) AS [External_TOTE],
		SUM(vwbd.[External_PandS]) AS [External_PandS],
		SUM(vwbd.[External_AdjOTE]) AS [External_AdjOTE],
		SUM(vwbd.[External_AdjSegNon]) AS [External_AdjSegNon],  -- This has no Value YET! We will need to source this from somewhere eventually when we know where to get it from.
		SUM(vwbd.[Difference]) AS [Difference],
		SUM(vwbd.cheque_adj) AS cheque_adj
	FROM [dbo].[vw_ib_CashReport_BrokerData] vwbd
	WHERE vwbd.CashReportId = @CashReportId AND vwbd.InstrumentTypeCode IN (''F'', ''O'') -- Premium Options are excluded
	GROUP BY 
		vwbd.BrokerName,
		vwbd.CurrencyId,
		vwbd.CurrencyCode,
		vwbd.TemplateTypeClassId,
		vwbd.TemplateTypeClassCode,
		vwbd.TemplateTypeClassName
) tmp2
ORDER BY tmp2.BrokerName, tmp2.CurrencyCode, tmp2.TemplateTypeClassCode

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Broker_Update]''
');

GO
EXECUTE ('
 CREATE PROCEDURE [dbo].[ib_Broker_Update]
(
 @BrokerId INT
,@Code VARCHAR(100)
,@Name VARCHAR(100)
,@UserCode VARCHAR(100)
,@IsActive BIT = 1
,@DataSourceId INT
,@UpdateUsername VARCHAR(50)
)
 AS 
SET NOCOUNT ON

 BEGIN TRY
--check for duplicates 
 
    UPDATE
        [dbo].[ib_Broker]
    SET 
        [Code] = @Code
       ,[Name] = @Name
       ,[UpdateUsername] = @UpdateUsername
       ,[UserCode] = @UserCode
       ,[IsActive] = @IsActive
       ,[DataSourceId] = @DataSourceId
    WHERE
        BrokerId = @BrokerId
 
 END TRY
 BEGIN CATCH
    EXEC [dbo].[sp_RethrowError]
 END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[aspnet_UsersInRoles_GetUsersInRoles]''
');

GO
SET QUOTED_IDENTIFIER OFF

GO
EXECUTE ('
CREATE PROCEDURE [dbo].[aspnet_UsersInRoles_GetUsersInRoles]
    @ApplicationName  nvarchar(256),
    @RoleName         nvarchar(256)
AS
SET NOCOUNT ON
BEGIN
    DECLARE @ApplicationId uniqueidentifier
    SELECT  @ApplicationId = NULL
    SELECT  @ApplicationId = ApplicationId FROM aspnet_Applications WHERE LOWER(@ApplicationName) = LoweredApplicationName
    IF (@ApplicationId IS NULL)
        RETURN(1)
     DECLARE @RoleId uniqueidentifier
     SELECT  @RoleId = NULL

     SELECT  @RoleId = RoleId
     FROM    dbo.aspnet_Roles
     WHERE   LOWER(@RoleName) = LoweredRoleName AND ApplicationId = @ApplicationId

     IF (@RoleId IS NULL)
         RETURN(1)

    SELECT u.UserName
    FROM   dbo.aspnet_Users u, dbo.aspnet_UsersInRoles ur
    WHERE  u.UserId = ur.UserId AND @RoleId = ur.RoleId AND u.ApplicationId = @ApplicationId
    ORDER BY u.UserName
    RETURN(0)
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[is_GTradeDetails]''
');

GO
SET QUOTED_IDENTIFIER ON

GO
EXECUTE ('CREATE TABLE [dbo].[is_GTradeDetails]
(
[GTradeDetailsId] [int] NOT NULL IDENTITY(1, 1),
[CorporationCode] [varchar] (4) NULL,
[PrincipalBrokerageID] [varchar] (1) NULL,
[OfficeCode] [varchar] (4) NULL,
[ACNumber] [varchar] (10) NULL,
[RecordID] [varchar] (2) NULL,
[BaseDate] [datetime] NULL,
[CalculationDate] [datetime] NULL,
[CalculationStartTime] [datetime] NULL,
[CalculationDateStartTime] [datetime] NULL,
[TradeDate] [datetime] NULL,
[ExecutingMarketCode] [varchar] (2) NULL,
[FuturesSubID] [varchar] (3) NULL,
[DerivativesCode] [varchar] (10) NULL,
[CompanyCode] [varchar] (7) NULL,
[SeriesNumber] [varchar] (4) NULL,
[SubCode] [varchar] (2) NULL,
[TradeCode] [varchar] (2) NULL,
[BuySellID] [varchar] (1) NULL,
[CancellationDataID] [varchar] (1) NULL,
[InputDate] [datetime] NULL,
[CancellationInputDate] [datetime] NULL,
[OptionsID] [varchar] (1) NULL,
[SpreadNumber] [varchar] (5) NULL,
[AutomaticExerciseAllotmentID] [varchar] (1) NULL,
[TradeNumber] [varchar] (5) NULL,
[TradeSubNumber] [varchar] (3) NULL,
[ContractMonth] [varchar] (7) NULL,
[StrikePrice] [decimal] (11, 4) NULL,
[Quantity] [int] NULL,
[Price] [decimal] (11, 4) NULL,
[ExecutionAmount] [decimal] (15, 0) NULL,
[Commission] [decimal] (15, 0) NULL,
[ConsumptionTax] [decimal] (15, 0) NULL,
[ExchangeTax] [decimal] (15, 0) NULL,
[NetAmount] [decimal] (15, 0) NULL,
[Remarks1] [varchar] (45) NULL,
[Remarks2] [varchar] (45) NULL,
[LocalCustomerInformation] [varchar] (12) NULL,
[SettlementPrice] [decimal] (15, 0) NULL,
[NumberStockSharesPerOption] [int] NULL,
[FullSeriesNumber] [varchar] (4) NULL,
[OneLotTradeNumber] [varchar] (5) NULL,
[CustomerNameAbbr] [varchar] (35) NULL,
[SecurityNameEnglish] [varchar] (28) NULL,
[SecurityNameKana] [varchar] (24) NULL,
[UnnamedField] [varchar] (1) NULL,
[TransactionDate] [datetime] NULL,
[CostPaymentMethod] [varchar] (1) NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_is_GTradeDetails_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_GTradeDetails_CreateDate] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_GTradeDetails] on [dbo].[is_GTradeDetails]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[is_GTradeDetails] ADD CONSTRAINT [PK_GTradeDetails] PRIMARY KEY CLUSTERED  ([GTradeDetailsId])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[is_GTradeDetails_Add]''
');

GO
EXECUTE ('

/*
<Details>
<Summary>Inserts an item into the GTradeDetails table</Summary>
<Created author="laurentiu.macovei" date="04/05/2006 16:33:05" />
</Details>
*/
CREATE PROCEDURE [dbo].[is_GTradeDetails_Add]
	@CorporationCode varchar(4) = NULL,
	@PrincipalBrokerageID varchar(1) = NULL,
	@OfficeCode varchar(4) = NULL,
	@ACNumber varchar(10) = NULL,
	@RecordID varchar(2) = NULL,
	@BaseDate datetime = NULL,
	@CalculationDate datetime = NULL,
	@CalculationStartTime datetime = NULL,
	@TradeDate datetime = NULL,
	@ExecutingMarketCode varchar(2) = NULL,
	@FuturesSubID varchar(3) = NULL,
	@DerivativesCode varchar(10) = NULL,
	@CompanyCode varchar(7) = NULL,
	@SeriesNumber varchar(4) = NULL,
	@SubCode varchar(2) = NULL,
	@TradeCode varchar(2) = NULL,
	@BuySellID varchar(1) = NULL,
	@CancellationDataID varchar(1) = NULL,
	@InputDate datetime = NULL,
	@CancellationInputDate datetime = NULL,
	@OptionsID varchar(1) = NULL,
	@SpreadNumber varchar(5) = NULL,
	@AutomaticExerciseAllotmentID varchar(1) = NULL,
	@TradeNumber varchar(5) = NULL,
	@TradeSubNumber varchar(3) = NULL,
	@ContractMonth varchar(7) = NULL,
	@StrikePrice decimal(11,4) = NULL,
	@Quantity int = NULL,
	@Price decimal(11,4) = NULL,
	@ExecutionAmount decimal(15,0) = NULL,
	@Commission decimal(15,0) = NULL,
	@ConsumptionTax decimal(15,0) = NULL,
	@ExchangeTax decimal(15,0) = NULL,
	@NetAmount decimal(15,0) = NULL,
	@Remarks1 varchar(45) = NULL,
	@Remarks2 varchar(45) = NULL,
	@LocalCustomerInformation varchar(12) = NULL,
	@SettlementPrice decimal(15,0) = NULL,
	@NumberStockSharesPerOption int = NULL,
	@FullSeriesNumber varchar(4) = NULL,
	@OneLotTradeNumber varchar(5) = NULL,
	@CustomerNameAbbr varchar(35) = NULL,
	@SecurityNameEnglish varchar(28) = NULL,
	@SecurityNameKana varchar(24) = NULL,
	@UnnamedField varchar(1) = NULL,
	@TransactionDate datetime = NULL,
	@CostPaymentMethod varchar(1) = NULL
AS
SET NOCOUNT ON

SET NOCOUNT OFF

DECLARE  @CalculationDateStartTime	DATETIME


IF @BaseDate = ''01/01/1900 00:00:00'' 
	SET @BaseDate = NULL

IF @CalculationDate = ''01/01/1900 00:00:00'' 
	SET @CalculationDate = NULL

IF @CalculationStartTime = ''01/01/1900 00:00:00'' 
	SET @CalculationStartTime = NULL

IF @TradeDate = ''01/01/1900 00:00:00'' 
	SET @TradeDate = NULL

IF @InputDate = ''01/01/1900 00:00:00'' 
	SET @InputDate = NULL

IF @CancellationInputDate = ''01/01/1900 00:00:00'' 
	SET @CancellationInputDate = NULL

IF @TransactionDate = ''01/01/1900 00:00:00'' 
	SET @TransactionDate = NULL

SET @CalculationDateStartTime = CONVERT(DATETIME,CONVERT(VARCHAR(12), CONVERT(DATETIME,@CalculationDate,112)) + '' '' + CONVERT(VARCHAR(8),RIGHT(@CalculationStartTime,8)))
--SET @CalculationDateStartTime =  CONVERT(VARCHAR(8), CONVERT(DATETIME,@CalculationDate,112)) + '' '' + CONVERT(VARCHAR(8),CONVERT(DATETIME,@CalculationStartTime,108))
--DATEPART(YYYY,@CalculationDate) + DATEPART(MM,@CalculationDate) + DATEPART(DD,@CalculationDate) + '' '' + DATEPART(hh,@CalculationStartTime) + '':'' + DATEPART(mm,@CalculationStartTime) + '':'' + DATEPART(ss,@CalculationStartTime)


INSERT INTO is_GTradeDetails 
			(
				[CorporationCode], 
				[PrincipalBrokerageID], 
				[OfficeCode], 
				[ACNumber], 
				[RecordID], 
				[BaseDate], 
				[CalculationDate], 
				[CalculationStartTime],
				[CalculationDateStartTime], 
				[TradeDate], 
				[ExecutingMarketCode], 
				[FuturesSubID], 
				[DerivativesCode], 
				[CompanyCode], 
				[SeriesNumber], 
				[SubCode], 
				[TradeCode], 
				[BuySellID], 
				[CancellationDataID], 
				[InputDate], 
				[CancellationInputDate], 
				[OptionsID], 
				[SpreadNumber], 
				[AutomaticExerciseAllotmentID], 
				[TradeNumber], 
				[TradeSubNumber], 
				[ContractMonth], 
				[StrikePrice], 
				[Quantity], 
				[Price], 
				[ExecutionAmount], 
				[Commission], 
				[ConsumptionTax], 
				[ExchangeTax], 
				[NetAmount], 
				[Remarks1], 
				[Remarks2], 
				[LocalCustomerInformation], 
				[SettlementPrice], 
				[NumberStockSharesPerOption], 
				[FullSeriesNumber], 
				[OneLotTradeNumber], 
				[CustomerNameAbbr], 
				[SecurityNameEnglish], 
				[SecurityNameKana], 
				[UnnamedField], 
				[TransactionDate], 
				[CostPaymentMethod]
				) 
	VALUES		(
				@CorporationCode, 
				@PrincipalBrokerageID, 
				@OfficeCode, 
				@ACNumber, 
				@RecordID, 
				@BaseDate, 
				@CalculationDate, 
				@CalculationStartTime,
				@CalculationDateStartTime, 
				@TradeDate, 
				@ExecutingMarketCode, 
				@FuturesSubID, 
				@DerivativesCode, 
				@CompanyCode, 
				@SeriesNumber, 
				@SubCode, 
				@TradeCode, 
				@BuySellID, 
				@CancellationDataID, 
				@InputDate, 
				@CancellationInputDate, 
				@OptionsID, 
				@SpreadNumber, 
				@AutomaticExerciseAllotmentID, 
				@TradeNumber, 
				@TradeSubNumber, 
				@ContractMonth, 
				@StrikePrice, 
				@Quantity, 
				@Price, 
				@ExecutionAmount, 
				@Commission, 
				@ConsumptionTax, 
				@ExchangeTax, 
				@NetAmount, 
				@Remarks1, 
				@Remarks2, 
				@LocalCustomerInformation, 
				@SettlementPrice, 
				@NumberStockSharesPerOption, 
				@FullSeriesNumber, 
				@OneLotTradeNumber, 
				@CustomerNameAbbr, 
				@SecurityNameEnglish, 
				@SecurityNameKana, 
				@UnnamedField, 
				@TransactionDate, 
				@CostPaymentMethod
				);

Return Scope_Identity()
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Rule_GetCurrencies]''
');

GO
EXECUTE ('/*
	Created By: Kirill Shilin
	Create On: 14.07.2011
	Issue: Update Issue MBAL-18241 screen3
	Purpose: Returns Currencies list filtering only those suitable for the rule
	
	Updated By: Kirill Shilin
	Update On: 04.10.2011
	Changes: Sort by Code added

*/

CREATE PROCEDURE [dbo].[ib_Rule_GetCurrencies]
		@ruleId int
AS
SET NOCOUNT ON
	SELECT DISTINCT
		C.CurrencyId, C.Code
	FROM
		ib_Currency C
	INNER JOIN
		ib_TemplateGroup TG ON TG.CurrencyId = C.CurrencyId
	INNER JOIN
		ib_Rule R ON R.TemplateId = TG.TemplateId AND R.RuleId = @ruleId
	ORDER BY	
		C.Code
');

GO
EXECUTE ('PRINT N''Creating [dbo].[eib_Position_Load]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[eib_Position_Load] 
(
	@LocationPath VARCHAR(100),
	@StagingFileId INT,
	@ImportFileId INT,
	@DataSourceCode VARCHAR(100),
	@ExchangeCode VARCHAR(25),
	@DataSourceFirmCode VARCHAR(100),
	@AccountCode VARCHAR(100) = NULL,
	@AsOfDate DATETIME,
	@ContractCode VARCHAR(100) = NULL,
	@InstrumentCode VARCHAR(100) = NULL,
	@Quantity DECIMAL(19, 4),
	@CurrencyCode VARCHAR(100),
	@ExpiryYear SMALLINT,
	@ExpiryMonth SMALLINT,
	@ExpiryDay SMALLINT,
	@LongQuantity DECIMAL(19, 4) = NULL,
	@ShortQuantity DECIMAL(19, 4) = NULL,
	@TradedLongQuantity DECIMAL(19, 4) = NULL,
	@TradedShortQuantity DECIMAL(19, 4) = NULL,
	@SettlementPrice DECIMAL(24, 10) = NULL,
	@MarketValue DECIMAL(19, 4) = NULL,
	@InstrumentType VARCHAR(1) = NULL,
	@StrikePrice DECIMAL(19, 4) = NULL,
	@OptionTypeCode VARCHAR(25) = NULL,
	@ReceiveLocationSysId INT,
	@RunId INT
)

AS
--History:
-- 09 Jan 2014	ED		EIB 25004 - remove importLog table and use Log table

SET NOCOUNT ON
			
-- Get data source ID and default currency ID
DECLARE @DataSourceId INT
DECLARE @DefaultCurrencyId INT
EXEC [_ib_DataSource_GetByCodeForOutput] @DataSourceCode, @DataSourceId OUTPUT, @DefaultCurrencyId OUTPUT	
	
-- Get the default Strike Price Divisor
DECLARE	@DefaultStrikePriceDivisor DECIMAL(19,6)
SET @DefaultStrikePriceDivisor = [dbo].[udf_GetDefaultStrikePriceDivisor](@DataSourceId, NULL)
							
-- We prefix the Instruments with the IntrumentTypeCode
DECLARE @InstrumentCd VARCHAR(100)
IF (@InstrumentCode IS NULL)
	SET @InstrumentCd = @InstrumentType + ''_'' + @ExchangeCode + ''_'' + @ContractCode
ELSE
	SET @InstrumentCd = @InstrumentCode
	
-- Get Divisors
DECLARE	@PriceDivisor		DECIMAL(19,4)
DECLARE	@StrikePriceDivisor	DECIMAL(19,4)
DECLARE	@MarketValueDivisor	DECIMAL(19,4)			
SELECT @StrikePriceDivisor = ids.StrikePriceDivisor
		, @PriceDivisor = ids.PriceDivisor
		, @MarketValueDivisor = ids.MarketValueDivisor
FROM [dbo].[ib_InstrumentDataSource] ids
WHERE ids.DataSourceId = @DataSourceId
	AND ids.DataSourceInstrumentCode = @InstrumentCd
IF @PriceDivisor IS NULL
	SET @PriceDivisor = 1
IF @MarketValueDivisor IS NULL 
	SET @MarketValueDivisor = 1
											
-- Set Settlement Price				
SET @SettlementPrice = (@SettlementPrice / @PriceDivisor)
			
-- Set StrikePrice
IF @InstrumentType = ''F''
	SET @StrikePrice = 0
ELSE
BEGIN
	IF @StrikePriceDivisor IS NULL
		SET @StrikePrice = @StrikePrice / ISNULL(@DefaultStrikePriceDivisor, 1)
	ELSE
		SET @StrikePrice = @StrikePrice / @StrikePriceDivisor
END
		
-- Set Market Value
SET @MarketValue = (@MarketValue / @MarketValueDivisor)
		
-- Create position
DECLARE @TrxDate DATETIME
SET @TrxDate = GETDATE()  -- This is not actually used
DECLARE @PositionId INT
EXEC [ib_Position_Load]
		@DataSourceCode
		, @ExchangeCode
		, @DataSourceFirmCode
		, @AccountCode
		, @AsOfDate
		, @InstrumentCd
		, @Quantity
		, @MarketValue		
		, @ExpiryYear
		, @ExpiryMonth
		, @ExpiryDay
		, @StrikePrice
		, ''POSITION''
		, @OptionTypeCode
		, @TrxDate
		, @SettlementPrice
		, @StagingFileId
		, @InstrumentType
		, @LocationPath
		, @CurrencyCode
		, @LongQuantity
		, @ShortQuantity
		, @TradedLongQuantity
		, @TradedShortQuantity
		, @PositionId = @PositionId OUTPUT
		, @ReceiveLocationSysId = @ReceiveLocationSysId
		, @RunId = @RunId
			
-- Add Settlement Price											
EXEC ib_Price_AddFromPositionLoad
	@PositionId
	, @ImportFileId
	, @SettlementPrice
');

GO
EXECUTE ('PRINT N''Creating [dbo].[vw_ib_CashReport_ExchangeData]''
');

GO
EXECUTE ('CREATE VIEW [dbo].[vw_ib_CashReport_ExchangeData]
	AS

-- 08 Apr 2010		amk		MBAL-15158: Need to exclude all broker data (and related internal data)
--							so follow same process as the broker data view except do NOT IN
-- 06 Aug 2010		amk		MBAL-16409: Change external TOTE calculation
-- 13 Aug 2010		amk		MBAL-16453 Include cheque adjustments
-- 29 Nov 2010		amk		MBAL-17086 (originally done as MBAL-17069 on broker cash report view)
--									   1) good measure to only include brokers that have IsActive flag set
--									   2) when checking match codes in subquery only look at datasources 
--									      that are external on template
-- 15 Aug 2014		ED		EIB 26004: For OTCM external TOTE should not be computed(use existing)
	
SELECT 
		crs.ExchangeId AS ExchangeId
		, ex.[Code] AS ExchangeName
		, curr.CurrencyId AS CurrencyId
		, curr.[Code] AS CurrencyCode
		, curr.[Description] AS CurrencyName
		, ttc.TemplateTypeClassId AS TemplateTypeClassId
		, ttc.[Code] AS TemplateTypeClassCode
		, ttc.[Name] AS TemplateTypeClassName
		, instrType.[Code] AS InstrumentTypeCode
		, instrType.[Name] AS InstrumentTypeName
		, SUM(crs.[Internal_TOTE]) AS [Internal_TOTE]
		, SUM(crs.[Internal_PandS]) AS [Internal_PandS]
		, SUM(crs.[Internal_AdjOTE]) AS [Internal_AdjOTE]
		, SUM(crs.[Internal_AdjSegNon]) AS [Internal_AdjSegNon]  -- This has no Value YET! We will need to source this from somewhere eventually when we know where to get it from.
		, CASE WHEN exOTCM.Code IS NOT NULL
				THEN SUM(crs.External_TOTE)
				ELSE SUM(crs.[External_TOTE] + crs.[External_PandS] - crs.[External_YOTE]) END AS [External_TOTE]
		, SUM(crs.[External_PandS]) AS [External_PandS]
		, SUM(crs.[External_AdjOTE]) AS [External_AdjOTE]
		, SUM(crs.[External_AdjSegNon]) AS [External_AdjSegNon]  -- This has no Value YET! We will need to source this from somewhere eventually when we know where to get it from.
		, SUM(crs.[Difference]) AS [Difference]
		, crs.CashReportId
		, instrType.InstrumentTypeId
		, mc.MatchCodeId
		, cr.TodaysDate
		-- include cheque adjustments
		, (SELECT SUM(value) 
			FROM ib_Adjustment a
				JOIN ib_AdjustmentHeader h ON h.AdjustmentHeaderId = a.AdjustmentHeaderId
				JOIN ib_AdjustmentType at ON at.AdjustmentTypeId = h.AdjustmentTypeId
				JOIN ib_Instrument i ON i.InstrumentId = a.InstrumentId
				JOIN ib_InstrumentType it ON it.InstrumentTypeId = i.InstrumentTypeId
			WHERE at.Code = ''CQ''
				AND i.InstrumentTypeId = instrType.InstrumentTypeId
				AND a.ExchangeId = crs.ExchangeId
				AND a.CurrencyId = curr.CurrencyId
				AND a.MatchCodeId = mc.MatchCodeId
				AND a.AdjustmentDate = cr.TodaysDate
			) AS cheque_adj
FROM ib_CashReportSummary crs
	INNER JOIN ib_Exchange ex ON ex.ExchangeId = crs.ExchangeId
	INNER JOIN ib_Currency curr ON curr.CurrencyId = crs.CurrencyId
	INNER JOIN ib_InstrumentType instrType ON instrType.InstrumentTypeId = crs.InstrumentTypeId
	INNER JOIN ib_MatchCode mc ON mc.MatchCodeId = crs.MatchCodeId
	LEFT JOIN ib_TemplateTypeClass ttc ON ttc.TemplateTypeClassId = mc.TemplateTypeClassId
	INNER JOIN ib_ImbalanceReport ir ON ir.ImbalanceReportId = crs.ImbalanceReportId
	INNER JOIN ib_CashReport cr ON cr.CashReportId = crs.CashReportId
	LEFT JOIN ib_Exchange exOTCM ON exOTCM.ExchangeId = crs.ExchangeId AND exOTCM.Code = ''OTCM''
WHERE crs.MatchCodeId NOT IN (
--				first attempt was to get match codes from cash report summary itself
--				where broker is data source.  This can miss some data: it will not
--				get match codes where external side is all zero''s and internal side
--				has figures.  So for that reason must get the match codes from the
--				template itself.  Connection is quite loose (through account and firm)
--				but it seems to work.
				SELECT mc2.matchcodeid
				FROM ib_account a
					JOIN ib_templatecompare tc ON tc.firmid = a.firmid
					JOIN ib_broker b ON b.datasourceid = tc.datasourceid
					JOIN ib_templategroup tg 
						ON tg.accountid = a.accountid AND tg.templateid = tc.templateid
					JOIN ib_matchcode mc2 
						ON mc2.templateid = tg.templateid AND mc2.matchcode = tg.description
				WHERE tc.templateid = ir.templateid
					AND b.IsActive = 1
					AND tc.InternalExternalCode = ''E''
				)
GROUP BY crs.CashReportId
	, crs.ExchangeId
	, ex.[Code]
	, curr.CurrencyId
	, curr.[Code]
	, curr.[Description]
	, ttc.[Code]
	, ttc.TemplateTypeClassId
	, ttc.[Name]
	, instrType.[Code]
	, instrType.[Name]
	, instrType.InstrumentTypeId
	, mc.MatchCodeId
	, cr.TodaysDate
	, exOTCM.Code
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_CashReport_FileExportForExchange]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_CashReport_FileExportForExchange]
	@CashReportId INT
	, @ReportId INT -- Used for updating status
AS
SET NOCOUNT ON
BEGIN

-- 24 Mar 2010		AlisterM	Creation
-- 26 Mar 2010		AlisterM	Implement Select Statement
-- 16 Apr 2010		AlisterM	MBAL-15286 Ensure N/S not Non-Seg/Seg
-- 13 Aug 2010		amk			MBAL-16448 Multiply amounts by -1
--								MBAL-16453 Include cheque adjustments
-- 31 Aug 2010		amk			MBAL-16553 tweaks to cheque and corrections

-- Futures and Options at the top of our winner list
SELECT 
	ExchangeName AS Exchange
	, CurrencyCode AS Currency
	, TemplateTypeClassCode AS AccountType
	, NULL AS TradeType -- Trade Type not used
	, ([Internal_TOTE] + [Internal_AdjOTE] - [External_AdjOTE]) * -1 AS AdjustedOTE
	, [External_TOTE] * -1 AS ExternalOTE
	, cheque_adj * -1 AS ChequeAmounts
	, ([Internal_AdjOTE] - [External_AdjOTE] - ISNULL(cheque_adj, 0)) * -1 AS Corrections
	, [Internal_AdjOTE]
	, [External_AdjOTE]
	 FROM(
--This selects all the Exchanges that DO NOT belong to a group
	SELECT 1 AS 
		ReportSortOrder
		, vwed.ExchangeName
		, vwed.CurrencyCode
		, vwed.TemplateTypeClassCode
		, vwed.TemplateTypeClassName
		, SUM(vwed.[Internal_TOTE]) AS [Internal_TOTE]
		, SUM(vwed.[Internal_PandS]) AS [Internal_PandS]
		, SUM(vwed.[Internal_AdjOTE]) AS [Internal_AdjOTE]
		, SUM(vwed.[Internal_AdjSegNon]) AS [Internal_AdjSegNon]  -- This has no Value YET! We will need to source this from somewhere eventually when we know where to get it from.
		, SUM(vwed.[External_TOTE]) AS [External_TOTE]
		, SUM(vwed.[External_PandS]) AS [External_PandS]
		, SUM(vwed.[External_AdjOTE]) AS [External_AdjOTE]
		, SUM(vwed.[External_AdjSegNon]) AS [External_AdjSegNon] 
		--, cge.CashGroupId
		, NULL AS SortOrder
		, SUM(vwed.cheque_adj) AS cheque_adj
	FROM [dbo].[vw_ib_CashReport_ExchangeData] vwed
		LEFT JOIN ib_CashGroupExchange cge ON cge.ExchangeId = vwed.ExchangeId
	WHERE vwed.InstrumentTypeCode IN (''F'', ''O'') -- Premium Paid Options are excluded
		AND vwed.CashReportId = @CashReportId
		AND cge.CashGroupId IS NULL
	GROUP BY vwed.ExchangeId
		, vwed.ExchangeName
		, vwed.CurrencyCode
		, vwed.TemplateTypeClassName
		, vwed.TemplateTypeClassCode 
		-- Amalgamate Instrument Types (i.e. no Grouping by InstrumentType)
UNION ALL
	SELECT 3 AS ReportSortOrder 
		--, NULL AS ExchangeId 
		, cg.Name AS ExchangeName
		--, vwed.CurrencyId
		, vwed.CurrencyCode
		--, vwed.TemplateTypeClassId
		, vwed.TemplateTypeClassCode
		, vwed.TemplateTypeClassName
		, SUM(vwed.[Internal_TOTE]) AS [Internal_TOTE]
		, SUM(vwed.[Internal_PandS]) AS [Internal_PandS]
		, SUM(vwed.[Internal_AdjOTE]) AS [Internal_AdjOTE]
		, SUM(vwed.[Internal_AdjSegNon]) AS [Internal_AdjSegNon]  -- This has no Value YET! We will need to source this from somewhere eventually when we know where to get it from.
		, SUM(vwed.[External_TOTE]) AS [External_TOTE]
		, SUM(vwed.[External_PandS]) AS [External_PandS]
		, SUM(vwed.[External_AdjOTE]) AS [External_AdjOTE]
		, SUM(vwed.[External_AdjSegNon]) AS [External_AdjSegNon]  -- This has no Value YET! We will need to source this from somewhere eventually when we know where to get it from.
		--, SUM(vwed.[Difference]) AS [Difference]
		--, NULL AS CashGroupId
		, NULL AS SortOrder
		, SUM(vwed.cheque_adj) AS cheque_adj
	FROM [dbo].[vw_ib_CashReport_ExchangeData] vwed
		INNER JOIN ib_CashGroupExchange cge ON cge.ExchangeId = vwed.ExchangeId
		INNER JOIN ib_CashGroup cg ON cge.CashGroupId = cg.CashGroupId
	WHERE vwed.InstrumentTypeCode IN (''F'', ''O'') --Futures and Options
		AND vwed.CashReportId = @CashReportId
	GROUP BY 
		vwed.CurrencyId
		, vwed.CurrencyCode
		, vwed.TemplateTypeClassId
		, vwed.TemplateTypeClassCode
		, vwed.TemplateTypeClassName
		, vwed.CashReportId
		, cg.CashGroupId
		, cg.Name
) tmp2 
ORDER BY tmp2.ReportSortOrder, tmp2.SortOrder, tmp2.ExchangeName, tmp2.CurrencyCode, tmp2.TemplateTypeClassCode

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_ImbalanceReportPhase2Trace]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_ImbalanceReportPhase2Trace]
(
[RuleType] [varchar] (50) NOT NULL,
[ImbalanceReportDetailId] [int] NOT NULL,
[Description] [varchar] (100) NOT NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_ib_ImbalanceReportPhase2Trace] on [dbo].[ib_ImbalanceReportPhase2Trace]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_ImbalanceReportPhase2Trace] ADD CONSTRAINT [PK_ib_ImbalanceReportPhase2Trace] PRIMARY KEY CLUSTERED  ([ImbalanceReportDetailId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_ib_ImbalanceReportPhase2Trace_ImbalanceReportDrillDown] on [dbo].[ib_ImbalanceReportPhase2Trace]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_ib_ImbalanceReportPhase2Trace_ImbalanceReportDrillDown] ON [dbo].[ib_ImbalanceReportPhase2Trace] ([Description], [ImbalanceReportDetailId])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_CashReport_GatherAdjustments]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_CashReport_GatherAdjustments]
(
	@CashReportId INT
)
AS
SET NOCOUNT ON

--	28 may 2010		ED		Creation
--	01 Jun 2010     ED		MBAL 15705 - CT should be on AdjSegNon column
--  02 Jun 2010     ED      Exclude Automatically Matched Adjustments
--  25 Jun 2010		ED		MBAL 15949 - don''t include manually matched adjustments
--  01 Jul 2010     ED      MBAL 15690 - Insert rows not found
DECLARE @Today		DATETIME
DECLARE @Yesterday	DATETIME
DECLARE @TemplateId	INT
DECLARE @ImbalanceReportId INT

-- get variables

SELECT @Today = cr.TodaysDate
	, @TemplateId = ir.TemplateId, @ImbalanceReportId = cr.ImbalanceReportId
FROM ib_CashReport cr
INNER JOIN ib_ImbalanceReport ir ON ir.ImbalanceReportId=cr.ImbalanceReportId
WHERE cr.CashReportId = @CashReportId

--insert non-existing adjustments
INSERT INTO [dbo].[ib_CashReportSummary]
           ([ImbalanceReportId]
           ,[CashReportId]
           ,[MatchCodeId]
           ,[DatasourceId]
           ,[ExchangeId]
           ,[CurrencyId]
           ,[InstrumentTypeId]
           ,[Internal_TOTE]
           ,[Internal_PandS]
           ,[Internal_AdjOTE]
           ,[Internal_AdjSegNon]
           ,[External_TOTE]
           ,[External_PandS]
           ,[External_AdjOTE]
           ,[External_AdjSegNon]
           ,[Difference])
SELECT	@ImbalanceReportId,
		@CashReportId,
		a.[MatchcodeId],
		a.[DataSourceId],
		a.[ExchangeId],
		a.[CurrencyId],
		i.InstrumentTypeId,
		0,
		0,
		0,
		0 AS [Internal_AdjSegNon],  -- This has no Value YET! We will need to source this from somewhere eventually when we know where to get it from.
		0,
		0,
		0,
		0 AS [External_AdjSegNon],  -- This has no Value YET! We will need to source this from somewhere eventually when we know where to get it from.
		0 -- We''ll Update this next because I reckon it''ll be quicker
FROM ib_Adjustment a
INNER JOIN ib_Instrument i ON i.InstrumentId = a.InstrumentId
INNER JOIN ib_AdjustmentHeader ah ON ah.AdjustmentHeaderId=a.AdjustmentHeaderiD
LEFT JOIN ib_AdjustmentStatus [as] ON [as].AdjustmentStatusId=a.AdjustmentStatusId
WHERE a.AdjustmentDate = @Today
	AND a.TemplateId = @TemplateId 
	AND ([as].Code NOT IN (''A'',''M'') OR a.AdjustmentStatusId IS NULL)
	AND NOT EXISTS(SELECT crs.CashReportSummaryId FROM ib_CashReportSummary crs 
					WHERE a.MatchCodeId = crs.MatchCodeId
						AND a.DataSourceId=crs.DataSourceId
						AND a.ExchangeId = crs.ExchangeId
						AND a.CurrencyId = crs.CurrencyId
						AND i.InstrumentTypeId=crs.InstrumentTypeId
						AND crs.CashReportId = @CashReportId
				)
GROUP BY a.MatchCodeId, a.DataSourceId ,a.ExchangeId, a.CurrencyId, i.InstrumentTypeId

-- group adjustments and load total into temp table



SELECT SUM(a.Value) AS VALUE
	, a.AdjustmentDate, a.MatchCodeId, a.DataSourceId 
		,a.ExchangeId, a.CurrencyId
		, i.InstrumentTypeId
		,a.InternalExternalCode
INTO #adjustments
FROM ib_Adjustment a
INNER JOIN ib_Instrument i ON i.InstrumentId=a.InstrumentId
INNER JOIN ib_AdjustmentHeader ah ON ah.AdjustmentHeaderId=a.AdjustmentHeaderiD
INNER JOIN ib_AdjustmentType adjType ON adjType.AdjustmentTypeId=ah.AdjustmentTypeId
LEFT JOIN ib_AdjustmentStatus [as] ON [as].AdjustmentStatusId=a.AdjustmentStatusId
WHERE a.AdjustmentDate = @Today
	AND a.TemplateId = @TemplateId AND adjType.Code != ''CT''
	AND ([as].Code NOT IN (''A'',''M'') OR a.AdjustmentStatusId IS NULL)
GROUP BY
	a.AdjustmentDate, a.MatchCodeId, a.DataSourceId 
		,a.ExchangeId, a.CurrencyId
		, i.InstrumentTypeId, a.InternalExternalCode

SELECT SUM(a.Value) AS VALUE
	, a.AdjustmentDate, a.MatchCodeId, a.DataSourceId 
		,a.ExchangeId, a.CurrencyId
		, i.InstrumentTypeId
		,a.InternalExternalCode
INTO #adjustmentsSegNon
FROM ib_Adjustment a
INNER JOIN ib_Instrument i ON i.InstrumentId=a.InstrumentId
INNER JOIN ib_AdjustmentHeader ah ON ah.AdjustmentHeaderId=a.AdjustmentHeaderiD
INNER JOIN ib_AdjustmentType adjType ON adjType.AdjustmentTypeId=ah.AdjustmentTypeId
LEFT JOIN ib_AdjustmentStatus [as] ON [as].AdjustmentStatusId=a.AdjustmentStatusId
WHERE a.AdjustmentDate = @Today
	AND a.TemplateId = @TemplateId AND adjType.Code = ''CT''
	AND ([as].Code NOT IN (''A'',''M'') OR a.AdjustmentStatusId IS NULL)
GROUP BY
	a.AdjustmentDate, a.MatchCodeId, a.DataSourceId 
		,a.ExchangeId, a.CurrencyId
		, i.InstrumentTypeId, a.InternalExternalCode

-- internal T OTE

UPDATE ib_CashReportSummary
SET Internal_AdjOTE = Internal_AdjOTE + a.Value
FROM ib_CashReportSummary crs
	INNER JOIN #adjustments a 
		ON a.MatchCodeId = crs.MatchCodeId
		AND a.DataSourceId=crs.DataSourceId
		AND a.ExchangeId = crs.ExchangeId
		AND a.CurrencyId = crs.CurrencyId
		AND a.InstrumentTypeId=crs.InstrumentTypeId
WHERE a.InternalExternalCode = ''I''
	AND a.AdjustmentDate = @Today AND CashReportId=@CashReportId 

-- internal T OTE Non Seg

UPDATE ib_CashReportSummary
SET Internal_AdjSegNon = Internal_AdjSegNon + a.Value
FROM ib_CashReportSummary crs
	INNER JOIN #adjustmentsSegNon a 
		ON a.MatchCodeId = crs.MatchCodeId
		AND a.DataSourceId=crs.DataSourceId
		AND a.ExchangeId = crs.ExchangeId
		AND a.CurrencyId = crs.CurrencyId
		AND a.InstrumentTypeId=crs.InstrumentTypeId
WHERE a.InternalExternalCode = ''I''
	AND a.AdjustmentDate = @Today AND CashReportId=@CashReportId 

-- external T OTE
UPDATE ib_CashReportSummary
SET External_AdjOTE = External_AdjOTE + a.Value
FROM ib_CashReportSummary crs
	INNER JOIN #adjustments a 
		ON a.MatchCodeId = crs.MatchCodeId
		AND a.DataSourceId=crs.DataSourceId
		AND a.ExchangeId = crs.ExchangeId
		AND a.CurrencyId = crs.CurrencyId
		AND a.InstrumentTypeId=crs.InstrumentTypeId
WHERE a.InternalExternalCode = ''E''
	AND a.AdjustmentDate = @Today AND CashReportId=@CashReportId 

-- external T OTE Non Seg
UPDATE ib_CashReportSummary
SET External_AdjSegNon = External_AdjSegNon + a.Value
FROM ib_CashReportSummary crs
	INNER JOIN #adjustmentsSegNon a 
		ON a.MatchCodeId = crs.MatchCodeId
		AND a.DataSourceId=crs.DataSourceId
		AND a.ExchangeId = crs.ExchangeId
		AND a.CurrencyId = crs.CurrencyId
		AND a.InstrumentTypeId=crs.InstrumentTypeId
WHERE a.InternalExternalCode = ''E''
	AND a.AdjustmentDate = @Today AND CashReportId=@CashReportId 
-- cleanup

DROP TABLE #adjustments
DROP TABLE #adjustmentsSegNon
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_CashReport_BuildReport]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_CashReport_BuildReport]
	@ImbalanceReportId int = NULL,
	@CashReportId INT = NULL
AS
SET NOCOUNT ON
BEGIN

	--	24 Mar 2010		KevinP	Added SP to Build Cash Reprot Data
	--	06 Aug 2010		amk		MBAL-16409: Populate new external YOTE figures so can be used for revised external TOTE calculation
	--	22 Sep 2010		amk		MBAL-16684: exclude zero rows

	-- Make sure we have the correct ImbalanceReportId for this CashReport.
	UPDATE [dbo].[ib_CashReport] 
	SET ImbalanceReportId = @ImbalanceReportId
	WHERE CashReportId = @CashReportId 
		AND ImbalanceReportId IS NULL

	-- Create the CashReportDetail records
	INSERT INTO [dbo].[ib_CashReportDetail]
			   ([CashReportId]
			   , [DataSourceId]
			   , [ExchangeId]
			   , [FirmId]
			   , [ClassId]
			   , [AccountId]
			   , [InstrumentId]
			   , [CurrencyId]
			   , [Internal_TOTE]
			   , [Internal_PandS]
			   , [Internal_AdjOTE]
			   , [Internal_AdjSegNon]
			   , [External_TOTE]
			   , [External_PandS]
			   , [External_AdjOTE]
			   , [External_AdjSegNon]
			   , [Difference]
			   , [External_YOTE]
			   )
	SELECT  @CashReportId
			, ird.DataSourceId
			, ird.ExchangeId
			, ird.FirmId
			, ird.ClassId
			, ird.AccountId
			, ird.InstrumentId
			, ird.CurrencyId
			, SUM(ird.[Internal_TOTE])
			, SUM(ird.[Internal_PandS])
			, SUM(ird.[Internal_TAdjOTE])
			, 0 AS [Internal_AdjSegNon]  -- This has no Value YET! We will need to source this from somewhere eventually when we know where to get it from.
			, SUM([External_TOTE])
			, SUM([External_PandS])
			, SUM([External_TAdjOTE])
			, 0 AS [External_AdjSegNon]  -- This has no Value YET! We will need to source this from somewhere eventually when we know where to get it from.
			, 0 -- We''ll Update this next because I reckon it''ll be quicker
			, SUM([External_YOTE])
	FROM [dbo].[ib_ImbalanceReportDetail] ird
	WHERE ird.ImbalanceReportId = @ImbalanceReportId
		AND (
				ird.Internal_TOTE <> 0 OR ird.Internal_PandS <> 0 OR ird.Internal_TAdjOTE <> 0
				OR ird.External_TOTE <> 0 OR ird.External_PandS <> 0 OR ird.External_TAdjOTE <> 0
			)
	GROUP BY ird.ImbalanceReportId, ird.DataSourceId, ird.ExchangeId, ird.FirmId
			, ird.ClassId, ird.AccountId, ird.InstrumentId, ird.CurrencyId

	UPDATE [dbo].[ib_CashReportDetail] 
	SET [Difference] = ([Internal_TOTE]) + ([Internal_AdjOTE] - [External_AdjOTE])
	WHERE CashReportId = @CashReportId

	--Create the Cash Report Summary records
	INSERT INTO [dbo].[ib_CashReportSummary]
			   ([ImbalanceReportId]
			   , [CashReportId]
			   , [MatchCodeId]
			   , [DatasourceId]
			   , [ExchangeId]
			   , [CurrencyId]
			   , [InstrumentTypeId]
			   , [Internal_TOTE]
			   , [Internal_PandS]
			   , [Internal_AdjOTE]
			   , [Internal_AdjSegNon]
			   , [External_TOTE]
			   , [External_PandS]
			   , [External_AdjOTE]
			   , [External_AdjSegNon]
			   , [Difference]
			   , [External_YOTE]
			   )
	SELECT	ird.[ImbalanceReportId]
			, @CashReportId
			, mc.[MatchcodeId]
			, ird.[DataSourceId]
			, ird.[ExchangeId]
			, ird.[CurrencyId]
			, it.InstrumentTypeId
			, SUM(ird.[Internal_TOTE])
			, SUM(ird.[Internal_PandS])
			, SUM(ird.[Internal_TAdjOTE])
			, 0 AS [Internal_AdjSegNon]  -- This has no Value YET! We will need to source this from somewhere eventually when we know where to get it from.
			, SUM([External_TOTE])
			, SUM([External_PandS])
			, SUM([External_TAdjOTE])
			, 0 AS [External_AdjSegNon]  -- This has no Value YET! We will need to source this from somewhere eventually when we know where to get it from.
			, 0 -- We''ll Update this next because I reckon it''ll be quicker
			, SUM([External_YOTE])
	FROM ib_ImbalanceReport ir
		INNER JOIN ib_ImbalanceReportDetail ird ON ir.ImbalanceReportId = ird.ImbalanceReportId
		INNER JOIN ib_ImbalanceReportPhase2Trace irp2t ON irp2t.ImbalanceReportDetailId = ird.ImbalanceReportDetailId 
		INNER JOIN ib_Instrument inst ON inst.InstrumentId = ird.InstrumentId
		INNER JOIN ib_InstrumentType it ON it.InstrumentTypeId = inst.InstrumentTypeId
		INNER JOIN ib_MatchCode mc ON mc.MatchCode = irp2t.[Description] AND mc.TemplateId = ir.TemplateId
	WHERE ird.ImbalanceReportId = @ImbalanceReportId
		AND (
				ird.Internal_TOTE <> 0 OR ird.Internal_PandS <> 0 OR ird.Internal_TAdjOTE <> 0
				OR ird.External_TOTE <> 0 OR ird.External_PandS <> 0 OR ird.External_TAdjOTE <> 0
			)
	GROUP BY ird.[ImbalanceReportId], mc.[MatchcodeId], ird.[DataSourceId]
			, ird.[ExchangeId], ird.[CurrencyId], it.InstrumentTypeId

	--gather adjustments
	EXEC [dbo].[ib_CashReport_GatherAdjustments] @CashReportId

	UPDATE [dbo].[ib_CashReportSummary] 
	SET [Difference] = ([Internal_TOTE]) + ([Internal_AdjOTE] - [External_AdjOTE])
	WHERE ImbalanceReportId = @ImbalanceReportId
		AND CashReportId = @CashReportId

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[aspnet_UsersInRoles_IsUserInRole]''
');

GO
SET QUOTED_IDENTIFIER OFF

GO
EXECUTE ('
CREATE PROCEDURE [dbo].[aspnet_UsersInRoles_IsUserInRole]
    @ApplicationName  nvarchar(256),
    @UserName         nvarchar(256),
    @RoleName         nvarchar(256)
AS
SET NOCOUNT ON
BEGIN
    DECLARE @ApplicationId uniqueidentifier
    SELECT  @ApplicationId = NULL
    SELECT  @ApplicationId = ApplicationId FROM aspnet_Applications WHERE LOWER(@ApplicationName) = LoweredApplicationName
    IF (@ApplicationId IS NULL)
        RETURN(2)
    DECLARE @UserId uniqueidentifier
    SELECT  @UserId = NULL
    DECLARE @RoleId uniqueidentifier
    SELECT  @RoleId = NULL

    SELECT  @UserId = UserId
    FROM    dbo.aspnet_Users
    WHERE   LoweredUserName = LOWER(@UserName) AND ApplicationId = @ApplicationId

    IF (@UserId IS NULL)
        RETURN(2)

    SELECT  @RoleId = RoleId
    FROM    dbo.aspnet_Roles
    WHERE   LoweredRoleName = LOWER(@RoleName) AND ApplicationId = @ApplicationId

    IF (@RoleId IS NULL)
        RETURN(3)

    IF (EXISTS( SELECT * FROM dbo.aspnet_UsersInRoles WHERE  UserId = @UserId AND RoleId = @RoleId))
        RETURN(1)
    ELSE
        RETURN(0)
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[is_GUnclosedContractDetails]''
');

GO
SET QUOTED_IDENTIFIER ON

GO
EXECUTE ('CREATE TABLE [dbo].[is_GUnclosedContractDetails]
(
[GUnclosedContractDetailsId] [int] NOT NULL IDENTITY(1, 1),
[CorporationCode] [varchar] (4) NULL,
[PrincipalBrokerageID] [varchar] (1) NULL,
[OfficeCode] [varchar] (4) NULL,
[ACNumber] [varchar] (10) NULL,
[RecordID] [varchar] (2) NULL,
[BaseDate] [datetime] NULL,
[CalculationDate] [datetime] NULL,
[CalculationStartTime] [datetime] NULL,
[CalulationDateStartTime] [datetime] NULL,
[MarketCode] [varchar] (2) NULL,
[FuturesSubId] [varchar] (3) NULL,
[DerivativesCode] [varchar] (10) NULL,
[CompanyCode] [varchar] (7) NULL,
[SeriesNo] [varchar] (4) NULL,
[SubCode] [varchar] (2) NULL,
[BuySellContractId] [varchar] (2) NULL,
[TradeDate] [datetime] NULL,
[Price] [decimal] (11, 4) NULL,
[ContractMonth] [varchar] (7) NULL,
[StrikePrice] [decimal] (11, 4) NULL,
[FinalTradeDate] [datetime] NULL,
[Quantity] [decimal] (15, 0) NULL,
[ExecutionAmount] [decimal] (15, 0) NULL,
[MarketPrice] [decimal] (11, 4) NULL,
[MarketValue] [decimal] (15, 0) NULL,
[RealizedPLSign] [varchar] (1) NULL,
[RealizedPL] [decimal] (15, 0) NULL,
[RealizedPLSigned] [decimal] (15, 0) NULL,
[Commission] [decimal] (15, 0) NULL,
[ConsumptionTax] [decimal] (15, 0) NULL,
[ExchangeTax] [decimal] (15, 0) NULL,
[TradeNo] [varchar] (5) NULL,
[TradeSubNo] [varchar] (3) NULL,
[NumberOfStockSharesPerOption] [decimal] (15, 0) NULL,
[FullSeriesNo] [varchar] (4) NULL,
[OptionIdClose] [varchar] (1) NULL,
[CustomerNameAbbreviated] [varchar] (35) NULL,
[SecurityNameEnglish] [varchar] (28) NULL,
[SecurityNameKana] [varchar] (24) NULL,
[TradeCodeClose] [varchar] (2) NULL,
[TradeSubCode] [varchar] (1) NULL,
[TransactionDate] [datetime] NULL,
[CostPaymentMethod] [varchar] (1) NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_is_GUnclosedContractDetails_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_GUnclosedContractDetails_CreationDate] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_GUnclosedContractDetails] on [dbo].[is_GUnclosedContractDetails]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[is_GUnclosedContractDetails] ADD CONSTRAINT [PK_GUnclosedContractDetails] PRIMARY KEY CLUSTERED  ([GUnclosedContractDetailsId])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[is_GUnclosedContractDetails_Add]''
');

GO
EXECUTE ('



/*
<Details>
<Summary>Inserts an item into the GUnclosedContractDetails table</Summary>
<Created author="laurentiu.macovei" date="04/05/2006 16:33:05" />
</Details>
*/
CREATE PROCEDURE [dbo].[is_GUnclosedContractDetails_Add]
	@CorporationCode varchar(4) = NULL,
	@PrincipalBrokerageID varchar(1) = NULL,
	@OfficeCode varchar(4) = NULL,
	@ACNumber varchar(10) = NULL,
	@RecordID varchar(2) = NULL,
	@BaseDate datetime = NULL,
	@CalculationDate datetime = NULL,
	@CalculationStartTime datetime = NULL,
	@MarketCode varchar(2) = NULL,
	@FuturesSubId varchar(3) = NULL,
	@DerivativesCode varchar(10) = NULL,
	@CompanyCode varchar(7) = NULL,
	@SeriesNo varchar(4) = NULL,
	@SubCode varchar(2) = NULL,
	@BuySellContractId varchar(2) = NULL,
	@TradeDate datetime = NULL,
	@Price decimal(11,4) = NULL,
	@ContractMonth varchar(7) = NULL,
	@StrikePrice decimal(11,4) = NULL,
	@FinalTradeDate datetime = NULL,
	@Quantity decimal(15,0) = NULL,
	@ExecutionAmount decimal(15,0) = NULL,
	@MarketPrice decimal(11,4) = NULL,
	@MarketValue decimal(15,0) = NULL,
	@RealizedPLSign varchar(1) = NULL,
	@RealizedPL decimal(15,0) = NULL,
	@Commission decimal(15,0) = NULL,
	@ConsumptionTax decimal(15,0) = NULL,
	@ExchangeTax decimal(15,0) = NULL,
	@TradeNo varchar(5) = NULL,
	@TradeSubNo varchar(3) = NULL,
	@NumberOfStockSharesPerOption decimal(15,0) = NULL,
	@FullSeriesNo varchar(4) = NULL,
	@OptionIdClose varchar(1) = NULL,
	@CustomerNameAbbreviated varchar(35) = NULL,
	@SecurityNameEnglish varchar(28) = NULL,
	@SecurityNameKana varchar(24) = NULL,
	@TradeCodeClose varchar(2) = NULL,
	@TradeSubCode varchar(1) = NULL,
	@TransactionDate datetime = NULL,
	@CostPaymentMethod varchar(1) = NULL
AS
SET NOCOUNT ON

SET NOCOUNT OFF

	DECLARE		@CalculationDateStartTime	DATETIME
	DECLARE		@RealizedPLSigned			DECIMAL(15,0)


	IF @BaseDate = ''01/01/1900 00:00:00'' 
		SET @BaseDate = NULL

	IF @CalculationDate = ''01/01/1900 00:00:00'' 
		SET @CalculationDate = NULL

	IF @CalculationStartTime = ''01/01/1900 00:00:00'' 
		SET @CalculationStartTime = NULL

	IF @TradeDate = ''01/01/1900 00:00:00'' 
		SET @TradeDate = NULL

	IF @FinalTradeDate = ''01/01/1900 00:00:00'' 
		SET @FinalTradeDate = NULL

	IF @TransactionDate = ''01/01/1900 00:00:00'' 
		SET @TransactionDate = NULL

	IF @RealizedPLSign = ''-'' 
		SET @RealizedPLSigned = @RealizedPL * -1
	ELSE
		SET @RealizedPLSigned = @RealizedPL

	SET @CalculationDateStartTime = CONVERT(DATETIME,CONVERT(VARCHAR(12), CONVERT(DATETIME,@CalculationDate,112)) + '' '' + CONVERT(VARCHAR(8),RIGHT(@CalculationStartTime,8)))


	INSERT INTO is_GUnclosedContractDetails 
		(
			[CorporationCode], 
			[PrincipalBrokerageID], 
			[OfficeCode], 
			[ACNumber], 
			[RecordID], 
			[BaseDate], 
			[CalculationDate], 
			[CalculationStartTime],
 			[CalulationDateStartTime],
			[MarketCode], 
			[FuturesSubId], 
			[DerivativesCode], 
			[CompanyCode], 
			[SeriesNo], 
			[SubCode], 
			[BuySellContractId], 
			[TradeDate], 
			[Price], 
			[ContractMonth], 
			[StrikePrice], 
			[FinalTradeDate], 
			[Quantity], 
			[ExecutionAmount], 
			[MarketPrice], 
			[MarketValue], 
			[RealizedPLSign], 
			[RealizedPL], 
			[RealizedPLSigned], 
			[Commission], 
			[ConsumptionTax], 
			[ExchangeTax], 
			[TradeNo], 
			[TradeSubNo], 
			[NumberOfStockSharesPerOption], 
			[FullSeriesNo], 
			[OptionIdClose], 
			[CustomerNameAbbreviated], 
			[SecurityNameEnglish], 
			[SecurityNameKana], 
			[TradeCodeClose], 
			[TradeSubCode], 
			[TransactionDate], 
			[CostPaymentMethod]
		) 
	VALUES
		(
			@CorporationCode,	
			@PrincipalBrokerageID, 
			@OfficeCode, 
			@ACNumber, 
			@RecordID, 
			@BaseDate, 
			@CalculationDate, 
			@CalculationStartTime,
			@CalculationDateStartTime,
			@MarketCode, 
			@FuturesSubId, 
			@DerivativesCode, 
			@CompanyCode, 
			@SeriesNo, 
			@SubCode, 
			@BuySellContractId, 
			@TradeDate, 
			@Price, 
			@ContractMonth, 
			@StrikePrice, 
			@FinalTradeDate, 
			@Quantity, 
			@ExecutionAmount, 
			@MarketPrice, 
			@MarketValue, 
			@RealizedPLSign, 
			@RealizedPL,
			@RealizedPLSigned, 
			@Commission, 
			@ConsumptionTax, 
			@ExchangeTax, 
			@TradeNo, 
			@TradeSubNo, 
			@NumberOfStockSharesPerOption, 
			@FullSeriesNo, 
			@OptionIdClose, 
			@CustomerNameAbbreviated, 
			@SecurityNameEnglish, 
			@SecurityNameKana, 
			@TradeCodeClose, 
			@TradeSubCode, 
			@TransactionDate, 
			@CostPaymentMethod
		);

Return Scope_Identity()
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Rule_GetFields]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Rule_GetFields]
AS
SET NOCOUNT ON
	SELECT 
		FieldId, Description
	FROM 
		ib_Field
	ORDER BY
		Description
');

GO
EXECUTE ('PRINT N''Creating [dbo].[eib_Trade_Load]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[eib_Trade_Load] 
(
	@LocationPath VARCHAR(100),
	@StagingFileId int,
	@DataSourceCode VARCHAR(100),
	@ExchangeCode VARCHAR(25),
	@DataSourceFirmCode VARCHAR(100),
	@AccountCode VARCHAR(100) = NULL,
	@DetailAccountCode VARCHAR(100) = NULL,
	@AsOfDate DATETIME,
	@TrxDate DATETIME,
	@TrxTypeCode VARCHAR(25) = NULL,
	@ContractCode VARCHAR(100) = NULL,
	@InstrumentCode VARCHAR(100) = NULL,
	@Quantity DECIMAL(19, 4),
	@CurrencyCode VARCHAR(100),
	@ExpiryYear SMALLINT,
	@ExpiryMonth SMALLINT,
	@ExpiryDay SMALLINT,
	@QuantityLong DECIMAL(19, 4) = NULL,
	@QuantityShort DECIMAL(19, 4) = NULL,
	@Price DECIMAL(24, 10) = NULL,
	@InstrumentType VARCHAR(1) = NULL,
	@StrikePrice DECIMAL(19, 4) = NULL,
	@OptionTypeCode VARCHAR(25) = NULL,
	@MarketValue DECIMAL(19, 4) = NULL,
	@IncludeMarexFirmId bit,
	@ReceiveLocationSysId INT,
	@RunId INT
)
AS
-- History:
-- 09 Jan 2014	ED		EIB 25004 - remove importLog table and use Log table

SET NOCOUNT ON
			
-- Get data source ID and default currency ID
DECLARE @DataSourceId INT
DECLARE @DefaultCurrencyId INT
EXEC [_ib_DataSource_GetByCodeForOutput] @DataSourceCode, @DataSourceId OUTPUT, @DefaultCurrencyId OUTPUT	

-- Get the default Strike Price Divisor
DECLARE	@DefaultStrikePriceDivisor DECIMAL(19,6)
SET @DefaultStrikePriceDivisor = [dbo].[udf_GetDefaultStrikePriceDivisor](@DataSourceId, NULL)

-- We prefix the Instruments with the IntrumentTypeCode
DECLARE @InstrumentCd VARCHAR(100)
IF (@InstrumentCode IS NULL)
	SET @InstrumentCd = @InstrumentType + ''_'' + @ExchangeCode + ''_'' + @ContractCode
ELSE
	SET @InstrumentCd = @InstrumentCode

-- Get Divisors
DECLARE	@PriceDivisor		DECIMAL(19,4)
DECLARE	@StrikePriceDivisor	DECIMAL(19,4)
DECLARE	@MarketValueDivisor	DECIMAL(19,4)			
SELECT @StrikePriceDivisor = ids.StrikePriceDivisor
		, @PriceDivisor = ids.PriceDivisor
		, @MarketValueDivisor = ids.MarketValueDivisor
FROM [dbo].[ib_InstrumentDataSource] ids
WHERE ids.DataSourceId = @DataSourceId
	AND ids.DataSourceInstrumentCode = @InstrumentCd
IF @PriceDivisor IS NULL
	SET @PriceDivisor = 1
IF @MarketValueDivisor IS NULL 
	SET @MarketValueDivisor = 1

-- Set price
SET @Price = @Price / @PriceDivisor

-- Set StrikePrice
IF @InstrumentType = ''F''
	SET @StrikePrice = 0
ELSE
BEGIN
	IF @StrikePriceDivisor IS NULL
		SET @StrikePrice = @StrikePrice / ISNULL(@DefaultStrikePriceDivisor, 1)
	ELSE
		SET @StrikePrice = @StrikePrice / @StrikePriceDivisor
END

DECLARE @MarexFirmId int
IF (@IncludeMarexFirmId = 1)
	SET @MarexFirmId = [dbo].[udf_GetMarexFirmId]()

-- Create trade
EXEC [ib_Trx_Load]
	@DataSourceCode
	, @ExchangeCode		
	, @DataSourceFirmCode
	, @AccountCode
	, @DetailAccountCode
	, @InstrumentCd
	, @ExpiryYear
	, @ExpiryMonth
	, @ExpiryDay
	, @StrikePrice
	, @TrxTypeCode
	, @OptionTypeCode
	, @Quantity
	, @TrxDate				
	, @Price 
	, @StagingFileId
	, @InstrumentType
	, @AsOfDate		
	, @LocationPath
	, @MarketValue
	, @CurrencyCode
	, NULL
	, NULL
	, @MarexFirmId
	, @QuantityLong
	, @QuantityShort
	, @ReceiveLocationSysId
	, @RunId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Class_Add]''
');

GO
EXECUTE ('  /*
<details>
 <summary>Adds a class into the ib_Class table</summary>
 <created author="Laurentiu Macovei" Date=" Thursday 14 September 2006 9:26PM GMT" /> 
</details>
*/
 CREATE PROCEDURE [dbo].[ib_Class_Add]
(
	@Code varchar(100),
    @Description varchar(100),
    @CreateUsername varchar(50),	
    @@ClassId int OUTPUT
)
AS
SET NOCOUNT ON

BEGIN TRY
--check for duplicates 
EXEC [dbo].[ib_Currency_CheckForDuplicate] @Code, @Description, -1

IF @CreateUserName IS NULL
	BEGIN
		SET @CreateUserName = (suser_sname())
	END


INSERT INTO [dbo].[ib_Class]
           ([Code]
           ,[Description]
           ,[CreateUsername])
     VALUES
           (@Code,
            @Description,
            @CreateUsername)
SELECT @@ClassId = Scope_Identity()

END TRY
BEGIN CATCH
	EXEC [dbo].[sp_RethrowError]
END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[aspnet_UsersInRoles_RemoveUsersFromRoles]''
');

GO
SET QUOTED_IDENTIFIER OFF

GO
EXECUTE ('
CREATE PROCEDURE [dbo].[aspnet_UsersInRoles_RemoveUsersFromRoles]
	@ApplicationName  nvarchar(256),
	@UserNames		  nvarchar(4000),
	@RoleNames		  nvarchar(4000)
AS
SET NOCOUNT ON
BEGIN
	DECLARE @AppId uniqueidentifier
	SELECT  @AppId = NULL
	SELECT  @AppId = ApplicationId FROM aspnet_Applications WHERE LOWER(@ApplicationName) = LoweredApplicationName
	IF (@AppId IS NULL)
		RETURN(2)


	DECLARE @TranStarted   bit
	SET @TranStarted = 0

	IF( @@TRANCOUNT = 0 )
	BEGIN
		BEGIN TRANSACTION
		SET @TranStarted = 1
	END

	DECLARE @tbNames  table(Name nvarchar(256) NOT NULL PRIMARY KEY)
	DECLARE @tbRoles  table(RoleId uniqueidentifier NOT NULL PRIMARY KEY)
	DECLARE @tbUsers  table(UserId uniqueidentifier NOT NULL PRIMARY KEY)
	DECLARE @Num	  int
	DECLARE @Pos	  int
	DECLARE @NextPos  int
	DECLARE @Name	  nvarchar(256)
	DECLARE @CountAll int
	DECLARE @CountU	  int
	DECLARE @CountR	  int


	SET @Num = 0
	SET @Pos = 1
	WHILE(@Pos <= LEN(@RoleNames))
	BEGIN
		SELECT @NextPos = CHARINDEX(N'','', @RoleNames,  @Pos)
		IF (@NextPos = 0 OR @NextPos IS NULL)
			SELECT @NextPos = LEN(@RoleNames) + 1
		SELECT @Name = RTRIM(LTRIM(SUBSTRING(@RoleNames, @Pos, @NextPos - @Pos)))
		SELECT @Pos = @NextPos+1

		INSERT INTO @tbNames VALUES (@Name)
		SET @Num = @Num + 1
	END

	INSERT INTO @tbRoles
	  SELECT RoleId
	  FROM   dbo.aspnet_Roles ar, @tbNames t
	  WHERE  LOWER(t.Name) = ar.LoweredRoleName AND ar.ApplicationId = @AppId
	SELECT @CountR = @@ROWCOUNT

	IF (@CountR <> @Num)
	BEGIN
		SELECT TOP 1 N'''', Name
		FROM   @tbNames
		WHERE  LOWER(Name) NOT IN (SELECT ar.LoweredRoleName FROM dbo.aspnet_Roles ar,  @tbRoles r WHERE r.RoleId = ar.RoleId)
		IF( @TranStarted = 1 )
			ROLLBACK TRANSACTION
		RETURN(2)
	END


	DELETE FROM @tbNames WHERE 1=1
	SET @Num = 0
	SET @Pos = 1


	WHILE(@Pos <= LEN(@UserNames))
	BEGIN
		SELECT @NextPos = CHARINDEX(N'','', @UserNames,  @Pos)
		IF (@NextPos = 0 OR @NextPos IS NULL)
			SELECT @NextPos = LEN(@UserNames) + 1
		SELECT @Name = RTRIM(LTRIM(SUBSTRING(@UserNames, @Pos, @NextPos - @Pos)))
		SELECT @Pos = @NextPos+1

		INSERT INTO @tbNames VALUES (@Name)
		SET @Num = @Num + 1
	END

	INSERT INTO @tbUsers
	  SELECT UserId
	  FROM   dbo.aspnet_Users ar, @tbNames t
	  WHERE  LOWER(t.Name) = ar.LoweredUserName AND ar.ApplicationId = @AppId

	SELECT @CountU = @@ROWCOUNT
	IF (@CountU <> @Num)
	BEGIN
		SELECT TOP 1 Name, N''''
		FROM   @tbNames
		WHERE  LOWER(Name) NOT IN (SELECT au.LoweredUserName FROM dbo.aspnet_Users au,  @tbUsers u WHERE u.UserId = au.UserId)

		IF( @TranStarted = 1 )
			ROLLBACK TRANSACTION
		RETURN(1)
	END

	SELECT  @CountAll = COUNT(*)
	FROM	dbo.aspnet_UsersInRoles ur, @tbUsers u, @tbRoles r
	WHERE   ur.UserId = u.UserId AND ur.RoleId = r.RoleId

	IF (@CountAll <> @CountU * @CountR)
	BEGIN
		SELECT TOP 1 UserName, RoleName
		FROM		 @tbUsers tu, @tbRoles tr, dbo.aspnet_Users u, dbo.aspnet_Roles r
		WHERE		 u.UserId = tu.UserId AND r.RoleId = tr.RoleId AND
					 tu.UserId NOT IN (SELECT ur.UserId FROM dbo.aspnet_UsersInRoles ur WHERE ur.RoleId = tr.RoleId) AND
					 tr.RoleId NOT IN (SELECT ur.RoleId FROM dbo.aspnet_UsersInRoles ur WHERE ur.UserId = tu.UserId)
		IF( @TranStarted = 1 )
			ROLLBACK TRANSACTION
		RETURN(3)
	END

	DELETE FROM dbo.aspnet_UsersInRoles
	WHERE UserId IN (SELECT UserId FROM @tbUsers)
	  AND RoleId IN (SELECT RoleId FROM @tbRoles)
	IF( @TranStarted = 1 )
		COMMIT TRANSACTION
	RETURN(0)
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[is_HUnsettledContractDetails]''
');

GO
SET QUOTED_IDENTIFIER ON

GO
EXECUTE ('CREATE TABLE [dbo].[is_HUnsettledContractDetails]
(
[HUnsettledContractDetailsId] [int] NOT NULL IDENTITY(1, 1),
[CorporationCode] [varchar] (4) NULL,
[PrincipalBrokerageId] [varchar] (1) NULL,
[OfficeCode] [varchar] (4) NULL,
[ACNo] [varchar] (10) NULL,
[SecuritiesId] [varchar] (2) NULL,
[BaseDate] [datetime] NULL,
[CalcDate] [datetime] NULL,
[CalcStartTime] [datetime] NULL,
[CalcDateStartTime] [datetime] NULL,
[MarketCode] [varchar] (2) NULL,
[DerivativesCode] [varchar] (10) NULL,
[SecCode1] [varchar] (7) NULL,
[SecCode2] [varchar] (4) NULL,
[SecCode3] [varchar] (2) NULL,
[SecCode4] [varchar] (1) NULL,
[BuySellContractId] [varchar] (2) NULL,
[TradeDate] [datetime] NULL,
[UnitPrice] [decimal] (11, 4) NULL,
[ContractMonth] [varchar] (7) NULL,
[StrikePrice] [decimal] (11, 4) NULL,
[FinalTradeDate] [datetime] NULL,
[Quantity] [decimal] (15, 0) NULL,
[ExecutionAmnt] [decimal] (15, 0) NULL,
[MarketPrice] [decimal] (11, 2) NULL,
[MarketValue] [decimal] (15, 0) NULL,
[UnrealzedPLPlusMinusSign] [varchar] (1) NULL,
[UnrealizedPL] [decimal] (15, 0) NULL,
[UnrealizedPLSigned] [decimal] (15, 0) NULL,
[Commission] [decimal] (15, 0) NULL,
[ConsumptionTax] [decimal] (15, 0) NULL,
[ExchangeTax] [decimal] (15, 0) NULL,
[TradeNo] [varchar] (5) NULL,
[TradeSubNo] [varchar] (3) NULL,
[OptExerciseAllotmentId] [varchar] (1) NULL,
[CustomerNameAbb] [varchar] (35) NULL,
[SecNameInEnglish] [varchar] (28) NULL,
[SecNameInKana] [varchar] (24) NULL,
[TradeCodeClose] [varchar] (2) NULL,
[NightTradingId] [varchar] (1) NULL,
[TradeType] [varchar] (1) NULL,
[ExecutionDate] [datetime] NULL,
[CostPaymentMethod] [varchar] (1) NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_is_HUnsettledContractDetails_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_HUnsettledContractDetails_CreationDate] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_HUnsettledContractDetails] on [dbo].[is_HUnsettledContractDetails]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[is_HUnsettledContractDetails] ADD CONSTRAINT [PK_HUnsettledContractDetails] PRIMARY KEY CLUSTERED  ([HUnsettledContractDetailsId])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[is_HTradeDetails]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[is_HTradeDetails]
(
[HTradeDetailsId] [int] NOT NULL IDENTITY(1, 1),
[CorporationCode] [varchar] (4) NULL,
[PrincipalBrokerageId] [varchar] (1) NULL,
[OfficeCode] [varchar] (4) NULL,
[ACNo] [varchar] (10) NULL,
[SecuritiesId] [varchar] (2) NULL,
[BaseDate] [datetime] NULL,
[CalcDate] [datetime] NULL,
[CalcStartTime] [datetime] NULL,
[CalcDateStartTime] [datetime] NULL,
[TradeDate] [datetime] NULL,
[ExecutionMarketCode] [varchar] (2) NULL,
[DerivativesCode] [varchar] (10) NULL,
[SecCode1] [varchar] (7) NULL,
[SecCode2] [varchar] (4) NULL,
[SecCode3] [varchar] (2) NULL,
[SecCode4] [varchar] (1) NULL,
[TradeCode] [varchar] (2) NULL,
[BuySellId] [varchar] (1) NULL,
[CancelDataId] [varchar] (1) NULL,
[InputDate] [datetime] NULL,
[CancelInputDate] [datetime] NULL,
[OptExerciseAllotmentId] [varchar] (1) NULL,
[SpreadNo] [varchar] (5) NULL,
[AutomaticExerciseAllotmentId] [varchar] (1) NULL,
[TradeNo] [varchar] (5) NULL,
[SubTradeNo] [varchar] (3) NULL,
[ContractMonth] [varchar] (7) NULL,
[StrikePrice] [decimal] (15, 0) NULL,
[Quantity] [decimal] (11, 4) NULL,
[UnitPrice] [decimal] (11, 2) NULL,
[ExecutionAmnt] [decimal] (15, 0) NULL,
[Commission] [decimal] (15, 0) NULL,
[ConsumptionTax] [decimal] (15, 0) NULL,
[ExchangeTax] [decimal] (15, 0) NULL,
[NetAmnt] [decimal] (15, 0) NULL,
[Remarks1] [varchar] (45) NULL,
[Remarks2] [varchar] (45) NULL,
[LocalCustomerInformation] [varchar] (12) NULL,
[CustomerNameAbb] [varchar] (35) NULL,
[SecNameInEnglish] [varchar] (28) NULL,
[SecNameInKana] [varchar] (24) NULL,
[NightTradingId] [varchar] (1) NULL,
[TradeType] [varchar] (1) NULL,
[ExecutionDate] [datetime] NULL,
[CostPaymentMethod] [varchar] (1) NULL,
[MemberCode] [varchar] (4) NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_is_HTradeDetails_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_HTradeDetails_CreationDate] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_HTradeDetails] on [dbo].[is_HTradeDetails]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[is_HTradeDetails] ADD CONSTRAINT [PK_HTradeDetails] PRIMARY KEY CLUSTERED  ([HTradeDetailsId])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[is_HReceiptPaymentDetails]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[is_HReceiptPaymentDetails]
(
[HReceiptPaymentDetailsId] [int] NOT NULL IDENTITY(1, 1),
[CorporationCode] [varchar] (4) NULL,
[PrincipalBrokerageId] [varchar] (1) NULL,
[OfficeCode] [varchar] (4) NULL,
[ACNo] [varchar] (10) NULL,
[SecuritiesId] [varchar] (2) NULL,
[BaseDate] [datetime] NULL,
[CalcDate] [datetime] NULL,
[CalcStartTime] [datetime] NULL,
[CalcDateStartTime] [datetime] NULL,
[MarginId] [varchar] (2) NULL,
[Currency] [varchar] (3) NULL,
[PostDate] [datetime] NULL,
[PaymentReceiptNo] [varchar] (5) NULL,
[DetailsOfCashFlow] [varchar] (1) NULL,
[PaymentReceiptId] [varchar] (1) NULL,
[CancellationId] [varchar] (1) NULL,
[AmntMoved] [decimal] (15, 0) NULL,
[EntryDate] [datetime] NULL,
[InternalBankCode] [varchar] (3) NULL,
[CheckNo] [varchar] (6) NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_is_HReceiptPaymentDetails_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_HReceiptPaymentDetails_CreationDate] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_HReceiptPaymentDetails] on [dbo].[is_HReceiptPaymentDetails]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[is_HReceiptPaymentDetails] ADD CONSTRAINT [PK_HReceiptPaymentDetails] PRIMARY KEY CLUSTERED  ([HReceiptPaymentDetailsId])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[is_HRealizedProfitLossDetails]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[is_HRealizedProfitLossDetails]
(
[HRealizedProfitLossDetailsId] [int] NOT NULL IDENTITY(1, 1),
[CorporationCode] [varchar] (4) NULL,
[PrincipalBrokerageId] [varchar] (1) NULL,
[OfficeCode] [varchar] (4) NULL,
[ACNo] [varchar] (10) NULL,
[SecuritiesId] [varchar] (2) NULL,
[BaseDate] [datetime] NULL,
[CalcDate] [datetime] NULL,
[CalcStartTime] [datetime] NULL,
[CalcDateStartTime] [datetime] NULL,
[TradeDateClose] [datetime] NULL,
[ExecutionMarketCode] [varchar] (2) NULL,
[DerivativesCode] [varchar] (10) NULL,
[SecCode1] [varchar] (7) NULL,
[SecCode2] [varchar] (4) NULL,
[SecCode3] [varchar] (2) NULL,
[SecCode4] [varchar] (1) NULL,
[BuySellIdClose] [varchar] (1) NULL,
[CanceledDataId] [varchar] (1) NULL,
[InputDate] [datetime] NULL,
[CancelInputDate] [datetime] NULL,
[TradeCodeClose] [varchar] (2) NULL,
[OptExerciseAssignmentIdClose] [varchar] (1) NULL,
[TradeNoClose] [varchar] (5) NULL,
[TradeSubNoClose] [varchar] (3) NULL,
[AutomaticExerciseAssignmentId] [varchar] (1) NULL,
[TradeDateOpen] [datetime] NULL,
[BuySellIdOpen] [varchar] (1) NULL,
[TradeCodeOpen] [varchar] (2) NULL,
[OptExerciseAssignmentIdOpen] [varchar] (1) NULL,
[TradeNoOpen] [varchar] (5) NULL,
[TradeSubNoOpen] [varchar] (3) NULL,
[ContractMonth] [varchar] (7) NULL,
[StrikePrice] [decimal] (11, 4) NULL,
[Quantity] [decimal] (15, 0) NULL,
[UnitPriceOpen] [decimal] (11, 4) NULL,
[UnitPriceClose] [decimal] (11, 4) NULL,
[ExecutionAmntOpen] [decimal] (15, 0) NULL,
[ExecutionAmntClose] [decimal] (15, 0) NULL,
[RealizedPLGrossPlusMinusSign] [varchar] (1) NULL,
[RealizedPLGross] [decimal] (15, 0) NULL,
[RealizedPLGrossSigned] [decimal] (15, 0) NULL,
[CommissionOpen] [decimal] (11, 4) NULL,
[CommissionClose] [decimal] (11, 4) NULL,
[ConsumptionTaxOpen] [decimal] (15, 0) NULL,
[ConsumptionTaxClose] [decimal] (15, 0) NULL,
[ExchangeTaxOpen] [decimal] (11, 4) NULL,
[ExchangeTaxClose] [decimal] (15, 0) NULL,
[RealizedPLNetSign] [varchar] (1) NULL,
[RealizedPLNet] [decimal] (15, 0) NULL,
[RealizedPLNetSigned] [decimal] (15, 0) NULL,
[CustomerNameAbb] [varchar] (35) NULL,
[SecNameInEnglish] [varchar] (28) NULL,
[SecNameInKana] [varchar] (24) NULL,
[NightTradingIdOpen] [varchar] (1) NULL,
[NightTradingIdClose] [varchar] (1) NULL,
[TradeTypeOpen] [varchar] (1) NULL,
[TradeTypeClose] [varchar] (1) NULL,
[ExecutionDateOpen] [datetime] NULL,
[ExecutionDateClose] [datetime] NULL,
[CostPaymentMethod] [varchar] (1) NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_is_HRealizedProfitLossDetails_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_HRealizedProfitLossDetails_CreationDate] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_HRealizedProfitLossDetails] on [dbo].[is_HRealizedProfitLossDetails]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[is_HRealizedProfitLossDetails] ADD CONSTRAINT [PK_HRealizedProfitLossDetails] PRIMARY KEY CLUSTERED  ([HRealizedProfitLossDetailsId])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[is_HProductTotal]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[is_HProductTotal]
(
[HProductTotalId] [int] NOT NULL IDENTITY(1, 1),
[CorporationCode] [varchar] (4) NULL,
[PrincipalBrokerageId] [varchar] (1) NULL,
[OfficeCode] [varchar] (4) NULL,
[ACNo] [varchar] (10) NULL,
[SecuritiesId] [varchar] (2) NULL,
[BaseDate] [datetime] NULL,
[CalcDate] [datetime] NULL,
[CalcStartTime] [datetime] NULL,
[CalcDateStartTime] [datetime] NULL,
[DerivativesCode] [varchar] (10) NULL,
[QuantityOfBuyContract] [decimal] (10, 0) NULL,
[QuantityOfSellContract] [decimal] (10, 0) NULL,
[UnrealizedPLSign] [varchar] (1) NULL,
[UnrealizedPL] [decimal] (15, 0) NULL,
[UnrealizedPLSigned] [decimal] (15, 0) NULL,
[UnrealizedPLNonCalculableFlag] [varchar] (1) NULL,
[AdjForThePreviousDaySTradeSign] [varchar] (1) NULL,
[AdjForThePreviousDaySTrade] [decimal] (15, 0) NULL,
[AdjForThePreviousDaySTradeSigned] [decimal] (15, 0) NULL,
[AdjFuturesRealizedPLSign] [varchar] (1) NULL,
[AdjFuturesRealizedPL] [decimal] (15, 0) NULL,
[AdjFuturesRealizedPLSigned] [decimal] (15, 0) NULL,
[AdjOptPremiumBuySign] [varchar] (1) NULL,
[AdjOptPremiumBuy] [decimal] (15, 0) NULL,
[AdjOptPremiumBuySigned] [decimal] (15, 0) NULL,
[AdjOptPremiumSellSign] [varchar] (1) NULL,
[AdjOptPremiumSell] [decimal] (15, 0) NULL,
[AdjOptPremiumSellSigned] [decimal] (15, 0) NULL,
[AdjNetStrikePriceOptExerciseSign] [varchar] (1) NULL,
[AdjNetStrikePriceOptExercise] [decimal] (15, 0) NULL,
[AdjNetStrikePriceOptExerciseSigned] [decimal] (15, 0) NULL,
[AdjNetStrikePriceOptAssignmentSign] [varchar] (1) NULL,
[AdjNetStrikePriceOptAssignment] [decimal] (15, 0) NULL,
[AdjNetStrikePriceOptAssignmentSigned] [decimal] (15, 0) NULL,
[AdjCommissionSign] [varchar] (1) NULL,
[AdjCommission] [decimal] (15, 0) NULL,
[AdjCommissionSigned] [decimal] (15, 0) NULL,
[AdjConsumptionTaxSign] [varchar] (1) NULL,
[AdjConsumptionTax] [decimal] (15, 0) NULL,
[AdjConsumptionTaxSigned] [decimal] (15, 0) NULL,
[AdjExchangeTaxSign] [varchar] (1) NULL,
[AdjExchangeTax] [decimal] (15, 0) NULL,
[AdjExchangeTaxSigned] [decimal] (15, 0) NULL,
[SettlementAmntFromTradesSign] [varchar] (1) NULL,
[SettlementAmntFromTrades] [decimal] (15, 0) NULL,
[SettlementAmntFromTradesSigned] [decimal] (15, 0) NULL,
[FuturesRealizedPLOTDSign] [varchar] (1) NULL,
[FuturesRealizedPLOTD] [decimal] (15, 0) NULL,
[FuturesRealizedPLOTDSigned] [decimal] (15, 0) NULL,
[OptPremiumOTDBuySign] [varchar] (1) NULL,
[OptPremiumOTDBuy] [decimal] (15, 0) NULL,
[OptPremiumOTDBuySigned] [decimal] (15, 0) NULL,
[OptPremiumOTDSellSign] [varchar] (1) NULL,
[OptPremiumOTDSell] [decimal] (15, 0) NULL,
[OptPremiumOTDSellSigned] [decimal] (15, 0) NULL,
[NetStrikePOTDOptExerciseSign] [varchar] (1) NULL,
[NetStrikePOTDOptExercise] [decimal] (15, 0) NULL,
[NetStrikePOTDOptExerciseSigned] [decimal] (15, 0) NULL,
[NetStrikePOTDOptAssignmentSign] [varchar] (1) NULL,
[NetStrikePOTDOptAssignment] [decimal] (15, 0) NULL,
[NetStrikePOTDOptAssignmentSigned] [decimal] (15, 0) NULL,
[CommissionOTDSign] [varchar] (1) NULL,
[CommissionOTD] [decimal] (15, 0) NULL,
[CommissionOTDSigned] [decimal] (15, 0) NULL,
[ConsumptionTaxOTDSign] [varchar] (1) NULL,
[ConsumptionTaxOTD] [decimal] (15, 0) NULL,
[ConsumptionTaxOTDSigned] [decimal] (15, 0) NULL,
[ExchangeTaxOTDSign] [varchar] (1) NULL,
[ExchangeTaxOTD] [decimal] (15, 0) NULL,
[ExchangeTaxOTDSigned] [decimal] (15, 0) NULL,
[SecNameInEnglish] [varchar] (28) NULL,
[SecNameInKana] [varchar] (24) NULL,
[BuyOptValue] [decimal] (15, 0) NULL,
[SellOptValue] [decimal] (15, 0) NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_is_HProductTotal_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_HProductTotal_CreationDate] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_HProductTotal] on [dbo].[is_HProductTotal]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[is_HProductTotal] ADD CONSTRAINT [PK_HProductTotal] PRIMARY KEY CLUSTERED  ([HProductTotalId])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[is_HCollateralSecuritiesMovement]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[is_HCollateralSecuritiesMovement]
(
[HCollateralSecuritiesMovementId] [int] NOT NULL IDENTITY(1, 1),
[CorporationCode] [varchar] (4) NULL,
[PrincipalBrokerageId] [varchar] (1) NULL,
[OfficeCode] [varchar] (4) NULL,
[ACNo] [varchar] (10) NULL,
[SecuritiesId] [varchar] (2) NULL,
[BaseDate] [datetime] NULL,
[CalcDate] [datetime] NULL,
[CalcStartTime] [datetime] NULL,
[CalcDateStartTime] [datetime] NULL,
[DepositId] [varchar] (2) NULL,
[DateOfDepositWithdrawal] [datetime] NULL,
[DepositWithdrawalId] [varchar] (1) NULL,
[ProductCode] [varchar] (2) NULL,
[CompanyCode] [varchar] (7) NULL,
[SeriesNo] [varchar] (4) NULL,
[SubSeriesNo] [varchar] (2) NULL,
[OldNewId] [varchar] (1) NULL,
[DepositDate] [datetime] NULL,
[RecordNo] [varchar] (5) NULL,
[Quantity] [decimal] (15, 0) NULL,
[MarketValue] [decimal] (15, 0) NULL,
[CollateralRate] [varchar] (3) NULL,
[UnitValuePerCollateral] [decimal] (15, 0) NULL,
[EvaluationOfCollatSec] [decimal] (15, 0) NULL,
[CustodianCode] [varchar] (3) NULL,
[DepositaryReceiptNo] [varchar] (5) NULL,
[JasdecMemberCode] [varchar] (7) NULL,
[DirectCustodian] [varchar] (2) NULL,
[CustomerNameAbb] [varchar] (35) NULL,
[SecNameInEnglish] [varchar] (28) NULL,
[SecNameInKana] [varchar] (24) NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_is_HCollateralSecuritiesMovement_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_HCollateralSecuritiesMovement_CreationDate] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_HCollateralSecuritiesMovement] on [dbo].[is_HCollateralSecuritiesMovement]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[is_HCollateralSecuritiesMovement] ADD CONSTRAINT [PK_HCollateralSecuritiesMovement] PRIMARY KEY CLUSTERED  ([HCollateralSecuritiesMovementId])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[is_HCollateralSecuritiesDetails]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[is_HCollateralSecuritiesDetails]
(
[HCollateralSecuritiesDetailsId] [int] NOT NULL IDENTITY(1, 1),
[CorporationCode] [varchar] (4) NULL,
[PrincipalBrokerageId] [varchar] (1) NULL,
[OfficeCode] [varchar] (4) NULL,
[ACNo] [varchar] (10) NULL,
[SecuritiesId] [varchar] (2) NULL,
[BaseDate] [datetime] NULL,
[CalcDate] [datetime] NULL,
[CalcStartTime] [datetime] NULL,
[CalcDateStartTime] [datetime] NULL,
[DepositId] [varchar] (2) NULL,
[ProductCode] [varchar] (2) NULL,
[CompanyCode] [varchar] (7) NULL,
[SeriesNo] [varchar] (4) NULL,
[SubSeriesNo] [varchar] (2) NULL,
[OldNewId] [varchar] (1) NULL,
[DepositDate] [datetime] NULL,
[WithdrawalDate] [datetime] NULL,
[RecordNo] [varchar] (5) NULL,
[Quantity] [decimal] (15, 0) NULL,
[MarketValue] [decimal] (15, 0) NULL,
[CollateralRate] [varchar] (3) NULL,
[UnitValuePerCollateral] [decimal] (15, 0) NULL,
[EvaluationOfCollatSec] [decimal] (15, 0) NULL,
[CustodianCode] [varchar] (3) NULL,
[DepositaryReceiptNo] [varchar] (5) NULL,
[JasdecMemberCode] [varchar] (7) NULL,
[DirectCustodian] [varchar] (2) NULL,
[CustomerNameAbb] [varchar] (35) NULL,
[SecNameInEnglish] [varchar] (28) NULL,
[SecNameInKana] [varchar] (24) NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_is_HCollateralSecuritiesDetails_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_is_HCollateralSecuritiesDetails_CreateDate] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_HCollateralSecuritiesDetails] on [dbo].[is_HCollateralSecuritiesDetails]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[is_HCollateralSecuritiesDetails] ADD CONSTRAINT [PK_HCollateralSecuritiesDetails] PRIMARY KEY CLUSTERED  ([HCollateralSecuritiesDetailsId])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[is_HAccountTotal]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[is_HAccountTotal]
(
[HAccountTotalId] [int] NOT NULL IDENTITY(1, 1),
[CorporationCode] [varchar] (4) NULL,
[PrincipalBrokerageId] [varchar] (1) NULL,
[OfficeCode] [varchar] (4) NULL,
[ACNo] [varchar] (10) NULL,
[SecuritiesId] [varchar] (2) NULL,
[BaseDate] [varchar] (20) NULL,
[CalculationDate] [datetime] NULL,
[CalculationStartTime] [datetime] NULL,
[CalculationDateStartTime] [datetime] NULL,
[FinalCashBalanceofPreviousDaySign] [varchar] (1) NULL,
[FinalCashBalanceofPreviousDay] [decimal] (15, 0) NULL,
[FinalCashBalanceofPreviousDaySigned] [decimal] (15, 0) NULL,
[SettlementAmntOfThePreviousDaySTradeSign] [varchar] (1) NULL,
[SettlementAmntOfThePreviousDaySTrade] [decimal] (15, 0) NULL,
[SettlementAmntOfThePreviousDaySTradeSigned] [decimal] (15, 0) NULL,
[PreviousDaySReportedCashBalanceSign] [varchar] (1) NULL,
[PreviousDaySReportedCashBalance] [decimal] (15, 0) NULL,
[PreviousDaySReportedCashBalanceSigned] [decimal] (15, 0) NULL,
[AdjustmentFPDFuturesRealizedPLSign] [varchar] (1) NULL,
[AdjustmentFPDFuturesRealizedPL] [decimal] (15, 0) NULL,
[AdjustmentFPDFuturesRealizedPLSigned] [decimal] (15, 0) NULL,
[AdjustmentFPDOptionsPremiumAmountBuySign] [varchar] (1) NULL,
[AdjustmentFPDOptionsPremiumAmountBuy] [decimal] (15, 0) NULL,
[AdjustmentFPDOptionsPremiumAmountBuySigned] [decimal] (15, 0) NULL,
[AdjustmentFPDOptionsPremiumAmountSellSign] [varchar] (1) NULL,
[AdjustmentFPDOptionsPremiumAmountSell] [decimal] (15, 0) NULL,
[AdjustmentFPDOptionsPremiumAmountSellSigned] [decimal] (15, 0) NULL,
[AdjustmentFPDNetStrikePriceForExerciseSign] [varchar] (1) NULL,
[AdjustmentFPDNetStrikePriceForExercise] [decimal] (15, 0) NULL,
[AdjustmentFPDNetStrikePriceForExerciseSigned] [decimal] (15, 0) NULL,
[AdjustmentFPDNetStrikePriceForAllotmentSign] [varchar] (1) NULL,
[AdjustmentFPDNetStrikePriceForAllotment] [decimal] (15, 0) NULL,
[AdjustmentFPDNetStrikePriceForAllotmentSigned] [decimal] (15, 0) NULL,
[AdjustmentFPDDomesticCommissionSign] [varchar] (1) NULL,
[AdjustmentFPDDomesticCommission] [decimal] (15, 0) NULL,
[AdjustmentFPDDomesticCommissionSigned] [decimal] (15, 0) NULL,
[AdjustmentFPDConsumptionTaxOnCommissionSign] [varchar] (1) NULL,
[AdjustmentFPDConsumptionTaxOnCommission] [decimal] (15, 0) NULL,
[AdjustmentFPDConsumptionTaxOnCommissionSigned] [decimal] (15, 0) NULL,
[AdjustmentFPDExchangeTaxSign] [varchar] (1) NULL,
[AdjustmentFPDExchangeTax] [decimal] (15, 0) NULL,
[AdjustmentFPDExchangeTaxSigned] [decimal] (15, 0) NULL,
[AdjustmentFPDCashFlowSign] [varchar] (1) NULL,
[AdjustmentFPDCashFlow] [decimal] (15, 0) NULL,
[AdjustmentFPDCashFlowSigned] [decimal] (15, 0) NULL,
[AdjustmentFPDTradeSign] [varchar] (1) NULL,
[AdjustmentFPDTrade] [decimal] (15, 0) NULL,
[AdjustmentFPDTradeSigned] [decimal] (15, 0) NULL,
[CashPaidReceivedSign] [varchar] (1) NULL,
[CashPaidReceived] [decimal] (15, 0) NULL,
[CashPaidReceivedSigned] [decimal] (15, 0) NULL,
[EndingCashBalanceSign] [varchar] (1) NULL,
[EndingCashBalance] [decimal] (15, 0) NULL,
[EndingCashBalanceSigned] [decimal] (15, 0) NULL,
[SettlementAmountFCDTradingSign] [varchar] (1) NULL,
[SettlementAmountFCDTrading] [decimal] (15, 0) NULL,
[SettlementAmountFCDTradingSigned] [decimal] (15, 0) NULL,
[FuturesRealizedPLOTDSign] [varchar] (1) NULL,
[FuturesRealizedPLOTD] [decimal] (15, 0) NULL,
[FuturesRealizedPLOTDSigned] [decimal] (15, 0) NULL,
[OptPremiumOTDBuySign] [varchar] (1) NULL,
[OptPremiumOTDBuy] [decimal] (15, 0) NULL,
[OptPremiumOTDBuySigned] [decimal] (15, 0) NULL,
[OptPremiumOTDSellSign] [varchar] (1) NULL,
[OptPremiumOTDSell] [decimal] (15, 0) NULL,
[OptPremiumOTDSellSigned] [decimal] (15, 0) NULL,
[NetStrikePOTDOptExerciseSign] [varchar] (1) NULL,
[NetStrikePOTDOptExercise] [decimal] (15, 0) NULL,
[NetStrikePOTDOptExerciseSigned] [decimal] (15, 0) NULL,
[NetStrikePOTDOptAssignmentSign] [varchar] (1) NULL,
[NetStrikePOTDOptAssignment] [decimal] (15, 0) NULL,
[NetStrikePOTDOptAssignmentSigned] [decimal] (15, 0) NULL,
[DomesticCommissionOTDSign] [varchar] (1) NULL,
[DomesticCommissionOTD] [decimal] (15, 0) NULL,
[DomesticCommissionOTDSigned] [decimal] (15, 0) NULL,
[ConsumptionTaxOnCommissionOTDSign] [varchar] (1) NULL,
[ConsumptionTaxOnCommissionOTD] [decimal] (15, 0) NULL,
[ConsumptionTaxOnCommissionOTDSigned] [decimal] (15, 0) NULL,
[ExchangeTaxOTDSign] [varchar] (1) NULL,
[ExchangeTaxOTD] [decimal] (15, 0) NULL,
[ExchangeTaxOTDSigned] [decimal] (15, 0) NULL,
[ReportedCashBalanceOTDSign] [varchar] (1) NULL,
[ReportedCashBalanceOTD] [decimal] (15, 0) NULL,
[ReportedCashBalanceOTDSigned] [decimal] (15, 0) NULL,
[UnrealizedPLSign] [varchar] (1) NULL,
[UnrealizedPL] [decimal] (15, 0) NULL,
[UnrealizedPLSigned] [decimal] (15, 0) NULL,
[MarketValueNonCalculableFlag] [varchar] (1) NULL,
[TotalMarginMoneySign] [varchar] (1) NULL,
[TotalMarginMoney] [decimal] (15, 0) NULL,
[TotalMarginMoneySigned] [decimal] (15, 0) NULL,
[PresentCollateralBalanceDirectDepositToTiffe] [decimal] (15, 0) NULL,
[PresentCollateralBalanceDirectDepositToMemberFirm] [decimal] (15, 0) NULL,
[PresentCollateralBalanceReplacementDeposit] [decimal] (15, 0) NULL,
[PresentCollateralBalanceTotal] [decimal] (15, 0) NULL,
[NextDayCollateralMovementSignDirectDepositToTiffe] [varchar] (1) NULL,
[NextDayCollateralMovementDirectDepositTo] [decimal] (15, 0) NULL,
[NextDayCollateralMovementSignDirectDepositToMemberFirm] [varchar] (1) NULL,
[NextDayCollateralMovementDirectDepositToMemberFirm] [decimal] (15, 0) NULL,
[NextDayCollateralMovementDirectDepositToMemberFirmSigned] [decimal] (15, 0) NULL,
[NextDayCollateralMovementSignReplacementDeposit] [varchar] (1) NULL,
[NextDayCollateralMovementReplacementDeposit] [decimal] (15, 0) NULL,
[NextDayCollateralMovementReplacementDepositSigned] [decimal] (15, 0) NULL,
[NextDayCollateralMovementTotalSign] [varchar] (1) NULL,
[NextDayCollateralMovementTotal] [decimal] (15, 0) NULL,
[NextDayCollateralMovementTotalSigned] [decimal] (15, 0) NULL,
[CollateralEvaluationNonCalculableFlagTotal] [varchar] (1) NULL,
[TotalAmntOfMarginSign] [varchar] (1) NULL,
[TotalAmntOfMargin] [decimal] (15, 0) NULL,
[TotalAmntOfMarginSigned] [decimal] (15, 0) NULL,
[MarginRequirement] [decimal] (15, 0) NULL,
[MarginRequirementNonCalculableFlag] [varchar] (1) NULL,
[NewContractFlag] [varchar] (1) NULL,
[BuyOptValue] [decimal] (15, 0) NULL,
[SellOptValue] [decimal] (15, 0) NULL,
[MarginExcessDeficitTotalSign] [varchar] (1) NULL,
[MarginExcessDeficitTotal] [decimal] (15, 0) NULL,
[MarginExcessDeficitTotalSigned] [decimal] (15, 0) NULL,
[MarginExcessDeficitCashSign] [varchar] (1) NULL,
[MarginExcessDeficitCash] [decimal] (15, 0) NULL,
[MarginExcessDeficitCashSigned] [decimal] (15, 0) NULL,
[StandardMarginAmntInCashSign] [varchar] (1) NULL,
[StandardMarginAmntInCash] [decimal] (15, 0) NULL,
[StandardMarginAmntInCashSigned] [decimal] (15, 0) NULL,
[SettlementDate] [datetime] NULL,
[NextDaySCashFlowSign] [varchar] (1) NULL,
[NextDaySCashFlow] [decimal] (15, 0) NULL,
[NextDaySCashFlowSigned] [decimal] (15, 0) NULL,
[TheDayAfterNextCashFlowSign] [varchar] (1) NULL,
[TheDayAfterNextCashFlow] [decimal] (15, 0) NULL,
[TheDayAfterNextCashFlowSigned] [decimal] (15, 0) NULL,
[TheDayAfterNextCollateralMovementSign] [varchar] (1) NULL,
[TheDayAfterNextCollateralMovement] [decimal] (15, 0) NULL,
[TheDayAfterNextCollateralMovementSigned] [decimal] (15, 0) NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_is_HAccountTotal_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_HAccountTotal_CreationDate] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_HAccountTotal] on [dbo].[is_HAccountTotal]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[is_HAccountTotal] ADD CONSTRAINT [PK_HAccountTotal] PRIMARY KEY CLUSTERED  ([HAccountTotalId])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[is_HAccountAttribute]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[is_HAccountAttribute]
(
[HAccountAttributeId] [int] NOT NULL IDENTITY(1, 1),
[CorporationCode] [varchar] (4) NULL,
[PrincipalBrokerageId] [varchar] (1) NULL,
[OfficeCode] [varchar] (4) NULL,
[ACNo] [varchar] (10) NULL,
[SecuritiesId] [varchar] (2) NULL,
[BaseDate] [datetime] NULL,
[CalcDate] [datetime] NULL,
[CalcStartTime] [datetime] NULL,
[CalcDateStartTime] [datetime] NULL,
[SettlementCycle] [varchar] (1) NULL,
[SettlementMethod] [varchar] (2) NULL,
[Remarks] [varchar] (45) NULL,
[DailyStatementId] [varchar] (1) NULL,
[DailyStatementIdTradeDetails] [varchar] (1) NULL,
[DailyStatementIdAccountTotal] [varchar] (1) NULL,
[DailyStatementIdOpenContract] [varchar] (1) NULL,
[DailyStatementCashFlow] [varchar] (1) NULL,
[DailyStatementCollatSecMovement] [varchar] (1) NULL,
[DailyStatementCollatSecDetails] [varchar] (1) NULL,
[BusinessId] [varchar] (2) NULL,
[BranchCodeOfTrustBK] [varchar] (4) NULL,
[FundNumber] [varchar] (10) NULL,
[FundName] [varchar] (20) NULL,
[CommissionSettlementId] [varchar] (1) NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_is_HAccountAttribute_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_HAccountAttribute_CreationDate] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_HAccountAttribute] on [dbo].[is_HAccountAttribute]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[is_HAccountAttribute] ADD CONSTRAINT [PK_HAccountAttribute] PRIMARY KEY CLUSTERED  ([HAccountAttributeId])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[is_H_LoadStateChange]''
');

GO
EXECUTE ('


-- =============================================
-- Author:		Lee Manifold
-- Create date: 12 Jul 2006
-- Description:	Changes the LoadState of the is_G type tables
-- =============================================
CREATE PROCEDURE [dbo].[is_H_LoadStateChange] 
	-- Add the parameters for the stored procedure here
	(
	@OldLoadState	TINYINT,
	@NewLoadState	TINYINT,
	@RecordDate		DATETIME = NULL
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	-- Need to add code to handle RecordDate
	IF @RecordDate IS NOT NULL 
	BEGIN
		UPDATE [dbo].[is_HAccountAttribute] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState

		UPDATE [dbo].[is_HCollateralSecuritiesDetails] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState
		
		UPDATE [dbo].[is_HCollateralSecuritiesMovement] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState

		UPDATE [dbo].[is_HProductTotal] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState		

		UPDATE [dbo].[is_HRealizedProfitLossDetails] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState
		
		UPDATE [dbo].[is_HReceiptPaymentDetails] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState
		
		UPDATE [dbo].[is_HTradeDetails] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState
		
		UPDATE [dbo].[is_HUnsettledContractDetails] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState

		UPDATE [dbo].[is_HAccountTotal] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState

	END

	IF @RecordDate IS NULL 
	BEGIN

		UPDATE [dbo].[is_HAccountAttribute] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState

		UPDATE [dbo].[is_HCollateralSecuritiesDetails] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState
		
		UPDATE [dbo].[is_HCollateralSecuritiesMovement] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState

		UPDATE [dbo].[is_HProductTotal] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState		

		UPDATE [dbo].[is_HRealizedProfitLossDetails] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState
		
		UPDATE [dbo].[is_HReceiptPaymentDetails] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState
		
		UPDATE [dbo].[is_HTradeDetails] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState
		
		UPDATE [dbo].[is_HUnsettledContractDetails] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState

		UPDATE [dbo].[is_HAccountTotal] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState

	END


END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Rule_GetFirms]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Rule_GetFirms]
	@ruleId int
AS
SET NOCOUNT ON
	SELECT DISTINCT
		F.FirmId, F.Code, F.Name
	FROM
		ib_Firm F
	INNER JOIN
		ib_TemplateGroup TG ON TG.FirmId = F.FirmId
	INNER JOIN
		ib_Rule R ON R.TemplateId = TG.TemplateId AND R.RuleId = @ruleId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[GetInstrumentTickSizeByInstrumentId]''
');

GO
EXECUTE ('CREATE FUNCTION [dbo].[GetInstrumentTickSizeByInstrumentId]
(
	@InstrumentId INT
)
RETURNS DECIMAL(24, 10)
AS

--	18 May 2010		ED		Creation
--	25 Aug 2010		amk		MBAL-16524 bug fix, return decimal portion too!

BEGIN
	DECLARE @Tick DECIMAL(24, 10)
	
	SELECT @Tick = ISNULL(TickSize, 1)
		FROM ib_Instrument i 
		WHERE i.InstrumentId = @InstrumentId
		
	IF (@Tick = 0) SET @Tick = 1
	
	RETURN @Tick
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Instrument_GetInstrumentTickSizeByInstrumentId]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Instrument_GetInstrumentTickSizeByInstrumentId]
(
	@InstrumentId INT
)
AS
SET NOCOUNT ON
	/*
--	
--	Created 25 May 2010 ED
*/
SELECT [dbo].[GetInstrumentTickSizeByInstrumentId](@InstrumentId)
');

GO
EXECUTE ('PRINT N''Creating [dbo].[GetSettlementPriceByAlternateKey]''
');

GO
EXECUTE ('CREATE FUNCTION [dbo].[GetSettlementPriceByAlternateKey]
(
	@AsOfDate DATETIME,
    @DataSourceId INT,
    @ExchangeId INT,
    @InstrumentId INT,
    @CurrencyId INT,
    @ExpiryYear SMALLINT,
    @ExpiryMonth SMALLINT,
    @ExpiryDay SMALLINT,
    @StrikePrice MONEY,
    @OptionTypeCode VARCHAR(25)
)
RETURNS DECIMAL(24,10)
AS
/*
--	get settlement price
--	Created 18 May 2010 ED
*/
BEGIN
	DECLARE @SettlementPrice DECIMAL(24,10)
	
	SELECT @SettlementPrice = SettlementPrice FROM ib_Price 
			WHERE [AsOfDate] = @AsOfDate AND [DataSourceId] = @DataSourceId AND [ExchangeId] = @ExchangeId AND [InstrumentId] = @InstrumentId AND [CurrencyId] = @CurrencyId AND [ExpiryYear] = @ExpiryYear AND [ExpiryMonth] = @ExpiryMonth 
			AND ([ExpiryDay] = @ExpiryDay OR (ExpiryDay IS NULL AND @ExpiryDay IS NULL)) 
			AND ([StrikePrice] = @StrikePrice OR (ISNULL(StrikePrice,0)=0 AND ISNULL(@StrikePrice,0)=0)) 
			AND ([OptionTypeCode] = @OptionTypeCode OR (ISNULL(OptionTypeCode,'''')='''' AND ISNULL(@OptionTypeCode,'''')='''')) 
	RETURN @SettlementPrice
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Adjustment_Load]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Adjustment_Load]
(
	@AdjustmentType VARCHAR(5),
	@TemplateId INT,
	@ExchangeId INT,
	@InstrumentId INT,
	@InternalExternalCode VARCHAR(1),
	@TradeDate DATETIME,
	@AdjustmentDate DATETIME,
	@Quantity INT,
	@QuantityLong INT,
	@QuantityShort INT,
	@CurrencyId INT,
	@ExpiryYear INT,
	@ExpiryMonth INT,
	@ExpiryDay INT = NULL,
	@StrikePrice DECIMAL(24,10), 
	@TradePrice DECIMAL(24,10), 
	@SettlementPrice DECIMAL(24,10) = NULL, 
	@OptionTypeCode VARCHAR(25), 
	@Value DECIMAL(24,10) = NULL, 
	@IsBuy BIT,
	@MatchCodeId INT,
	@DataSourceId INT,
	@FirmId INT,
	@AccountId INT,
	@DetailAccountId INT = NULL,
	@TrxTypeCode VARCHAR (25) = NULL, 
	@AdjustmentId INT OUTPUT
)
AS
-- Description: Load Adjustments
-- 27 Jun 2014		ED		Created EIB 25768
-- 30 Sep 2014		ED		EIB 26042 - fix value formula for Premium instruments
BEGIN
SET NOCOUNT ON 

BEGIN TRY
	BEGIN TRAN

	DECLARE @PremiumInstrumentTypeId INT
	SET @PremiumInstrumentTypeId = (SELECT InstrumentTypeId FROM ib_InstrumentType WHERE Code = ''P'')


	DECLARE @AdjustmentTypeId INT
	DECLARE @AdjustmentHeaderId INT

	SELECT @AdjustmentTypeId = AdjustmentTypeId  FROM ib_AdjustmentType WHERE Code = @AdjustmentType
	
	INSERT INTO [dbo].[ib_AdjustmentHeader] ([AdjustmentTypeId])
		SELECT @AdjustmentTypeId
	SET @AdjustmentHeaderId = SCOPE_IDENTITY()
	
	SET @SettlementPrice = ISNULL(@SettlementPrice, ISNULL([dbo].[GetSettlementPriceByAlternateKey](@AdjustmentDate, @DataSourceId, @ExchangeId, @InstrumentId, @CurrencyId, 
						@ExpiryYear, @ExpiryMonth, @ExpiryDay, @StrikePrice, @OptionTypeCode), 0))
	DECLARE @Tick DECIMAL(24, 10), @InstrumentTypeId INT
	
	SET @Tick = NULL
	SET @InstrumentTypeId = NULL
	SELECT @Tick = ISNULL(TickSize, 1), @InstrumentTypeId = InstrumentTypeId FROM ib_Instrument i WHERE i.InstrumentId = @InstrumentId
		
	IF (@Tick = 0 OR @Tick IS NULL) SET @Tick = 1
	IF (@InstrumentTypeId = @PremiumInstrumentTypeId)
		SET @Value = ISNULL(@Value, -1 * @TradePrice * @Tick * @Quantity * (CASE WHEN @IsBuy = 1 THEN 1 ELSE -1 END))
	ELSE
		SET @Value = ISNULL(@Value, (@SettlementPrice - @TradePrice) * @Tick * @Quantity * (CASE WHEN @IsBuy = 1 THEN 1 ELSE -1 END))

	INSERT INTO [dbo].[ib_Adjustment] 
		([TemplateId], 
		[ExchangeId], 
		[InstrumentId], 
		[InternalExternalCode],
		[TradeDate], 
		[AdjustmentDate], 
		[Quantity], 
		[CurrencyId], 
		[ExpiryYear], 
		[ExpiryMonth], 
		[ExpiryDay], 
		[StrikePrice], 
		[TradePrice], 
		[SettlementPrice], 
		[OptionTypeCode], 
		[VALUE], 
		[IsBuy], 
		[MatchCodeId], 
		[AdjustmentHeaderId], 
		[DataSourceId], 
		[FirmId], 
		[QuantityLong], 
		[QuantityShort], 
		[DetailAccountId], 
		[AccountId], 
		[TrxTypeCode])
	SELECT 
		@TemplateId, 
		@ExchangeId, 
		@InstrumentId, 
		@InternalExternalCode, 
		@TradeDate, 
		@AdjustmentDate, 
		@Quantity, 
		@CurrencyId,
		@ExpiryYear, 
		@ExpiryMonth, 
		@ExpiryDay,
		@StrikePrice, 
		@TradePrice, 
		@SettlementPrice,
		@OptionTypeCode, 
		@Value, 
		@IsBuy, 
		@MatchCodeId, 
		@AdjustmentHeaderId, 
		@DataSourceId, 
		@FirmId, 
		@QuantityLong, 
		@QuantityShort, 
		@DetailAccountId, 
		@AccountId, 
		@TrxTypeCode
		
		SELECT @AdjustmentId = SCOPE_IDENTITY()
	COMMIT TRAN
END TRY
BEGIN CATCH
	ROLLBACK TRAN
	EXEC [dbo].[sp_RethrowError]
END CATCH

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[GetPreviousBusinessDay]''
');

GO
EXECUTE ('CREATE FUNCTION [dbo].[GetPreviousBusinessDay]
(
	@AsOfDate DATETIME
)
RETURNS DATETIME
AS

--	03 Aug 2010		amk		Creation

BEGIN
	DECLARE @PreviousAsOfDate DATETIME
	SET @PreviousAsOfDate = DATEADD(dd, -1, @AsOfDate)
	IF DATENAME(Weekday, @PreviousAsOfDate) = ''Sunday'' 
	BEGIN
		SET @PreviousAsOfDate = DATEADD(dd, -2, @PreviousAsOfDate)
	END
	IF DATENAME(Weekday, @PreviousAsOfDate) = ''Saturday'' 
	BEGIN
		SET @PreviousAsOfDate = DATEADD(dd, -1, @PreviousAsOfDate)
	END
	RETURN @PreviousAsOfDate
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[GetMatchCodeIdForAdjustmentsInsert]''
');

GO
EXECUTE ('CREATE FUNCTION [dbo].[GetMatchCodeIdForAdjustmentsInsert]
(
	@AccountCode VARCHAR(100),
	@ExchangeCode VARCHAR(100),
	@FirmCode VARCHAR(100),
	@TemplateId INT
)
RETURNS INT
AS
--	Description: GetMatchCodeIdForAdjustmentsInsert
--	25 Jun 2014		ED		EIB 25768 - Created
--	09 Jul 2014		ED		EIB 25774 - changed logic
BEGIN

	DECLARE @FirmId INT, @ExchangeId INT, @MatchCodeId INT, @ClassId INT, @AccountId INT
	
	SET @ExchangeId = (SELECT ExchangeId FROM ib_Exchange WHERE Code = @ExchangeCode)
	SET @FirmId = (SELECT FirmId FROM ib_Firm WHERE Code = @FirmCode)
	
	SELECT @ClassId = ClassId, @AccountId = AccountId FROM ib_Account WHERE Code = @AccountCode AND FirmId = @FirmId
	
	IF @AccountId IS NULL
		RETURN NULL

	--Firm=Marex (R&N), class="Class" A
	SET @MatchCodeId = (SELECT TOP 1 MatchCodeId FROM ib_MatchCode mc INNER JOIN ib_TemplateGroup tg ON tg.TemplateId = mc.TemplateId AND tg.Description = mc.MatchCode
				 WHERE tg.TemplateId = @TemplateId 
						AND tg.FirmId = @FirmId AND tg.ClassId = @ClassId 
						AND tg.AccountId IS NULL AND tg.ExchangeId IS NULL AND tg.InstrumentId IS NULL
						AND mc.MatchCode IN (''Seg'',''House'',''Non Seg''))
	RETURN @MatchCodeId

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Adjustment_AddAdjustmentsFromSSIS]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Adjustment_AddAdjustmentsFromSSIS]
(
	@Metal VARCHAR(5),
	@Lots INT,
	@Price DECIMAL(20,4),
	@AccountCode VARCHAR(100),
	@PromptDate DATE,
	@ReceiveLocationSysId INT,
	@RunId INT,
	@Filename VARCHAR(255),
	@ExchangeCode VARCHAR(100),
	@DataSourceCode VARCHAR(100),
	@FirmCode VARCHAR(100),
	@TemplateTypeCode VARCHAR(100),
	@TemplateDesc VARCHAR(100)
)	
AS
/*
	-- Description: Insert adjustments from SSIS for LME
	-- 25 Jun 2014		ED		Created EIB 25768
	-- 01 Jul 2014		ED		EIB 25779 - use last char from metal to get currency
	-- 19 Dec 2014		ED		EIB 26110 - strike price should be 0
*/

BEGIN
	
	SET NOCOUNT ON 
	
	DECLARE @DataSourceId INT, @FirmId INT, @MatchCodeId INT, @ExchangeId INT, @AccountId INT,
		@CurrencyId INT, @InstrumentId INT, @Message VARCHAR(255), @IsError BIT = 0, @TemplateId INT
	
	SET @ExchangeId = (SELECT ExchangeId FROM ib_Exchange WHERE Code = @ExchangeCode)
	SET @DataSourceId = (SELECT DataSourceId FROM ib_DataSource WHERE Code = @DataSourceCode)
	SET @FirmId = (SELECT FirmId FROM ib_Firm WHERE Code = @FirmCode)
	
	SET @TemplateId = (SELECT TemplateId FROM ib_Template WHERE Description = @TemplateDesc AND TypeCode = @TemplateTypeCode)
	
	DECLARE @ReturnValue	int
	DECLARE	@OutPut			int
	DECLARE	@OutPut2		int  
	DECLARE @CurrencyCode CHAR(1) = RIGHT(@Metal, 1)
	IF @CurrencyCode != ''D'' AND @CurrencyCode != ''E'' AND @CurrencyCode != ''Y'' AND @CurrencyCode != ''S'' 
		SET @CurrencyCode = ''D''
	exec @ReturnValue = [ib_Currency_AddAsNeeded] @DataSourceId, @CurrencyCode, @Output output
	set @CurrencyId = @Output

	DECLARE @InstrumentCode VARCHAR(100)
	SET @InstrumentCode = ''F_'' + @ExchangeCode + ''_'' + @Metal

	EXEC @ReturnValue= [ib_InstrumentDataSource_GetByCode] @DataSourceId, @InstrumentCode, @InstrumentId output,@OutPut2 output
	
	IF @InstrumentId IS NULL
	BEGIN
		SET @Message = ''Instrument not found '' + @InstrumentCode
		EXEC Log_Insert @ReceiveLocationSysId, @Filename, ''Orchestrated'', @Message , ''Error'', '''', @RunId
		SET @IsError = 1
	END
	
	SET @MatchCodeId = dbo.GetMatchCodeIdForAdjustmentsInsert(@AccountCode, @ExchangeCode,''Marex (R&N)'', @TemplateId)
	IF @MatchCodeId IS NULL
	BEGIN
		SET @Message = ''MatchCode not found for Account ''+@AccountCode
		EXEC Log_Insert @ReceiveLocationSysId, @Filename, ''Orchestrated'', @Message , ''Error'', '''', @RunId
		SET @IsError = 1
	END
	
	SET @AccountId = (SELECT AccountId FROM ib_Account WHERE Code = @AccountCode AND FirmId = @FirmId)
	IF @AccountId IS NULL
	BEGIN
		SET @Message = ''Account not found ''+@AccountCode
		EXEC Log_Insert @ReceiveLocationSysId, @Filename, ''Orchestrated'', @Message , ''Error'', '''', @RunId
		SET @IsError = 1
	END
	IF @IsError = 1
		RETURN 1

	DECLARE @AdjustmentDate DATE =  dbo.GetPreviousBusinessDay(@PromptDate)
	DECLARE @ExpiryYear INT = YEAR(@PromptDate), @ExpiryMonth INT = MONTH(@PromptDate), @ExpiryDay INT = DAY(@PromptDate)
	
	DECLARE @Quantity INT = ABS(@Lots),
		 @IsBuy BIT, 
		 @QuantityShort INT = CASE WHEN @Lots > 0 THEN @Lots ELSE 0 END, 
		 @QuantityLong INT = CASE WHEN @Lots > 0 THEN 0 ELSE ABS(@Lots) END,
		 @AdjustmentId INT
	
	SET @IsBuy = CASE WHEN @QuantityShort = 0 THEN 1 ELSE 0 END

	EXEC ib_Adjustment_Load ''DL'', @TemplateId, @ExchangeId, @InstrumentId, ''I'', @AdjustmentDate, @AdjustmentDate, @Quantity, @QuantityLong, @QuantityShort
		, @CurrencyId, @ExpiryYear, @ExpiryMonth, @ExpiryDay, 0/*@StrikePrice*/, @Price, NULL/*@SettlementPrice*/,'''' /*@OptionTypeCode*/, NULL/*@Value*/, @IsBuy, @MatchCodeId
		, @DataSourceId, @FirmId, @AccountId, NULL, NULL, @AdjustmentId OUTPUT
	RETURN 0
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_CashReport_GetCashReportDataForBroker]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_CashReport_GetCashReportDataForBroker]
	@CashReportId int, 
	@ReportId int -- Used for updating status...
AS
SET NOCOUNT ON
BEGIN
/*
Author		Date			Description
KevinP		24 Mar 2010		Added very simple select statement... still needs improving to meet User Story
AlisterM	24 Mar 2010		Change to access View
amk			08 Apr 2010		MBAL-15158: need to group data so data source gets abstracted out
							otherwise will only show external.  need external and internal on
							same lines.
AlisterM	24 May 2010		MBAL-15605: Fix report not producing totals by Broker
*/


-- Create table variable to hold ordered list of Brokers from the view
DECLARE @tblBrokersOrdered TABLE
(
	[SortOrder] INT IDENTITY(1,1)
	, [BrokerName] VARCHAR(100) NOT NULL
)

-- Insert the Brokers, unique identity will be created which will be used to
-- sort the report for Broker and Broker Group Totals.
INSERT INTO @tblBrokersOrdered ([BrokerName]) 
SELECT vwbd.BrokerName
FROM [dbo].[vw_ib_CashReport_BrokerData] vwbd
WHERE CashReportId = @CashReportId
GROUP BY vwbd.BrokerName
ORDER BY vwbd.BrokerName

SELECT * FROM(

	SELECT (SELECT ([SortOrder] * 2) FROM @tblBrokersOrdered WHERE [BrokerName] = vwbd.[BrokerName])  AS ReportSortOrder,
		vwbd.BrokerName,
		vwbd.CurrencyId,
		vwbd.CurrencyCode,
		vwbd.CurrencyName,
		vwbd.TemplateTypeClassId,
		vwbd.TemplateTypeClassCode + '' - '' + vwbd.MatchCode AS TemplateTypeClassCode,
		vwbd.TemplateTypeClassName,
		vwbd.InstrumentTypeCode,
		vwbd.InstrumentTypeName,
		SUM(vwbd.[Internal_TOTE]) AS [Internal_TOTE],
		SUM(vwbd.[Internal_PandS]) AS [Internal_PandS],
		SUM(vwbd.[Internal_AdjOTE]) AS [Internal_AdjOTE],
		SUM(vwbd.[Internal_AdjSegNon]) AS [Internal_AdjSegNon],  -- This has no Value YET! We will need to source this from somewhere eventually when we know where to get it from.
		SUM(vwbd.[External_TOTE]) AS [External_TOTE],
		SUM(vwbd.[External_PandS]) AS [External_PandS],
		SUM(vwbd.[External_AdjOTE]) AS [External_AdjOTE],
		SUM(vwbd.[External_AdjSegNon]) AS [External_AdjSegNon],  -- This has no Value YET! We will need to source this from somewhere eventually when we know where to get it from.
		SUM(vwbd.[Difference]) AS [Difference],
		vwbd.CashReportId
	FROM [dbo].[vw_ib_CashReport_BrokerData] vwbd
	WHERE CashReportId = @CashReportId
	GROUP BY vwbd.BrokerName,
		vwbd.CurrencyId,
		vwbd.CurrencyCode,
		vwbd.CurrencyName,
		vwbd.TemplateTypeClassId,
		vwbd.TemplateTypeClassCode + '' - '' + vwbd.MatchCode,
		vwbd.TemplateTypeClassName,
		vwbd.InstrumentTypeCode,
		vwbd.InstrumentTypeName,
		vwbd.CashReportId

UNION ALL

	SELECT (SELECT (([SortOrder] * 2) + 1) FROM @tblBrokersOrdered WHERE [BrokerName] = vwbd.[BrokerName]) AS ReportSortOrder, 
		''GROUP'' AS BrokerName,
		vwbd.CurrencyId,
		vwbd.CurrencyCode,
		vwbd.CurrencyName,
		vwbd.TemplateTypeClassId,
		vwbd.TemplateTypeClassCode,
		vwbd.TemplateTypeClassName,
		'''' AS InstrumentTypeCode,
		'''' AS InstrumentTypeName,
		SUM(vwbd.[Internal_TOTE]) AS [Internal_TOTE],
		SUM(vwbd.[Internal_PandS]) AS [Internal_PandS],
		SUM(vwbd.[Internal_AdjOTE]) AS [Internal_AdjOTE],
		SUM(vwbd.[Internal_AdjSegNon]) AS [Internal_AdjSegNon],  -- This has no Value YET! We will need to source this from somewhere eventually when we know where to get it from.
		SUM(vwbd.[External_TOTE]) AS [External_TOTE],
		SUM(vwbd.[External_PandS]) AS [External_PandS],
		SUM(vwbd.[External_AdjOTE]) AS [External_AdjOTE],
		SUM(vwbd.[External_AdjSegNon]) AS [External_AdjSegNon],  -- This has no Value YET! We will need to source this from somewhere eventually when we know where to get it from.
		SUM(vwbd.[Difference]) AS [Difference],
		vwbd.CashReportId
	FROM [dbo].[vw_ib_CashReport_BrokerData] vwbd
	WHERE vwbd.CashReportId = @CashReportId
	GROUP BY vwbd.BrokerName,
		vwbd.CurrencyId,
		vwbd.CurrencyCode,
		vwbd.CurrencyName,
		vwbd.TemplateTypeClassId,
		vwbd.TemplateTypeClassCode,
		vwbd.TemplateTypeClassName,
		vwbd.CashReportId

) tmp2
ORDER BY tmp2.ReportSortOrder, tmp2.BrokerName, tmp2.CurrencyCode, tmp2.TemplateTypeClassCode


END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Class_GetByCode]''
');

GO
EXECUTE ('-- =============================================
-- Author:		Lee Manifold
-- Create date: 1 Sept 2006
-- Description:	Retrieve ClassId
-- =============================================
CREATE PROC [dbo].[ib_Class_GetByCode]
	(
	@Code			VARCHAR(25),
	@ClassId		INT OUTPUT
	)

AS
SET NOCOUNT ON

	SELECT	@ClassId = ClassId 
	
	FROM	[dbo].[ib_Class]
	
	WHERE	[Code] = @Code
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Class_AddAsNeeded]''
');

GO
EXECUTE ('-- =============================================
-- Author:		Lee Manifold
-- Create date: 31 August 2006
-- Description:	Retrieve ClassId

CREATE PROC [dbo].[ib_Class_AddAsNeeded]
	(
	@Code			VARCHAR(100),
	@Description	VARCHAR(100),	
	@ClassId		INT OUTPUT
	)
AS
SET NOCOUNT ON

	DECLARE @ReturnValue	INT
	DECLARE	@OutPut			INT  
	
	EXEC @ReturnValue = [ib_Class_GetByCode] @Code,@OutPut OUTPUT	
	
	SET @ClassId = @OutPut

	IF @ClassId is null
	BEGIN
		EXEC	ib_Class_Add @Code,@Description, NULL,@OutPut OUTPUT
		SELECT	@ClassId = @OutPut
	END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[aspnet_WebEvent_Events]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[aspnet_WebEvent_Events]
(
[EventId] [char] (32) NOT NULL,
[EventTimeUtc] [datetime] NOT NULL,
[EventTime] [datetime] NOT NULL,
[EventType] [nvarchar] (256) NOT NULL,
[EventSequence] [decimal] (19, 0) NOT NULL,
[EventOccurrence] [decimal] (19, 0) NOT NULL,
[EventCode] [int] NOT NULL,
[EventDetailCode] [int] NOT NULL,
[Message] [nvarchar] (1024) NULL,
[ApplicationPath] [nvarchar] (256) NULL,
[ApplicationVirtualPath] [nvarchar] (256) NULL,
[MachineName] [nvarchar] (256) NOT NULL,
[RequestUrl] [nvarchar] (1024) NULL,
[ExceptionType] [nvarchar] (256) NULL,
[Details] [ntext] NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK__aspnet_WebEvent___30EE274C] on [dbo].[aspnet_WebEvent_Events]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[aspnet_WebEvent_Events] ADD CONSTRAINT [PK__aspnet_WebEvent___30EE274C] PRIMARY KEY CLUSTERED  ([EventId])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[aspnet_WebEvent_LogEvent]''
');

GO
SET QUOTED_IDENTIFIER OFF

GO
EXECUTE ('CREATE PROCEDURE [dbo].[aspnet_WebEvent_LogEvent]
        @EventId         char(32),
        @EventTimeUtc    datetime,
        @EventTime       datetime,
        @EventType       nvarchar(256),
        @EventSequence   decimal(19,0),
        @EventOccurrence decimal(19,0),
        @EventCode       int,
        @EventDetailCode int,
        @Message         nvarchar(1024),
        @ApplicationPath nvarchar(256),
        @ApplicationVirtualPath nvarchar(256),
        @MachineName    nvarchar(256),
        @RequestUrl      nvarchar(1024),
        @ExceptionType   nvarchar(256),
        @Details         ntext
AS
SET NOCOUNT ON
BEGIN
    INSERT
        dbo.aspnet_WebEvent_Events
        (
            EventId,
            EventTimeUtc,
            EventTime,
            EventType,
            EventSequence,
            EventOccurrence,
            EventCode,
            EventDetailCode,
            Message,
            ApplicationPath,
            ApplicationVirtualPath,
            MachineName,
            RequestUrl,
            ExceptionType,
            Details
        )
    VALUES
    (
        @EventId,
        @EventTimeUtc,
        @EventTime,
        @EventType,
        @EventSequence,
        @EventOccurrence,
        @EventCode,
        @EventDetailCode,
        @Message,
        @ApplicationPath,
        @ApplicationVirtualPath,
        @MachineName,
        @RequestUrl,
        @ExceptionType,
        @Details
    )
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[is_H_Purge]''
');

GO
SET QUOTED_IDENTIFIER ON

GO
EXECUTE ('




-- =============================================
-- Author:		Lee Manifold
-- Create date: 11 Jul 2006
-- Description:	Deletes from all is_H type files where the LoadState = @LoadState
-- =============================================
CREATE PROCEDURE [dbo].[is_H_Purge]
	(
	@LoadState		TINYINT = 0,
	@RecordDate		DATETIME = NULL
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	
	--raiserror (''Lee doing specific raiserror in stored proc for testing'', 19, 1) with log
	
	IF @RecordDate IS NOT NULL 
	BEGIN
		--****Need to Add code here to factor in @RecordDate into table fields 
		DELETE FROM [dbo].[is_HAccountAttribute] WHERE LoadState= @LoadState

		DELETE FROM [dbo].[is_HAccountTotal] WHERE LoadState= @LoadState

		DELETE FROM [dbo].[is_HCollateralSecuritiesDetails] WHERE LoadState= @LoadState

		DELETE FROM [dbo].[is_HCollateralSecuritiesMovement] WHERE LoadState= @LoadState
	
		DELETE FROM [dbo].[is_HProductTotal] WHERE LoadState= @LoadState

		DELETE FROM [dbo].[is_HRealizedProfitLossDetails] WHERE LoadState= @LoadState

		DELETE FROM [dbo].[is_HReceiptPaymentDetails] WHERE LoadState= @LoadState

		DELETE FROM [dbo].[is_HTradeDetails] WHERE LoadState= @LoadState		

		DELETE FROM [dbo].[is_HUnsettledContractDetails] WHERE LoadState= @LoadState
	END
	
	IF @RecordDate IS NULL 
	BEGIN
	
		DELETE FROM [dbo].[is_HAccountAttribute] WHERE LoadState= @LoadState

		DELETE FROM [dbo].[is_HAccountTotal] WHERE LoadState= @LoadState

		DELETE FROM [dbo].[is_HCollateralSecuritiesDetails] WHERE LoadState= @LoadState

		DELETE FROM [dbo].[is_HCollateralSecuritiesMovement] WHERE LoadState= @LoadState
	
		DELETE FROM [dbo].[is_HProductTotal] WHERE LoadState= @LoadState

		DELETE FROM [dbo].[is_HRealizedProfitLossDetails] WHERE LoadState= @LoadState

		DELETE FROM [dbo].[is_HReceiptPaymentDetails] WHERE LoadState= @LoadState

		DELETE FROM [dbo].[is_HTradeDetails] WHERE LoadState= @LoadState		

		DELETE FROM [dbo].[is_HUnsettledContractDetails] WHERE LoadState= @LoadState


	END
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Rule_GetMatchCodeIdByName]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Rule_GetMatchCodeIdByName]
@MatchCode varchar(100)
AS
SET NOCOUNT ON

SELECT MatchCodeId
	FROM ib_MatchCode
	WHERE [MatchCode] = @MatchCode
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Instrument_GetInstumentCodesHintByKeyword]''
');

GO
EXECUTE ('/*
<details>
 <summary> Returns the instruments hint for a specific code /summary>
 <created author="Laurentiu Macovei" Date="Thursday, 16 August 2006 20:31 GMT" /> 
 <tasks>
 </tasks>
</details>
-- 13 May 2014  ED  EIB 25499 - add IsActive flag to ib_Instrument
*/
CREATE PROCEDURE [dbo].[ib_Instrument_GetInstumentCodesHintByKeyword]
@InstrumentCode varchar(100),
@HintByStartOnly bit = 0,
@HintLength int = 1
AS
SET NOCOUNT ON

DECLARE @len int
SET @len = LEN(@InstrumentCode)
IF @HintByStartOnly = 1
BEGIN
	SELECT DISTINCT SUBSTRING ([Code], @len, @HintLength) x
		FROM [dbo].[ib_Instrument]
		WHERE [Code] LIKE @InstrumentCode+''%'' AND IsActive = 1
		ORDER BY x

END
ELSE
BEGIN
	SELECT DISTINCT SUBSTRING ([Code], PATINDEX(''%''+@InstrumentCode+''%'', [Code]) + @len, @HintLength) x
		FROM [dbo].[ib_Instrument]
		WHERE [Code] LIKE ''%''+@InstrumentCode+''%'' AND IsActive = 1
		ORDER BY x
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[SetDataSourceErrorMessage]''
');

GO
EXECUTE ('CREATE FUNCTION [dbo].[SetDataSourceErrorMessage]
(@DataSourceErrorCode INT=NULL)
RETURNS VARCHAR (MAX)
AS
BEGIN
-- -1 not found using Instrument Data Source Mappping
-- -2 Found Multiple by Using Instrument Data Source mapping, but none found by using Firm Data Source Mapping
-- -3 Found Multiple by using both mappings
-- NULL -- error
	DECLARE @ErrorMessage VARCHAR(MAX)
	IF @DataSourceErrorCode IS NULL
	SET @ErrorMessage = ''External DataSource can not be found '' 
	ELSE	
	IF @DataSourceErrorCode = -1
		SET @ErrorMessage = ''External DataSource can not be found using Instrument Data Source Mappping ''
	ELSE
	IF @DataSourceErrorCode = -2
		SET @ErrorMessage = ''External DataSource:Found Multiple by Using Instrument Data Source mapping, but none found by using Firm Data Source Mapping  '' 
	ELSE IF @DataSourceErrorCode = -3
		SET @ErrorMessage = ''Found Multiple by using both mappings ''

	RETURN @ErrorMessage
END


');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TradeReconciliationSummary_GetDetailsTransaction]''
');

GO
EXECUTE ('
CREATE PROCEDURE [dbo].[ib_TradeReconciliationSummary_GetDetailsTransaction]
(
		@TradeReconciliationSummaryId INT
		, @IncludeMatched BIT = 0
		, @InternalExternalCode CHAR(1) = NULL
)
AS
SET NOCOUNT ON
-- Description: Get the Trade Reconciliation Details for a Summary Record</summary>

-- History:
-- 04 Aug 2009	AAJM	Creation
-- 07 Aug 2009	AAJM	Add InternalExternalCode and IsMatched for displaying automated matches
-- 02 Nov 2009	amk		Bug Fix: left outer join trxtype in case item not yet in master
-- 02 Mar 2010	AAJM	Implement Sort Order.  Add outer clause for assessing IsLong.#
-- 10 Mar 2010	KevinP  MBAL-14919 - Changed to return Account Code and DetailAccount Code rather than Name
-- 20 May 2010  ED      LEFT JOIN on firm and account

DECLARE @SQL NVARCHAR(4000)
DECLARE @WHERE NVARCHAR(1000)
DECLARE @OuterOrderBy NVARCHAR(1000)
DECLARE @HeaderSQL NVARCHAR(1000)
DECLARE @FooterSQL NVARCHAR(1000)

SET @HeaderSQL = ''SELECT * FROM ( ''
SET @FooterSQL = '' ) AS q ''

SET @SQL = ''SELECT  
	  d.[Name] AS [Datasource]
	, f.[Name] AS [Firm]
	, a.[Code] AS [Account]
	, a2.[Code] AS [DetailAccount]
	, [trs].[TradePrice] 
	, [trd].[InternalLong]
	, [trd].[InternalShort]
	, [trd].[ExternalLong]
	, [trd].[ExternalShort]
	, ISNULL([tt].[Description], trd.TrxTypeCode) AS [Type]
	, [trd].[TrxDate] AS [TrxDate]
	, [trd].[IsMatched]
	, CASE 
		WHEN ([trd].[InternalLong] <> 0 OR [trd].[ExternalLong] <> 0)
		THEN 1
		ELSE 0
	   END 		AS [IsLong]
	,[trd].TradeReconciliationDetailId
	,[trx].UTI
	,CASE WHEN [trx].IsUnmatched = 1 THEN ''''Y'''' ELSE '''''''' END AS Unmatched
	FROM [dbo].[ib_TradeReconciliationSummary] [trs]
	INNER JOIN [dbo].[ib_TradeReconciliationDetail] [trd] 
	ON [trs].[TradeReconciliationId] = [trd].[TradeReconciliationId]
	AND [trd].[ExchangeId] = [trs].[ExchangeId]
	AND [trd].[CurrencyId] = [trs].[CurrencyId]
	AND [trd].[InstrumentId] = [trs].[InstrumentId]
	
	INNER JOIN ib_Datasource d ON d.DataSourceId=trd.DataSourceId
	LEFT JOIN ib_Firm f ON f.FirmId=trd.FirmId
	LEFT JOIN ib_Account a ON a.AccountId=trd.AccountId
	LEFT JOIN ib_Account a2 ON a2.AccountId = trd.DetailAccountId
	LEFT OUTER JOIN ib_TrxType tt ON trd.TrxTypeCode = tt.Code AND tt.DataSourceId = trd.DataSourceId 
	LEFT JOIN ib_Trx trx ON trx.TrxId = trd.TrxId ''
	
SET @WHERE = ''WHERE [trs].[TradeReconciliationSummaryId] = '' + CAST(@TradeReconciliationSummaryId AS VARCHAR(50)) +
	''AND [trd].[MatchCode] = [trs].[MatchCode]
	AND [trd].[ExpiryMonth] = [trs].[ExpiryMonth]
	AND [trd].[ExpiryYear] = [trs].[ExpiryYear]
	AND [trd].[ExpiryDay] = [trs].[ExpiryDay] 
	AND [trd].[OptionTypeCode] = [trs].[OptionTypeCode]
	AND [trd].[StrikePrice] = [trs].[StrikePrice]
	AND [trd].[TradePrice] = [trs].[TradePrice]''
	
IF @IncludeMatched = 0
BEGIN
	SET @WHERE = @WHERE + ''	AND [trd].[IsMatched] IS NULL''	
END

IF @InternalExternalCode IS NOT NULL
	SET @WHERE = @WHERE + '' AND [trd].[InternalExternalCode] = '''''' + @InternalExternalCode + ''''''''

SET @OuterOrderBy = '' ORDER BY [q].[IsMatched] ASC, [q].[IsLong] DESC, [q].[InternalLong], [q].[ExternalLong], [q].[InternalShort], [q].[ExternalShort], [q].[DetailAccount]''

SET @SQL = @HeaderSQL + @SQL + @WHERE + @FooterSQL + @OuterOrderBy

EXEC sp_executesql @SQL
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Price_GetPreviousByAlternateKey]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Price_GetPreviousByAlternateKey]
(	
	@AsOfDate DATETIME,
    @DataSourceId INT,
    @OtherDataSourceId INT,
    @ExchangeId INT,
    @InstrumentId INT,
    @CurrencyId INT,
    @ExpiryYear SMALLINT,
    @ExpiryMonth SMALLINT,
    @ExpiryDay SMALLINT,
    @StrikePrice MONEY,
    @OptionTypeCode VARCHAR(25),
    @SettlementPrice DECIMAL(25,10) OUTPUT
)
AS
SET NOCOUNT ON
--	get settlement price

--	22 Jun 2010		ED		creation
--	17 Aug 2010		amk		MBAL-16343: work at preventing ''can not calculate...'' message so adjustment goes through
--	10 Jul 2012		ED		MBAL 21151 - Try to get ignoring datasource
--	17 Jul 2012		ED		MBAL 21151 - Try to get ignoring datasource for previous days too
BEGIN
	-- try first to see if there is a settlement price for any datasource for that instrument
	SET @SettlementPrice = (SELECT TOP 1 SettlementPrice FROM ib_Price 
			WHERE [AsOfDate] = @AsOfDate AND [ExchangeId] = @ExchangeId AND [InstrumentId] = @InstrumentId AND [CurrencyId] = @CurrencyId AND [ExpiryYear] = @ExpiryYear AND [ExpiryMonth] = @ExpiryMonth 
			AND ([ExpiryDay] = @ExpiryDay OR (ExpiryDay IS NULL AND @ExpiryDay IS NULL)) 
			AND ([StrikePrice] = @StrikePrice OR (ISNULL(StrikePrice,0)=0 AND ISNULL(@StrikePrice,0)=0)) 
			AND ([OptionTypeCode] = @OptionTypeCode OR (ISNULL(OptionTypeCode,'''')='''' AND ISNULL(@OptionTypeCode,'''')='''')))
	IF @SettlementPrice IS NOT NULL
	BEGIN
		SELECT TOP 1 @SettlementPrice, @AsOfDate, DataSourceId FROM ib_Price 
			WHERE [AsOfDate] = @AsOfDate AND [ExchangeId] = @ExchangeId AND [InstrumentId] = @InstrumentId AND [CurrencyId] = @CurrencyId AND [ExpiryYear] = @ExpiryYear AND [ExpiryMonth] = @ExpiryMonth 
			AND ([ExpiryDay] = @ExpiryDay OR (ExpiryDay IS NULL AND @ExpiryDay IS NULL)) 
			AND ([StrikePrice] = @StrikePrice OR (ISNULL(StrikePrice,0)=0 AND ISNULL(@StrikePrice,0)=0)) 
			AND ([OptionTypeCode] = @OptionTypeCode OR (ISNULL(OptionTypeCode,'''')='''' AND ISNULL(@OptionTypeCode,'''')=''''))
		RETURN
	END
	
	DECLARE @UsedDataSourceId INT
	DECLARE @POS INT
	SET @POS = 1
	WHILE @POS < 8
	BEGIN
		--DECREASE AsOfDate
		SET @AsOfDate = dbo.GetPreviousBusinessDay(@AsOfDate)
		
		SET @SettlementPrice = (SELECT [dbo].[GetSettlementPriceByAlternateKey](@AsOfDate, @DataSourceId, @ExchangeId, @InstrumentId, @CurrencyId
			, @ExpiryYear, @ExpiryMonth, @ExpiryDay, @StrikePrice, @OptionTypeCode))
		SET @UsedDataSourceId = @DataSourceId
		IF @SettlementPrice IS NOT NULL -- if found, exit from loop
			SET @POS = 10
		ELSE
		BEGIN
			-- try the other side
			SET @SettlementPrice = (SELECT [dbo].[GetSettlementPriceByAlternateKey](@AsOfDate, @OtherDataSourceId, @ExchangeId, @InstrumentId, @CurrencyId
				, @ExpiryYear, @ExpiryMonth, @ExpiryDay, @StrikePrice, @OptionTypeCode))
			SET @UsedDataSourceId = @OtherDataSourceId
			IF @SettlementPrice IS NOT NULL -- if found, exit from loop
				SET @POS = 10	
			ELSE
			BEGIN
			-- try to see if there is a settlement price for any datasource for that instrument
				SELECT TOP 1  @SettlementPrice = SettlementPrice, @UsedDataSourceId = DataSourceId FROM ib_Price 
										WHERE [AsOfDate] = @AsOfDate AND [ExchangeId] = @ExchangeId AND [InstrumentId] = @InstrumentId AND [CurrencyId] = @CurrencyId AND [ExpiryYear] = @ExpiryYear AND [ExpiryMonth] = @ExpiryMonth 
										AND ([ExpiryDay] = @ExpiryDay OR (ExpiryDay IS NULL AND @ExpiryDay IS NULL)) 
										AND ([StrikePrice] = @StrikePrice OR (ISNULL(StrikePrice,0)=0 AND ISNULL(@StrikePrice,0)=0)) 
										AND ([OptionTypeCode] = @OptionTypeCode OR (ISNULL(OptionTypeCode,'''')='''' AND ISNULL(@OptionTypeCode,'''')=''''))
				IF @SettlementPrice IS NOT NULL
					SET @POS = 10	
				ELSE
					SET @POS = @POS + 1
			END
		END
	END 			
	IF @POS = 8
	BEGIN
		SET @SettlementPrice = 0
		SELECT 0, NULL, NULL
	END
	ELSE
		SELECT @SettlementPrice, @AsOfDate, @UsedDataSourceId
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[GetFirmIdForTradeAdjustments]''
');

GO
EXECUTE ('CREATE FUNCTION [dbo].[GetFirmIdForTradeAdjustments]
(@TemplateId INT, @MatchCode VARCHAR (255), @ExchangeId INT, @DataSourceId INT)
RETURNS INT
AS
BEGIN
	DECLARE @FirmId INT
	DECLARE @COUNT INT
	

	--first, try to get it from matchcode-exchange, and datasource-firm relation
	DECLARE @Firms TABLE (FirmId INT)
	
	INSERT INTO @Firms(FirmId)
	SELECT DISTINCT tg.FirmId 
		FROM ib_TemplateGroup tg
			INNER JOIN ib_FirmDataSource fds ON fds.FirmId=tg.FirmId
		WHERE TemplateId=@TemplateId AND ExchangeId=@ExchangeId AND tg.[Description]=@MatchCode
			AND fds.DataSourceId=@DataSourceId
	
	
	SELECT @COUNT = COUNT(*) FROM @Firms f
	IF @COUNT = 1 
	BEGIN
		SELECT @FirmId = f.FirmId FROM @Firms f
		RETURN @FirmId
	END
	ELSE IF @COUNT IS NULL OR @COUNT = 0 -- if none found, try again releasing the join
		INSERT INTO @Firms(FirmId)
		SELECT DISTINCT tg.FirmId 
		FROM ib_TemplateGroup tg
			INNER JOIN ib_FirmDataSource fds ON fds.FirmId=tg.FirmId
		WHERE TemplateId=@TemplateId AND tg.[Description]=@MatchCode AND fds.DataSourceId=@DataSourceId
		SELECT @COUNT = COUNT(*) FROM @Firms f
		IF @COUNT = 1 
		BEGIN
			SELECT @FirmId = f.FirmId FROM @Firms f
			RETURN @FirmId
		END
		ELSE
		RETURN -1
	
	RETURN NULL
END


');

GO
EXECUTE ('PRINT N''Creating [dbo].[GetDetailedErrorMessageByTradeReconciliationDetailId]''
');

GO
EXECUTE ('CREATE FUNCTION [dbo].[GetDetailedErrorMessageByTradeReconciliationDetailId]
(
	@TradeReconciliationSummaryId INT = NULL,
	@TradeReconciliationDetailId INT = NULL
)
RETURNS VARCHAR(MAX)
AS
/*
--	get detailed error message
--	Created 18 May 2010 ED
*/
BEGIN
DECLARE @Ids TABLE(SummaryId INT, DetailId INT)
INSERT INTO @Ids(SummaryId, DetailId)
VALUES (@TradeReconciliationSummaryId, @TradeReconciliationDetailId)
DECLARE @ErrorMessage VARCHAR(MAX)
SELECT @ErrorMessage = 
		ISNULL(trs.MatchCode,trd.MatchCode) +'', ''
		+ ''Exchange: '' /*+ CAST(e.ExchangeId AS VARCHAR) + '' Code: ''*/+ e.Code+'', ''
		+ ''Currency: '' /*+ CAST(c.CurrencyId AS VARCHAR) + '' Code: ''*/+ c.Code+'', ''
		+ ''Instrument: '' /*+ CAST(i.InstrumentId AS VARCHAR) + '' Code: ''*/+ i.Code + '', ''
		/*+ ''SummaryId: '' + CAST(ISNULL(SummaryId,0) AS VARCHAR) + '', ''*/
		/*+ ''DetailId: '' + CAST(ISNULL(DetailId,0) AS VARCHAR) */
	FROM @Ids ids
		LEFT JOIN ib_TradeReconciliationSummary trs ON trs.TradeReconciliationSummaryId = ids.SummaryId
		LEFT JOIN ib_TradeReconciliationDetail trd ON trd.TradeReconciliationDetailId = ids.DetailId
		INNER JOIN ib_Exchange e ON e.ExchangeId=ISNULL(trs.ExchangeId, trd.ExchangeId)
		INNER JOIN ib_Currency c ON c.CurrencyId=ISNULL(trs.CurrencyId, trd.CurrencyId)
		INNER JOIN ib_Instrument i ON i.InstrumentId=ISNULL(trs.InstrumentId, trd.InstrumentId)

RETURN @ErrorMessage

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[GetDataSourceIdForTradeAdjustments]''
');

GO
EXECUTE ('CREATE FUNCTION [dbo].[GetDataSourceIdForTradeAdjustments]
(
     @TemplateId INT
	,@InstrumentId INT
	,@ExchangeId INT
	,@MatchCode VARCHAR(100)
	,@InternalExternalCode CHAR(1)
)
RETURNS INT
--return values
-- -1 not found using Instrument Data Source Mappping
-- -2 Found Multiple by Using Instrument Data Source mapping, but none found by using Firm Data Source Mapping
-- -3 Found Multiple by using both mappings
-- NULL -- error
-- 28 Jun 2010 ED MBAL 15960 - add some extra logic, to try get it by firm/template/matchcode, and only after that add exchange if multiple found on first check
-- 18 Jul 2012 ED MBAL 21151 - fix the logic on getting by firm to count distinct, not the number of rows
AS
BEGIN
	DECLARE @DataSourceId INT
	DECLARE @COUNT INT
	

	--first, try to get it from instrument-data source mapping
	DECLARE @DataSources TABLE (DataSourceId INT)
	
	INSERT INTO @DataSources(DataSourceId)
	SELECT DISTINCT tc.DataSourceId 
		FROM ib_TemplateCompare tc
			INNER JOIN ib_InstrumentDataSource ids ON ids.DataSourceId=tc.DataSourceId
		WHERE TemplateId=@TemplateId AND InternalExternalCode=@InternalExternalCode AND ids.InstrumentId=@InstrumentId
	
	SELECT @COUNT = COUNT(*) FROM @DataSources d
	IF @COUNT IS NULL OR @COUNT = 0
		RETURN -1
	ELSE IF @COUNT = 1 
	BEGIN
		SET @DataSourceId = (SELECT d.DataSourceId FROM @DataSources d)
		RETURN @DataSourceId
	END
	 --more than one found, go on the firm branch
	 --
	DECLARE @COUNT2 INT
	--try first without exchange
	SET @COUNT2 = (SELECT COUNT(DISTINCT d.DatasourceId) FROM @DataSources d
		INNER JOIN ib_FirmDataSource fds ON d.DataSourceId=fds.DataSourceId
		INNER JOIN ib_TemplateGroup tg ON fds.FirmId=tg.FirmId
		WHERE TemplateId=@TemplateId AND Description=@MatchCode)
	
	IF @COUNT2 IS NULL OR @COUNT2 = 0
		RETURN -2 -- not found by firm, but found multiple by first
	ELSE IF @COUNT2 = 1 
		BEGIN
			SET @DataSourceId = (SELECT TOP 1 d.DataSourceId FROM @DataSources d
				INNER JOIN ib_FirmDataSource fds ON d.DataSourceId=fds.DataSourceId
				INNER JOIN ib_TemplateGroup tg ON fds.FirmId=tg.FirmId
				WHERE TemplateId=@TemplateId AND Description=@MatchCode)
			RETURN @DataSourceId
		END
	ELSE --more than 1 found
		BEGIN
			SET @COUNT2 = (SELECT COUNT(DISTINCT d.DatasourceId) FROM @DataSources d
			INNER JOIN ib_FirmDataSource fds ON d.DataSourceId=fds.DataSourceId
			INNER JOIN ib_TemplateGroup tg ON fds.FirmId=tg.FirmId
			WHERE TemplateId=@TemplateId AND ExchangeId=@ExchangeId AND Description=@MatchCode)
		
			IF @COUNT2 IS NULL OR @COUNT2 = 0
				RETURN -2 -- not found by firm, but found multiple by first
			ELSE IF @COUNT2 = 1 
			BEGIN
				SET @DataSourceId = (SELECT TOP 1 d.DataSourceId FROM @DataSources d
					INNER JOIN ib_FirmDataSource fds ON d.DataSourceId=fds.DataSourceId
					INNER JOIN ib_TemplateGroup tg ON fds.FirmId=tg.FirmId
					WHERE TemplateId=@TemplateId AND ExchangeId=@ExchangeId AND Description=@MatchCode)
				RETURN @DataSourceId
			END
			ELSE 
				RETURN -3 -- multiple found
		END
	RETURN NULL
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TradeReconciliationSummary_InsertGroupedAdjustmentAndDetail]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_TradeReconciliationSummary_InsertGroupedAdjustmentAndDetail]
(
	@TradeReconciliationSummaryId INT
	, @AdjustmentHeaderId INT 
	, @InternalExternalCode CHAR(1)
	, @QuantityAmount INT
	, @InstrumentTypeCode VARCHAR(1)
	, @IsLongInsert BIT
	, @CancelMultiplier INT
	, @CreateUsername VARCHAR(50)
	, @ErrorMessage VARCHAR(MAX) OUTPUT
	, @AsOfDate DATETIME = NULL
)
AS
SET NOCOUNT ON
/*
--	Insert Long O rShort Grouped Adjustment
--	Created 20 May 2010 ED
--			16 Jun 2010 ED		MBAL 15748 - Set quantity as being long-short quantity 
--			16 Jun 2010 ED		MBAL 15710 - add logic for positive/negative lots
--			21 Jun 2010 ED		MBAL 15710 - fix quantity in case of negative lots
--			21 Jun 2010 ED		MBAL 13980 - Fix ClassId
--			24 Jun 2010 ED		MBAL 15712 - Improved logic for SettlementPrice
--			24 Jun 2010 ED		MBAL 15710 - get account/detail account for TC too
--			06 Jul 2010 ED		MBAL 16065 - use ABS for SumLots and Difference in Lots for ''P''
--			26 Jul 2010	AAJM	MBAL-16249 - Fix Premium Paid Assignment Adjustments Being Created With Value
--			27 Jul 2010	AAJM	MBAL-16249 - Ensure TradePrice = 0 when resetting Value
--			28 Jul 2010	AAJM	MBAL-16300 - Specify AsOfDate for Rolled Trade Adjustment
--			22 Jul 2014	ED	EIB 25831 - fix call to ib_TradeReconciliationSummary_GetDetailsTransaction sp
*/
BEGIN TRY
BEGIN TRAN LSInsert
DECLARE @TemplateId INT
DECLARE @DataSourceId INT
DECLARE @FirmId INT
DECLARE @SettlementPrice DECIMAL(24,10)
DECLARE @Value DECIMAL(24,10)

SELECT @TemplateId = TemplateId FROM ib_TradeReconciliation tr
	INNER JOIN ib_TradeReconciliationSummary trs ON tr.TradeReconciliationId=trs.TradeReconciliationId
	WHERE TradeReconciliationSummaryId=@TradeReconciliationSummaryId
	
SELECT @DataSourceId = [dbo].[GetDataSourceIdForTradeAdjustments]( @TemplateId,InstrumentId,ExchangeId ,MatchCode,@InternalExternalCode)
	FROM ib_TradeReconciliationSummary trs 
	WHERE TradeReconciliationSummaryId=@TradeReconciliationSummaryId

IF @DataSourceId IS NULL OR @DataSourceId < 0
BEGIN
	SET @ErrorMessage = [dbo].[SetDataSourceErrorMessage](@DataSourceId) + dbo.GetDetailedErrorMessageByTradeReconciliationDetailId(@TradeReconciliationSummaryId,NULL)
	IF(@@TRANCOUNT = 1) ROLLBACK TRAN
		ELSE IF(@@TRANCOUNT > 1) COMMIT TRAN LSInsert
	RETURN -1
END
--try to get firm id
SELECT @FirmId = [dbo].[GetFirmIdForTradeAdjustments] (@TemplateId, MatchCode, ExchangeId, @DataSourceId)
	FROM ib_TradeReconciliationSummary trs 
	WHERE TradeReconciliationSummaryId=@TradeReconciliationSummaryId

IF @FirmId < 0  SET @FirmId = NULL
	
--get all unmatched rows for drilldown
	DECLARE @tempTranDetail TABLE 
				(
					[Datasource] VARCHAR(1000)
					, [Firm] VARCHAR(1000)
					, [Account] VARCHAR(1000)
					, [DetailAccount] VARCHAR(1000)
					,[TradePrice] DECIMAL(24,10)
					,[InternalLong] INT 
					,[InternalShort] INT 
					,[ExternalLong] INT 
					,[ExternalShort] INT 
					,[TYPE] VARCHAR(1000)
					,[TrxDate] DATETIME
					,[IsMatched] BIT
					,[IsLong] BIT
					,TradeReconciliationDetailId INT
					,UTI varchar(100)
					,Unmatched varchar(100)
				)
				INSERT INTO @tempTranDetail
				([Datasource],[Firm],[Account],[DetailAccount],[TradePrice] ,[InternalLong],[InternalShort],[ExternalLong],[ExternalShort]
					,[TYPE],[TrxDate],[IsMatched],[IsLong], TradeReconciliationDetailId, UTI, Unmatched)
				EXEC  [dbo].[ib_TradeReconciliationSummary_GetDetailsTransaction] @TradeReconciliationSummaryId, 0



--try to get @AccountId, @DetailAccountId, @AdjustmentStatusId
DECLARE @AccountId INT
DECLARE @DetailAccountId INT

DECLARE @AdjustmentStatusId INT
DECLARE @NoOfRows INT
--IF @CancelMultiplier = 1 -- if we have an ADD Trade Adjustment, we need to determine account
	--BEGIN
	--account is get based on what type of insert is(internal/external)
	DECLARE @Ids TABLE(Id INT) --get by matchcode only & template id
	--IF @InternalExternalCode = ''I'' -- in this case is a more complex logic??
		--BEGIN
			--INSERT INTO @Ids(Id)
			--SELECT  DISTINCT tg.AccountId FROM ib_TemplateGroup tg 
					--INNER JOIN ib_TradeReconciliationSummary trs ON tg.[Description]=trs.MatchCode AND tg.TemplateId=@TemplateId
				--WHERE TradeReconciliationSummaryId=@TradeReconciliationSummaryId AND tg.AccountId IS NOT NULL
			--SET @NoOfRows = @@ROWCOUNT
			--IF @NoOfRows = 1
				--BEGIN
					--SET @AccountId = (SELECT Id FROM @Ids)
					--SET @DetailAccountId = (SELECT Id FROM @Ids)
				--END
			--ELSE IF @NoOfRows > 1
				--BEGIN
					--DELETE FROM @Ids
					--INSERT INTO @Ids(Id) --get by matchcode, exchange & template id
					--SELECT  DISTINCT tg.AccountId FROM ib_TemplateGroup tg 
							--INNER JOIN ib_TradeReconciliationSummary trs  ON tg.[Description]=trs.MatchCode AND tg.ExchangeId=trs.ExchangeId AND tg.TemplateId=@TemplateId
							--WHERE TradeReconciliationSummaryId=@TradeReconciliationSummaryId  AND tg.AccountId IS NOT NULL
					--SET @NoOfRows = @@ROWCOUNT
					--IF @NoOfRows = 1
					--BEGIN
						--SET @AccountId = (SELECT Id FROM @Ids)
						--SET @DetailAccountId = (SELECT Id FROM @Ids)
					--END
				--END
		--END
	--ELSE --external
	--BEGIN
		SET @DetailAccountId = NULL
		INSERT INTO @Ids(Id)
		SELECT DISTINCT tg.AccountId FROM ib_TemplateGroup tg 
			INNER JOIN ib_TradeReconciliationSummary trs ON tg.[Description]=trs.MatchCode AND tg.TemplateId=@TemplateId AND tg.FirmId=@FirmId
			WHERE TradeReconciliationSummaryId=@TradeReconciliationSummaryId  AND tg.AccountId IS NOT NULL
		SET @NoOfRows = @@ROWCOUNT
		IF @NoOfRows = 1
			SET @AccountId = (SELECT Id FROM @Ids)
		ELSE IF @NoOfRows > 1
			BEGIN
				DELETE FROM @Ids
				INSERT INTO @Ids(Id)
				SELECT DISTINCT tg.AccountId FROM ib_TemplateGroup tg  
					INNER JOIN ib_TradeReconciliationSummary trs ON tg.[Description]=trs.MatchCode AND tg.ExchangeId=trs.ExchangeId AND tg.TemplateId=@TemplateId AND tg.FirmId=@FirmId
					WHERE TradeReconciliationSummaryId=@TradeReconciliationSummaryId  AND tg.AccountId IS NOT NULL
				SET @NoOfRows = @@ROWCOUNT
				IF @NoOfRows = 1 
					SET @AccountId = (SELECT Id FROM @Ids)
			END
		
	--END
IF @InternalExternalCode = ''I'' 
	SET @DetailAccountId = @AccountId
IF @AccountId IS NULL -- not found
	SELECT @AdjustmentStatusId=AdjustmentStatusId,@AccountId = NULL, @DetailAccountId = NULL FROM ib_AdjustmentStatus a
				WHERE a.Code=''U''
--get price
IF @InstrumentTypeCode = ''F'' OR @InstrumentTypeCode = ''O'' 
BEGIN
--get settlement price
	
	SET @SettlementPrice = (SELECT dbo.GetSettlementPriceByAlternateKey(
		CASE WHEN @AsOfDate IS NULL THEN tr.Today ELSE @AsOfDate END  -- Use Rolled Over Adjustment Date if passed in
		, @DataSourceId, trs.ExchangeId, trs.InstrumentId, trs.CurrencyId, 
		trs.ExpiryYear, trs.ExpiryMonth, trs.ExpiryDay, trs.StrikePrice, trs.OptionTypeCode) FROM ib_TradeReconciliation tr
		INNER JOIN ib_TradeReconciliationSummary trs ON tr.TradeReconciliationId=trs.TradeReconciliationId
		WHERE TradeReconciliationSummaryId=@TradeReconciliationSummaryId)
	IF @SettlementPrice IS NULL
	BEGIN
		DECLARE @OtherDataSourceId INT
		SET @OtherDataSourceId = (SELECT [dbo].[GetDataSourceIdForTradeAdjustments]( @TemplateId,InstrumentId,ExchangeId ,MatchCode,CASE WHEN @InternalExternalCode = ''I'' THEN ''E'' ELSE ''I'' END)
							FROM ib_TradeReconciliationSummary trs 
							WHERE TradeReconciliationSummaryId=@TradeReconciliationSummaryId)
		
		SET @SettlementPrice = (SELECT dbo.GetSettlementPriceByAlternateKey(
			CASE WHEN @AsOfDate IS NULL THEN tr.Today ELSE @AsOfDate END  -- Use Rolled Over Adjustment Date if passed in
		, @OtherDataSourceId, trs.ExchangeId, trs.InstrumentId, trs.CurrencyId, 
		trs.ExpiryYear, trs.ExpiryMonth, trs.ExpiryDay, trs.StrikePrice, trs.OptionTypeCode) FROM ib_TradeReconciliation tr
		INNER JOIN ib_TradeReconciliationSummary trs ON tr.TradeReconciliationId=trs.TradeReconciliationId
		WHERE TradeReconciliationSummaryId=@TradeReconciliationSummaryId)
		IF @SettlementPrice IS NULL
		BEGIN
				DECLARE	@TradeRecAsOfDate DATETIME, @InstrumentId INT, @ExpiryYear SMALLINT, @ExpiryMonth SMALLINT, @ExpiryDay SMALLINT, @StrikePrice MONEY, @OptionTypeCode VARCHAR(25), @ExchangeId INT
					,@CurrencyId INT
				SELECT @TradeRecAsOfDate = Today, @InstrumentId = InstrumentId,  @ExpiryYear = ExpiryYear, @ExpiryMonth = ExpiryMonth,
					@ExpiryDay = ExpiryDay, @StrikePrice = StrikePrice, @OptionTypeCode = OptionTypeCode, @ExchangeId = ExchangeId, @CurrencyId = CurrencyId
				FROM ib_TradeReconciliationSummary trs 
				INNER JOIN ib_TradeReconciliation tr ON tr.TradeReconciliationId = trs.TradeReconciliationId
				WHERE TradeReconciliationSummaryId = @TradeReconciliationSummaryId
				
				DECLARE @DateToUseForFindingPrice DATETIME
				
				SET @DateToUseForFindingPrice =
					CASE WHEN @AsOfDAte IS NULL THEN @TradeRecAsOfDate
					ELSE @AsOfDate
					END
					
				EXEC ib_Price_GetPreviousByAlternateKey @DateToUseForFindingPrice, @DataSourceId, @OtherDataSourceId, @ExchangeId,@InstrumentId,@CurrencyId,@ExpiryYear
						,@ExpiryMonth,@ExpiryDay,@StrikePrice,@OptionTypeCode, @SettlementPrice OUTPUT
		END
	END
		/*SET @ErrorMessage = ''No Settlement Price Found for: '' + dbo.GetDetailedErrorMessageByTradeReconciliationDetailId(@TradeReconciliationSummaryId,NULL)
		IF(@@TRANCOUNT = 1) ROLLBACK TRAN
			ELSE IF(@@TRANCOUNT > 1) COMMIT TRAN LSInsert
		RETURN -1*/

	SELECT @Value = (@SettlementPrice - TradePrice)*dbo.GetInstrumentTickSizeByInstrumentId(InstrumentId)
			*(CASE WHEN @IsLongInsert=1 THEN @QuantityAmount  ELSE @QuantityAmount*(-1) END)*@CancelMultiplier 
		FROM ib_TradeReconciliationSummary trs WHERE TradeReconciliationSummaryId=@TradeReconciliationSummaryId
END
ELSE 
BEGIN
	SET @SettlementPrice = 0
	--do some grouping
	
	DECLARE @SumTradeValue DECIMAL(24,10)
	DECLARE @SumLots INT
	SELECT @SumTradeValue = SUM(ISNULL(trx.MarketValue, adj.Value))
		FROM ib_TradeReconciliationDetail trd 
		LEFT JOIN ib_Trx trx ON trd.TrxId=trx.TrxId
		LEFT JOIN ib_Adjustment adj ON trd.AdjustmentId=adj.AdjustmentId
		INNER JOIN @tempTranDetail ttrd ON trd.TradeReconciliationDetailId=ttrd.TradeReconciliationDetailId
		WHERE IsLong=@IsLongInsert 
		--only positive or negative ones
		AND ( 
				(@QuantityAmount > 0 
					AND (
							(@IsLongInsert = 1 AND ((ttrd.InternalLong > 0 AND ttrd.ExternalLong = 0) OR (ttrd.InternalLong = 0 AND ttrd.ExternalLong > 0)))
							OR
							(@IsLongInsert = 0 AND ((ttrd.InternalShort > 0 AND ttrd.ExternalShort = 0) OR (ttrd.InternalShort = 0 AND ttrd.ExternalShort > 0)))
						)
				 )
			  OR (@QuantityAmount < 0 
					AND (
							(@IsLongInsert = 1 AND ((ttrd.InternalLong < 0 AND ttrd.ExternalLong = 0) OR (ttrd.InternalLong = 0 AND ttrd.ExternalLong < 0)))
							OR
							(@IsLongInsert = 0 AND ((ttrd.InternalShort < 0 AND ttrd.ExternalShort = 0) OR (ttrd.InternalShort = 0 AND ttrd.ExternalShort < 0)))
						)
				 )
			)
	SELECT @SumLots = SUM(CASE WHEN @IsLongInsert=1 THEN  ABS(InternalLong) + ABS(ExternalLong) 
													ELSE ABS(InternalShort) + ABS(ExternalShort) 
						END)
		FROM @tempTranDetail ttrd 
		WHERE IsLong=@IsLongInsert
		--only positive or negative ones
		AND ( 
				(@QuantityAmount > 0 
					AND (
							(@IsLongInsert = 1 AND ((ttrd.InternalLong > 0 AND ttrd.ExternalLong = 0) OR (ttrd.InternalLong = 0 AND ttrd.ExternalLong > 0)))
							OR
							(@IsLongInsert = 0 AND ((ttrd.InternalShort > 0 AND ttrd.ExternalShort = 0) OR (ttrd.InternalShort = 0 AND ttrd.ExternalShort > 0)))
						)
				 )
			  OR (@QuantityAmount < 0 
					AND (
							(@IsLongInsert = 1 AND ((ttrd.InternalLong < 0 AND ttrd.ExternalLong = 0) OR (ttrd.InternalLong = 0 AND ttrd.ExternalLong < 0)))
							OR
							(@IsLongInsert = 0 AND ((ttrd.InternalShort < 0 AND ttrd.ExternalShort = 0) OR (ttrd.InternalShort = 0 AND ttrd.ExternalShort < 0)))
						)
				 )
			)
	IF (@SumLots = 0) -- divide by zero error, so we should throw exception
		BEGIN
			SET @ErrorMessage = ''Sum Of All Lots is Zero for: '' + dbo.GetDetailedErrorMessageByTradeReconciliationDetailId(@TradeReconciliationSummaryId,NULL)
			IF(@@TRANCOUNT = 1) ROLLBACK TRAN
			ELSE IF(@@TRANCOUNT > 1) COMMIT TRAN LSInsert
			RETURN -1
		END
	
	DECLARE @AdjustmentTypeCode VARCHAR(100)
	SET @AdjustmentTypeCode = NULL

	SELECT @AdjustmentTypeCode = at.Code
	FROM ib_AdjustmentHeader ah 
	INNER JOIN ib_AdjustmentType at ON ah.AdjustmentTypeId = at.AdjustmentTypeId
	WHERE ah.AdjustmentHeaderId = @AdjustmentHeaderId
	
	DECLARE @TradePrice DECIMAL(24,10)	
	SELECT @TradePrice = trs.TradePrice FROM ib_TradeReconciliationSummary trs WHERE trs.TradeReconciliationSummaryId = @TradeReconciliationSummaryId
		
	IF (@InstrumentTypeCode = ''P'' AND (@AdjustmentTypeCode = ''TI'' OR @AdjustmentTypeCode = ''TC'' ) AND @TradePrice = 0)
		SET @Value = 0
	ELSE
		SET @Value = (@SumTradeValue/@SumLots) * ABS(@QuantityAmount) * @CancelMultiplier 

END

IF @Value IS NULL
BEGIN
	SET @ErrorMessage = ''Can not calculate value for: '' + dbo.GetDetailedErrorMessageByTradeReconciliationDetailId(@TradeReconciliationSummaryId,NULL)
	IF(@@TRANCOUNT = 1) ROLLBACK TRAN
		ELSE IF(@@TRANCOUNT > 1) COMMIT TRAN LSInsert
	RETURN -1
END

DECLARE @ClassId INT
DECLARE @AdjustmentId INT
DECLARE @Quantity INT
	
	SET @ClassId = (SELECT ClassId FROM ib_Account WHERE AccountId=@AccountId)
	SET @Quantity = @QuantityAmount * @CancelMultiplier
	
	INSERT INTO ib_Adjustment ([TemplateId], [ExchangeId], [InstrumentId], [InternalExternalCode], [TradeDate], [AdjustmentDate], 
	[Quantity], [CurrencyId], [ExpiryYear], [ExpiryMonth], [ExpiryDay], [StrikePrice], [TradePrice], [SettlementPrice], [OptionTypeCode], [VALUE], 
	[CreateDate], [CreateUsername], [MatchCodeId], [AdjustmentHeaderId], [DataSourceId], [FirmId], [QuantityLong], [QuantityShort], 
	[DetailAccountId], [AccountId], [ClassId], [TrxTypeCode],AdjustmentStatusId)
	SELECT tr.TemplateId, trs.ExchangeId, trs.InstrumentId, @InternalExternalCode, tr.Today, -- This is OK for Trade Date
	CASE WHEN @AsOfDate IS NULL THEN tr.Today ELSE @AsOfDate END -- Use AsOfDate from rolled adjustment if passed in
	,CASE WHEN @IsLongInsert=1 THEN @Quantity ELSE -1*@Quantity END--Quantity
	, trs.CurrencyId, trs.ExpiryYear, trs.ExpiryMonth, trs.ExpiryDay, trs.StrikePrice, trs.TradePrice, @SettlementPrice, trs.OptionTypeCode, 
	@Value, GETDATE(), @CreateUsername, mc.MatchCodeId, @AdjustmentHeaderId, @DataSourceId, @FirmId
	,CASE WHEN @IsLongInsert=1 THEN @Quantity ELSE 0 END--QuantityLoNG
	,CASE WHEN @IsLongInsert=0 THEN @Quantity ELSE 0 END--QuantityShoRT
	,@DetailAccountId, @AccountId , @ClassId, NULL, @AdjustmentStatusId
		FROM ib_TradeReconciliation tr
		INNER JOIN ib_TradeReconciliationSummary trs ON trs.TradeReconciliationId=tr.TradeReconciliationId
		INNER JOIN ib_MatchCode mc ON mc.TemplateId=tr.TemplateId AND mc.MatchCode=trs.MatchCode
		WHERE trs.TradeReconciliationSummaryId=@TradeReconciliationSummaryId
	
	SET  @AdjustmentId = SCOPE_IDENTITY()

	INSERT INTO [dbo].[ib_TradeReconciliationDetail] 
	([TradeReconciliationId], [MatchCode], [TrxId], [ExchangeId], [FirmId], [AccountId], [DetailAccountId]
	, [InstrumentId], [ClassId], [ExpiryYear], [ExpiryMonth], [ExpiryDay], [OptionTypeCode], [CurrencyId], [StrikePrice]
	, [TradePrice], [InternalLong], [InternalShort], [ExternalLong], [ExternalShort], 
	[CreateDate], [CreateUsername], [IsMatched], [MatchingTradeReconciliationDetailId], [InternalExternalCode], [DataSourceId], [TrxDate], [TrxTypeCode], [AdjustmentId])
	SELECT trs.TradeReconciliationId, trs.MatchCode, NULL , trs.ExchangeId, @FirmId, @AccountId, @DetailAccountId
	, trs.InstrumentId, @ClassId, trs.ExpiryYear, trs.ExpiryMonth, trs.ExpiryDay, trs.OptionTypeCode, trs.CurrencyId, trs.StrikePrice
	, trs.TradePrice
	, CASE WHEN @IsLongInsert=1 AND @InternalExternalCode = ''I'' THEN @Quantity ELSE 0 END --InternalLong
	, CASE WHEN @IsLongInsert=0 AND @InternalExternalCode = ''I'' THEN @Quantity ELSE 0 END --InternalShort
	, CASE WHEN @IsLongInsert=1 AND @InternalExternalCode = ''E'' THEN @Quantity ELSE 0 END --ExternalLong
	, CASE WHEN @IsLongInsert=0 AND @InternalExternalCode = ''E'' THEN @Quantity ELSE 0 END --ExternalShort
	, GETDATE(), @CreateUsername, NULL, NULL, @InternalExternalCode, @DataSourceId, tr.Today, NULL, @AdjustmentId
	FROM ib_TradeReconciliation tr
		INNER JOIN ib_TradeReconciliationSummary trs ON trs.TradeReconciliationId=tr.TradeReconciliationId
	WHERE trs.TradeReconciliationSummaryId=@TradeReconciliationSummaryId

COMMIT TRAN LSInsert
RETURN 0
END TRY
BEGIN CATCH
ROLLBACK TRAN
EXEC [dbo].[sp_RethrowError]
END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TradeReconciliationSummary_GetQuantityAndPosNegForGroupAdj]''
');

GO
EXECUTE ('CREATE FUNCTION [dbo].[ib_TradeReconciliationSummary_GetQuantityAndPosNegForGroupAdj]
(
	@TradeReconciliationSummaryId INT
	,@IsCancel BIT
)
  RETURNS @Result TABLE (InternalExternalCode CHAR(1), Quantity INT, IsLong BIT)  AS
  /*
--	Get what type of record to insert for grouped adjustments
--	Created 16 Jun 2010 ED
*/
  
BEGIN
	DECLARE @ICode CHAR(1)
	DECLARE @ECode CHAR(1)
	--if it is contra insertion, then Internal needs to be changed to External and vice-versa, as the oposite side will be cancelled
	IF (@IsCancel = 1)
		BEGIN
			SET @ICode = ''I''
			SET @ECode = ''E''
		END
	ELSE
		BEGIN
			SET @ICode = ''E''
			SET @ECode = ''I''
		END
	
	DECLARE @tempTranDetail TABLE 
				(
					[InternalLong] INT 
					,[InternalShort] INT 
					,[ExternalLong] INT 
					,[ExternalShort] INT 
				)
	INSERT INTO @tempTranDetail
			([InternalLong],[InternalShort],[ExternalLong],[ExternalShort])
	SELECT  
			 [trd].[InternalLong]
			,[trd].[InternalShort]
			,[trd].[ExternalLong]
			,[trd].[ExternalShort]
			FROM [dbo].[ib_TradeReconciliationSummary] [trs]
			INNER JOIN [dbo].[ib_TradeReconciliationDetail] [trd] 
				ON [trs].[TradeReconciliationId] = [trd].[TradeReconciliationId]
					AND [trd].[ExchangeId] = [trs].[ExchangeId]
					AND [trd].[CurrencyId] = [trs].[CurrencyId]
					AND [trd].[InstrumentId] = [trs].[InstrumentId]
					AND [trd].[MatchCode] = [trs].[MatchCode]
					AND [trd].[ExpiryMonth] = [trs].[ExpiryMonth]
					AND [trd].[ExpiryYear] = [trs].[ExpiryYear]
					AND [trd].[ExpiryDay] = [trs].[ExpiryDay] 
					AND [trd].[OptionTypeCode] = [trs].[OptionTypeCode]
					AND [trd].[StrikePrice] = [trs].[StrikePrice]
					AND [trd].[TradePrice] = [trs].[TradePrice]
			WHERE [trs].[TradeReconciliationSummaryId] = @TradeReconciliationSummaryId
				AND [trd].[IsMatched] IS NULL	

	--positive internal/external long
	INSERT INTO @Result (InternalExternalCode, Quantity, IsLong)
	SELECT CASE WHEN SUM(InternalLong) > SUM(ExternalLong) THEN @ICode ELSE @ECode END
		 , ABS(SUM(InternalLong)-SUM(ExternalLong))
		 ,1
	FROM @tempTranDetail WHERE (InternalLong > 0 AND ExternalLong = 0) OR (InternalLong = 0 AND ExternalLong > 0)
		HAVING SUM(InternalLong)!=SUM(ExternalLong)
		
	--negative internal/external long
	INSERT INTO @Result (InternalExternalCode, Quantity,IsLong)
	SELECT CASE WHEN SUM(InternalLong) < SUM(ExternalLong) THEN @ICode ELSE @ECode END
		 , -1*ABS(SUM(InternalLong)-SUM(ExternalLong))
		 ,1
	FROM @tempTranDetail WHERE (InternalLong < 0 AND ExternalLong = 0) OR (InternalLong = 0 AND ExternalLong < 0)
		HAVING SUM(InternalLong)!=SUM(ExternalLong)
	
	--positive internal/external Short
	INSERT INTO @Result (InternalExternalCode, Quantity,IsLong)
	SELECT CASE WHEN SUM(InternalShort) > SUM(ExternalShort) THEN @ICode ELSE @ECode END
		 , ABS(SUM(InternalShort)-SUM(ExternalShort))
		 ,0
	FROM @tempTranDetail WHERE (InternalShort > 0 AND ExternalShort = 0) OR (InternalShort = 0 AND ExternalShort > 0)
		HAVING SUM(InternalShort)!=SUM(ExternalShort)
		
	--negative internal/external Short
	INSERT INTO @Result (InternalExternalCode, Quantity,IsLong)
	SELECT CASE WHEN SUM(InternalShort) < SUM(ExternalShort) THEN @ICode ELSE @ECode END
		 , -1*ABS(SUM(InternalShort)-SUM(ExternalShort))
		 ,0
	FROM @tempTranDetail WHERE (InternalShort < 0 AND ExternalShort = 0) OR (InternalShort = 0 AND ExternalShort < 0)
		HAVING SUM(InternalShort)!=SUM(ExternalShort)
	
	RETURN
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TradeReconciliationSummary_GenerateTradeCancelAdjustmentsAtGroupLevel]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_TradeReconciliationSummary_GenerateTradeCancelAdjustmentsAtGroupLevel]
(	
	@TradeReconciliationSummaryId INT
	, @AdjustmentHeaderId INT
	, @CreateUsername VARCHAR(50)
	, @ErrorMessage VARCHAR(MAX) OUTPUT
	, @AsOfDate DATETIME = NULL
)
AS
SET NOCOUNT ON
/*
--	Insert trade rec CANCEL adjustment
--	19 May 2010 ED		Creation
--	16 Jun 2010 ED		MBAL 15710 - add logic for positive/negative lots
--	28 Jul 2010	AAJM	MBAL-16300 - Specify AsOfDate for Rolled Trade Adjustment
*/

BEGIN TRY
BEGIN TRAN TrCancel

DECLARE @InstrumentTypeCode VARCHAR(50)

--get instrument type

SELECT @InstrumentTypeCode = it.Code FROM ib_TradeReconciliationSummary trs
	INNER JOIN ib_Instrument i ON trs.InstrumentId=i.InstrumentId
	INNER JOIN ib_InstrumentType it ON i.InstrumentTypeId=it.InstrumentTypeId
	WHERE trs.TradeReconciliationSummaryId=@TradeReconciliationSummaryId
IF @InstrumentTypeCode IS NULL OR (@InstrumentTypeCode != ''F'' AND @InstrumentTypeCode != ''O'' AND @InstrumentTypeCode != ''P'')
BEGIN
	SET @ErrorMessage = ''Wrong Instrument Type: '' + @InstrumentTypeCode  + dbo.GetDetailedErrorMessageByTradeReconciliationDetailId(@TradeReconciliationSummaryId,NULL)
	IF(@@TRANCOUNT = 1) ROLLBACK TRAN
		ELSE IF(@@TRANCOUNT > 1) COMMIT TRAN TrCancel
	RETURN -1
END

	DECLARE @InternalExternalCode CHAR(1)
	DECLARE @Quantity INT
	DECLARE @IsLong BIT
	DECLARE @tempGroupDetails TABLE(InternalExternalCode CHAR(1), Quantity INT, IsLong BIT)
	INSERT INTO @tempGroupDetails(InternalExternalCode, Quantity, IsLong)
	SELECT  InternalExternalCode, Quantity, IsLong FROM dbo.ib_TradeReconciliationSummary_GetQuantityAndPosNegForGroupAdj(@TradeReconciliationSummaryId, 1)
	
	DECLARE groupDetail_cursor CURSOR FOR
	SELECT InternalExternalCode, Quantity,IsLong FROM @tempGroupDetails
	
	OPEN groupDetail_cursor
	
		FETCH NEXT FROM groupDetail_cursor
		INTO @InternalExternalCode, @Quantity,@IsLong
			
		-- Check @@FETCH_STATUS to see IF there are any more rows to fetch.
		WHILE @@FETCH_STATUS = 0
		BEGIN
			 EXEC ib_TradeReconciliationSummary_InsertGroupedAdjustmentAndDetail @TradeReconciliationSummaryId, @AdjustmentHeaderId
			,@InternalExternalCode, @Quantity, @InstrumentTypeCode, @IsLong, -1,  @CreateUsername, @ErrorMessage OUTPUT, @AsOfDate
			IF LEN(@ErrorMessage) > 0
			BEGIN
			IF(@@TRANCOUNT = 1) ROLLBACK TRAN
				ELSE IF(@@TRANCOUNT > 1) COMMIT TRAN TrCancel
			RETURN -1
			END
		FETCH NEXT FROM groupDetail_cursor
		INTO @InternalExternalCode, @Quantity,@IsLong
		END
						
	CLOSE groupDetail_cursor
	DEALLOCATE groupDetail_cursor

COMMIT TRAN TrCancel
END TRY
BEGIN CATCH
ROLLBACK TRAN
EXEC [dbo].[sp_RethrowError]
END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TradeReconciliationSummary_GenerateTradeAddAdjustmentsAtGroupLevel]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_TradeReconciliationSummary_GenerateTradeAddAdjustmentsAtGroupLevel]
(	
	@TradeReconciliationSummaryId INT
	, @AdjustmentHeaderId INT
	, @CreateUsername VARCHAR(50)
	, @ErrorMessage VARCHAR(MAX) OUTPUT
	, @AsOfDate DATETIME = NULL
)
AS
SET NOCOUNT ON
/*
--	Insert trade rec ADD adjustment
--	19 May 2010 ED		Created 
--	16 Jun 2010 ED		MBAL 15710 - add logic for positive/negative lots
--	28 Jul 2010	AAJM	MBAL-16300 Specify AsOfDate for Rolled Trade Adjustment
*/


BEGIN TRY
BEGIN TRAN TrAdd
--we will need DataSource, Firm, Account and DetailAccount

DECLARE @InstrumentTypeCode VARCHAR(50)

--get instrument type
SELECT @InstrumentTypeCode = it.Code FROM ib_TradeReconciliationSummary trs
	INNER JOIN ib_Instrument i ON trs.InstrumentId=i.InstrumentId
	INNER JOIN ib_InstrumentType it ON i.InstrumentTypeId=it.InstrumentTypeId
	WHERE trs.TradeReconciliationSummaryId=@TradeReconciliationSummaryId
IF @InstrumentTypeCode IS NULL OR (@InstrumentTypeCode != ''F'' AND @InstrumentTypeCode != ''O'' AND @InstrumentTypeCode != ''P'')
BEGIN
	SET @ErrorMessage = ''Wrong Instrument Type: '' + @InstrumentTypeCode  + dbo.GetDetailedErrorMessageByTradeReconciliationDetailId(@TradeReconciliationSummaryId,NULL)
	IF(@@TRANCOUNT = 1) ROLLBACK TRAN
		ELSE IF(@@TRANCOUNT > 1) COMMIT TRAN TrCancel
	RETURN -1
END

	DECLARE @InternalExternalCode CHAR(1)
	DECLARE @Quantity INT
	DECLARE @IsLong BIT
	DECLARE @tempGroupDetails TABLE(InternalExternalCode CHAR(1), Quantity INT, IsLong BIT)
	INSERT INTO @tempGroupDetails(InternalExternalCode, Quantity, IsLong)
	SELECT  InternalExternalCode, Quantity, IsLong FROM dbo.ib_TradeReconciliationSummary_GetQuantityAndPosNegForGroupAdj(@TradeReconciliationSummaryId, 0)
	
	DECLARE groupDetail_cursor CURSOR FOR
	SELECT InternalExternalCode, Quantity,IsLong FROM @tempGroupDetails
	
	OPEN groupDetail_cursor
	
		FETCH NEXT FROM groupDetail_cursor
		INTO @InternalExternalCode, @Quantity,@IsLong
			
		-- Check @@FETCH_STATUS to see IF there are any more rows to fetch.
		WHILE @@FETCH_STATUS = 0
		BEGIN
			 EXEC ib_TradeReconciliationSummary_InsertGroupedAdjustmentAndDetail @TradeReconciliationSummaryId, @AdjustmentHeaderId
			,@InternalExternalCode, @Quantity, @InstrumentTypeCode, @IsLong, 1,  @CreateUsername, @ErrorMessage OUTPUT, @AsOfDate
			IF LEN(@ErrorMessage) > 0
			BEGIN
			IF(@@TRANCOUNT = 1) ROLLBACK TRAN
				ELSE IF(@@TRANCOUNT > 1) COMMIT TRAN TrAdd
			RETURN -1
			END
		FETCH NEXT FROM groupDetail_cursor
		INTO @InternalExternalCode, @Quantity,@IsLong
		END
						
	CLOSE groupDetail_cursor
	DEALLOCATE groupDetail_cursor
	
COMMIT TRAN TrAdd
END TRY
BEGIN CATCH
ROLLBACK TRAN
EXEC [dbo].[sp_RethrowError]
END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TradeReconciliationDetail_GenerateTradeCancelAdjustmentsAtDetailLevel]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_TradeReconciliationDetail_GenerateTradeCancelAdjustmentsAtDetailLevel]
(	
	@TradeReconciliationDetailId INT
	, @AdjustmentHeaderId INT
	, @CreateUsername VARCHAR(50)
	, @ErrorMessage VARCHAR(MAX) OUTPUT
	, @AsOfDate DATETIME = NULL
)
AS
SET NOCOUNT ON
--	Insert trade rec CANCEL adjustment
--	18 May 2010 ED		Creation
--  24 Jun 2010 ED		MBAL 15712 - Improved logic for SettlementPrice
--  28 Jun 2010 ED		MBAL 15697 - set status = ''U'' is account blank/not approved
--  22 Jul 2010 AAJM	MBAL-16249 When generating trade cancel adj and trade add adj, set Value to 0 for Instrument Type P (Premium Options)
--  27 Jul 2010	AAJM	MBAL-16249 - Ensure TradePrice = 0 when resetting Value
--	28 Jul 2010	AAJM	MBAL-16300 - Specify AsOfDate for Rolled Trade Adjustment
--	08 Sep 2010	amk		MBAL-16609: Bug Fix: get trxdate from trd record if no trx link made
--  04 Nov 2010	ED		EIB 26171 - fix value for instrument type =''P''

BEGIN TRY
	BEGIN TRAN TrCancel

	DECLARE @SettlementPrice DECIMAL(24,10)
	DECLARE @Value DECIMAL(24,10)
	DECLARE @InstrumentTypeCode VARCHAR(50)

	--get instrument type

	SELECT @InstrumentTypeCode = it.Code 
	FROM ib_TradeReconciliationDetail trd 
		INNER JOIN ib_Instrument i ON trd.InstrumentId = i.InstrumentId
		INNER JOIN ib_InstrumentType it ON i.InstrumentTypeId = it.InstrumentTypeId
	WHERE trd.TradeReconciliationDetailId = @TradeReconciliationDetailId
	IF @InstrumentTypeCode IS NULL OR (@InstrumentTypeCode != ''F'' AND @InstrumentTypeCode != ''O'' AND @InstrumentTypeCode != ''P'')
	BEGIN
		SET @ErrorMessage = ''Wrong Instrument Type: '' + @InstrumentTypeCode  + dbo.GetDetailedErrorMessageByTradeReconciliationDetailId(NULL,@TradeReconciliationDetailId)
		IF(@@TRANCOUNT = 1) ROLLBACK TRAN
			ELSE IF(@@TRANCOUNT > 1) COMMIT TRAN TrCancel
		RETURN -1
	END
	IF @InstrumentTypeCode = ''F'' OR @InstrumentTypeCode = ''O'' 
	BEGIN
		--get price
		SET @SettlementPrice = (
			SELECT dbo.GetSettlementPriceByAlternateKey(
			CASE WHEN @AsOfDate IS NULL THEN tr.Today ELSE @AsOfDate END -- Use Rolled Over Adjustment Date if passed in
			, trd.DataSourceId, trd.ExchangeId, trd.InstrumentId, trd.CurrencyId, 
								trd.ExpiryYear, trd.ExpiryMonth, trd.ExpiryDay, trd.StrikePrice, trd.OptionTypeCode) FROM ib_TradeReconciliation tr
								INNER JOIN ib_TradeReconciliationDetail trd ON trd.TradeReconciliationId=tr.TradeReconciliationId
								WHERE trd.TradeReconciliationDetailId=@TradeReconciliationDetailId)
		IF @SettlementPrice IS NULL
		BEGIN
			DECLARE @OtherDataSourceId INT, @DataSourceId INT
			SET @DataSourceId = (SELECT DataSourceId 
									FROM ib_TradeReconciliationDetail 
									WHERE TradeReconciliationDetailId = @TradeReconciliationDetailId)
			SET @OtherDataSourceId = (SELECT [dbo].[GetDataSourceIdForTradeAdjustments]( TemplateId,InstrumentId,ExchangeId ,MatchCode,CASE WHEN InternalExternalCode = ''I'' THEN ''E'' ELSE ''I'' END)
								FROM ib_TradeReconciliation tr
								INNER JOIN ib_TradeReconciliationDetail trd ON trd.TradeReconciliationId=tr.TradeReconciliationId
										WHERE trd.TradeReconciliationDetailId = @TradeReconciliationDetailId)
			SET @SettlementPrice = (SELECT dbo.GetSettlementPriceByAlternateKey(
				CASE WHEN @AsOfDate IS NULL THEN tr.Today ELSE @AsOfDate END  -- Use Rolled Over Adjustment Date if passed in
				, @OtherDataSourceId, trd.ExchangeId, trd.InstrumentId, trd.CurrencyId, 
								trd.ExpiryYear, trd.ExpiryMonth, trd.ExpiryDay, trd.StrikePrice, trd.OptionTypeCode) FROM ib_TradeReconciliation tr
								INNER JOIN ib_TradeReconciliationDetail trd ON trd.TradeReconciliationId = tr.TradeReconciliationId
								WHERE trd.TradeReconciliationDetailId = @TradeReconciliationDetailId)
			IF @SettlementPrice IS NULL -- try to get older ones
			BEGIN
				DECLARE	@TradeRecAsOfDate DATETIME, @InstrumentId INT, @ExpiryYear SMALLINT, @ExpiryMonth SMALLINT, @ExpiryDay SMALLINT, @StrikePrice MONEY, @OptionTypeCode VARCHAR(25), @ExchangeId INT
						,@CurrencyId INT
				SELECT @TradeRecAsOfDate = Today, @InstrumentId = InstrumentId,  @ExpiryYear = ExpiryYear, @ExpiryMonth = ExpiryMonth,
						@ExpiryDay = ExpiryDay, @StrikePrice = StrikePrice, @OptionTypeCode = OptionTypeCode, @ExchangeId = ExchangeId, @CurrencyId = CurrencyId
				FROM ib_TradeReconciliation tr
					INNER JOIN ib_TradeReconciliationDetail trd ON trd.TradeReconciliationId=tr.TradeReconciliationId
				WHERE trd.TradeReconciliationDetailId = @TradeReconciliationDetailId
											
				DECLARE @DateToUseForFindingPrice DATETIME
					
				SET @DateToUseForFindingPrice =
					CASE WHEN @AsOfDAte IS NULL THEN @TradeRecAsOfDate
					ELSE @AsOfDate
					END
													
				EXEC ib_Price_GetPreviousByAlternateKey @DateToUseForFindingPrice, @DataSourceId, @OtherDataSourceId, @ExchangeId,@InstrumentId,@CurrencyId,@ExpiryYear
					, @ExpiryMonth, @ExpiryDay, @StrikePrice, @OptionTypeCode, @SettlementPrice OUTPUT
			END
		END
		SELECT @Value = (@SettlementPrice - TradePrice) * dbo.GetInstrumentTickSizeByInstrumentId(InstrumentId)
				*(InternalLong+ExternalLong-InternalShort-ExternalShort)*(-1) -- -1 because it is cancell
		FROM ib_TradeReconciliationDetail trd 
		WHERE trd.TradeReconciliationDetailId = @TradeReconciliationDetailId
	END
	ELSE 
	BEGIN

		-- MBAL-16249 Premium Paid Assignment Adjustments shouldn''t be created with Value
		
		DECLARE @TradePrice DECIMAL(24,10)	
		SELECT @TradePrice = trd.TradePrice 
		FROM ib_TradeReconciliationDetail trd 
		WHERE trd.TradeReconciliationDetailId = @TradeReconciliationDetailId	
		
		IF (@InstrumentTypeCode = ''P'' AND @TradePrice = 0)
			SET @Value = 0
		ELSE
			SELECT @Value = t.MarketValue * (-1) -- -1 because it is cancell
			FROM ib_TradeReconciliationDetail trd 
				INNER JOIN ib_Trx t ON trd.TrxId=t.TrxId
			WHERE trd.TradeReconciliationDetailId = @TradeReconciliationDetailId
						
		SET @SettlementPrice = 0
		IF @Value IS NULL
			SELECT @Value = (@SettlementPrice - TradePrice) * dbo.GetInstrumentTickSizeByInstrumentId(InstrumentId)
					*(InternalLong+ExternalLong-InternalShort-ExternalShort)*(-1) -- -1 because it is cancell
			FROM ib_TradeReconciliationDetail trd 
			WHERE trd.TradeReconciliationDetailId = @TradeReconciliationDetailId
		
	END

	IF @Value IS NULL
	BEGIN
		SET @ErrorMessage = ''Can not calculate value for: '' + dbo.GetDetailedErrorMessageByTradeReconciliationDetailId(NULL, @TradeReconciliationDetailId)
		IF(@@TRANCOUNT = 1) ROLLBACK TRAN
			ELSE IF(@@TRANCOUNT > 1) COMMIT TRAN TrCancel
		RETURN -1
	END

	DECLARE @AdjustmentId INT
	DECLARE @AdjustmentStatusId INT
	SET @AdjustmentStatusId = (SELECT [as].AdjustmentStatusId 
								FROM ib_AdjustmentStatus [as]
									LEFT JOIN ib_TradeReconciliationDetail trd ON trd.TradeReconciliationDetailId = @TradeReconciliationDetailId
									LEFT JOIN ib_Account ac ON ac.AccountId = trd.AccountId
								WHERE [as].Code = ''U'' AND (ac.IsApproved = 0 OR trd.AccountId IS NULL))
	
	INSERT INTO ib_Adjustment ([TemplateId], [ExchangeId], [InstrumentId], [InternalExternalCode], [TradeDate], [AdjustmentDate]
		, [Quantity], [CurrencyId], [ExpiryYear], [ExpiryMonth], [ExpiryDay], [StrikePrice], [TradePrice], [SettlementPrice], [OptionTypeCode], [VALUE]
		, [CreateDate], [CreateUsername], [MatchCodeId], [AdjustmentHeaderId], [DataSourceId], [FirmId], [QuantityLong], [QuantityShort]
		, [DetailAccountId], [AccountId], [ClassId], [TrxTypeCode], AdjustmentStatusId)
	SELECT tr.TemplateId, trd.ExchangeId, trd.InstrumentId, trd.InternalExternalCode, ISNULL(t.TrxDate, trd.TrxDate)
		, CASE WHEN @AsOfDate IS NULL THEN tr.Today ELSE @AsOfDate END,  -- Use Rolled Over Adjustment Date if passed in
		-1 * (InternalLong+ExternalLong-InternalShort-ExternalShort) --Quantity
		, trd.CurrencyId, trd.ExpiryYear, trd.ExpiryMonth, trd.ExpiryDay, trd.StrikePrice, trd.TradePrice, @SettlementPrice, trd.OptionTypeCode
		, @Value, GETDATE(), @CreateUsername, mc.MatchCodeId, @AdjustmentHeaderId, trd.DataSourceId, trd.FirmId, -1*(InternalLong+ExternalLong), -1*(InternalShort+ExternalShort)
		, trd.DetailAccountId, trd.AccountId, trd.ClassId, trd.TrxTypeCode, @AdjustmentStatusId
	FROM ib_TradeReconciliation tr
		INNER JOIN ib_TradeReconciliationDetail trd ON trd.TradeReconciliationId = tr.TradeReconciliationId
		INNER JOIN ib_MatchCode mc ON mc.TemplateId = tr.TemplateId AND mc.MatchCode = trd.MatchCode
		LEFT JOIN ib_Trx t ON t.TrxId = trd.TrxId
	WHERE trd.TradeReconciliationDetailId = @TradeReconciliationDetailId
	
	SET  @AdjustmentId = SCOPE_IDENTITY()

	INSERT INTO [dbo].[ib_TradeReconciliationDetail] ([TradeReconciliationId], [MatchCode], [TrxId], [ExchangeId], [FirmId], [AccountId], [DetailAccountId], [InstrumentId], [ClassId], [ExpiryYear], [ExpiryMonth], [ExpiryDay], [OptionTypeCode], [CurrencyId], [StrikePrice], [TradePrice], [InternalLong], [InternalShort], [ExternalLong], [ExternalShort], [CreateDate], [CreateUsername], [IsMatched], [MatchingTradeReconciliationDetailId], [InternalExternalCode], [DataSourceId], [TrxDate], [TrxTypeCode], [AdjustmentId])
	SELECT trd.TradeReconciliationId, trd.MatchCode, NULL /*trd.TrxId*/, trd.ExchangeId, trd.FirmId, trd.AccountId, trd.DetailAccountId, trd.InstrumentId, trd.ClassId, trd.ExpiryYear, trd.ExpiryMonth, trd.ExpiryDay, trd.OptionTypeCode, trd.CurrencyId, trd.StrikePrice, trd.TradePrice, -1*trd.InternalLong, -1*trd.InternalShort, -1*trd.ExternalLong, -1*trd.ExternalShort, GETDATE(), @CreateUsername, trd.IsMatched, trd.MatchingTradeReconciliationDetailId, trd.InternalExternalCode, trd.DataSourceId, trd.TrxDate, trd.TrxTypeCode, @AdjustmentId
	FROM ib_TradeReconciliationDetail trd 
	WHERE trd.TradeReconciliationDetailId = @TradeReconciliationDetailId

	COMMIT TRAN TrCancel
END TRY
BEGIN CATCH
	ROLLBACK TRAN
	EXEC [dbo].[sp_RethrowError]
END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TradeReconciliationDetail_GenerateTradeAddAdjustmentsAtDetailLevel]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_TradeReconciliationDetail_GenerateTradeAddAdjustmentsAtDetailLevel]
(	
	@TradeReconciliationDetailId INT
	, @AdjustmentHeaderId INT
	, @CreateUsername VARCHAR(50)
	, @ErrorMessage VARCHAR(MAX) OUTPUT
	, @AsOfDate DATETIME = NULL
)
AS
SET NOCOUNT ON
--	Insert trade rec ADD adjustment
--	18 May 2010 ED		Creation
--  21 Jun 2010 ED		MBAL 13980 - Fix ClassId
--  24 Jun 2010 ED		MBAL 15712 - Improved logic for SettlementPrice
--	24 Jun 2010 ED		BAL 15710 - get account/detail account for TC too
--  28 Jun 2010 ED		MBAL 15697 - set status = ''U'' is account blank/not approved
--  22 Jul 2010 AAJM	MBAL-16249 When generating trade cancel adj and trade add adj, set Value to 0 for Instrument Type P (Premium Options)
--  27 Jul 2010	AAJM	MBAL-16249 - Ensure TradePrice = 0 when resetting Value
--	28 Jul 2010	AAJM	MBAL-16300 - Specify AsOfDate for Rolled Trade Adjustment
--	08 Sep 2010	amk		MBAL-16609: Bug Fix: get trxdate from trd record if no trx link made
--  04 Nov 2010	ED		EIB 26171 - fix value for instrument type =''P''

BEGIN TRY
BEGIN TRAN TrAdd
--we will need DataSource, Firm, Account and DetailAccount
DECLARE @DataSourceId INT
DECLARE @FirmId INT
DECLARE @TemplateId INT
DECLARE @AccountId INT
DECLARE @ClassId INT
DECLARE @DetailAccountId INT
DECLARE @InternalExternalCode CHAR(1)
DECLARE @AdjustmentStatusId INT

--get datasource id
SELECT @TemplateId = TemplateId FROM ib_TradeReconciliation tr
	INNER JOIN ib_TradeReconciliationDetail trs ON tr.TradeReconciliationId=trs.TradeReconciliationId
	WHERE TradeReconciliationDetailId=@TradeReconciliationDetailId

SELECT @InternalExternalCode = CASE WHEN InternalExternalCode=''E'' THEN ''I'' ELSE ''E'' END
	FROM ib_TradeReconciliationDetail WHERE  TradeReconciliationDetailId=@TradeReconciliationDetailId

SELECT @DataSourceId = [dbo].[GetDataSourceIdForTradeAdjustments]( @TemplateId,InstrumentId,ExchangeId ,MatchCode,@InternalExternalCode)
	FROM ib_TradeReconciliationDetail WHERE  TradeReconciliationDetailId=@TradeReconciliationDetailId

IF @DataSourceId IS NULL OR @DataSourceId < 0
BEGIN
	SET @ErrorMessage = [dbo].[SetDataSourceErrorMessage](@DataSourceId) + dbo.GetDetailedErrorMessageByTradeReconciliationDetailId(NULL,@TradeReconciliationDetailId)
	IF(@@TRANCOUNT = 1) ROLLBACK TRAN
		ELSE IF(@@TRANCOUNT > 1) COMMIT TRAN LSInsert
	RETURN -1
END

--try to get firm id
SELECT @FirmId = [dbo].[GetFirmIdForTradeAdjustments] (@TemplateId, MatchCode, ExchangeId, @DataSourceId)
	FROM ib_TradeReconciliationDetail WHERE TradeReconciliationDetailId=@TradeReconciliationDetailId

IF @FirmId < 0  SET @FirmId = NULL

--account is get based on what type of insert is(internal/external)
IF @InternalExternalCode = ''I''
	BEGIN
		SELECT @AccountId = DetailAccountId, @DetailAccountId = DetailAccountId
			FROM ib_TradeReconciliationDetail WHERE TradeReconciliationDetailId=@TradeReconciliationDetailId
		--set status = ''U'' for blank account, too
		SET @AdjustmentStatusId = (SELECT AdjustmentStatusId FROM ib_AdjustmentStatus a
									LEFT JOIN ib_Account ac ON ac.AccountId=@AccountId
									WHERE a.Code=''U'' AND (ac.IsApproved=0 OR @AccountId IS NULL))
	END
ELSE --external, more complex logic
	BEGIN
		DECLARE @Ids TABLE(Id INT)
		DECLARE @NoOfRows INT
		INSERT INTO @Ids(Id)
			SELECT DISTINCT tg.AccountId FROM ib_TemplateGroup tg 
				INNER JOIN ib_TradeReconciliationDetail trd ON tg.[Description]=trd.MatchCode AND tg.TemplateId=@TemplateId AND tg.FirmId=@FirmId
				WHERE TradeReconciliationDetailId=@TradeReconciliationDetailId  AND tg.AccountId IS NOT NULL
		SET @NoOfRows = @@ROWCOUNT
		IF @NoOfRows = 1
				SET @AccountId = (SELECT Id FROM @Ids)
		ELSE IF @NoOfRows > 1
			BEGIN
				DELETE FROM @Ids
				INSERT INTO @Ids(Id)
					SELECT  DISTINCT tg.AccountId FROM ib_TemplateGroup tg 
						INNER JOIN ib_TradeReconciliationDetail trd ON tg.[Description]=trd.MatchCode AND tg.ExchangeId=trd.ExchangeId AND tg.TemplateId=@TemplateId AND tg.FirmId=@FirmId
						WHERE TradeReconciliationDetailId=@TradeReconciliationDetailId  AND tg.AccountId IS NOT NULL
				SET @NoOfRows = @@ROWCOUNT
				IF @NoOfRows = 1
					BEGIN
						SET @AccountId = (SELECT Id FROM @Ids)
						SET @DetailAccountId = (SELECT DetailAccountId FROM ib_TradeReconciliationDetail WHERE TradeReconciliationDetailId=@TradeReconciliationDetailId)
					END
				ELSE
					SELECT @AdjustmentStatusId=AdjustmentStatusId,@AccountId = NULL, @DetailAccountId = NULL FROM ib_AdjustmentStatus a
						WHERE a.Code=''U''
			END
	END

DECLARE @SettlementPrice DECIMAL(24,10)
DECLARE @Value DECIMAL(24,10)
DECLARE @InstrumentTypeCode VARCHAR(50)

--get instrument type

SELECT @InstrumentTypeCode = it.Code FROM ib_TradeReconciliationDetail trd 
	INNER JOIN ib_Instrument i ON trd.InstrumentId=i.InstrumentId
	INNER JOIN ib_InstrumentType it ON i.InstrumentTypeId=it.InstrumentTypeId
	WHERE trd.TradeReconciliationDetailId=@TradeReconciliationDetailId
IF @InstrumentTypeCode IS NULL OR (@InstrumentTypeCode != ''F'' AND @InstrumentTypeCode != ''O'' AND @InstrumentTypeCode != ''P'')
BEGIN
	SET @ErrorMessage = ''Wrong Instrument Type: '' + @InstrumentTypeCode  + dbo.GetDetailedErrorMessageByTradeReconciliationDetailId(NULL,@TradeReconciliationDetailId)
	IF(@@TRANCOUNT = 1) ROLLBACK TRAN
		ELSE IF(@@TRANCOUNT > 1) COMMIT TRAN TrAdd
	RETURN -1
END
IF @InstrumentTypeCode = ''F'' OR @InstrumentTypeCode = ''O'' 
BEGIN
	--get price
	SET @SettlementPrice = (SELECT dbo.GetSettlementPriceByAlternateKey(
		CASE WHEN @AsOfDate IS NULL THEN tr.Today ELSE @AsOfDate END -- Use Rolled Over Adjustment Date if passed in
		, @DataSourceId, trd.ExchangeId, trd.InstrumentId, trd.CurrencyId, 
							trd.ExpiryYear, trd.ExpiryMonth, trd.ExpiryDay, trd.StrikePrice, trd.OptionTypeCode) FROM ib_TradeReconciliation tr
							INNER JOIN ib_TradeReconciliationDetail trd ON trd.TradeReconciliationId=tr.TradeReconciliationId
							WHERE trd.TradeReconciliationDetailId=@TradeReconciliationDetailId)
	IF @SettlementPrice IS NULL
	BEGIN
		DECLARE @OtherDataSourceId INT
		SET @OtherDataSourceId = (SELECT [dbo].[GetDataSourceIdForTradeAdjustments]( @TemplateId,InstrumentId,ExchangeId ,MatchCode,CASE WHEN @InternalExternalCode = ''I'' THEN ''E'' ELSE ''I'' END)
								FROM ib_TradeReconciliationDetail trd WHERE trd.TradeReconciliationDetailId=@TradeReconciliationDetailId)
		SET @SettlementPrice = (SELECT dbo.GetSettlementPriceByAlternateKey(
			CASE WHEN @AsOfDate IS NULL THEN tr.Today ELSE @AsOfDate END -- Use Rolled Over Adjustment Date if passed in
			, @OtherDataSourceId, trd.ExchangeId, trd.InstrumentId, trd.CurrencyId, 
							trd.ExpiryYear, trd.ExpiryMonth, trd.ExpiryDay, trd.StrikePrice, trd.OptionTypeCode) FROM ib_TradeReconciliation tr
							INNER JOIN ib_TradeReconciliationDetail trd ON trd.TradeReconciliationId=tr.TradeReconciliationId
							WHERE trd.TradeReconciliationDetailId=@TradeReconciliationDetailId)
		IF @SettlementPrice IS NULL--try to get older
		BEGIN
				DECLARE	@TradeRecAsOfDate DATETIME, @InstrumentId INT, @ExpiryYear SMALLINT, @ExpiryMonth SMALLINT, @ExpiryDay SMALLINT, @StrikePrice MONEY, @OptionTypeCode VARCHAR(25), @ExchangeId INT
						,@CurrencyId INT
				SELECT @TradeRecAsOfDate = Today, @InstrumentId = InstrumentId,  @ExpiryYear = ExpiryYear, @ExpiryMonth = ExpiryMonth,
						@ExpiryDay = ExpiryDay, @StrikePrice = StrikePrice, @OptionTypeCode = OptionTypeCode, @ExchangeId = ExchangeId, @CurrencyId = CurrencyId
				 FROM ib_TradeReconciliation tr
									INNER JOIN ib_TradeReconciliationDetail trd ON trd.TradeReconciliationId=tr.TradeReconciliationId
											WHERE trd.TradeReconciliationDetailId=@TradeReconciliationDetailId
											
				DECLARE @DateToUseForFindingPrice DATETIME
				
				SET @DateToUseForFindingPrice =
					CASE WHEN @AsOfDAte IS NULL THEN @TradeRecAsOfDate
					ELSE @AsOfDate
					END
					
				EXEC ib_Price_GetPreviousByAlternateKey @DateToUseForFindingPrice, @DataSourceId, @OtherDataSourceId, @ExchangeId,@InstrumentId,@CurrencyId,@ExpiryYear
							,@ExpiryMonth,@ExpiryDay,@StrikePrice,@OptionTypeCode, @SettlementPrice OUTPUT
		END
	END
	SELECT @Value = (@SettlementPrice - TradePrice)*dbo.GetInstrumentTickSizeByInstrumentId(InstrumentId)
			*(InternalLong+ExternalLong-InternalShort-ExternalShort)
		FROM ib_TradeReconciliationDetail trd WHERE trd.TradeReconciliationDetailId=@TradeReconciliationDetailId
END
ELSE 
BEGIN


	-- MBAL-16249 Premium Paid Assignment Adjustments shouldn''t be created with Value

	DECLARE @TradePrice DECIMAL(24,10)	
	SELECT @TradePrice = trd.TradePrice FROM ib_TradeReconciliationDetail trd WHERE trd.TradeReconciliationDetailId=@TradeReconciliationDetailId	
	
	IF (@InstrumentTypeCode = ''P'' AND @TradePrice = 0)
		SET @Value = 0
	ELSE
		SELECT @Value = t.MarketValue
			FROM ib_TradeReconciliationDetail trd 
			INNER JOIN ib_Trx t ON trd.TrxId=t.TrxId
			WHERE trd.TradeReconciliationDetailId=@TradeReconciliationDetailId
				
	SET @SettlementPrice = 0
	IF @Value IS NULL
		SELECT @Value = (@SettlementPrice - TradePrice)*dbo.GetInstrumentTickSizeByInstrumentId(InstrumentId)
			*(InternalLong+ExternalLong-InternalShort-ExternalShort)
		FROM ib_TradeReconciliationDetail trd WHERE trd.TradeReconciliationDetailId=@TradeReconciliationDetailId
	
END

IF @Value IS NULL
BEGIN
	SET @ErrorMessage = ''Can not calculate value for: '' + dbo.GetDetailedErrorMessageByTradeReconciliationDetailId(NULL, @TradeReconciliationDetailId)
	IF(@@TRANCOUNT = 1) ROLLBACK TRAN
		ELSE IF(@@TRANCOUNT > 1) COMMIT TRAN TrAdd
	RETURN -1
END

SET @ClassId = (SELECT ClassId FROM ib_Account WHERE AccountId=@AccountId)

DECLARE @AdjustmentId INT
	
	INSERT INTO ib_Adjustment ([TemplateId], [ExchangeId], [InstrumentId], [InternalExternalCode], [TradeDate], [AdjustmentDate], 
	[Quantity], [CurrencyId], [ExpiryYear], [ExpiryMonth], [ExpiryDay], [StrikePrice], [TradePrice], [SettlementPrice], [OptionTypeCode], [VALUE], 
	[CreateDate], [CreateUsername], [MatchCodeId], [AdjustmentHeaderId], [DataSourceId], [FirmId], [QuantityLong], [QuantityShort], 
	[DetailAccountId], [AccountId], [ClassId], [TrxTypeCode], AdjustmentStatusId)
	SELECT tr.TemplateId, trd.ExchangeId, trd.InstrumentId, @InternalExternalCode, ISNULL(t.TrxDate, trd.TrxDate), 
	CASE WHEN @AsOfDate IS NULL THEN tr.Today ELSE @AsOfDate END,  -- Use rolled adjustment date if passed in otherwise Today
	(InternalLong+ExternalLong-InternalShort-ExternalShort) --Quantity
	, trd.CurrencyId, trd.ExpiryYear, trd.ExpiryMonth, trd.ExpiryDay, trd.StrikePrice, trd.TradePrice, @SettlementPrice, trd.OptionTypeCode, 
	@Value, GETDATE(), @CreateUsername, mc.MatchCodeId, @AdjustmentHeaderId, @DataSourceId, @FirmId, InternalLong+ExternalLong, InternalShort+ExternalShort, 
	@DetailAccountId, @AccountId, @ClassId, trd.TrxTypeCode, @AdjustmentStatusId
		FROM ib_TradeReconciliation tr
		INNER JOIN ib_TradeReconciliationDetail trd ON trd.TradeReconciliationId=tr.TradeReconciliationId
		INNER JOIN ib_MatchCode mc ON mc.TemplateId=tr.TemplateId AND mc.MatchCode=trd.MatchCode
		LEFT JOIN ib_Trx t ON t.TrxId=trd.TrxId
		WHERE trd.TradeReconciliationDetailId=@TradeReconciliationDetailId
	
	SET  @AdjustmentId = SCOPE_IDENTITY()

	INSERT INTO [dbo].[ib_TradeReconciliationDetail] ([TradeReconciliationId], [MatchCode], [TrxId], [ExchangeId], [FirmId], [AccountId], [DetailAccountId], [InstrumentId], [ClassId], [ExpiryYear], [ExpiryMonth], [ExpiryDay], [OptionTypeCode], [CurrencyId], [StrikePrice], [TradePrice], [InternalLong], [InternalShort], [ExternalLong], [ExternalShort], [CreateDate], [CreateUsername], [IsMatched], [MatchingTradeReconciliationDetailId], [InternalExternalCode], [DataSourceId], [TrxDate], [TrxTypeCode], [AdjustmentId])
	SELECT trd.TradeReconciliationId, trd.MatchCode, NULL /*trd.TrxId*/, trd.ExchangeId, @FirmId, @AccountId, @DetailAccountId, trd.InstrumentId, trd.ClassId, trd.ExpiryYear, trd.ExpiryMonth, trd.ExpiryDay, trd.OptionTypeCode, trd.CurrencyId, trd.StrikePrice, trd.TradePrice, trd.ExternalLong, trd.ExternalShort, trd.InternalLong, trd.InternalShort, GETDATE(), @CreateUsername, trd.IsMatched, trd.MatchingTradeReconciliationDetailId, @InternalExternalCode, @DataSourceId, trd.TrxDate, trd.TrxTypeCode, @AdjustmentId
	FROM ib_TradeReconciliationDetail trd 
	WHERE trd.TradeReconciliationDetailId=@TradeReconciliationDetailId

COMMIT TRAN TrAdd
END TRY
BEGIN CATCH
ROLLBACK TRAN
EXEC [dbo].[sp_RethrowError]
END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_ImbalanceReport_GetLatestImbalanceReportIdByTemplateIdAndDate]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_ImbalanceReport_GetLatestImbalanceReportIdByTemplateIdAndDate]
	@TemplateId INT = NULL, 
	@TodaysDate DATETIME = NULL
AS
SET NOCOUNT ON
BEGIN
	IF @TemplateId IS NULL OR @TodaysDate IS NULL
	BEGIN
		RAISERROR (''@TemplateId or @TodaysDate cannot be NULL.'', 19, 1)
	END
	DECLARE @ImbalanceReportId INT
	
	
	SELECT @ImbalanceReportId = MAX(ir.ImbalanceReportId)
	FROM ib_ImbalanceReport ir 
	INNER JOIN ib_Report r on r.TargetReportId = ir.ImbalanceReportId 
						  AND r.ReportType = ''Imbalance''
	WHERE ir.TemplateId = @TemplateId
	  AND ir.[Today] = @TodaysDate
	  AND (r.ErrorMessage IS NULL OR r.ErrorDetails IS NULL)
	  
	SELECT @ImbalanceReportId
	
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_ImbalanceReport_GatherAdjustments]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_ImbalanceReport_GatherAdjustments]
	@ImbalanceReportId INT,
	@ImbalanceReportSummaryId INT = NULL,
	@AdjustmentHeaderId INT = NULL
AS
SET NOCOUNT ON

--	*** SEE ALSO THE SIMILAR ib_ImbalanceReport_RemoveAdjustments (that UN-pokes) ***

--	08 Dec 2006		amk		Creation
--	15 Dec 2006		amk		Bug Fix: Apply today to today, not yesterday!
--  08 Feb 2010		AAJM	Use Adjustment TradeDate not AdjustmentDate
--  05 May 2010		ED		Use MatchCode table and matchCodeId
--  19 May 2010     ED      Update Internal/External Position too, based on adjustments, addded option parameter @ImbalanceReportSummaryId
--							we only need to update the latest report, so for that user the imbalancereportid, as we may have multiple runs of a report
--  02 Jun 2010     ED      Exclude Automatically Matched Adjustments
--	25 Jun 2010		ED		MBAL-15949 - don''t include manually matched adjustments
--  30 Jun 2010		ED      MBAL-15993 - for SP - settlement price adjustment, set quantity to 0 
--  01 Jul 2010     ED      MBAL-15999 - don''t get yesterday data for CT
--	06 Aug 2010		amk		Remove @ReportId parameter since not used
--	21 Sep 2010		amk		MBAL-16673: not all adj rows showing on imbalance report

	DECLARE @Today DATETIME
	DECLARE @Yesterday DATETIME
	DECLARE @TemplateId	INT

	-- get variables

	SELECT @Today = ir.Today
		, @Yesterday = ir.Yesterday
		, @TemplateId = ir.TemplateId
	FROM ib_ImbalanceReport ir
	WHERE ir.ImbalanceReportId = @ImbalanceReportId

	-- group adjustments and load total into temp table

	SELECT SUM(a.Value) AS VALUE
		, SUM(CASE WHEN at.Code != ''SP'' THEN a.Quantity ELSE 0 END) AS Quantity
		, a.AdjustmentDate, a.ExchangeId, a.InstrumentId
		, a.ExpiryYear, a.ExpiryMonth, a.ExpiryDay
		, a.OptionTypeCode, a.CurrencyId, a.StrikePrice
		, a.InternalExternalCode, mc.MatchCode Description
	INTO #adjustments
	FROM ib_Adjustment a
		INNER JOIN ib_AdjustmentHeader ah ON a.AdjustmentHeaderId = ah.AdjustmentHeaderId
		INNER JOIN ib_AdjustmentType [at] ON ah.AdjustmentTypeId = [at].AdjustmentTypeId
		LEFT JOIN ib_TemplateGroup tg ON a.TemplateGroupId = tg.TemplateGroupId
		LEFT JOIN ib_MatchCode mc ON a.MatchCodeId = mc.MatchCodeId
		LEFT JOIN ib_AdjustmentStatus [as] ON [as].AdjustmentStatusId = a.AdjustmentStatusId
	WHERE (a.AdjustmentDate = @Today OR (a.AdjustmentDate = @Yesterday AND at.Code != ''CT''))
		AND a.TemplateId = @TemplateId
		AND (a.AdjustmentHeaderId = @AdjustmentHeaderId OR @AdjustmentHeaderId IS NULL)
		AND ([as].Code NOT IN (''A'',''M'') OR a.AdjustmentStatusId IS NULL)
	GROUP BY
		a.AdjustmentDate, a.ExchangeId, a.InstrumentId
		, a.ExpiryYear, a.ExpiryMonth, a.ExpiryDay
		, a.OptionTypeCode, a.CurrencyId, a.StrikePrice
		, a.InternalExternalCode, mc.MatchCode

	-- add rows to ib_ImbalanceReportSummary if ones we need are missing

	INSERT INTO [dbo].[ib_ImbalanceReportSummary]
		([ImbalanceReportId], [ExchangeId], [InstrumentId],
		[ExpiryYear], [ExpiryMonth], [ExpiryDay], 
		[OptionTypeCode], [CurrencyId], [StrikePrice], 
		[Internal_YAdjOTE], [Internal_YOTE], [Internal_PandS],
		[Internal_TAdjOTE], [Internal_TOTE], [Internal_Position], 
		[External_YAdjOTE], [External_YOTE], [External_PandS], 
		[External_TAdjOTE], [External_TOTE], [External_Position],
		[Lots], [Variation],
		[Description], [Exchange], [Currency], [Instrument])
	SELECT DISTINCT @ImbalanceReportId, a.[ExchangeId], a.[InstrumentId], 
			a.[ExpiryYear], a.[ExpiryMonth], a.[ExpiryDay], 
			a.[OptionTypeCode], a.[CurrencyId], a.[StrikePrice], 
			0 Internal_YAdjOTE, 0 Internal_YOTE, 0 Internal_PandS,
			0 Internal_TAdjOTE, 0 Internal_TOTE, 0 Internal_Position, 
			0 External_YAdjOTE, 0 External_YOTE, 0 External_PandS, 
			0 External_TAdjOTE, 0 External_TOTE, 0 External_Position,
			0, 0
			, a.Description, e.Name, c.Code, i.Code
	FROM #adjustments a
		JOIN ib_Exchange e ON e.ExchangeId = a.ExchangeId
		JOIN ib_Currency c ON c.CurrencyId = a.CurrencyId
		JOIN ib_Instrument i ON i.InstrumentId = a.InstrumentId
	WHERE NOT EXISTS (
		SELECT *
		FROM ib_ImbalanceReportSummary irs
		WHERE a.ExchangeId = irs.ExchangeId
			AND a.InstrumentId = irs.InstrumentId
			AND a.ExpiryYear = irs.ExpiryYear
			AND a.ExpiryMonth = irs.ExpiryMonth
			AND (a.ExpiryDay = irs.ExpiryDay OR (a.ExpiryDay IS NULL AND irs.ExpiryDay IS NULL))
			AND (a.OptionTypeCode = irs.OptionTypeCode OR (a.OptionTypeCode IS NULL AND irs.OptionTypeCode IS NULL))
			AND a.CurrencyId = irs.CurrencyId
			AND (a.StrikePrice = irs.StrikePrice OR (a.StrikePrice IS NULL AND irs.StrikePrice IS NULL))
			AND a.Description = irs.Description
			AND irs.ImbalanceReportId = @ImbalanceReportId			
		)

	-- internal Y OTE

	UPDATE ib_ImbalanceReportSummary
	SET Internal_YAdjOTE = a.Value
	FROM ib_ImbalanceReportSummary irs
		JOIN #adjustments a ON a.ExchangeId = irs.ExchangeId
			AND a.InstrumentId = irs.InstrumentId
			AND a.ExpiryYear = irs.ExpiryYear
			AND a.ExpiryMonth = irs.ExpiryMonth
			AND (a.ExpiryDay = irs.ExpiryDay OR (a.ExpiryDay IS NULL AND irs.ExpiryDay IS NULL))
			AND (a.OptionTypeCode = irs.OptionTypeCode OR (a.OptionTypeCode IS NULL AND irs.OptionTypeCode IS NULL))
			AND a.CurrencyId = irs.CurrencyId
			AND (a.StrikePrice = irs.StrikePrice OR (a.StrikePrice IS NULL AND irs.StrikePrice IS NULL))
			AND a.Description = irs.Description
	WHERE a.InternalExternalCode = ''I''
		AND a.AdjustmentDate = @Yesterday AND ImbalanceReportId = @ImbalanceReportId 
		AND (ImbalanceReportSummaryId = @ImbalanceReportSummaryId OR @ImbalanceReportSummaryId IS NULL)

	-- external Y OTE

	UPDATE ib_ImbalanceReportSummary
	SET External_YAdjOTE = a.Value
	FROM ib_ImbalanceReportSummary irs
		JOIN #adjustments a ON a.ExchangeId = irs.ExchangeId
			AND a.InstrumentId = irs.InstrumentId
			AND a.ExpiryYear = irs.ExpiryYear
			AND a.ExpiryMonth = irs.ExpiryMonth
			AND (a.ExpiryDay = irs.ExpiryDay OR (a.ExpiryDay IS NULL AND irs.ExpiryDay IS NULL))
			AND (a.OptionTypeCode = irs.OptionTypeCode OR (a.OptionTypeCode IS NULL AND irs.OptionTypeCode IS NULL))
			AND a.CurrencyId = irs.CurrencyId
			AND (a.StrikePrice = irs.StrikePrice OR (a.StrikePrice IS NULL AND irs.StrikePrice IS NULL))
			AND a.Description = irs.Description
	WHERE a.InternalExternalCode = ''E''
		AND a.AdjustmentDate = @Yesterday AND ImbalanceReportId = @ImbalanceReportId 
		AND (ImbalanceReportSummaryId = @ImbalanceReportSummaryId OR @ImbalanceReportSummaryId IS NULL)

	-- internal T OTE

	UPDATE ib_ImbalanceReportSummary
	SET Internal_TAdjOTE = Internal_TAdjOTE + a.Value
		, Internal_Position = Internal_Position + Quantity 
	FROM ib_ImbalanceReportSummary irs
		JOIN #adjustments a ON a.ExchangeId = irs.ExchangeId
			AND a.InstrumentId = irs.InstrumentId
			AND a.ExpiryYear = irs.ExpiryYear
			AND a.ExpiryMonth = irs.ExpiryMonth
			AND (a.ExpiryDay = irs.ExpiryDay OR (a.ExpiryDay IS NULL AND irs.ExpiryDay IS NULL))
			AND (a.OptionTypeCode = irs.OptionTypeCode OR (a.OptionTypeCode IS NULL AND irs.OptionTypeCode IS NULL))
			AND a.CurrencyId = irs.CurrencyId
			AND (a.StrikePrice = irs.StrikePrice OR (a.StrikePrice IS NULL AND irs.StrikePrice IS NULL))
			AND a.Description = irs.Description
	WHERE a.InternalExternalCode = ''I''
		AND a.AdjustmentDate = @Today AND ImbalanceReportId = @ImbalanceReportId 
		AND (ImbalanceReportSummaryId = @ImbalanceReportSummaryId OR @ImbalanceReportSummaryId IS NULL)

	-- external T OTE

	UPDATE ib_ImbalanceReportSummary
	SET External_TAdjOTE = External_TAdjOTE + a.Value
		, External_Position = External_Position + Quantity
	FROM ib_ImbalanceReportSummary irs
		JOIN #adjustments a ON a.ExchangeId = irs.ExchangeId
			AND a.InstrumentId = irs.InstrumentId
			AND a.ExpiryYear = irs.ExpiryYear
			AND a.ExpiryMonth = irs.ExpiryMonth
			AND (a.ExpiryDay = irs.ExpiryDay OR (a.ExpiryDay IS NULL AND irs.ExpiryDay IS NULL))
			AND (a.OptionTypeCode = irs.OptionTypeCode OR (a.OptionTypeCode IS NULL AND irs.OptionTypeCode IS NULL))
			AND a.CurrencyId = irs.CurrencyId
			AND (a.StrikePrice = irs.StrikePrice OR (a.StrikePrice IS NULL AND irs.StrikePrice IS NULL))
			AND a.Description = irs.Description
	WHERE a.InternalExternalCode = ''E''
		AND a.AdjustmentDate = @Today AND ImbalanceReportId = @ImbalanceReportId 
		AND (ImbalanceReportSummaryId = @ImbalanceReportSummaryId OR @ImbalanceReportSummaryId IS NULL)

	-- cleanup

	DROP TABLE #adjustments
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_ImbalanceReport_CalculateImbalance]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_ImbalanceReport_CalculateImbalance]
	@ImbalanceReportId INT
	, @ImbalanceReportSummaryId INT = NULL
AS
SET NOCOUNT ON

	--	06 Aug 2010		amk		Creation

	--calculate Lots and variation
	UPDATE [dbo].[ib_ImbalanceReportSummary]
	SET Lots = Internal_Position - External_Position
		, Variation = ((Internal_TOTE + Internal_TAdjOTE) - (Internal_YOTE + Internal_YAdjOTE) + Internal_PandS)
			- ((External_TOTE + External_TAdjOTE) - (External_YOTE + External_YAdjOTE) + External_PandS)
	WHERE ImbalanceReportId = @ImbalanceReportId
		AND (ImbalanceReportSummaryId = @ImbalanceReportSummaryId 
			OR @ImbalanceReportSummaryId IS NULL)
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TradeReconciliationSummary_InsertTradeAdjustments]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_TradeReconciliationSummary_InsertTradeAdjustments]
(
	@TradeReconciliationSummaryId INT
	, @IsAddTrade BIT
	, @CreateUsername VARCHAR(50)
	, @ErrorMessage VARCHAR(MAX) OUTPUT
	, @AsOfDate DATETIME = NULL
)
AS
SET NOCOUNT ON

--	Insert trade rec adjustment

--	12 May 2010		ED		Creation
--  06 Jul 2010		ED		MBAL 15626 - code for swap adjustments
--	28 Jul 2010		AAJM	MBAL-16300 Specify AsOfDate for Rolled Trade Adjustment
--	06 Aug 2010		amk		Externalize calculate imbalance logic so it can be re-used
--	08 Sep 2010		amk		MBAL-16609: Don''t rollback if rollback already done
--	06 Jan 2011		amk		MBAL-17523: make message that looks up E data source (to determine account matching flag) clearer
--	22 Jul 2014		ED		EIB 25831 - fix call to ib_TradeReconciliationSummary_GetDetailsTransaction sp

BEGIN TRY
	BEGIN TRAN TrInt

	--
	DECLARE @DoAtDetailLevel BIT
	--#region getDatasource
	-- NOTE: the only reason to lookup external data source is to check ''detail account matching'' flag a little later
	-- error message now makes this abundantly clear
	DECLARE @DataSourceId INT
	SELECT @DataSourceId = [dbo].[GetDataSourceIdForTradeAdjustments](TemplateId, InstrumentId, ExchangeId, MatchCode, ''E'')
	FROM ib_TradeReconciliation tr
		INNER JOIN ib_TradeReconciliationSummary trs ON tr.TradeReconciliationId = trs.TradeReconciliationId
	WHERE TradeReconciliationSummaryId = @TradeReconciliationSummaryId

	IF @DataSourceId IS NULL OR @DataSourceId < 0
	BEGIN
		SET @ErrorMessage = [dbo].[SetDataSourceErrorMessage](@DataSourceId) + dbo.GetDetailedErrorMessageByTradeReconciliationDetailId(@TradeReconciliationSummaryId,NULL)
			+ ''<br>Note: this check done at start to retrieve ''''detail account matching'''' flag on external data source''
		IF(@@TRANCOUNT = 1) ROLLBACK TRAN
			ELSE IF(@@TRANCOUNT > 1) COMMIT TRAN TrInt
		RETURN -1
	END
	--#endregion getDatasource
	---------------------------------
	--insert adjustment header, as we have 1 per trade rep summary record
	--#region insert adj header
	DECLARE @AdjustmentTypeId INT
	DECLARE @AdjustmentHeaderId INT
	IF @IsAddTrade = 1
		SELECT @AdjustmentTypeId = AdjustmentTypeId 
		FROM ib_AdjustmentType 
		WHERE Code = ''TI''
	ELSE
		SELECT @AdjustmentTypeId = AdjustmentTypeId 
		FROM ib_AdjustmentType 
		WHERE Code = ''TC''

	INSERT INTO [dbo].[ib_AdjustmentHeader] ([AdjustmentTypeId], [CreateDate], [CreateUsername], TradeReconciliationSummaryId)
	SELECT @AdjustmentTypeId, GETDATE(), @CreateUsername, @TradeReconciliationSummaryId
		
	SET @AdjustmentHeaderId = SCOPE_IDENTITY()
	--#endregion insert adj header

	SELECT @DoAtDetailLevel = IncludeDetailAccountInTradeReconciliation FROM ib_DataSource WHERE DataSourceId = @DataSourceId
		
		IF @DoAtDetailLevel = 1
			--#region do at detail level
			BEGIN
			--get details
			DECLARE @TradeReconciliationDetailId INT

			--get all unmatched rows for drilldown
			CREATE TABLE #tempTranDetail
					(
						[Datasource] VARCHAR(1000)
						, [Firm] VARCHAR(1000)
						, [Account] VARCHAR(1000)
						, [DetailAccount] VARCHAR(1000)
						,[TradePrice] DECIMAL(24,10)
						,[InternalLong] INT 
						,[InternalShort] INT 
						,[ExternalLong] INT 
						,[ExternalShort] INT 
						,[TYPE] VARCHAR(1000)
						,[TrxDate] DATETIME
						,[IsMatched] BIT
						,[IsLong] BIT
						,TradeReconciliationDetailId INT
						,UTI varchar(100)
						,Unmatched varchar(100)
					)
					INSERT INTO #tempTranDetail
					([Datasource],[Firm],[Account],[DetailAccount],[TradePrice] ,[InternalLong],[InternalShort],[ExternalLong],[ExternalShort]
						,[TYPE],[TrxDate],[IsMatched],[IsLong], TradeReconciliationDetailId, UTI, Unmatched)
					EXEC [dbo].[ib_TradeReconciliationSummary_GetDetailsTransaction] @TradeReconciliationSummaryId, 0
				
				DECLARE pos_cursor CURSOR FOR
				SELECT TradeReconciliationDetailId 
				FROM #tempTranDetail
				
				OPEN pos_cursor
				
				FETCH NEXT FROM pos_cursor
				INTO @TradeReconciliationDetailId
					
				-- Check @@FETCH_STATUS to see IF there are any more rows to fetch.
				WHILE @@FETCH_STATUS = 0
				BEGIN
					
					IF @IsAddTrade = 1
						EXEC ib_TradeReconciliationDetail_GenerateTradeAddAdjustmentsAtDetailLevel @TradeReconciliationDetailId, @AdjustmentHeaderId, @CreateUsername, @ErrorMessage OUTPUT, @AsOfDate
					ELSE
						EXEC ib_TradeReconciliationDetail_GenerateTradeCancelAdjustmentsAtDetailLevel @TradeReconciliationDetailId, @AdjustmentHeaderId, @CreateUsername, @ErrorMessage OUTPUT, @AsOfDate
					IF LEN(@ErrorMessage) > 0
					BEGIN
						IF(@@TRANCOUNT = 1) ROLLBACK TRAN
							ELSE IF(@@TRANCOUNT > 1) COMMIT TRAN TrInt
						RETURN -1
					END	
				FETCH NEXT FROM pos_cursor
				INTO @TradeReconciliationDetailId
				END
									
				CLOSE pos_cursor
				DEALLOCATE pos_cursor
			END
			--#endregion do at detail level
		ELSE -- do some grouping, not at detail level....
			--#region do at group level
			BEGIN
			IF @IsAddTrade = 1
				EXEC ib_TradeReconciliationSummary_GenerateTradeAddAdjustmentsAtGroupLevel @TradeReconciliationSummaryId, @AdjustmentHeaderId, @CreateUsername, @ErrorMessage OUTPUT, @AsOfDate
			ELSE
				EXEC ib_TradeReconciliationSummary_GenerateTradeCancelAdjustmentsAtGroupLevel @TradeReconciliationSummaryId, @AdjustmentHeaderId, @CreateUsername, @ErrorMessage OUTPUT, @AsOfDate
				IF LEN(@ErrorMessage) > 0
					BEGIN
						IF(@@TRANCOUNT = 1) ROLLBACK TRAN
							ELSE IF(@@TRANCOUNT > 1) COMMIT TRAN TrInt
						RETURN -1
					END	
			END
			--#endregion do at group level
	--if we are here, then adjustment inserted, so we need to update the trade rec summary and imbalance report summary
	--1 - trade rec summary
	--get the internal/external long/short
	--#region update "LIVE" reports
	DECLARE @InternalLong INT
	DECLARE @ExternalLong INT
	DECLARE @InternalShort INT
	DECLARE @ExternalShort INT

	SELECT @InternalLong = SUM(QuantityLong), @InternalShort = SUM(QuantityShort) 
	FROM ib_Adjustment
	WHERE AdjustmentHeaderId = @AdjustmentHeaderId AND InternalExternalCode = ''I''
		
	SELECT @ExternalLong = SUM(QuantityLong), @ExternalShort = SUM(QuantityShort) 
	FROM ib_Adjustment
	WHERE AdjustmentHeaderId = @AdjustmentHeaderId AND InternalExternalCode = ''E''

	IF @InternalLong IS NULL SET @InternalLong = 0
	IF @ExternalLong IS NULL SET @ExternalLong = 0
	IF @InternalShort IS NULL SET @InternalShort = 0
	IF @ExternalShort IS NULL SET @ExternalShort = 0

	UPDATE ib_TradeReconciliationSummary 
	SET TotalInternalLong = TotalInternalLong + @InternalLong
		, TotalInternalShort = TotalInternalShort + @InternalShort
		, TotalExternalLong = TotalExternalLong + @ExternalLong
		, TotalExternalShort = TotalExternalShort + @ExternalShort
		, DifferenceLong = DifferenceLong + @InternalLong - @ExternalLong
		, DifferenceShort = DifferenceShort + @InternalShort - @ExternalShort
	WHERE TradeReconciliationSummaryId = @TradeReconciliationSummaryId
		
	--update the imbalance report 	
	--we need to get the right ImbalanceReportSummaryId

	DECLARE @ImbalanceReportId INT
	DECLARE @ImbalanceReportSummaryId INT
	DECLARE @TemplateId INT
	DECLARE @TradeRecAsOfDate DATETIME

	SELECT @TemplateId = TemplateId, @TradeRecAsOfDate = Today
	FROM ib_TradeReconciliation tr
		INNER JOIN ib_TradeReconciliationSummary trs ON tr.TradeReconciliationId=trs.TradeReconciliationId
	WHERE TradeReconciliationSummaryId = @TradeReconciliationSummaryId

	CREATE TABLE #temp_ImbalanceReportId(ImbalanceReportId INT)
	INSERT INTO #temp_ImbalanceReportId(ImbalanceReportId)
	EXEC [dbo].[ib_ImbalanceReport_GetLatestImbalanceReportIdByTemplateIdAndDate] @TemplateId, @TradeRecAsOfDate

	SELECT @ImbalanceReportId = ImbalanceReportId 
	FROM #temp_ImbalanceReportId
	DROP TABLE #temp_ImbalanceReportId

		DECLARE @Ids TABLE(Id INT)
		INSERT INTO @Ids(Id)
		SELECT DISTINCT ImbalanceReportSummaryId 
		FROM ib_ImbalanceReportSummary irs
			INNER JOIN ib_TradeReconciliationSummary trs 
				ON irs.ExchangeId = trs.ExchangeId
					AND irs.InstrumentId = trs.InstrumentId
					AND irs.CurrencyId = trs.CurrencyId
					AND irs.ExpiryYear = trs.ExpiryYear
					AND irs.ExpiryMonth = trs.ExpiryMonth
					AND irs.ExpiryDay = trs.ExpiryDay
					AND (ISNULL(irs.OptionTypeCode,'''') = ISNULL(trs.OptionTypeCode,''''))
					AND (ISNULL(irs.StrikePrice,0) = ISNULL(trs.StrikePrice,0))
					AND irs.Description=trs.MatchCode
		WHERE irs.ImbalanceReportId = @ImbalanceReportId 
			AND trs.TradeReconciliationSummaryId = @TradeReconciliationSummaryId
		IF @@ROWCOUNT = 1
			SELECT @ImbalanceReportSummaryId = Id 
			FROM @Ids		
		/* ELSE
		IF @@ROWCOUNT > 1 -- then it is an error
		BEGIN
			IF(@@TRANCOUNT = 1) ROLLBACK TRAN
					ELSE IF(@@TRANCOUNT > 1) COMMIT TRAN TrInt
			SET @ErrorMessage = ''More than one Imbalance Report Record found to update: '' + dbo.GetDetailedErrorMessageByTradeReconciliationDetailId(@TradeReconciliationSummaryId,NULL)
				RETURN -1
		END
		IF @ImbalanceReportSummaryId IS NULL -- no one found
		BEGIN
			IF(@@TRANCOUNT = 1) ROLLBACK TRAN
					ELSE IF(@@TRANCOUNT > 1) COMMIT TRAN TrInt
			SET @ErrorMessage = ''No Imbalance Report Record found to update: '' + dbo.GetDetailedErrorMessageByTradeReconciliationDetailId(@TradeReconciliationSummaryId,NULL)
				RETURN -1
		END*/
		--if only one found, update:
		IF @ImbalanceReportSummaryId IS NOT NULL
		BEGIN
			EXEC [dbo].[ib_ImbalanceReport_GatherAdjustments] 
				@ImbalanceReportId, @ImbalanceReportSummaryId, @AdjustmentHeaderId

			--calculate Lots and variation
			EXEC ib_ImbalanceReport_CalculateImbalance 
				@ImbalanceReportId, @ImbalanceReportSummaryId
		END
	--closeout report
	/* -- no need for live update
		DECLARE @CloseOutReportId INT
		SELECT @CloseOutReportId = MAX(cr.CloseOutReportId)
		FROM ib_CloseOutReport cr 
		INNER JOIN ib_Report r on r.TargetReportId = cr.CloseOutReportId 
							  AND r.ReportType = ''CloseOut''
		WHERE cr.TemplateId = @TemplateId
		  AND cr.Date = @TradeRecAsOfDate
		  AND (r.ErrorDetails IS NULL)
		 
		DECLARE @CloseOutReportSummaryId INT
		DECLARE @CIds TABLE(Id INT)
		INSERT INTO @CIds(Id)
		SELECT DISTINCT CloseOutReportSummaryId FROM ib_CloseOutReportSummary crs
		INNER JOIN ib_TradeReconciliationSummary trs 
			ON 	crs.ExchangeId = trs.ExchangeId
					AND crs.InstrumentId = trs.InstrumentId
					AND crs.ExpiryYear = trs.ExpiryYear
					AND crs.ExpiryMonth = trs.ExpiryMonth
					AND crs.ExpiryDay = trs.ExpiryDay
					AND (ISNULL(crs.OptionTypeCode,'''') = ISNULL(trs.OptionTypeCode,''''))
					AND (ISNULL(crs.StrikePrice,0) = ISNULL(trs.StrikePrice,0))
					AND crs.Description=trs.MatchCode
				WHERE crs.CloseOutReportId=@CloseOutReportId AND  trs.TradeReconciliationSummaryId=@TradeReconciliationSummaryId
		IF @@ROWCOUNT = 1
			SELECT @CloseOutReportSummaryId = Id FROM @CIds	
		  IF @CloseOutReportSummaryId IS NOT NULL
		BEGIN
			EXEC [dbo].[ib_CloseOutReport_GatherAdjustments]  	-1,	@CloseOutReportId, @CloseOutReportSummaryId, @AdjustmentHeaderId
		END
	*/	
		--if we are here, everything is good - hooray
		--get only affected row
	--#endregion update "LIVE" reports
	COMMIT TRAN TrInt
END TRY
BEGIN CATCH
	IF (@@TRANCOUNT >= 1) ROLLBACK TRAN
	EXEC [dbo].[sp_RethrowError]
END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_ImbalanceReport_RemoveAdjustments]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_ImbalanceReport_RemoveAdjustments]
	@ImbalanceReportId INT,
	@ImbalanceReportSummaryId INT = NULL,
	@AdjustmentHeaderId INT
AS
SET NOCOUNT ON

--	*** SEE ALSO THE SIMILAR ib_ImbalanceReport_GatherAdjustments (that pokes IN) ***

--	17 Nov 2010		amk		Creation

	DECLARE @Today DATETIME
	DECLARE @Yesterday DATETIME
	DECLARE @TemplateId	INT

	-- get variables

	SELECT @Today = ir.Today
		, @Yesterday = ir.Yesterday
		, @TemplateId = ir.TemplateId
	FROM ib_ImbalanceReport ir
	WHERE ir.ImbalanceReportId = @ImbalanceReportId

	-- group adjustments and load total into temp table

	SELECT SUM(a.Value) AS VALUE
		, SUM(CASE WHEN at.Code != ''SP'' THEN a.Quantity ELSE 0 END) AS Quantity
		, a.AdjustmentDate, a.ExchangeId, a.InstrumentId
		, a.ExpiryYear, a.ExpiryMonth, a.ExpiryDay
		, a.OptionTypeCode, a.CurrencyId, a.StrikePrice
		, a.InternalExternalCode, mc.MatchCode Description
	INTO #adjustments
	FROM ib_Adjustment a
		INNER JOIN ib_AdjustmentHeader ah ON a.AdjustmentHeaderId = ah.AdjustmentHeaderId
		INNER JOIN ib_AdjustmentType [at] ON ah.AdjustmentTypeId = [at].AdjustmentTypeId
		LEFT JOIN ib_TemplateGroup tg ON a.TemplateGroupId = tg.TemplateGroupId
		LEFT JOIN ib_MatchCode mc ON a.MatchCodeId = mc.MatchCodeId
		LEFT JOIN ib_AdjustmentStatus [as] ON [as].AdjustmentStatusId = a.AdjustmentStatusId
	WHERE a.AdjustmentDate = @Today 
		AND a.TemplateId = @TemplateId
		AND a.AdjustmentHeaderId = @AdjustmentHeaderId 
		AND ([as].Code NOT IN (''A'',''M'') OR a.AdjustmentStatusId IS NULL)
	GROUP BY
		a.AdjustmentDate, a.ExchangeId, a.InstrumentId
		, a.ExpiryYear, a.ExpiryMonth, a.ExpiryDay
		, a.OptionTypeCode, a.CurrencyId, a.StrikePrice
		, a.InternalExternalCode, mc.MatchCode

	-- NO NEED to update YAdjOTE values since only matching Adjustment date to Imbalance Report today date

	-- internal T OTE

	UPDATE ib_ImbalanceReportSummary
	SET Internal_TAdjOTE = Internal_TAdjOTE - a.Value
		, Internal_Position = Internal_Position - a.Quantity 
		, UpdateDate = GETDATE()
	FROM ib_ImbalanceReportSummary irs
		JOIN #adjustments a ON a.ExchangeId = irs.ExchangeId
			AND a.InstrumentId = irs.InstrumentId
			AND a.ExpiryYear = irs.ExpiryYear
			AND a.ExpiryMonth = irs.ExpiryMonth
			AND (a.ExpiryDay = irs.ExpiryDay OR (a.ExpiryDay IS NULL AND irs.ExpiryDay IS NULL))
			AND (a.OptionTypeCode = irs.OptionTypeCode OR (a.OptionTypeCode IS NULL AND irs.OptionTypeCode IS NULL))
			AND a.CurrencyId = irs.CurrencyId
			AND (a.StrikePrice = irs.StrikePrice OR (a.StrikePrice IS NULL AND irs.StrikePrice IS NULL))
			AND a.Description = irs.Description
	WHERE a.InternalExternalCode = ''I''
		AND a.AdjustmentDate = @Today 
		AND ImbalanceReportId = @ImbalanceReportId 
		AND (ImbalanceReportSummaryId = @ImbalanceReportSummaryId OR @ImbalanceReportSummaryId IS NULL)

	-- external T OTE

	UPDATE ib_ImbalanceReportSummary
	SET External_TAdjOTE = External_TAdjOTE - a.Value
		, External_Position = External_Position - a.Quantity
		, UpdateDate = GETDATE()
	FROM ib_ImbalanceReportSummary irs
		JOIN #adjustments a ON a.ExchangeId = irs.ExchangeId
			AND a.InstrumentId = irs.InstrumentId
			AND a.ExpiryYear = irs.ExpiryYear
			AND a.ExpiryMonth = irs.ExpiryMonth
			AND (a.ExpiryDay = irs.ExpiryDay OR (a.ExpiryDay IS NULL AND irs.ExpiryDay IS NULL))
			AND (a.OptionTypeCode = irs.OptionTypeCode OR (a.OptionTypeCode IS NULL AND irs.OptionTypeCode IS NULL))
			AND a.CurrencyId = irs.CurrencyId
			AND (a.StrikePrice = irs.StrikePrice OR (a.StrikePrice IS NULL AND irs.StrikePrice IS NULL))
			AND a.Description = irs.Description
	WHERE a.InternalExternalCode = ''E''
		AND a.AdjustmentDate = @Today 
		AND ImbalanceReportId = @ImbalanceReportId 
		AND (ImbalanceReportSummaryId = @ImbalanceReportSummaryId OR @ImbalanceReportSummaryId IS NULL)

	-- cleanup

	DROP TABLE #adjustments
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Adjustment_UnpokeImbalanceReport]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Adjustment_UnpokeImbalanceReport]
	@AdjustmentHeaderId INT 
AS
SET NOCOUNT ON
	--	*** this must be called BEFORE adjustments are deleted
	--	*** it is assumed caller is running a transaction

	--	17 Nov 2010		amk		Creation (MBAL-16341)

	-- there''s only one adjustment date per adjustment group (header) - so let''s look it up
	-- and there should also only by 1 template
	DECLARE @AdjustmentDate DATETIME
	DECLARE @TemplateId INT
	DECLARE @ImbalanceReportId INT
	
	SELECT @AdjustmentDate = a.AdjustmentDate
		, @TemplateId = a.TemplateId
	FROM ib_Adjustment a
	WHERE a.AdjustmentHeaderId = @AdjustmentHeaderId

	DECLARE @temp_ImbalanceReportId TABLE (ImbalanceReportId INT)
	INSERT INTO @temp_ImbalanceReportId(ImbalanceReportId)
		EXEC [dbo].[ib_ImbalanceReport_GetLatestImbalanceReportIdByTemplateIdAndDate] 
			@TemplateId, @AdjustmentDate

	SELECT @ImbalanceReportId = ImbalanceReportId 
	FROM @temp_ImbalanceReportId

	EXEC [dbo].[ib_ImbalanceReport_RemoveAdjustments]
		@ImbalanceReportId, NULL, @AdjustmentHeaderId

	--calculate Lots and variation
	EXEC ib_ImbalanceReport_CalculateImbalance 
		@ImbalanceReportId, NULL
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Adjustment_SwapAdjustments]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Adjustment_SwapAdjustments]
(
	@AdjustmentId INT
	, @CreateUsername VARCHAR(50)
	, @ErrorMessage VARCHAR(MAX) OUTPUT
)
AS
SET NOCOUNT ON
--	Swap trade rec adjustment

--	05 Jul 2010 ED		Created
--	28 Jul 2010	AAJM	MBAL-16300: Specify AsOfDate for Rolled Trade Adjustment
--	13 Aug 2010	amk		MBAL-16442: Ensure adjustments added after swap or else fail operation
--	08 Sep 2010	amk		MBAL-16609: Don''t rollback if rollback already done
--	17 Nov 2010	amk		MBAL-17007: Unpoke imbalance report

BEGIN TRY
	BEGIN TRAN TrSwap
	--first, clean up
	DECLARE @AdjustmentHeaderId INT
	DECLARE @TradeReconciliationSummaryId INT, @IsAddTrade BIT
	SET @IsAddTrade = (
		SELECT CASE WHEN [AT].Code = ''TC'' THEN 1 ELSE 0 END 
		FROM ib_Adjustment a 
			INNER JOIN  ib_AdjustmentHeader ah ON a.AdjustmentHeaderId = ah.AdjustmentHeaderId
			INNER JOIN ib_AdjustmentType [AT] ON [AT].AdjustmentTypeId = ah.AdjustmentTypeId
		WHERE a.AdjustmentId = @AdjustmentId)
	DECLARE @ManualMatchId INT, @AutoMatchId INT
	SET @ManualMatchId = (SELECT AdjustmentStatusId FROM ib_AdjustmentStatus WHERE Code = ''M'')
	SET @AutoMatchId = (SELECT AdjustmentStatusId FROM ib_AdjustmentStatus WHERE Code = ''A'')

	SELECT @AdjustmentHeaderId = a.AdjustmentHeaderId
		, @TradeReconciliationSummaryId = ah.TradeReconciliationSummaryId
	FROM ib_Adjustment a 
		INNER JOIN ib_AdjustmentHeader ah ON a.AdjustmentHeaderId = ah.AdjustmentHeaderId
	WHERE a.AdjustmentId = @AdjustmentId
	--fix the tradereconciliationsummary 
	DECLARE @InternalLong INT, @ExternalLong INT, @InternalShort INT, @ExternalShort INT

	SELECT @InternalLong = SUM(QuantityLong), @InternalShort = SUM(QuantityShort) 
	FROM ib_Adjustment
	WHERE AdjustmentHeaderId = @AdjustmentHeaderId 
		AND InternalExternalCode = ''I'' 
		AND (AdjustmentStatusId NOT IN(@ManualMatchId, @AutoMatchId) OR AdjustmentStatusId IS NULL)
		
	SELECT @ExternalLong = SUM(QuantityLong), @ExternalShort = SUM(QuantityShort) 
	FROM ib_Adjustment
	WHERE AdjustmentHeaderId = @AdjustmentHeaderId 
		AND InternalExternalCode = ''E'' 
		AND (AdjustmentStatusId NOT IN(@ManualMatchId, @AutoMatchId) OR AdjustmentStatusId IS NULL)

	IF @InternalLong IS NULL SET @InternalLong = 0
	IF @ExternalLong IS NULL SET @ExternalLong = 0
	IF @InternalShort IS NULL SET @InternalShort = 0
	IF @ExternalShort IS NULL SET @ExternalShort = 0
	--remove from totals the values

	UPDATE ib_TradeReconciliationSummary 
	SET TotalInternalLong = TotalInternalLong - @InternalLong
		, TotalInternalShort = TotalInternalShort - @InternalShort
		, TotalExternalLong = TotalExternalLong - @ExternalLong
		, TotalExternalShort = TotalExternalShort - @ExternalShort
		, DifferenceLong = DifferenceLong - @InternalLong + @ExternalLong
		, DifferenceShort = DifferenceShort - @InternalShort + @ExternalShort
	WHERE TradeReconciliationSummaryId = @TradeReconciliationSummaryId

	-- Get the AsOfDate
	DECLARE @AsOfDate DATETIME
	SELECT @AsOfDate = a.AdjustmentDate 
	FROM ib_Adjustment a 
	WHERE a.AdjustmentId = @AdjustmentId

	--break link
	DELETE FROM ib_TradeReconciliationDetail 
	WHERE AdjustmentId IN 
	(
		SELECT a.AdjustmentId 
		FROM ib_Adjustment a 
		WHERE a.AdjustmentHeaderId = @AdjustmentHeaderId 
			AND (AdjustmentStatusId NOT IN(@ManualMatchId, @AutoMatchId) OR AdjustmentStatusId IS NULL)
	)

	-- this must be called BEFORE the adjustments are deleted
	EXEC ib_Adjustment_UnpokeImbalanceReport @AdjustmentHeaderId

	DELETE 
	FROM ib_Adjustment 
	WHERE AdjustmentId IN 
	(
		SELECT AdjustmentId 
		FROM ib_Adjustment 
		WHERE AdjustmentHeaderId = @AdjustmentHeaderId 
			AND (AdjustmentStatusId NOT IN(@ManualMatchId, @AutoMatchId) OR AdjustmentStatusId IS NULL)
	)
	
	DECLARE @LeftCount INT
	SET @LeftCount = (SELECT COUNT(*) 
						FROM ib_Adjustment 
						WHERE AdjustmentHeaderId = @AdjustmentHeaderId)
	IF @LeftCount = 0
		DELETE FROM ib_AdjustmentHeader 
		WHERE AdjustmentHeaderId = @AdjustmentHeaderId

	DECLARE @DateJustBeforeAdjAdd DATETIME
	SET @DateJustBeforeAdjAdd = GETDATE()

	--then, call the add adjustment
	EXEC ib_TradeReconciliationSummary_InsertTradeAdjustments @TradeReconciliationSummaryId
		, @IsAddTrade, @CreateUsername , @ErrorMessage OUTPUT, @AsOfDate

	-- BEGIN failsafe - just make sure we at least added a new header for the swapped adjustments
	-- if not then something went wrong, and rollback the whole operation
	DECLARE @AdjustmentRowsAdded INT
	SET @AdjustmentRowsAdded = 0
	
	SELECT @AdjustmentRowsAdded = COUNT(*)
	FROM ib_AdjustmentHeader h
		JOIN ib_Adjustment a ON a.AdjustmentHeaderId = h.AdjustmentHeaderId
	WHERE h.TradeReconciliationSummaryId = @TradeReconciliationSummaryId
		AND h.CreateDate >= @DateJustBeforeAdjAdd
		AND a.AdjustmentDate = @AsOfDate
	
	IF @AdjustmentRowsAdded = 0
		RAISERROR (N''No reverse adjustments generated; swap aborted'', 11, 1)
	
	-- END failsafe	

	COMMIT TRAN TrSwap
END TRY
BEGIN CATCH
	IF (@@TRANCOUNT >= 1) ROLLBACK TRAN
	EXEC [dbo].[sp_RethrowError]
END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_CashReport_GetCashReportDataForExchange]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_CashReport_GetCashReportDataForExchange]
	@CashReportId INT,
	@ReportId INT -- Used for updating status...
AS
SET NOCOUNT ON
BEGIN

-- 24 Mar 2010		kevinp		Added very simple select statement... still needs improving to meet User Story
-- 24 Mar 2010		alisterm	Change to access View
-- 25 Mar 2010		kevinp		Neatend the SP up. Selected data to make sure that Premium Paid Options are at the end of the select.
-- 29 Mar 2010		kevinp		Fixed Grouping totals, so that GROUP totals appear just after the group of exchanges.
-- 17 Aug 2010		amk			MBAL-16453: don''t select * from view as columns added to support cheque amount

-- Futures and Options at the top of our winner list
SELECT * FROM(

--This selects all the Exchanges that DO NOT belong to a group
	SELECT 1 AS ReportSortOrder
		, vwed.ExchangeId, vwed.ExchangeName, vwed.CurrencyId, vwed.CurrencyCode
		, vwed.CurrencyName, vwed.TemplateTypeClassId, vwed.TemplateTypeClassCode
		, vwed.TemplateTypeClassname, vwed.InstrumentTypeCode, vwed.InstrumentTypeName
		, vwed.Internal_TOTE, vwed.Internal_PandS, vwed.Internal_AdjOTE
		, vwed.Internal_AdjSegNon, vwed.External_TOTE, vwed.External_PandS
		, vwed.External_AdjOTE, vwed.External_AdjSegNon, vwed.Difference, vwed.CashReportId
		, cge.CashGroupId, cge.SortOrder
	FROM [dbo].[vw_ib_CashReport_ExchangeData] vwed
		LEFT JOIN ib_CashGroupExchange cge ON cge.ExchangeId = vwed.ExchangeId
	WHERE vwed.InstrumentTypeCode IN (''F'', ''O'') --Futures and Options
		AND vwed.CashReportId = @CashReportId
		AND cge.CashGroupId IS NULL
	  
UNION ALL

-- This then selects Exchanges that DO belong to a group
	SELECT 1 + cge.CashGroupId AS ReportSortOrder
		, vwed.ExchangeId, vwed.ExchangeName, vwed.CurrencyId, vwed.CurrencyCode
		, vwed.CurrencyName, vwed.TemplateTypeClassId, vwed.TemplateTypeClassCode
		, vwed.TemplateTypeClassname, vwed.InstrumentTypeCode, vwed.InstrumentTypeName
		, vwed.Internal_TOTE, vwed.Internal_PandS, vwed.Internal_AdjOTE
		, vwed.Internal_AdjSegNon, vwed.External_TOTE, vwed.External_PandS
		, vwed.External_AdjOTE, vwed.External_AdjSegNon, vwed.Difference, vwed.CashReportId
		, cge.CashGroupId, cge.SortOrder
	FROM [dbo].[vw_ib_CashReport_ExchangeData] vwed
		INNER JOIN ib_CashGroupExchange cge ON cge.ExchangeId = vwed.ExchangeId
	WHERE vwed.InstrumentTypeCode IN (''F'', ''O'') --Futures and Options
		AND vwed.CashReportId = @CashReportId

UNION ALL

-- This selects a "summary" of grouped exchanges where each grouping per Currency/TemplateTypeClass is at least kept together.
	SELECT 2 + cge.CashGroupId AS ReportSortOrder, 
		NULL AS ExchangeId, 
		''GROUP'' AS ExchangeName,
		vwed.CurrencyId,
		vwed.CurrencyCode,
		vwed.CurrencyName,
		vwed.TemplateTypeClassId,
		vwed.TemplateTypeClassCode,
		vwed.TemplateTypeClassName,
		'''' AS InstrumentTypeCode,
		'''' AS InstrumentTypeName,
		SUM(vwed.[Internal_TOTE]) AS [Internal_TOTE],
		SUM(vwed.[Internal_PandS]) AS [Internal_PandS],
		SUM(vwed.[Internal_AdjOTE]) AS [Internal_AdjOTE],
		SUM(vwed.[Internal_AdjSegNon]) AS [Internal_AdjSegNon],  -- This has no Value YET! We will need to source this from somewhere eventually when we know where to get it from.
		SUM(vwed.[External_TOTE]) AS [External_TOTE],
		SUM(vwed.[External_PandS]) AS [External_PandS],
		SUM(vwed.[External_AdjOTE]) AS [External_AdjOTE],
		SUM(vwed.[External_AdjSegNon]) AS [External_AdjSegNon],  -- This has no Value YET! We will need to source this from somewhere eventually when we know where to get it from.
		SUM(vwed.[Difference]) AS [Difference],
		vwed.CashReportId,
		NULL AS CashGroupId, 
		NULL AS SortOrder
	FROM [dbo].[vw_ib_CashReport_ExchangeData] vwed
		INNER JOIN ib_CashGroupExchange cge ON cge.ExchangeId = vwed.ExchangeId
	WHERE vwed.InstrumentTypeCode IN (''F'', ''O'') --Futures and Options
		AND vwed.CashReportId = @CashReportId
	GROUP BY 2 + cge.CashGroupId, cge.CashGroupId, vwed.CurrencyId,
		vwed.CurrencyCode,
		vwed.CurrencyName,
		vwed.TemplateTypeClassId,
		vwed.TemplateTypeClassCode,
		vwed.TemplateTypeClassName,
		vwed.CashReportId

UNION ALL

-- These would typically be all LTOM''s Premium Paid options
	SELECT 9999 AS ReportSortOrder
		, vwed.ExchangeId, vwed.ExchangeName, vwed.CurrencyId, vwed.CurrencyCode
		, vwed.CurrencyName, vwed.TemplateTypeClassId, vwed.TemplateTypeClassCode
		, vwed.TemplateTypeClassname, vwed.InstrumentTypeCode, vwed.InstrumentTypeName
		, vwed.Internal_TOTE, vwed.Internal_PandS, vwed.Internal_AdjOTE
		, vwed.Internal_AdjSegNon, vwed.External_TOTE, vwed.External_PandS
		, vwed.External_AdjOTE, vwed.External_AdjSegNon, vwed.Difference, vwed.CashReportId
		, cge.CashGRoupId, cge.SortOrder
	FROM [dbo].[vw_ib_CashReport_ExchangeData] vwed
		LEFT JOIN ib_CashGroupExchange cge ON cge.ExchangeId = vwed.ExchangeId
	WHERE vwed.InstrumentTypeCode NOT IN (''F'', ''O'') -- NOT Futures and Options
		AND vwed.CashReportId = @CashReportId
) tmp2

ORDER BY tmp2.ReportSortOrder, tmp2.SortOrder, tmp2.ExchangeName, tmp2.CurrencyCode
	, tmp2.TemplateTypeClassCode

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Class_Delete]''
');

GO
EXECUTE ('/*
<details>
 <summary>Deletes a class by its id from the ib_Class table</summary>
 <created author="Laurentiu Macovei" Date=" Thursday 14 September 2006 9:26PM GMT" /> 
</details>
*/
create PROCEDURE [dbo].[ib_Class_Delete]
@ClassId int
AS
SET NOCOUNT ON

BEGIN TRY
DELETE FROM ib_Class
	WHERE ClassId =  @ClassId
END TRY
BEGIN CATCH
	EXEC [dbo].[sp_RethrowError] ''Class is currently in use!''	
END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[BancoSantander_HOSTOPN]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[BancoSantander_HOSTOPN]
(
[BancoSantander_HOSTOPNID] [int] NOT NULL IDENTITY(1, 1),
[Ledger] [varchar] (7) NULL,
[HostCurrency] [varchar] (21) NULL,
[BaseCurrency] [varchar] (3) NULL,
[Market] [varchar] (5) NULL,
[MarketCode] [varchar] (5) NULL,
[HostInstrument] [varchar] (21) NULL,
[PromptDate] [varchar] (8) NULL,
[TradeType] [varchar] (4) NULL,
[Series] [varchar] (6) NULL,
[Lots] [varchar] (21) NULL,
[PremiumRate] [varchar] (21) NULL,
[Price] [varchar] (21) NULL,
[Filename] [varchar] (512) NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_BancoSantander_HOSTOPN_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_BancoSantander_HOSTOPN_CreateDate] DEFAULT (getdate()),
[MarketRate] [varchar] (21) NULL,
[Margin] [varchar] (21) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_BancoSantander_HOSTOPN] on [dbo].[BancoSantander_HOSTOPN]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[BancoSantander_HOSTOPN] ADD CONSTRAINT [PK_BancoSantander_HOSTOPN] PRIMARY KEY CLUSTERED  ([BancoSantander_HOSTOPNID])
');

GO
EXECUTE ('PRINT N''Creating index [IX_BancoSantander_HOSTOPN_FileName] on [dbo].[BancoSantander_HOSTOPN]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_BancoSantander_HOSTOPN_FileName] ON [dbo].[BancoSantander_HOSTOPN] ([Filename]) INCLUDE ([BancoSantander_HOSTOPNID], [CreateDate])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[BancoSantander_HOSTOPN_Add]''
');

GO
EXECUTE ('

-- =============================================
-- Author:		A McLeod
-- Create date: 09 Oct 2012
-- Description:	Insert into BancoSantander_HOSTOPN table
--				Copied from RolfeNolan
--
-- Revision History

-- =============================================
CREATE PROCEDURE [dbo].[BancoSantander_HOSTOPN_Add]
	-- Add the parameters for the stored procedure here
	(
	@Filename				varchar(512)=NULL,	
	@Ledger					varchar(7)=NULL,
	@HostCurrency			varchar(21)=NULL,
	@BaseCurrency			varchar(3)=NULL,
	@Market					varchar(5)=NULL,
	@MarketCode				varchar(5)=NULL,
	@HostInstrument			varchar(21)=NULL,
	@PromptDate				varchar(8)=NULL,
	@TradeType				varchar(4)=NULL,
	@Series					varchar(6)=NULL,
	@Lots					varchar(21)=NULL,
	@PremiumRate			varchar(21)=NULL,
	@Price					varchar(21)=NULL,
	@MarketRate				varchar(21)=NULL,
	@Margin					varchar(21)=NULL
    )
AS
BEGIN
	-- SET NOCOUNT ON added4 to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

  INSERT INTO [dbo].[BancoSantander_HOSTOPN]
			( 
			[Ledger]
			,[HostCurrency] 
			,[BaseCurrency]
			,[Market] 
			,[MarketCode]
			,[HostInstrument] 
			,[PromptDate]
			,[TradeType] 
			,[Series]
			,[Lots]
			,[PremiumRate]
			,[Price] 
			,[Filename]
			,[MarketRate]
			,[Margin]
			)
    VALUES
			( 
			@Ledger,
			@HostCurrency,
			@BaseCurrency,
			@Market,
			@MarketCode,
			@HostInstrument,
			@PromptDate,
			@TradeType,
			@Series,
			@Lots,
			@PremiumRate,
			@Price,
			@Filename,
			@MarketRate,
			@Margin
			)
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[is_HAccountAttribute_Add]''
');

GO
EXECUTE ('


/*
<Details>
<Summary>Inserts an item into the HAccountAttribute table</Summary>
<Created author="laurentiu.macovei" date="04/05/2006 16:33:06" />
</Details>
*/
CREATE PROCEDURE [dbo].[is_HAccountAttribute_Add]
	@CorporationCode varchar(4) = NULL,
	@PrincipalBrokerageId varchar(1) = NULL,
	@OfficeCode varchar(4) = NULL,
	@ACNo varchar(10) = NULL,
	@SecuritiesId varchar(2) = NULL,
	@BaseDate datetime = NULL,
	@CalcDate datetime = NULL,
	@CalcStartTime datetime = NULL,
	@SettlementCycle varchar(1) = NULL,
	@SettlementMethod varchar(2) = NULL,
	@Remarks varchar(45) = NULL,
	@DailyStatementId varchar(1) = NULL,
	@DailyStatementIdTradeDetails varchar(1) = NULL,
	@DailyStatementIdAccountTotal varchar(1) = NULL,
	@DailyStatementIdOpenContract varchar(1) = NULL,
	@DailyStatementCashFlow varchar(1) = NULL,
	@DailyStatementCollatSecMovement varchar(1) = NULL,
	@DailyStatementCollatSecDetails varchar(1) = NULL,
	@BusinessId varchar(2) = NULL,
	@BranchCodeOfTrustBK varchar(4) = NULL,
	@FundNumber varchar(10) = NULL,
	@FundName varchar(20) = NULL,
	@CommissionSettlementId varchar(1) = NULL
AS
SET NOCOUNT ON

SET NOCOUNT OFF

	DECLARE	@CalcDateStartTime DATETIME

	IF @BaseDate = ''01/01/1900 00:00:00'' 
		SET @BaseDate = NULL

	IF @CalcDate = ''01/01/1900 00:00:00'' 
		SET @CalcDate = NULL

	IF @CalcStartTime = ''01/01/1900 00:00:00'' 
		SET @CalcStartTime = NULL

	SET @CalcDateStartTime = CONVERT(DATETIME,CONVERT(VARCHAR(12), CONVERT(DATETIME,@CalcDate,112)) + '' '' + CONVERT(VARCHAR(8),RIGHT(@CalcStartTime,8)))


	INSERT INTO is_HAccountAttribute 
		(
			[CorporationCode], 
			[PrincipalBrokerageId], 
			[OfficeCode], 
			[ACNo], 
			[SecuritiesId], 
			[BaseDate], 
			[CalcDate], 
			[CalcStartTime], 
			[CalcDateStartTime], 
			[SettlementCycle], 
			[SettlementMethod], 
			[Remarks], 
			[DailyStatementId], 
			[DailyStatementIdTradeDetails], 
			[DailyStatementIdAccountTotal], 
			[DailyStatementIdOpenContract], 
			[DailyStatementCashFlow], 
			[DailyStatementCollatSecMovement], 
			[DailyStatementCollatSecDetails], 
			[BusinessId], 
			[BranchCodeOfTrustBK], 
			[FundNumber], 
			[FundName], 
			[CommissionSettlementId]
		) 
	VALUES
		(
			@CorporationCode, 
			@PrincipalBrokerageId, 
			@OfficeCode, 
			@ACNo, 
			@SecuritiesId, 
			@BaseDate, 
			@CalcDate, 
			@CalcStartTime,
			@CalcDateStartTime, 
			@SettlementCycle, 
			@SettlementMethod, 
			@Remarks, 
			@DailyStatementId, 
			@DailyStatementIdTradeDetails, 
			@DailyStatementIdAccountTotal,
			@DailyStatementIdOpenContract, 
			@DailyStatementCashFlow, 
			@DailyStatementCollatSecMovement, 
			@DailyStatementCollatSecDetails, 
			@BusinessId, 
			@BranchCodeOfTrustBK, 
			@FundNumber, 
			@FundName, 
			@CommissionSettlementId
		);

Return Scope_Identity()
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Rule_GetMatchCodesByKeyword]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Rule_GetMatchCodesByKeyword]
	@MatchCodeToFilter nvarchar(100), 
	@Top int = 10
AS
SET NOCOUNT ON
	SELECT MatchCodeId, MatchCode FROM ib_MatchCode
	WHERE MatchCode LIKE ''%''+@MatchCodeToFilter+''%''
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Instrument_GetInstumentNamesHintByKeyword]''
');

GO
EXECUTE ('/*
<details>
 <summary> Returns the instruments hint for a specific code /summary>
 <created author="Laurentiu Macovei" Date="Thursday, 16 August 2006 20:31 GMT" /> 
 <tasks>
 </tasks>
</details>
-- 13 May 2014  ED  EIB 25499 - add IsActive flag to ib_Instrument
*/
CREATE PROCEDURE [dbo].[ib_Instrument_GetInstumentNamesHintByKeyword]
@InstrumentName varchar(100),
@HintByStartOnly bit = 0,
@HintLength int = 1
AS
SET NOCOUNT ON

DECLARE @len int
SET @len = LEN(@InstrumentName)
IF @HintByStartOnly = 1
BEGIN
	SELECT DISTINCT SUBSTRING ([Name], @len, @HintLength) x
		FROM [dbo].[ib_Instrument]
		WHERE [Name] LIKE @InstrumentName+''%'' AND IsActive = 1
		ORDER BY x DESC

END
ELSE
BEGIN
	SELECT DISTINCT SUBSTRING ([Name], PATINDEX(''%''+@InstrumentName+''%'', [Name]) + @len, @HintLength) x
		FROM [dbo].[ib_Instrument]
		WHERE [Name] LIKE ''%''+@InstrumentName+''%'' AND IsActive = 1
		ORDER BY x DESC
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[SanitizeValue]''
');

GO
EXECUTE ('/*
----------------------------------------------------------------------------------------------------
Author			Date			Description
KevinP			14 Sep 2009		This function sanitizes a value to remove any escape chars in SQL TO prevent possible SQL injection attacks.
*/


CREATE FUNCTION [dbo].[SanitizeValue](@ValueToSanitise varchar(max))
RETURNS VARCHAR(MAX)
AS
BEGIN
	DECLARE @ReturnValue VARCHAR(MAX)
	SET @ReturnValue = @ValueToSanitise
	SET @ReturnValue = REPLACE(@ReturnValue,'''''''', '''''''''''')
	SET @ReturnValue = REPLACE(@ReturnValue,'';'', '''')
	SET @ReturnValue = REPLACE(@ReturnValue,''--'', '''')

	RETURN @ReturnValue
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[OperatorTranslate]''
');

GO
EXECUTE ('/*
----------------------------------------------------------------------------------------------------
Author			Date			Description
KevinP			07 Sep 2009		This translates an English comparison to a SQL comparison. e.g converts the word ''Starts With'' and the value ''bob'' to LIKE ''bob%''
KevinP			06 Oct 2009		Had to make a change specifically for dates, where the dat stored includes date AND time, but we only want to search by date
								So there''s a new input Param for the function which will modify the dynamic text to return a BETWEEN statement which includes
								the correct date + 00:00:00:000 and date + 23:59:59:997.
EmyD			23 Jun 2010     Fix the Less Than, Greaten Than for Date to not include "todays" dates
EmyD			09 Jan 2014     EIB 24964 - If it is date and not between, ignore the second value
*/


CREATE FUNCTION [dbo].[OperatorTranslate](@EnglishOperator varchar(max), @Value1 varchar(max), @Value2 varchar(max), @IncludeStringMarkers BIT,@GenerateSARGForDate BIT)
RETURNS VARCHAR(MAX)
AS
BEGIN
	DECLARE @ReturnValue VARCHAR(MAX)
	DECLARE @StringMarker VARCHAR(1)

	SET @Value1 = dbo.SanitizeValue(@Value1)
	SET @Value2 = dbo.SanitizeValue(@Value2)


IF @Value1 IS NULL AND @Value2 IS NULL
BEGIN
	SET @ReturnValue = ''''
END
ELSE
BEGIN
	IF @IncludeStringMarkers = 1
		SET @StringMarker = ''''''''
	ELSE
		SET @StringMarker = ''''
		
	IF @GenerateSARGForDate = 1
	BEGIN
		IF @EnglishOperator != ''Between''
			SET @Value2 = NULL
		IF (@Value2 IS NULL OR LEN(@Value2) = 0) AND ISDATE(@Value1) = 1
		BEGIN 
		
			SET @Value1 = CONVERT(VARCHAR, CAST(FLOOR(CAST(CAST(@Value1 AS DATETIME) AS FLOAT)) AS DATETIME) , 113)
			SET @Value2 = CONVERT(VARCHAR, CONVERT(VARCHAR, CAST(@Value1 AS DATETIME), 106) + '' 23:59:59:997'', 113)

			IF @EnglishOperator = ''Equals''
				SET @ReturnValue = '' BETWEEN '' + @StringMarker + @Value1 + @StringMarker + '' AND '' + @StringMarker + @Value2 + @StringMarker--CAST(FLOOR(CAST(nm.CreateDate AS FLOAT ))AS DATETIME)
				
			IF @EnglishOperator = ''Less Than''
				SET @ReturnValue = '' < '' + @StringMarker + @Value1 + @StringMarker

			IF @EnglishOperator = ''Greater Than'' OR @EnglishOperator = ''Between'' -- "Between" will happen if the user accidentally selected between, but never selected a 2nd value, so treat it like a greater than
				SET @ReturnValue = '' > '' + @StringMarker + @Value2 + @StringMarker
		END
		ELSE
		BEGIN
			SET @Value1 = CONVERT(VARCHAR, CAST(FLOOR(CAST(CAST(@Value1 AS DATETIME) AS FLOAT)) AS DATETIME) , 113)
			SET @Value2 = CONVERT(VARCHAR, CONVERT(VARCHAR, CAST(@Value2 AS DATETIME), 106) + '' 23:59:59:997'', 113)
			
			IF @EnglishOperator = ''Between''
				SET @ReturnValue = '' BETWEEN '' + @StringMarker + @Value1 + @StringMarker + '' AND '' + @StringMarker + @Value2 + @StringMarker
				
		END
	END
	ELSE
	BEGIN

		IF @EnglishOperator = ''Starts With'' 
			SET @ReturnValue = '' LIKE '''''' + @Value1 + ''%''''''

		IF @EnglishOperator = ''Equals''
			SET @ReturnValue = '' ='' + @StringMarker + @Value1 + @StringMarker

		IF @EnglishOperator = ''Contains''
			SET @ReturnValue = '' LIKE ''''%'' + @Value1 + ''%''''''

		IF @EnglishOperator = ''Less Than''
			SET @ReturnValue = '' < '' + @StringMarker + @Value1 + @StringMarker

		IF @EnglishOperator = ''Greater Than''
			SET @ReturnValue = '' > '' + @StringMarker + @Value1 + @StringMarker

		IF @EnglishOperator = ''Between''
			SET @ReturnValue = '' BETWEEN '' + @StringMarker + @Value1 + @StringMarker + '' AND '' + @StringMarker + @Value2 + @StringMarker
	END
END

RETURN  @ReturnValue

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[PerformCorrections]''
');

GO
EXECUTE ('CREATE FUNCTION [dbo].[PerformCorrections]
(@FractionValue DECIMAL (24, 10), @BaseId INT)
RETURNS DECIMAL (24, 10)
AS
BEGIN
	--	17 Jun 2010  ED		Creation
	--  17 Jun 2010  ED		MBAL 15621 - add logic for converting from 5 to 6 decimals
	--  17 Jun 2010  ED		MBAL 15702 - add logic for converting from 3 to 4 decimals
	--  01 Jul 2010  ED     MBAL 15981 - fixed the problem when baseId not null and not a conversion one
	-- Declare the return variable here
	DECLARE @Base10Value DECIMAL(24, 10)

	IF @BaseId IS NULL
		SET @Base10Value = @FractionValue
	ELSE
	BEGIN
		DECLARE @BaseCode VARCHAR(100)
		SET @BaseCode = (SELECT Code FROM ib_Base WHERE BaseId = @BaseId)
		IF (@BaseCode = ''Decimal3To4DPCorrection'' OR @BaseCode = ''Decimal5To6DPCorrection'')
		BEGIN
			DECLARE @DecimalsPart DECIMAL(24,10)
			DECLARE @LastDecimals DECIMAL(24,10)
			DECLARE @Multiplier INT
			DECLARE @Correction DECIMAL(24,10)
			IF @BaseCode = ''Decimal5To6DPCorrection'' -- 5 decimals 
			BEGIN
				SET @Multiplier = 100000
				SET @Correction = 0.000005
			END
			ELSE IF @BaseCode = ''Decimal3To4DPCorrection'' -- 3 decimals
			BEGIN
				SET @Multiplier = 1000
				SET @Correction = 0.0005
			END
			SET @Base10Value = @FractionValue
			SET @DecimalsPart = @Base10Value
			--get only decimals
			IF (@Base10Value > 0)
				SET @DecimalsPart = @DecimalsPart - FLOOR(@DecimalsPart)
			ELSE
				SET @DecimalsPart = @DecimalsPart - CEILING(@DecimalsPart)
			--check if only 5 decimals	/ 3 decimals
			SET @DecimalsPart = @DecimalsPart * @Multiplier -- 100,000 or 1,000 
			IF (@Base10Value > 0)
				SET @LastDecimals = @DecimalsPart - FLOOR(@DecimalsPart)
			ELSE
				SET @LastDecimals = @DecimalsPart - CEILING(@DecimalsPart)
			IF @LastDecimals = 0 -- we have only 5/3 digits, good
			BEGIN
				SET @DecimalsPart = @DecimalsPart/10 -- get last decimal
				IF (@Base10Value > 0)
						SET @DecimalsPart = @DecimalsPart - FLOOR(@DecimalsPart)
					ELSE
						SET @DecimalsPart = @DecimalsPart - CEILING(@DecimalsPart)
					IF ABS(@DecimalsPart) = 0.3 OR ABS(@DecimalsPart) = 0.8 -- if last decimal is 3 or 8, should be converted to 25 or 75
						IF @Base10Value > 0
							SET @Base10Value = @Base10Value - @Correction
						ELSE
							SET @Base10Value = @Base10Value + @Correction
			END
			
		END
		ELSE
			SET @Base10Value = @FractionValue
	END
	-- Return the result of the function
	RETURN @Base10Value

END


');

GO
EXECUTE ('PRINT N''Creating [dbo].[GetReutersMonthNumber]''
');

GO
EXECUTE ('CREATE FUNCTION [dbo].[GetReutersMonthNumber]
(
	@ReutersMonthChar CHAR(1)
)
RETURNS SMALLINT
AS
BEGIN

	--	03 Mar 2011		amk		MBAL-17728: creation
	
	DECLARE @Months CHAR(12)
	SET @Months = ''FGHJKMNQUVXZ''

	DECLARE @MonthNumber SMALLINT

	SET @MonthNumber = CHARINDEX(@ReutersMonthChar, @Months)

	RETURN @MonthNumber
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_BancoSantander_HOSTOPN_Load]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_BancoSantander_HOSTOPN_Load] 
	(
		@LocationPath VARCHAR(100) = NULL
		,@ReceiveLocationSysId INT
		,@RunId INT	
	)
AS
SET NOCOUNT ON

-- Author:		A McLeod
-- Create date: 09 Oct 2012
-- Description:	This stored procedure pulls data from the BancoSantander_HOSTOPN temp
-- table and inserts it into ib_Position
-- Whilst iterating through the records in BancoSantander_HOSTOPN, all 
-- of these inserts are wrapped in a transaction so that any failure causes
-- the changes to not commit.
-- (Initially copied from RolfeNolan)
--
-- Revision History
-- 19 Dec 2012	GC	Remove wrong calculation of Market Value left over from 
--					coding for a previous Santander file. 
-- 02 Jan 2014  RD	MBAL-24931 Added checking file age
-- 09 Jan 2014	ED	EIB 25004 - remove importLog table and use Log table
-- 14 Jan 2014  ED  EIB 25059 - refactor to check the AsOfDate outside of transaction
-- 25 Apr 2014  ED  EIB 25473 - raise error if file is too old and mark temp records as LoadState=3
-- 02 Oct 2015  ED  EIB 27843 - don''t load price for HOSTOPNCSHBZ	

DECLARE @DefaultStrikePriceDivisor DECIMAL(19,4)
DECLARE @DataSourceCd VARCHAR(100)
DECLARE @ReturnValue INT, @Output INT, @Output2 int
DECLARE @DataSourceId INT
DECLARE @FirmCd VARCHAR(100)
DECLARE		@AsOfDate				datetime
DECLARE		@AsOfDayStr				varchar(2)
--- BEGIN AS OF DATE COMPUTATION
DECLARE @Today DATETIME
SET @Today = GETDATE()		-- used for YEAR portion ONLY

-- get last 2 characters of filename - this is a day number
SET @AsOfDate = NULL
SET @AsOfDayStr = SUBSTRING(@LocationPath, LEN(@LocationPath) - 1, 2)

-- get 3rd character from end of filename - this is a reuters month indicator (letter)
DECLARE @ReutersMonthChar CHAR(1)
SET @ReutersMonthChar = SUBSTRING(@LocationPath, LEN(@LocationPath) - 2, 1)
DECLARE @ReutersMonthNumber SMALLINT
SET @ReutersMonthNumber = dbo.GetReutersMonthNumber(@ReutersMonthChar)

DECLARE @Year SMALLINT
SET @Year = NULL
 
IF (ISNUMERIC(@AsOfDayStr) > 0) AND @ReutersMonthNumber > 0
BEGIN
	SET @Year = YEAR(@Today)
	SET @AsOfDate = CONVERT(DATETIME
		, CONVERT(VARCHAR(2), @ReutersMonthNumber) + ''/'' + @AsOfDayStr 
			+ ''/'' + CONVERT(VARCHAR(4), @Year), 101)

	-- back up 1 year if we''ve constructed a date into the future
	IF @AsOfDate > @Today
		SET @AsOfDate = DATEADD(yy, -1, @AsOfDate)
END
--- END AS OF DATE COMPUTATION
			
--rd - make sure the As Of Date is not older than acceptable
DECLARE @IsAcceptable bit
EXECUTE [dbo].[Load_IsFileTooOld] @DataSourceId,@LocationPath,@AsOfDate,@IsAcceptable OUTPUT, @ReceiveLocationSysId, @RunId
IF (@IsAcceptable = 0)
BEGIN
	UPDATE [BancoSantander_HOSTOPN] SET [LoadState] = 3 WHERE [Filename] = @LocationPath
	RAISERROR (''File is too old.'', 18, 0)
	RETURN
END

SET @FirmCd = ''BZ''
SET @DataSourceCd = ''BZ''
		
IF @LocationPath IS NULL SET @LocationPath = @DataSourceCd
					
DECLARE @CurrencyId int
DECLARE @DefaultCurrencyId INT
				
EXEC @ReturnValue= [_ib_DataSource_GetByCodeForOutput] @DataSourceCd, @OutPut OUTPUT, @Output2 OUTPUT
SET @DataSourceId = @Output
SET @DefaultCurrencyId = @Output2	

--Gets the defaultStrikePriceDivisor
SET @DefaultStrikePriceDivisor = [dbo].[udf_GetDefaultStrikePriceDivisor](@DataSourceId, NULL)

-- Duplicate file check										
DECLARE @IsFileAlreadyLoaded INT
EXEC @IsFileALreadyLoaded = HasFileBeenLoaded @LocationPath, @DataSourceId

IF @IsFileAlreadyLoaded = 1
BEGIN
	UPDATE [BancoSantander_HOSTOPN]
	SET [LoadState] = 3
	WHERE [LoadState] = 1
		AND [Filename] = @LocationPath
	
	RETURN
END
										
-- Store ImportFile record to be associated with Settlement Price load
DECLARE @ImportFileId INT
EXEC ib_ImportFile_Add @DataSourceId, @LocationPath, @ImportFileId OUTPUT
DECLARE @SelectedAsOfDate DATETIME
-- There really isn''t any need for orchestration to call a LoadStateChange anymore
-- since we only process rows for single file now
-- but to keep consistent with other loaders - we''ll update to LoadState 1 at 
-- start of this Load stored procedure
UPDATE [BancoSantander_HOSTOPN]
SET LoadState = 1
WHERE LoadState = 0
	AND Filename = @LocationPath

CREATE TABLE #temp1
	(
		BancoSantander_HOSTOPNID		int,
		Ledger						varchar(7),
		HostCurrency				varchar(21),
		Market						varchar(5),
		MarketCode					varchar(5),
		HostInstrument				varchar(21),
		PromptDate					varchar(8),
		TradeType					varchar(4),
		Series						varchar(6),
		Lots						varchar(21),
		PremiumRate					varchar(21),
		Price						varchar(21),
		MarketRate					varchar(21),
		[Filename]					varchar(512),
		Margin						varchar(21)
	)

	INSERT INTO #temp1
	(
		BancoSantander_HOSTOPNID,
		Ledger,
		HostCurrency,
		Market,
		MarketCode,
		HostInstrument,
		PromptDate,
		TradeType,
		Series,
		Lots,
		PremiumRate,
		Price,
		MarketRate,
		[Filename],
		Margin	
	)
	SELECT 	
		BancoSantander_HOSTOPNID,
		Ledger,
		HostCurrency,
		Market,
		MarketCode,
		HostInstrument,
		PromptDate,
		TradeType,
		Series,
		Lots,
		PremiumRate,
		Price,
		MarketRate,
		[Filename],
		Margin
	FROM [dbo].[BancoSantander_HOSTOPN]
	WHERE LoadState = 1
		AND [Filename] = @LocationPath

	BEGIN TRAN T1

			-- BizTalk''s SQL Adapter uses more restrictive read serializable
			-- so this is necessary to relax it to something that is default
			-- and perfectly acceptable!
			SET TRANSACTION ISOLATION LEVEL READ COMMITTED

			DECLARE @BancoSantander_HOSTOPNID		int
			DECLARE @Ledger						varchar(7)
			DECLARE @HostCurrency				varchar(21)
			DECLARE @Market						varchar(5)
			DECLARE @MarketCode					varchar(5)
			DECLARE @HostInstrument				varchar(21)
			DECLARE @PromptDate					varchar(8)
			DECLARE @TradeType					varchar(4)
			DECLARE @Series						varchar(6)
			DECLARE @Lots						varchar(21)
			DECLARE @PremiumRate				varchar(21)
			DECLARE @Price						varchar(21)
			DECLARE @MarketRate					varchar(21)
			DECLARE @Margin						varchar(21)
			DECLARE @Filename					varchar(512)

			DECLARE pos_cursor CURSOR FOR
			SELECT	BancoSantander_HOSTOPNID,
					Ledger,
					HostCurrency,
					Market,
					MarketCode,
					HostInstrument,
					PromptDate,
					TradeType,
					Series,
					Lots,
					PremiumRate,
					Price,
					MarketRate,
					[Filename],
					Margin
			FROM	#temp1

			OPEN pos_cursor

			FETCH NEXT FROM pos_cursor
			INTO 
					@BancoSantander_HOSTOPNID,
					@Ledger,
					@HostCurrency,
					@Market,
					@MarketCode,
					@HostInstrument,
					@PromptDate,
					@TradeType,
					@Series,
					@Lots,
					@PremiumRate,
					@Price,
					@MarketRate,
					@Filename,
					@Margin

				-- Check @@FETCH_STATUS to see IF there are any more rows to fetch.
				WHILE @@FETCH_STATUS = 0
				BEGIN
					DECLARE		@AccountCd				varchar(100)
					DECLARE		@ExchangeCd				varchar(25)
					DECLARE		@InstrumentCd			varchar(100)
					DECLARE		@Quantity				decimal(19,4)
					DECLARE		@ShortQuantity			decimal(19,4)
					DECLARE		@LongQuantity			decimal(19,4)
					DECLARE		@MarketValue			decimal(19,4)
					DECLARE		@ExpYr					smallint
					DECLARE		@ExpMth					smallint
					DECLARE		@ExpDay					smallint
					DECLARE		@PriceDivisor			DECIMAL(19,4)
					DECLARE		@StrikePrice			decimal(19,4)
					DECLARE		@StrikePriceDivisor		decimal(19,4)
					DECLARE		@TrxTypeCd				varchar(25)
					DECLARE		@OptionTypeCd			varchar(25)
					DECLARE		@TrxDate				datetime
					DECLARE		@InstrumentTypeCd		varchar(100)
					DECLARE     @ErrorMessageForRecord	varchar(1024)
					
					-- Temporary variables
                    DECLARE     @TempDate datetime
					DECLARE 	@Code varchar(100), @Code2 varchar(100)
					
			SET @AccountCd = @Ledger
			SET @StrikePrice = NULL
			SET	@ExchangeCd = @Market
			
			-- PromptDate can be 99999999

			IF @PromptDate = ''99999999''
                BEGIN
					SET @ExpYr = 9999
					SET @ExpMth = 99
					SET @ExpDay = 99
				END

			-- ExpiryDate = PromptDate, PromptDate is in yyyymmdd ISO 112 format
			ELSE IF @PromptDate <> ''99999999''
			BEGIN TRY
				SET @TempDate = CONVERT(datetime, @PromptDate, 112)
				SET @ExpYr = DATEPART(yyyy, @TempDate)
				SET @ExpMth = DATEPART(mm, @TempDate)			
				SET @ExpDay = DATEPART(dd, @TempDate)
			END TRY
			BEGIN CATCH
				SET @ErrorMessageForRecord = ERROR_MESSAGE()
				EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @ErrorMessageForRecord, ''Success'', @BancoSantander_HOSTOPNID, @RunId
			END CATCH
				
			
			-- Set the OptionTypeCode - From Trade Type (FT=Future, TP=Put TC=Call)
			IF @TradeType = ''FT'' 
			   BEGIN
					SET @OptionTypeCd = ''Future''
					-- InstrumentTypeCd
					SET @InstrumentTypeCd = ''F''			
			   END
			ELSE IF @TradeType <> ''FT''
				BEGIN
					-- StrikePrice = Series, Series have a value only for TP and TC Trade types.
					IF ISNUMERIC(@Series) > 0 
						BEGIN
							SET @StrikePrice = CONVERT(decimal(19,4), @Series)
						END
                        
					-- The InstrumentTypeCd value is based on the TradeType value
					-- We want to make sure that only in the case the TradeType value is correct we also SET the InstrumentTypeCd value
					IF @TradeType = ''TP''
						BEGIN		
							SET @OptionTypeCd = ''P''
							SET @InstrumentTypeCd = ''O''
						END
					ELSE IF @TradeType = ''TC''
						BEGIN	
							SET @OptionTypeCd = ''C''
							SET @InstrumentTypeCd = ''O''
						END
				END
			
			-- We prefix the Instruments with the IntrumentTypeCode
			SET @InstrumentCd = @InstrumentTypeCd + ''_'' + @Market + ''_'' + @HostInstrument
			
			SET @Output = null

			DECLARE @InstrumentTypeId int
			SET @Code = @InstrumentTypeCd
			EXEC @ReturnValue = ib_Instrumenttype_AddAsNeeded @DataSourceId,@Code,@OutPut OUTPUT
			SET @InstrumentTypeId = @OutPut
			SET @Output = null

				IF @HostCurrency IS NOT NULL
				BEGIN
					EXEC @ReturnValue = [ib_Currency_AddAsNeeded] @DataSourceId, @HostCurrency, @Output OUTPUT
					SET @CurrencyId = @Output
				end

				SET @Output = null
				SET @Output2 = null
				DECLARE @InstrumentId int
				SET @Code = @InstrumentCd
				EXEC @ReturnValue= [ib_Instrument_AddAsNeeded] @DataSourceId,@InstrumentTypeId,@Code,@CurrencyId,@Output OUTPUT,@Output2 OUTPUT	
				SET @InstrumentId = @Output
				if @CurrencyId is null
				BEGIN
					if @Output2 is null
						SET @CurrencyId = @DefaultCurrencyId	
					else
						SET @CurrencyId = @Output2
				end
			
			DECLARE @Base INT
			DECLARE @BaseId INT
			SET @Base = NULL
			SET @BaseId = NULL
			
			SELECT @StrikePriceDivisor = ids.StrikePriceDivisor
				, @PriceDivisor = ids.PriceDivisor
				, @Base = b.Base
				, @BaseId = b.BaseId
			FROM [dbo].[ib_InstrumentDataSource] ids
				LEFT OUTER JOIN ib_Base b ON b.BaseId = ids.BaseId
			WHERE ids.DataSourceId = @DataSourceId
				AND ids.DataSourceInstrumentCode = @InstrumentCd 	
				
				
			IF @StrikePrice IS NOT NULL
			BEGIN
				
				IF @StrikePriceDivisor IS NULL
					BEGIN
						SET @StrikePrice		= @StrikePrice / @DefaultStrikePriceDivisor
					END
				ELSE
					BEGIN
						SET @StrikePrice		= @StrikePrice / @StrikePriceDivisor
					END		
			END

			-- Set Settlement Price				
			IF @PriceDivisor IS NULL 
				SET @PriceDivisor = 1
					
			DECLARE @SettlementPrice DECIMAL(24,10)
			SET @SettlementPrice = CONVERT(DECIMAL(24,10), @MarketRate) 
			--fix 3-4, 5-6 dps
			SET @SettlementPrice = dbo.PerformCorrections(@SettlementPrice, @BaseId)
			
			SET @SettlementPrice = @SettlementPrice / @PriceDivisor
				
			-- Quantity = Lots
			SET @Quantity = 0
			IF ISNUMERIC(@Lots) > 0 
				SET @Quantity = CONVERT(decimal(19,4), @Lots)

			SET	@ShortQuantity = 0	
			SET	@LongQuantity = 0

			IF @Quantity > 0
				SET @LongQuantity = @Quantity

			IF @Quantity < 0
				SET @ShortQuantity = (-1) * @Quantity
								
				DECLARE	@MarketValueDivisor DECIMAL(19,4)
	
				SELECT @MarketValueDivisor = ids.MarketValueDivisor 
				FROM ib_InstrumentDataSource ids 
			    WHERE ids.DataSourceInstrumentCode = @InstrumentCd 	
				   AND ids.DataSourceId = @DataSourceId 
				   AND ids.CurrencyId = @CurrencyId

				IF @MarketValueDivisor IS NULL OR @MarketValueDivisor = 0
				BEGIN
					SET @MarketValueDivisor = 1
				END
				
			-- Now calculate Market Value
			-- Market Value = Lots * Price
			IF ISNUMERIC(@Margin) > 0
							SET @MarketValue = (CONVERT(decimal(19,4), @Margin) / @MarketValueDivisor)
			
			SET @TrxTypeCd = ''POSITION''

			-- TrxDate
			SET @TrxDate = GETDATE()

			SET @SelectedAsOfDate = @AsOfDate
			
			DECLARE @PositionId INT
			SET @PositionId = NULL
						
			EXEC [ib_Position_Load]
			@DataSourceCd,			
			@ExchangeCd,				
			@FirmCd,					
			@AccountCd,				
			@AsOfDate,				
			@InstrumentCd,			
			@Quantity,				
			@MarketValue,			
			@ExpYr,					
			@ExpMth,					
			@ExpDay,					
			@StrikePrice,			
			@TrxTypeCd,				
			@OptionTypeCd,			
			@TrxDate,				
			0,		-- This value is not used in the ib_Position_Load Stored Procedure, should be removed ?			
			@BancoSantander_HOSTOPNID,
			@InstrumentTypeCd,		
			@LocationPath,
			@HostCurrency,
			@LongQuantity,
			@ShortQuantity,		
			@PositionId = @PositionId OUTPUT, 
			@ReceiveLocationSysId = @ReceiveLocationSysId,
			@RunId = @RunId
			if (CHARINDEX(''HOSTOPNCSHBZ'',@LocationPath) = 0)		-- don''t load price for HOSTOPNCSHBZ					
				-- Add Settlement Price											
				EXEC ib_Price_AddFromPositionLoad
					@PositionId
					, @ImportFileId
					, @SettlementPrice
					, @Base
						
			--flip processed flag in source table.
			UPDATE [BancoSantander_HOSTOPN]
			SET [LoadState] = 2
			WHERE [BancoSantander_HOSTOPNID] = @BancoSantander_HOSTOPNID
				AND [LoadState] = 1

			FETCH NEXT FROM pos_cursor
			INTO 
					@BancoSantander_HOSTOPNID,
					@Ledger,
					@HostCurrency,
					@Market,
					@MarketCode,
					@HostInstrument,
					@PromptDate,
					@TradeType,
					@Series,
					@Lots,
					@PremiumRate,
					@Price,
					@MarketRate,
					@Filename,
					@Margin

		END
			
			CLOSE pos_cursor
			DEALLOCATE pos_cursor
			
			UPDATE ib_ImportFile 
			SET AsOfDate = CAST(CONVERT(CHAR(10), @SelectedAsOfDate, 101) AS DATETIME)  
			WHERE ImportFileId = @ImportFileId
			
		COMMIT TRAN T1

	DROP TABLE #temp1
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Class_CheckForDuplicate]''
');

GO
EXECUTE (' /*
<details>
 <summary>
	Checks for the duplicate classes with same code or description. 
	The duplicates are considered if the count of the code or the description is greater than zero (0) for 
	the non-matching ClassId
</summary>
 <created author="Laurentiu Macovei" Date=" Thursday 14 September 2006 9:26PM GMT" /> 
</details>
*/
create PROCEDURE [dbo].[ib_Class_CheckForDuplicate]
@Code varchar(100),
@Description varchar(100),
@ClassId int
AS
SET NOCOUNT ON

DECLARE @Count int

SELECT TOP 1 @Count = 1
	FROM [dbo].[ib_Class] c
	WHERE Code = @Code
		AND ClassID <> @ClassId

IF @Count > 0
	RAISERROR (N''There is already another class with same code (%s). Please specify other code!'', 11, 1, @Code)

SET @Count = 0
SELECT TOP 1 @Count = 1
	FROM [dbo].[ib_Class] c
	WHERE Description = @Description
		AND ClassID <> @ClassId

IF @Count > 0
	RAISERROR (N''There is already another class with same description (%s). Please specify other description!'', 11, 1, @Description)
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Class_Update]''
');

GO
EXECUTE (' /*
<details>
 <summary>Updates a class from the ib_Class table by its id</summary>
 <created author="Laurentiu Macovei" Date=" Thursday 14 September 2006 9:26PM GMT" /> 
</details>
*/ 
 create PROCEDURE [dbo].[ib_Class_Update]
(
	@ClassId int,
	@Code varchar(100),
    @Description varchar(100),
    @UpdateUsername varchar(50)
)
AS
SET NOCOUNT ON

BEGIN TRY
--check for duplicates 
EXEC [dbo].[ib_Currency_CheckForDuplicate] @Code, @Description, @ClassId

UPDATE [dbo].[ib_Class]
   SET [Code] = @Code
      ,[Description] = @Description
      ,[UpdateUsername] = @UpdateUsername
 WHERE ClassId = @ClassId
 
 END TRY
BEGIN CATCH
	EXEC [dbo].[sp_RethrowError]
END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[is_HAccountTotal_Add]''
');

GO
EXECUTE ('





/*
Details
SummaryInserts an item into the GAccountTotal table/Summary
Created author="laurentiu.macovei" date="04/05/2006 16:33:05" /
/Details
*/
CREATE PROCEDURE [dbo].[is_HAccountTotal_Add]
			(
			@CorporationCode								varchar(4),
			@PrincipalBrokerageId							varchar(1),
			@OfficeCode varchar(4),
			@ACNo varchar(10),
			@SecuritiesId varchar(2),
			@BaseDate datetime,
			@CalculationDate datetime,
			@CalculationStartTime  datetime,
			@FinalCashBalanceofPreviousDaySign varchar(1),
			@FinalCashBalanceofPreviousDay decimal(15,0),
			@SettlementAmntOfThePreviousDaySTradeSign varchar(1),
			@SettlementAmntOfThePreviousDaySTrade decimal(15,0),
	 		@PreviousDaySReportedCashBalanceSign varchar(1),
			@PreviousDaySReportedCashBalance decimal(15,0),
			--@AdjustmentFPDAmountSign varchar(1),
			--@AdjustmentFPDAmount decimal(15,0),
			@AdjustmentFPDFuturesRealizedPLSign varchar(1),
			@AdjustmentFPDFuturesRealizedPL decimal(15,0),
			@AdjustmentFPDOptionsPremiumAmountBuySign varchar(1),
			@AdjustmentFPDOptionsPremiumAmountBuy decimal(15,0),
			@AdjustmentFPDOptionsPremiumAmountSellSign varchar(1),
			@AdjustmentFPDOptionsPremiumAmountSell decimal(15,0),
			@AdjustmentFPDNetStrikePriceForExerciseSign varchar(1),
			@AdjustmentFPDNetStrikePriceForExercise decimal(15,0),
			@AdjustmentFPDNetStrikePriceForAllotmentSign varchar(1),
			@AdjustmentFPDNetStrikePriceForAllotment decimal(15,0),
			@AdjustmentFPDDomesticCommissionSign varchar(1),
			@AdjustmentFPDDomesticCommission decimal(15,0),
			@AdjustmentFPDConsumptionTaxOnCommissionSign varchar(1),
			@AdjustmentFPDConsumptionTaxOnCommission decimal(15,0),
			@AdjustmentFPDExchangeTaxSign varchar(1),
			@AdjustmentFPDExchangeTax decimal(15,0),
			@AdjustmentFPDTradeSign varchar(1),
			@AdjustmentFPDTrade decimal(15,0),
			@AdjustmentFPDCashFlowSign varchar(1),
			@AdjustmentFPDCashFlow decimal(15,0),
			@CashPaidReceivedSign varchar(1),
			@CashPaidReceived decimal(15,0),
			@EndingCashBalanceSign varchar(1),
			@EndingCashBalance decimal(15,0),
			@SettlementAmountFCDTradingSign varchar(1),
			@SettlementAmountFCDTrading decimal(15,0),
			@FuturesRealizedPLOTDSign varchar(1),
			@FuturesRealizedPLOTD decimal(15,0),
			@OptPremiumOTDBuySign varchar(1),
			@OptPremiumOTDBuy decimal(15,0),
			@OptPremiumOTDSellSign varchar(1),
			@OptPremiumOTDSell decimal(15,0),
			@NetStrikePOTDOptExerciseSign varchar(1),
			@NetStrikePOTDOptExercise decimal(15,0),
			@NetStrikePOTDOptAssignmentSign varchar(1),
			@NetStrikePOTDOptAssignment decimal(15,0),
			@DomesticCommissionOTDSign varchar(1),
			@DomesticCommissionOTD decimal(15,0),
			@ConsumptionTaxOnCommissionOTDSign varchar(1),
			@ConsumptionTaxOnCommissionOTD decimal(15,0),
			@ExchangeTaxOTDSign varchar(1),
			@ExchangeTaxOTD decimal(15,0),
			@ReportedCashBalanceOTDSign varchar(1),
			@ReportedCashBalanceOTD decimal(15,0),
			@UnrealizedPLSign varchar(1),
			@UnrealizedPL decimal(15,0),
			@MarketValueNonCalculableFlag varchar(1),
			@TotalMarginMoneySign varchar(1),
			@TotalMarginMoney decimal(15,0),
			@PresentCollateralBalanceDirectDepositToTiffe decimal(15,0),
			@PresentCollateralBalanceDirectDepositToMemberFirm decimal(15,0),
			@PresentCollateralBalanceReplacementDeposit decimal(15,0),
			@PresentCollateralBalanceTotal decimal(15,0),
			@NextDayCollateralMovementSignDirectDepositToTiffe varchar(1),
			@NextDayCollateralMovementDirectDepositTo decimal(15,0),
			@NextDayCollateralMovementSignDirectDepositToMemberFirm varchar(1),
			@NextDayCollateralMovementDirectDepositToMemberFirm decimal(15,0),
			@NextDayCollateralMovementSignReplacementDeposit varchar(1),
			@NextDayCollateralMovementReplacementDeposit decimal(15,0),
			@NextDayCollateralMovementTotalSign varchar(1),
			@NextDayCollateralMovementTotal decimal(15,0),
			@CollateralEvaluationNonCalculableFlagTotal varchar(1),
			@TotalAmntOfMarginSign varchar(1),
			@TotalAmntOfMargin decimal(15,0),
			@MarginRequirement decimal(15,0),
			@MarginRequirementNonCalculableFlag varchar(1),
			@NewContractFlag varchar(1),
			@BuyOptValue decimal(15,0),
			@SellOptValue decimal(15,0),
			@MarginExcessDeficitTotalSign varchar(1),
			@MarginExcessDeficitTotal decimal(15,0),
			@MarginExcessDeficitCashSign varchar(1),
			@MarginExcessDeficitCash decimal(15,0),
			@StandardMarginAmntInCashSign varchar(1),
			@StandardMarginAmntInCash decimal(15,0),
			@SettlementDate datetime,
			@NextDaySCashFlowSign varchar(1),
			@NextDaySCashFlow decimal(15,0),
			@TheDayAfterNextCashFlowSign varchar(1),
			@TheDayAfterNextCashFlow decimal(15,0),
			@TheDayAfterNextCollateralMovementSign varchar(1),
			@TheDayAfterNextCollateralMovement decimal(15,0)
			)
AS
SET NOCOUNT ON

SET NOCOUNT OFF


	DECLARE	@CalculationDateStartTime												DATETIME
	
	DECLARE @FinalCashBalanceofPreviousDaySigned									DECIMAL(15,0)
	DECLARE	@PreviousDaySReportedCashBalanceSigned 									DECIMAL(15,0)
	--DECLARE @AdjustmentFPDAmountSigned 												DECIMAL(15,0)
	DECLARE @AdjustmentFPDFuturesRealizedPLSigned									DECIMAL(15,0) 
	DECLARE @AdjustmentFPDOptionsPremiumAmountBuySigned								DECIMAL(15,0) 
	DECLARE @AdjustmentFPDOptionsPremiumAmountSellSigned 							DECIMAL(15,0)
	DECLARE	@AdjustmentFPDNetStrikePriceForExerciseSigned 							DECIMAL(15,0)
	DECLARE @AdjustmentFPDNetStrikePriceForAllotmentSigned							DECIMAL(15,0) 
	DECLARE @AdjustmentFPDDomesticCommissionSigned									DECIMAL(15,0) 
	DECLARE @AdjustmentFPDConsumptionTaxOnCommissionSigned							DECIMAL(15,0) 
	DECLARE @AdjustmentFPDExchangeTaxSigned											DECIMAL(15,0) 
	DECLARE @AdjustmentFPDCashFlowSigned											DECIMAL(15,0)				 
	DECLARE	@AdjustmentFPDTradeSigned												DECIMAL(15,0)
	DECLARE @CashPaidReceivedSigned													DECIMAL(15,0) 
	DECLARE @EndingCashBalanceSigned												DECIMAL(15,0) 
	DECLARE @SettlementAmountFCDTradingSigned										DECIMAL(15,0) 
	DECLARE @FuturesRealizedPLOTDSigned 											DECIMAL(15,0)
	DECLARE @OptPremiumOTDBuySigned													DECIMAL(15,0) 
	DECLARE @OptPremiumOTDSellSigned 												DECIMAL(15,0)
	DECLARE @NetStrikePOTDOptExerciseSigned											DECIMAL(15,0)
	DECLARE @NetStrikePOTDOptAssignmentSigned										DECIMAL(15,0)
	DECLARE @DomesticCommissionOTDSigned   											DECIMAL(15,0)
	DECLARE @ConsumptionTaxOnCommissionOTDSigned									DECIMAL(15,0) 
	DECLARE @ExchangeTaxOTDSigned 													DECIMAL(15,0)
	DECLARE @ReportedCashBalanceOTDSigned											DECIMAL(15,0)
	DECLARE @UnrealizedPLSigned														DECIMAL(15,0)
	DECLARE @TotalMarginMoneySigned													DECIMAL(15,0)
	DECLARE @NextDayCollateralMovementDirectDepositToMemberFirmSigned				DECIMAL(15,0)
	DECLARE @NextDayCollateralMovementReplacementDepositSigned						DECIMAL(15,0)
	DECLARE @NextDayCollateralMovementTotalSigned									DECIMAL(15,0)
	DECLARE @TotalAmntOfMarginSigned												DECIMAL(15,0)
	DECLARE @MarginExcessDeficitTotalSigned											DECIMAL(15,0)
	DECLARE @MarginExcessDeficitCashSigned											DECIMAL(15,0)
	DECLARE @StandardMarginAmntInCashSigned											DECIMAL(15,0)
	DECLARE @NextDaySCashFlowSigned													DECIMAL(15,0)
	DECLARE @TheDayAfterNextCashFlowSigned											DECIMAL(15,0)
	DECLARE @TheDayAfterNextCollateralMovementSigned								DECIMAL(15,0)             
	DECLARE @SettlementAmntOfThePreviousDaySTradeSigned								DECIMAL(15,0)

	IF @BaseDate = ''01/01/1900 00:00:00'' 
		SET @BaseDate = NULL

	IF @CalculationDate = ''01/01/1900 00:00:00'' 
		SET @CalculationDate = NULL

	IF @CalculationStartTime = ''01/01/1900 00:00:00'' 
		SET @CalculationStartTime = NULL

	IF @SettlementDate = ''01/01/1900 00:00:00'' 
		SET @SettlementDate = NULL

	IF @FinalCashBalanceofPreviousDaySign = ''-'' 	
		SET @FinalCashBalanceofPreviousDaySigned = @FinalCashBalanceofPreviousDay * -1 
	ELSE	
		SET @FinalCashBalanceofPreviousDaySigned = @FinalCashBalanceofPreviousDay

	IF @PreviousDaySReportedCashBalanceSign = ''-'' 	
		SET @PreviousDaySReportedCashBalanceSigned = @PreviousDaySReportedCashBalance * -1 
	ELSE	
		SET @PreviousDaySReportedCashBalanceSigned = @PreviousDaySReportedCashBalance

	/*IF @AdjustmentFPDAmountSign  = ''-'' 	
		SET @AdjustmentFPDAmountSigned  = @AdjustmentFPDAmount  * -1 
	ELSE	
		SET @AdjustmentFPDAmountSigned  = @AdjustmentFPDAmount 
	*/
	IF @AdjustmentFPDFuturesRealizedPLSign = ''-'' 	
		SET @AdjustmentFPDFuturesRealizedPLSigned = @AdjustmentFPDFuturesRealizedPL * -1 
	ELSE	
		SET @AdjustmentFPDFuturesRealizedPLSigned = @AdjustmentFPDFuturesRealizedPL

	IF @AdjustmentFPDOptionsPremiumAmountBuySign = ''-'' 	
		SET @AdjustmentFPDOptionsPremiumAmountBuySigned = @AdjustmentFPDOptionsPremiumAmountBuy * -1 
	ELSE	
		SET @AdjustmentFPDOptionsPremiumAmountBuySigned = @AdjustmentFPDOptionsPremiumAmountBuy

	IF @AdjustmentFPDOptionsPremiumAmountSellSign = ''-'' 	
		SET @AdjustmentFPDOptionsPremiumAmountSellSigned = @AdjustmentFPDOptionsPremiumAmountSell * -1 
	ELSE	
		SET @AdjustmentFPDOptionsPremiumAmountSellSigned = @AdjustmentFPDOptionsPremiumAmountSell

	IF @AdjustmentFPDNetStrikePriceForExerciseSign = ''-'' 	
		SET @AdjustmentFPDNetStrikePriceForExerciseSigned = @AdjustmentFPDNetStrikePriceForExercise * -1 
	ELSE	
		SET @AdjustmentFPDNetStrikePriceForExerciseSigned = @AdjustmentFPDNetStrikePriceForExercise

	IF @AdjustmentFPDNetStrikePriceForAllotmentSign = ''-'' 	
		SET @AdjustmentFPDNetStrikePriceForAllotmentSigned = @AdjustmentFPDNetStrikePriceForAllotment * -1 
	ELSE	
		SET @AdjustmentFPDNetStrikePriceForAllotmentSigned = @AdjustmentFPDNetStrikePriceForAllotment

	IF @AdjustmentFPDDomesticCommissionSign= ''-'' 	
		SET @AdjustmentFPDDomesticCommissionSigned = @AdjustmentFPDDomesticCommission * -1 
	ELSE	
		SET @AdjustmentFPDDomesticCommissionSigned = @AdjustmentFPDDomesticCommission

	IF @AdjustmentFPDConsumptionTaxOnCommissionSign = ''-'' 	
		SET @AdjustmentFPDConsumptionTaxOnCommissionSigned = @AdjustmentFPDConsumptionTaxOnCommission * -1 
	ELSE	
		SET @AdjustmentFPDConsumptionTaxOnCommissionSigned = @AdjustmentFPDConsumptionTaxOnCommission

	IF @AdjustmentFPDExchangeTaxSign = ''-'' 	
		SET @AdjustmentFPDExchangeTaxSigned = @AdjustmentFPDExchangeTax * -1 
	ELSE	
		SET @AdjustmentFPDExchangeTaxSigned = @AdjustmentFPDExchangeTax

	IF @AdjustmentFPDTradeSign = ''-''
		SET @AdjustmentFPDTradeSigned = @AdjustmentFPDTrade * -1
	ELSE
		SET	@AdjustmentFPDTradeSigned = @AdjustmentFPDTrade

	IF @CashPaidReceivedSign = ''-'' 	
		SET @CashPaidReceivedSigned = @CashPaidReceived * -1 
	ELSE	
		SET @CashPaidReceivedSigned = @CashPaidReceived

	IF @CashPaidReceivedSign = ''-'' 	
		SET @CashPaidReceivedSigned = @CashPaidReceived * -1 
	ELSE	
		SET @CashPaidReceivedSigned = @CashPaidReceived
	
	IF @EndingCashBalanceSign = ''-'' 	
		SET @EndingCashBalanceSigned = @EndingCashBalance * -1 
	ELSE	
		SET @EndingCashBalanceSigned = @EndingCashBalance

	IF @SettlementAmountFCDTradingSign = ''-'' 	
		SET @SettlementAmountFCDTradingSigned = @SettlementAmountFCDTrading * -1 
	ELSE	
		SET @SettlementAmountFCDTradingSigned = @SettlementAmountFCDTrading

	IF @FuturesRealizedPLOTDSign = ''-'' 	
		SET @FuturesRealizedPLOTDSigned = @FuturesRealizedPLOTD * -1 
	ELSE	
		SET @FuturesRealizedPLOTDSigned = @FuturesRealizedPLOTD

	IF @OptPremiumOTDBuySign = ''-'' 	
		SET @OptPremiumOTDBuySigned = @OptPremiumOTDBuy * -1 
	ELSE	
		SET @OptPremiumOTDBuySigned = @OptPremiumOTDBuy

	IF @OptPremiumOTDSellSign = ''-'' 	
		SET @OptPremiumOTDSellSigned = @OptPremiumOTDSell * -1 
	ELSE	
		SET @OptPremiumOTDSellSigned = @OptPremiumOTDSell

	IF @NetStrikePOTDOptExerciseSign = ''-'' 	
		SET @NetStrikePOTDOptExerciseSigned = @NetStrikePOTDOptExercise * -1 
	ELSE	
		SET @NetStrikePOTDOptExerciseSigned = @NetStrikePOTDOptExercise

	IF @NetStrikePOTDOptAssignmentSign = ''-'' 	
		SET @NetStrikePOTDOptAssignmentSigned = @NetStrikePOTDOptAssignment * -1 
	ELSE	
		SET @NetStrikePOTDOptAssignmentSigned = @NetStrikePOTDOptAssignment

	IF @DomesticCommissionOTDSign = ''-'' 	
		SET @DomesticCommissionOTDSigned = @DomesticCommissionOTD * -1 
	ELSE	
		SET @DomesticCommissionOTDSigned = @DomesticCommissionOTD

	IF @ConsumptionTaxOnCommissionOTDSign = ''-'' 	
		SET @ConsumptionTaxOnCommissionOTDSigned = @ConsumptionTaxOnCommissionOTD * -1 
	ELSE	
		SET @ConsumptionTaxOnCommissionOTDSigned = @ConsumptionTaxOnCommissionOTD

	IF @ExchangeTaxOTDSign = ''-'' 	
		SET @ExchangeTaxOTDSigned = @ExchangeTaxOTD * -1 
	ELSE	
		SET @ExchangeTaxOTDSigned = @ExchangeTaxOTD

	IF @ReportedCashBalanceOTDSign = ''-'' 	
		SET @ReportedCashBalanceOTDSigned = @ReportedCashBalanceOTD * -1 
	ELSE	
		SET @ReportedCashBalanceOTDSigned = @ReportedCashBalanceOTD

	IF @UnrealizedPLSign = ''-'' 	
		SET @UnrealizedPLSigned = @UnrealizedPL * -1 
	ELSE	
		SET @UnrealizedPLSigned = @UnrealizedPL

	IF @TotalMarginMoneySign = ''-'' 	
		SET @TotalMarginMoneySigned = @TotalMarginMoney * -1 
	ELSE	
		SET @TotalMarginMoneySigned = @TotalMarginMoney

	IF @NextDayCollateralMovementSignDirectDepositToMemberFirm = ''-'' 	
		SET @NextDayCollateralMovementDirectDepositToMemberFirmSigned = @NextDayCollateralMovementDirectDepositToMemberFirm * -1 
	ELSE	
		SET @NextDayCollateralMovementDirectDepositToMemberFirmSigned = @NextDayCollateralMovementDirectDepositToMemberFirm

	IF @NextDayCollateralMovementSignReplacementDeposit = ''-'' 	
		SET @NextDayCollateralMovementReplacementDepositSigned = @NextDayCollateralMovementReplacementDeposit * -1 
	ELSE	
		SET @NextDayCollateralMovementReplacementDepositSigned = @NextDayCollateralMovementReplacementDeposit

	IF @NextDayCollateralMovementTotalSign = ''-'' 	
		SET @NextDayCollateralMovementTotalSigned = @NextDayCollateralMovementTotal * -1 
	ELSE	
		SET @NextDayCollateralMovementTotalSigned = @NextDayCollateralMovementTotal

	IF @TotalAmntOfMarginSign = ''-'' 	
		SET @TotalAmntOfMarginSigned = @TotalAmntOfMargin * -1 
	ELSE	
		SET @TotalAmntOfMarginSigned = @TotalAmntOfMargin

	IF @MarginExcessDeficitTotalSign = ''-'' 	
		SET @MarginExcessDeficitTotalSigned = @MarginExcessDeficitTotal * -1 
	ELSE	
		SET @MarginExcessDeficitTotalSigned = @MarginExcessDeficitTotal

	IF @MarginExcessDeficitCashSign = ''-'' 	
		SET @MarginExcessDeficitCashSigned = @MarginExcessDeficitCash * -1 
	ELSE	
		SET @MarginExcessDeficitCashSigned = @MarginExcessDeficitCash

	IF @StandardMarginAmntInCashSign = ''-'' 	
		SET @StandardMarginAmntInCashSigned = @StandardMarginAmntInCash * -1 
	ELSE	
		SET @StandardMarginAmntInCashSigned = @StandardMarginAmntInCash

	IF @NextDaySCashFlowSign = ''-'' 	
		SET @NextDaySCashFlowSigned = @NextDaySCashFlow * -1 
	ELSE	
		SET @NextDaySCashFlowSigned = @NextDaySCashFlow

	IF @TheDayAfterNextCashFlowSign = ''-'' 	
		SET @TheDayAfterNextCashFlowSigned = @TheDayAfterNextCashFlow * -1 
	ELSE	
		SET @TheDayAfterNextCashFlowSigned = @TheDayAfterNextCashFlow

	IF @TheDayAfterNextCollateralMovementSign = ''-'' 	
		SET @TheDayAfterNextCollateralMovementSigned = @TheDayAfterNextCollateralMovement * -1 
	ELSE	
		SET @TheDayAfterNextCollateralMovementSigned = @TheDayAfterNextCollateralMovement

	IF @SettlementAmntOfThePreviousDaySTradeSign = ''-'' 	
		SET @SettlementAmntOfThePreviousDaySTradeSigned = @SettlementAmntOfThePreviousDaySTrade * -1 
	ELSE	
		SET @SettlementAmntOfThePreviousDaySTradeSigned = @SettlementAmntOfThePreviousDaySTrade


	--raiserror (''problem'', 19, 1) with log

	SET @CalculationDateStartTime = CONVERT(DATETIME,CONVERT(VARCHAR(12), CONVERT(DATETIME,@CalculationDate,112)) + '' '' + CONVERT(VARCHAR(8),RIGHT(@CalculationStartTime,8)))




	INSERT INTO [dbo].[is_HAccountTotal]
		   (
				[CorporationCode]
			   ,[PrincipalBrokerageId]
			   ,[OfficeCode]
			   ,[ACNo]
			   ,[SecuritiesId]
			   ,[BaseDate]
			   ,[CalculationDate]
			   ,[CalculationStartTime]
			   ,[CalculationDateStartTime]
			   ,[FinalCashBalanceofPreviousDaySign]
			   ,[FinalCashBalanceofPreviousDay]
			   ,[FinalCashBalanceofPreviousDaySigned]
			   ,[SettlementAmntOfThePreviousDaySTradeSign]
			   ,[SettlementAmntOfThePreviousDaySTrade]
			   ,[SettlementAmntOfThePreviousDaySTradeSigned]
			   ,[PreviousDaySReportedCashBalanceSign]
			   ,[PreviousDaySReportedCashBalance]
			   ,[PreviousDaySReportedCashBalanceSigned]
			   --,[AdjustmentFPDAmountSign]
			   --,[AdjustmentFPDAmount]
			   --,[AdjustmentFPDAmountSigned]
			   ,[AdjustmentFPDFuturesRealizedPLSign]
			   ,[AdjustmentFPDFuturesRealizedPL]
			   ,[AdjustmentFPDFuturesRealizedPLSigned]
			   ,[AdjustmentFPDOptionsPremiumAmountBuySign]
			   ,[AdjustmentFPDOptionsPremiumAmountBuy]
			   ,[AdjustmentFPDOptionsPremiumAmountBuySigned]
			   ,[AdjustmentFPDOptionsPremiumAmountSellSign]
			   ,[AdjustmentFPDOptionsPremiumAmountSell]
			   ,[AdjustmentFPDOptionsPremiumAmountSellSigned]
			   ,[AdjustmentFPDNetStrikePriceForExerciseSign]
			   ,[AdjustmentFPDNetStrikePriceForExercise]
			   ,[AdjustmentFPDNetStrikePriceForExerciseSigned]
			   ,[AdjustmentFPDNetStrikePriceForAllotmentSign]
			   ,[AdjustmentFPDNetStrikePriceForAllotment]
			   ,[AdjustmentFPDNetStrikePriceForAllotmentSigned]
			   ,[AdjustmentFPDDomesticCommissionSign]
			   ,[AdjustmentFPDDomesticCommission]
			   ,[AdjustmentFPDDomesticCommissionSigned]
			   ,[AdjustmentFPDConsumptionTaxOnCommissionSign]
			   ,[AdjustmentFPDConsumptionTaxOnCommission]
			   ,[AdjustmentFPDConsumptionTaxOnCommissionSigned]
			   ,[AdjustmentFPDExchangeTaxSign]
			   ,[AdjustmentFPDExchangeTax]
			   ,[AdjustmentFPDExchangeTaxSigned]
			   ,[AdjustmentFPDTradeSign]
			   ,[AdjustmentFPDTrade]
			   ,[AdjustmentFPDTradeSigned]		 	
			   ,[AdjustmentFPDCashFlowSign]
			   ,[AdjustmentFPDCashFlow]
			   ,[AdjustmentFPDCashFlowSigned]
			   ,[CashPaidReceivedSign]
			   ,[CashPaidReceived]
			   ,[CashPaidReceivedSigned]
			   ,[EndingCashBalanceSign]
			   ,[EndingCashBalance]
			   ,[EndingCashBalanceSigned]
			   ,[SettlementAmountFCDTradingSign]
			   ,[SettlementAmountFCDTrading]
			   ,[SettlementAmountFCDTradingSigned]
			   ,[FuturesRealizedPLOTDSign]
			   ,[FuturesRealizedPLOTD]
			   ,[FuturesRealizedPLOTDSigned]
			   ,[OptPremiumOTDBuySign]
			   ,[OptPremiumOTDBuy]
			   ,[OptPremiumOTDBuySigned]
			   ,[OptPremiumOTDSellSign]
			   ,[OptPremiumOTDSell]
			   ,[OptPremiumOTDSellSigned]
			   ,[NetStrikePOTDOptExerciseSign]
			   ,[NetStrikePOTDOptExercise]
			   ,[NetStrikePOTDOptExerciseSigned]
			   ,[NetStrikePOTDOptAssignmentSign]
			   ,[NetStrikePOTDOptAssignment]
			   ,[NetStrikePOTDOptAssignmentSigned]
			   ,[DomesticCommissionOTDSign]
			   ,[DomesticCommissionOTD]
			   ,[DomesticCommissionOTDSigned]
			   ,[ConsumptionTaxOnCommissionOTDSign]
			   ,[ConsumptionTaxOnCommissionOTD]
			   ,[ConsumptionTaxOnCommissionOTDSigned]
			   ,[ExchangeTaxOTDSign]
			   ,[ExchangeTaxOTD]
			   ,[ExchangeTaxOTDSigned]
			   ,[ReportedCashBalanceOTDSign]
			   ,[ReportedCashBalanceOTD]
			   ,[ReportedCashBalanceOTDSigned]
			   ,[UnrealizedPLSign]
			   ,[UnrealizedPL]
			   ,[UnrealizedPLSigned]
			   ,[MarketValueNonCalculableFlag]
			   ,[TotalMarginMoneySign]
			   ,[TotalMarginMoney]
			   ,[TotalMarginMoneySigned]
			   ,[PresentCollateralBalanceDirectDepositToTiffe]
			   ,[PresentCollateralBalanceDirectDepositToMemberFirm]
			   ,[PresentCollateralBalanceReplacementDeposit]
			   ,[PresentCollateralBalanceTotal]
			   ,[NextDayCollateralMovementSignDirectDepositToTiffe]
			   ,[NextDayCollateralMovementDirectDepositTo]
			   ,[NextDayCollateralMovementSignDirectDepositToMemberFirm]
			   ,[NextDayCollateralMovementDirectDepositToMemberFirm]
			   ,[NextDayCollateralMovementDirectDepositToMemberFirmSigned]
			   ,[NextDayCollateralMovementSignReplacementDeposit]
			   ,[NextDayCollateralMovementReplacementDeposit]
			   ,[NextDayCollateralMovementReplacementDepositSigned]
			   ,[NextDayCollateralMovementTotalSign]
			   ,[NextDayCollateralMovementTotal]
			   ,[NextDayCollateralMovementTotalSigned]
			   ,[CollateralEvaluationNonCalculableFlagTotal]
			   ,[TotalAmntOfMarginSign]
			   ,[TotalAmntOfMargin]
			   ,[TotalAmntOfMarginSigned]
			   ,[MarginRequirement]
			   ,[MarginRequirementNonCalculableFlag]
			   ,[NewContractFlag]
			   ,[BuyOptValue]
			   ,[SellOptValue]
			   ,[MarginExcessDeficitTotalSign]
			   ,[MarginExcessDeficitTotal]
			   ,[MarginExcessDeficitTotalSigned]
			   ,[MarginExcessDeficitCashSign]
			   ,[MarginExcessDeficitCash]
			   ,[MarginExcessDeficitCashSigned]
			   ,[StandardMarginAmntInCashSign]
			   ,[StandardMarginAmntInCash]
			   ,[StandardMarginAmntInCashSigned]
			   ,[SettlementDate]
			   ,[NextDaySCashFlowSign]
			   ,[NextDaySCashFlow]
			   ,[NextDaySCashFlowSigned]
			   ,[TheDayAfterNextCashFlowSign]
			   ,[TheDayAfterNextCashFlow]
			   ,[TheDayAfterNextCashFlowSigned]
			   ,[TheDayAfterNextCollateralMovementSign]
			   ,[TheDayAfterNextCollateralMovement]
			   ,[TheDayAfterNextCollateralMovementSigned]
			)
		 VALUES
			(	
				@CorporationCode,
				@PrincipalBrokerageId,
				@OfficeCode,
				@ACNo,
				@SecuritiesId,
				@BaseDate,
				@CalculationDate,
				@CalculationStartTime,
				@CalculationDateStartTime,
				@FinalCashBalanceofPreviousDaySign,
				@FinalCashBalanceofPreviousDay,
				@FinalCashBalanceofPreviousDaySigned,
				@SettlementAmntOfThePreviousDaySTradeSign,
				@SettlementAmntOfThePreviousDaySTrade,
				@SettlementAmntOfThePreviousDaySTradeSigned,
				@PreviousDaySReportedCashBalanceSign,
				@PreviousDaySReportedCashBalance,
				@PreviousDaySReportedCashBalanceSigned,
				--@AdjustmentFPDAmountSign,
				--@AdjustmentFPDAmount,
				--@AdjustmentFPDAmountSigned,
				@AdjustmentFPDFuturesRealizedPLSign,
				@AdjustmentFPDFuturesRealizedPL,
				@AdjustmentFPDFuturesRealizedPLSigned,
				@AdjustmentFPDOptionsPremiumAmountBuySign,
				@AdjustmentFPDOptionsPremiumAmountBuy,
				@AdjustmentFPDOptionsPremiumAmountBuySigned,
				@AdjustmentFPDOptionsPremiumAmountSellSign,
				@AdjustmentFPDOptionsPremiumAmountSell,
				@AdjustmentFPDOptionsPremiumAmountSellSigned,
				@AdjustmentFPDNetStrikePriceForExerciseSign,
				@AdjustmentFPDNetStrikePriceForExercise,
				@AdjustmentFPDNetStrikePriceForExerciseSigned,
				@AdjustmentFPDNetStrikePriceForAllotmentSign,
				@AdjustmentFPDNetStrikePriceForAllotment,
				@AdjustmentFPDNetStrikePriceForAllotmentSigned,
				@AdjustmentFPDDomesticCommissionSign,
				@AdjustmentFPDDomesticCommission,
				@AdjustmentFPDDomesticCommissionSigned,
				@AdjustmentFPDConsumptionTaxOnCommissionSign,
				@AdjustmentFPDConsumptionTaxOnCommission,
				@AdjustmentFPDConsumptionTaxOnCommissionSigned,
				@AdjustmentFPDExchangeTaxSign,
				@AdjustmentFPDExchangeTax,
				@AdjustmentFPDExchangeTaxSigned,
				@AdjustmentFPDCashFlowSign,
				@AdjustmentFPDCashFlow,
				@AdjustmentFPDCashFlowSigned,
				@AdjustmentFPDTradeSign,
				@AdjustmentFPDTrade,
				@AdjustmentFPDTradeSigned,
				@CashPaidReceivedSign,
				@CashPaidReceived,
				@CashPaidReceivedSigned,
				@EndingCashBalanceSign,
				@EndingCashBalance,
				@EndingCashBalanceSigned,
				@SettlementAmountFCDTradingSign,
				@SettlementAmountFCDTrading,
				@SettlementAmountFCDTradingSigned,
				@FuturesRealizedPLOTDSign,
				@FuturesRealizedPLOTD,
				@FuturesRealizedPLOTDSigned,
				@OptPremiumOTDBuySign,
				@OptPremiumOTDBuy,
				@OptPremiumOTDBuySigned,
				@OptPremiumOTDSellSign,
				@OptPremiumOTDSell,
				@OptPremiumOTDSellSigned,
				@NetStrikePOTDOptExerciseSign,
				@NetStrikePOTDOptExercise,
				@NetStrikePOTDOptExerciseSigned,
				@NetStrikePOTDOptAssignmentSign,
				@NetStrikePOTDOptAssignment,
				@NetStrikePOTDOptAssignmentSigned,
				@DomesticCommissionOTDSign,
				@DomesticCommissionOTD,
				@DomesticCommissionOTDSigned,
				@ConsumptionTaxOnCommissionOTDSign,
				@ConsumptionTaxOnCommissionOTD,
				@ConsumptionTaxOnCommissionOTDSigned,
				@ExchangeTaxOTDSign,
				@ExchangeTaxOTD,
				@ExchangeTaxOTDSigned,
				@ReportedCashBalanceOTDSign,
				@ReportedCashBalanceOTD,
				@ReportedCashBalanceOTDSigned,
				@UnrealizedPLSign,
				@UnrealizedPL,
				@UnrealizedPLSigned,
				@MarketValueNonCalculableFlag,
				@TotalMarginMoneySign,
				@TotalMarginMoney,
				@TotalMarginMoneySigned,
				@PresentCollateralBalanceDirectDepositToTiffe,
				@PresentCollateralBalanceDirectDepositToMemberFirm,
				@PresentCollateralBalanceReplacementDeposit,
				@PresentCollateralBalanceTotal,
				@NextDayCollateralMovementSignDirectDepositToTiffe,
				@NextDayCollateralMovementDirectDepositTo,
				@NextDayCollateralMovementSignDirectDepositToMemberFirm,
				@NextDayCollateralMovementDirectDepositToMemberFirm,
				@NextDayCollateralMovementDirectDepositToMemberFirmSigned,
				@NextDayCollateralMovementSignReplacementDeposit,
				@NextDayCollateralMovementReplacementDeposit,
				@NextDayCollateralMovementReplacementDepositSigned,
				@NextDayCollateralMovementTotalSign,
				@NextDayCollateralMovementTotal,
				@NextDayCollateralMovementTotalSigned,
				@CollateralEvaluationNonCalculableFlagTotal,
				@TotalAmntOfMarginSign,
				@TotalAmntOfMargin,
				@TotalAmntOfMarginSigned,
				@MarginRequirement,
				@MarginRequirementNonCalculableFlag,
				@NewContractFlag,
				@BuyOptValue,
				@SellOptValue,
				@MarginExcessDeficitTotalSign,
				@MarginExcessDeficitTotal,
				@MarginExcessDeficitTotalSigned,
				@MarginExcessDeficitCashSign,
				@MarginExcessDeficitCash,
				@MarginExcessDeficitCashSigned,
				@StandardMarginAmntInCashSign,
				@StandardMarginAmntInCash,
				@StandardMarginAmntInCashSigned,
				@SettlementDate,
				@NextDaySCashFlowSign,
				@NextDaySCashFlow,
				@NextDaySCashFlowSigned,
				@TheDayAfterNextCashFlowSign,
				@TheDayAfterNextCashFlow,
				@TheDayAfterNextCashFlowSigned,
				@TheDayAfterNextCollateralMovementSign,
				@TheDayAfterNextCollateralMovement,
				@TheDayAfterNextCollateralMovementSigned
			)


RETURN Scope_Identity()
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Rule_GetMatchCodesSortableAndPaginate]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Rule_GetMatchCodesSortableAndPaginate]
	@firmId int = -1, 
	@currencyId int = -1,
	@ruleId int,
	@@OrderBy VARCHAR(100) = NULL,
	@@StartRowIndex INT = NULL,
	@@MaximumRows INT = NULL
AS
SET NOCOUNT ON
	DECLARE @templateId INT
	
	SELECT @templateId = TemplateId FROM ib_Rule WHERE RuleId = @ruleId
	
DECLARE @sql NVARCHAR(MAX)
SET @sql = ''
SELECT DISTINCT
	MC.MatchCode,
	MC.MatchCodeId,
	CAST(CASE WHEN RMC.RuleMatchCodeId IS NULL THEN 0 ELSE 1 END AS BIT) AS Included
FROM
	ib_MatchCode MC
INNER JOIN
	ib_TemplateGroup TG ON TG.Description = MC.MatchCode
''

IF (@currencyId > -1)
	SET @sql = @sql + ''
	AND
	CurrencyId = ''+CAST(@currencyId AS NVARCHAR(50))
	
IF (@firmId > -1)
	SET @sql = @sql + ''
	AND
	FirmId = ''+CAST(@firmId AS NVARCHAR(50))+''
	''
SET @sql = @sql + ''
INNER JOIN
	ib_Rule R ON R.TemplateId = TG.TemplateId AND R.RuleId = '' + CAST(@ruleId AS NVARCHAR(50))
SET @sql = @sql + ''	
LEFT OUTER JOIN
	ib_RuleMatchCode RMC ON RMC.MatchCodeId = MC.MatchCodeId
	AND 
	RMC.RuleId = '' + CAST(@ruleId AS NVARCHAR(50))

PRINT @sql
EXEC sp_executesql @sql
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Instrument_GetInstumentNamessHintByKeyword]''
');

GO
EXECUTE ('/*
<details>
 <summary> Returns the instruments hint for a specific code /summary>
 <created author="Laurentiu Macovei" Date="Thursday, 16 August 2006 20:31 GMT" /> 
 <tasks>
 </tasks>
</details>
-- 13 May 2014  ED  EIB 25499 - add IsActive flag to ib_Instrument
*/
create PROCEDURE [dbo].[ib_Instrument_GetInstumentNamessHintByKeyword]
@Instrument varchar(100),
@HintLength int = 1
AS
SET NOCOUNT ON

DECLARE @len int
SET @len = LEN(@Instrument)
SELECT DISTINCT SUBSTRING ([Name], PATINDEX(''%''+@Instrument+''%'', [Name]) + @len, @HintLength ) x
	FROM [dbo].[ib_Instrument]
	WHERE [Name] LIKE ''%''+@Instrument+''%'' AND IsActive = 1
	ORDER BY x DESC
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Trx_WithIds_Load]''
');

GO
EXECUTE ('/*
Programmer:  Konrad
Date: 09/07/2009

Loads Transactions and has some parameters as Id''s

Revision History

16/07/2009	AAJM	Added DetailAccountId - see MBAL-12454
28/07/2009	AAJM	Added QuantityLong and QuantityShort - see MBAL-12623
23/04/2010	amk		MBAL-15240: more decimals for price
09 Jan 2014 ED      EIB 25004 - remove importLog table and use Log table
17 Apr 2014 ED      EIB 25498 - log exchange not found as warning
24 Jun 2014 ED      EIB 25764 - add UTI
*/
CREATE proc [dbo].[ib_Trx_WithIds_Load]

	@DataSourceId		int,
	@ExchangeCd			varchar(25),
	@FirmId				int,
	@AccountId			int,
	@DetailAccountId	int,
	@InstrumentId		int,
	@ExpYr				smallint,
	@ExpMth				smallint,
	@ExpDay				smallint,
	@StrikePrice		decimal(19,4),
	@TrxTypeCd			varchar(25),
	@OptionTypeCd		varchar(25),
	@Quantity			decimal(19,4),
	@TrxDate			datetime,
	@Price				decimal(24,10),
	@TempTableRecordId	int,
	@InstrumentTypeId	int,
	@AsOfDate			datetime,
	@LocationPath		varchar(100) = NULL,
	@MarketValue		decimal(19,4) = NULL,
	@CurrencyId			int = NULL, 
	@ClassId			int = NULL,
	@TrxId				int = NULL	Output,
	@QuantityLong		int = NULL,
	@QuantityShort		int = NULL,
	@ReceiveLocationSysId   INT,
	@RunId                  INT,
	@UTI                    VARCHAR(100) = NULL
	
as
SET NOCOUNT ON

	declare @ReturnValue int,@OutPut int,@OutPut2 int 
	declare @Code varchar(100)
	
	set @OutPut = null
	declare @ExchangeId int
	set @Code = @ExchangeCd
	exec @ReturnValue = ib_DataSourceExchange_GetByCode @DataSourceId,@Code,@Output output
	set @ExchangeId = @OutPut

	--if no exchange found then quit here.
	if @ExchangeId is null 
		begin
		declare @now datetime
		declare @user varchar(100)
		declare @logmsg varchar(100)
		set @user = suser_sname()
		set @now = getdate()
		set @logmsg = ''Exchange Code Not Found for ib_Trx_Load run for code: '' + ISNULL(@ExchangeCd,'''')

		EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @logmsg, ''Warning'', @TempTableRecordId, @RunId

		end
	else
		begin
		
		--now inserting into the ib_Trx table.
		exec ib_Trx_Add @DataSourceId,@ExchangeId,@FirmId,@AccountId,@DetailAccountId,@TrxDate,@AsOfDate,@InstrumentId,@Quantity,@CurrencyId,@Price,@ExpYr,@ExpMth,@ExpDay,@StrikePrice,@TrxTypeCd,@OptionTypeCd,@TempTableRecordId,null, null, @MarketValue, @ClassId, @TrxId Output, @QuantityLong, @QuantityShort, @UTI

		end
');

GO
EXECUTE ('PRINT N''Creating [dbo].[BancoSantander_HOSTTRN]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[BancoSantander_HOSTTRN]
(
[BancoSantander_HOSTTRNID] [int] NOT NULL IDENTITY(1, 1),
[Type] [varchar] (3) NULL,
[Serial] [varchar] (5) NULL,
[Ledger] [varchar] (7) NULL,
[FASCurrency] [varchar] (3) NULL,
[Currency] [varchar] (3) NULL,
[BaseCurrency] [varchar] (3) NULL,
[Market] [varchar] (5) NULL,
[MarketCode] [varchar] (5) NULL,
[DummyField] [varchar] (3) NULL,
[RunDate] [varchar] (8) NULL,
[Serial2] [varchar] (10) NULL,
[PromptDate] [varchar] (8) NULL,
[StrikeShort] [varchar] (21) NULL,
[Strike] [varchar] (21) NULL,
[PutCall] [varchar] (2) NULL,
[Lots] [varchar] (21) NULL,
[Price] [varchar] (21) NULL,
[OpenClose] [varchar] (1) NULL,
[PostingAmount] [varchar] (20) NULL,
[IsMergedTrade] [char] (1) NULL,
[Series] [varchar] (20) NULL,
[FullSeries] [varchar] (20) NULL,
[Premium] [varchar] (20) NULL,
[IsCashSettlingOption] [char] (1) NULL,
[Filename] [varchar] (512) NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_BancoSantander_HOSTTRN_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_BancoSantander_HOSTTRN_CreateDate] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_BancoSantander_HOSTTRN] on [dbo].[BancoSantander_HOSTTRN]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[BancoSantander_HOSTTRN] ADD CONSTRAINT [PK_BancoSantander_HOSTTRN] PRIMARY KEY CLUSTERED  ([BancoSantander_HOSTTRNID])
');

GO
EXECUTE ('PRINT N''Creating index [IX_BancoSantander_HOSTTRN_FileName] on [dbo].[BancoSantander_HOSTTRN]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_BancoSantander_HOSTTRN_FileName] ON [dbo].[BancoSantander_HOSTTRN] ([Filename]) INCLUDE ([BancoSantander_HOSTTRNID], [CreateDate])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_BancoSantander_HOSTTRN_Load]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_BancoSantander_HOSTTRN_Load] 
	(
		@LocationPath VARCHAR(512) = NULL
		,@ReceiveLocationSysId INT
		,@RunId INT
	)
AS
SET NOCOUNT ON

-- Author:		A McLeod
-- Create date: 09 Oct 2012
-- Description:	This stored procedure pulls data from the BancoSantander_HOSTTRN temp
-- table and inserts it into ib_Position
-- Whilst iterating through the records in BancoSantander_HOSTTRN, all 
-- of these inserts are wrapped in a transaction so that any failure causes
-- the changes to not commit.
-- (Copied from RolfeNolan)
--
-- Revision History
-- 02 Jan 2014  RD		MBAL-24931 Added checking file age
-- 09 Jan 2014	ED		EIB 25004 - remove importLog table and use Log table
-- 25 Apr 2014	ED		EIB 25473 - raise error if file is too old and mark temp records as LoadState=3

DECLARE @DefaultStrikePriceDivisor DECIMAL(19,4)
DECLARE @DataSourceCd VARCHAR(100)
DECLARE @ReturnValue INT, @Output INT, @Output2 INT
DECLARE @DefaultCurrencyId INT
DECLARE @DataSourceId INT
DECLARE @FirmCd VARCHAR(100)

SET @FirmCd = ''BZ''
SET @DataSourceCd = ''BZ''

IF @LocationPath IS NULL SET @LocationPath = @DataSourceCd
					
EXEC @ReturnValue= [_ib_DataSource_GetByCodeForOutput] @DataSourceCd, @OutPut OUTPUT, @Output2 OUTPUT
SET @DataSourceId = @Output
SET @DefaultCurrencyId = @Output2	

--Gets the defaultStrikePriceDivisor
SET @DefaultStrikePriceDivisor = [dbo].[udf_GetDefaultStrikePriceDivisor](@DataSourceId, NULL)

-- Duplicate file check										
DECLARE @IsFileAlreadyLoaded INT
EXEC @IsFileALreadyLoaded = HasFileBeenLoaded @LocationPath, @DataSourceId

IF @IsFileAlreadyLoaded = 1
BEGIN
	UPDATE [BancoSantander_HOSTTRN]
	SET [LoadState] = 3
	WHERE [LoadState] = 1
		AND [Filename] = @LocationPath
	
	RETURN
END

-- Store ImportFile record to be associated with Settlement Price load
DECLARE @ImportFileId INT
EXEC ib_ImportFile_Add @DataSourceId, @LocationPath, @ImportFileId OUTPUT
DECLARE @SelectedAsOfDate DATETIME

CREATE TABLE #temp1
	(
		BancoSantander_HOSTTRNID		int,
		[Type]						varchar(3),
		Ledger						varchar(7),
		Currency					varchar(3),
		Market						varchar(5),
		MarketCode					varchar(5),
		RunDate						varchar(8),
		PromptDate					varchar(8),
		Strike						varchar(21),
		PutCall						varchar(2),
		Lots						varchar(21),
		Price						varchar(21),
		OpenClose					varchar(1),
		PostingAmount				VARCHAR(20),
		Premium						VARCHAR(20),
		Serial2						VARCHAR(10)
	)

	INSERT INTO #temp1
	(
		BancoSantander_HOSTTRNID,
		[Type],
		Ledger,
		Currency,
		Market,
		MarketCode,
		RunDate,
		PromptDate,
		Strike,
		PutCall,
		Lots,
		Price,
		OpenClose,
		PostingAmount,
		Premium,
		Serial2
	)
	SELECT 	
		BancoSantander_HOSTTRNID,
		[Type],
		Ledger,
		Currency,
		Market,
		MarketCode,
		RunDate,
		PromptDate,
		Strike,
		PutCall,
		Lots,
		Price,
		OpenClose,
		PostingAmount,
		Premium,
		Serial2
	FROM [BancoSantander_HOSTTRN]
	WHERE LoadState = 1
		AND [Filename] = @LocationPath
		AND (
				([IsMergedTrade] IS NULL OR [IsMergedTrade] = ''N'' OR RTRIM(IsMergedTrade) = '''')
				OR ([IsMergedTrade] = ''Y'' AND RIGHT(rundate, 6) <> LEFT(serial2, 6))
			)
		AND [PromptDate] <> ''99999999'' --KevinP 10 Mar 2010 - Make sure that if the prompt date happens to be 99999999, then skip the record completely

	--rd - make sure the As Of Date is not older than acceptable	
	DECLARE @CheckRunDate DATETIME
	SET @CheckRunDate = (SELECT MIN(CONVERT(DATETIME, RunDate)) AS CheckRunDate FROM #temp1)
	IF (@CheckRunDate IS NOT NULL)
	BEGIN		
		DECLARE @IsAcceptable bit
		EXECUTE [dbo].[Load_IsFileTooOld] @DataSourceId,@LocationPath,@CheckRunDate,@IsAcceptable OUTPUT, @ReceiveLocationSysId, @RunId
		IF (@IsAcceptable = 0)
		BEGIN
			DROP TABLE #temp1
			UPDATE [BancoSantander_HOSTTRN] SET [LoadState] = 3 WHERE [Filename] = @LocationPath
			RAISERROR (''File is too old.'', 18, 0)
			RETURN
		END
	END

	BEGIN TRAN T1

			-- BizTalk''s SQL Adapter uses more restrictive read serializable
			-- so this is necessary to relax it to something that is default
			-- and perfectly acceptable!
			SET TRANSACTION ISOLATION LEVEL READ COMMITTED

			DECLARE @BancoSantander_HOSTTRNID		int
			DECLARE	@Type						varchar(3)
			DECLARE	@Ledger						varchar(7)
			DECLARE	@Currency					varchar(3)
			DECLARE	@Market						varchar(5)
			DECLARE	@MarketCode					varchar(5)
			DECLARE	@RunDate					varchar(8)
			DECLARE	@PromptDate					varchar(8)
			DECLARE	@Strike						varchar(21)
			DECLARE	@PutCall					varchar(2)
			DECLARE	@Lots						varchar(21)
			DECLARE	@Price						varchar(21)
			DECLARE	@OpenClose					varchar(1)
			DECLARE @PostingAmount				VARCHAR(20)
			DECLARE @Premium					VARCHAR(20)
			DECLARE @Serial2					VARCHAR(10)
	
			DECLARE pos_cursor CURSOR FOR
			SELECT	BancoSantander_HOSTTRNID,
					[Type],
					Ledger,
					Currency,
					Market,
					MarketCode,
					RunDate,
					PromptDate,
					Strike,
					PutCall,
					Lots,
					Price,
					OpenClose,
					PostingAmount,
					Premium,
					Serial2
			FROM	#temp1

			OPEN pos_cursor

			FETCH NEXT FROM pos_cursor
			INTO 
					@BancoSantander_HOSTTRNID,
					@Type,
					@Ledger,
					@Currency,
					@Market,
					@MarketCode,
					@RunDate,
					@PromptDate,
					@Strike,
					@PutCall,
					@Lots,
					@Price,
					@OpenClose,
					@PostingAmount,
					@Premium,
					@Serial2

				-- Check @@FETCH_STATUS to see IF there are any more rows to fetch.
				WHILE @@FETCH_STATUS = 0
				BEGIN
					DECLARE		@AccountCd				varchar(100)
					DECLARE		@ExchangeCd				varchar(25)
					DECLARE		@AsOfDate				datetime
					DECLARE		@InstrumentCd			varchar(100)
					DECLARE		@Quantity				decimal(19,4)
					DECLARE		@MarketValue			decimal(19,4)
					DECLARE		@ExpYr					smallint
					DECLARE		@ExpMth					smallint
					DECLARE		@ExpDay					smallint
					DECLARE		@StrikePrice			decimal(19,4)
					DECLARE		@StrikePriceDivisor			decimal(19,4)
					DECLARE		@TrxTypeCd				varchar(25)
					DECLARE		@OptionTypeCd			varchar(25)
					DECLARE		@TrxDate				datetime
					DECLARE		@InstrumentTypeCd		varchar(100)
					DECLARE     @ErrorMessageForRecord	varchar(1024)
					DECLARE     @PriceDec				decimal(24,10)
					-- Temporary variables
                    DECLARE     @TempDate datetime
					DECLARE 	@Code varchar(100), @Code2 varchar(100)
					DECLARE		@TempNumLots				int
					DECLARE		@QuantityLong			int
					DECLARE		@QuantityShort			int
			
			SET @AccountCd = @Ledger
			SET @StrikePrice = NULL
			SET @PriceDec = NULL
            -- TODO Replace the ExchangeCode value constant with a real field value from the Temp Table
			SET	@ExchangeCd = @Market

			SET @TrxTypeCd = @Type

			-- ExpiryDate = PromptDate, PromptDate is in yyyymmdd ISO 112 format
			BEGIN TRY
				SET @TempDate = CONVERT(datetime, @PromptDate, 112)
				SET @ExpYr = DATEPART(yyyy, @TempDate)
				SET @ExpMth = DATEPART(mm, @TempDate)			
				SET @ExpDay = DATEPART(dd, @TempDate)
			END TRY
			BEGIN CATCH
				SET @ErrorMessageForRecord = ERROR_MESSAGE()
				EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @ErrorMessageForRecord, ''Success'', @BancoSantander_HOSTTRNID, @RunId
			END CATCH
				
			IF	@Type = ''001'' OR 
				@Type = ''002'' OR 
				@Type = ''014'' OR 
				@Type = ''018'' OR 
				@Type = ''019'' OR 
				@Type = ''091'' Or 
				@Type = ''005'' OR 
				@Type = ''003'' OR 
				@Type = ''004'' OR 
				@Type = ''020'' OR 
				@Type = ''093'' OR 
				@Type = ''006'' OR 
				@Type = ''007'' OR 
				@Type = ''012'' OR 
				@Type = ''013''
			BEGIN
				IF ISNUMERIC(@Strike) > 0 
				BEGIN
					SET @StrikePrice = CONVERT(decimal(19,4), @Strike)
				END
			END
						
			-- Set the OptionTypeCode - From @PutCall (NULL=Future, TP=Put TC=Call)
			IF @PutCall IS NULL AND (@Type = ''001'' OR @Type = ''002'' Or @Type = ''014'' OR @Type = ''018'' OR @Type = ''019'' OR @Type = ''091'' Or @Type = ''005'')
			   BEGIN
					
					SET @OptionTypeCd = ''Future''
					-- InstrumentTypeCd
					SET @InstrumentTypeCd = ''F''			
			   END
			ELSE IF @PutCall IS NOT NULL AND (@Type = ''003'' OR @Type = ''004'' OR @Type = ''020'' OR @Type = ''093'' OR @Type = ''006'' OR @Type = ''007'' OR @Type = ''012'' OR @Type = ''013'')
				BEGIN
                       
					-- The InstrumentTypeCd value is based on the @PutCall value
					-- We want to make sure that only in the case the @PutCall value is correct we also set the InstrumentTypeCd value
					IF @PutCall = ''TP''
						BEGIN		
							SET @OptionTypeCd = ''P''
							SET @InstrumentTypeCd = ''O''
						END
					ELSE IF @PutCall = ''TC''
						BEGIN	
							SET @OptionTypeCd = ''C''
							SET @InstrumentTypeCd = ''O''
						END
				END
			ELSE
				BEGIN
					-- Log that we''re skipping this record Type
					SET @ErrorMessageForRecord = ''Unable to Work out Put/Call value for RecordType: '' + @Type
					EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @ErrorMessageForRecord, ''Success'', @BancoSantander_HOSTTRNID, @RunId

				END
			
			-- We prefix the Instruments with the IntrumentTypeCode
			SET @InstrumentCd = @InstrumentTypeCd + ''_'' + @Market + ''_'' + @MarketCode

			-- Quantity = Lots
			SET @Quantity = 0
			IF ISNUMERIC(@Lots) > 0 
			BEGIN
				SET @Quantity = CONVERT(decimal(19,4), @Lots)
				
				-- Set QuantityLong and QuantityShort from @Lots
				SET @TempNumLots = CONVERT(int, @Lots)
					
				IF (@TempNumLots >= 0)
					BEGIN
						SET @QuantityLong = @TempNumLots
						SET @QuantityShort = 0
					END
				ELSE
					BEGIN
						SET @QuantityLong = 0
						SET @QuantityShort = ABS(@TempNumLots)
					END						

				IF @Type IN (''002'', ''004'', ''006'', ''013'', ''012'')
				BEGIN
					SET @QuantityLong = @QuantityLong * -1
					SET @QuantityShort = @QuantityShort * -1
				END
				
				IF @Type IN (''012'') --reverse long/shorts
				BEGIN
					DECLARE @TempQnt INT
					SET @TempQnt = @QuantityLong
					SET @QuantityLong = @QuantityShort
					SET @QuantityShort = @TempQnt
				END
			END

			set @Output = null
			declare @InstrumentTypeId int
			set @Code = @InstrumentTypeCd
			exec @ReturnValue = ib_Instrumenttype_AddAsNeeded @DataSourceId,@Code,@OutPut output
			set @InstrumentTypeId = @OutPut
			set @Output = null
			declare @FirmId int
			set @Code = @FirmCd
			exec @ReturnValue= [ib_Firm_AddAsNeeded] @DataSourceId,@Code,@OutPut output	
			set @FirmId = @OutPut
	
			set @Output = null
			set	@OutPut2 = null
			declare @AccountId int
			DECLARE @DetailAccountId INT
			declare @ClassId   int
			set @Code = @AccountCd
			DECLARE @IsImported bit
			SET @IsImported = NULL
			
			exec @ReturnValue= [ib_Account_AddAsNeeded] @Code,@FirmId,@OutPut output,@OutPut2 output, @IsImported = @IsImported OUTPUT
			set @AccountId = @OutPut
			set @ClassId = @OutPut2
			SET @DetailAccountId = @AccountId -- This is OK as @FirmId is correct Marex (R&N)
	
			IF (@IsImported = 1)
			BEGIN
			
				set @Output = null
				declare @CurrencyId int

				if @Currency is not Null
				begin
					exec @ReturnValue = [ib_Currency_AddAsNeeded] @DataSourceId, @Currency, @Output output
					set @CurrencyId = @Output
				end

				set @Output = null
				set @Output2 = null
				declare @InstrumentId int
				set @Code = @InstrumentCd
				exec @ReturnValue= [ib_Instrument_AddAsNeeded] @DataSourceId,@InstrumentTypeId,@Code,@CurrencyId,@Output output,@Output2 output	
				set @InstrumentId = @Output
				if @CurrencyId is null
				begin
					if @Output2 is null
						set @CurrencyId = @DefaultCurrencyId	
					else
						set @CurrencyId = @Output2
				end

				DECLARE	@MarketValueDivisor DECIMAL(19,4)
	
				SELECT @MarketValueDivisor = id.MarketValueDivisor 
				FROM ib_InstrumentDataSource id 
			    WHERE id.InstrumentId = @InstrumentId 
				   AND id.DataSourceId = @DataSourceId 
				   AND id.DataSourceId = @DataSourceId 
				   AND id.CurrencyId = @CurrencyId

				IF @MarketValueDivisor IS NULL OR @MarketValueDivisor = 0
				BEGIN
					SET @MarketValueDivisor = 1
				END

				/* New Code - Begin*/
				DECLARE @Base INT
				DECLARE @BaseId INT
				DECLARE @PriceDivisor DECIMAL(19, 4)
				
				SET @StrikePriceDivisor = NULL
				SET @PriceDivisor = NULL
				SET @Base = NULL
				SET @BaseId = NULL
				
				SELECT @StrikePriceDivisor = ids.StrikePriceDivisor
						, @PriceDivisor = ids.PriceDivisor
						, @Base = b.Base
						, @BaseId = b.BaseId
				FROM [dbo].[ib_InstrumentDataSource] ids
					LEFT OUTER JOIN ib_Base b ON b.BaseId = ids.BaseId
				WHERE ids.DataSourceId = @DataSourceId
					AND ids.DataSourceInstrumentCode = @InstrumentCd 
				
				IF ISNUMERIC(@Price) > 0
				BEGIN
					SET @PriceDec = CONVERT(DECIMAL(24, 10), @Price)
					--apply the 3-4 dp correction
					SET @PriceDec = dbo.PerformCorrections(@PriceDec, @BaseId)
				END
				
				IF @PriceDivisor IS NULL
				BEGIN
					SET @PriceDivisor = 1
				END
				
				--Reset correct price
				IF	@Type = ''001'' OR 
					@Type = ''002'' OR
					@Type = ''014'' OR
					@Type = ''018'' OR 
					@Type = ''019'' OR 
					@Type = ''091''
				BEGIN
					IF(@PriceDec IS NOT NULL)
					BEGIN
						SET @PriceDec = @PriceDec / @PriceDivisor
					END
				END
			
				SET @PriceDec = dbo.udf_ConvertToBase10(@PriceDec, @Base)
			
				IF	@Type = ''001'' OR 
					@Type = ''002'' OR
					@Type = ''018'' OR 
					@Type = ''019'' OR 
					@Type = ''091'' OR
					@Type = ''005'' OR			-- KevinP - Reset the Market Value for 005 Record Types as per conversation with Jeff..
					@Type = ''007''
				BEGIN
					SET @MarketValue = CONVERT(DECIMAL(19,4), @PostingAmount) / @MarketValueDivisor
				END
			
				IF	@Type = ''014'' -- This needs to be the inverse
				BEGIN
					SET @MarketValue = (CONVERT(DECIMAL(19,4), @PostingAmount) * -1) / @MarketValueDivisor
				END
			
				 -- The Market Value is to be derived from the Premium
				IF	@Type = ''006'' OR
					@Type = ''012'' OR 
					@Type = ''013'' OR
					@Type = ''003'' OR 
					@Type = ''004'' OR
					@Type = ''020'' OR 
					@Type = ''093''
				BEGIN
					SET @MarketValue = CONVERT(DECIMAL(19,4), @Premium) / @MarketValueDivisor
				END
			
				IF @Type IN (''004'', ''020'')
					SET @MarketValue = @MarketValue * -1

				IF @Type = ''004'' AND @PriceDec < 0
					SET @PriceDec = @PriceDec * -1
				-- fix price
				IF @Type IN (''006'', ''012'', ''013'')
					SET @PriceDec = 0
				/* New Code - End*/

				IF @StrikePrice IS NOT NULL
				BEGIN
					IF @StrikePriceDivisor IS NULL
					BEGIN
						SET @StrikePrice = @StrikePrice / @DefaultStrikePriceDivisor
					END
					ELSE
					BEGIN
						SET @StrikePrice = @StrikePrice / @StrikePriceDivisor
					END
				END
				
				-- TrxDate (first try serial2 but since not always a date, then go to rundate)
				IF LEN(@Serial2) = 10
					SET @TrxDate = ''20'' + LEFT(@Serial2, 6)
				ELSE
					SET @TrxDate = @RunDate
	
				-- AsOfDate
				SET @AsOfDate = @RunDate
				SET @SelectedAsOfDate = @AsOfDate

				EXEC [ib_Trx_WithIds_Load]
				@DataSourceId,			
				@ExchangeCd,				
				@FirmId,					
				@AccountId,
				@DetailAccountId,				
				@InstrumentId,			
				@ExpYr,					
				@ExpMth,					
				@ExpDay,					
				@StrikePrice,			
				@TrxTypeCd,				
				@OptionTypeCd,
				@Quantity,			
				@TrxDate,				
				@PriceDec,
				@BancoSantander_HOSTTRNID,
				@InstrumentTypeId,
				@AsOfDate,		
				@LocationPath,
				@MarketValue,
				@CurrencyId,
				@ClassId,
				@QuantityLong = @QuantityLong,
				@QuantityShort = @QuantityShort,
				@ReceiveLocationSysId = @ReceiveLocationSysId,
				@RunId = @RunId
				
			END -- IF @IsImported = 1
			
			--flip processed flag in source table.
			UPDATE [BancoSantander_HOSTTRN]
			SET [LoadState] = 2
			WHERE [BancoSantander_HOSTTRNID] = @BancoSantander_HOSTTRNID
				AND [LoadState] = 1

			FETCH NEXT FROM pos_cursor
			INTO 
					@BancoSantander_HOSTTRNID,
					@Type,
					@Ledger,
					@Currency,
					@Market,
					@MarketCode,
					@RunDate,
					@PromptDate,
					@Strike,
					@PutCall,
					@Lots,
					@Price,
					@OpenClose,
					@PostingAmount,
					@Premium,
					@Serial2

		END
			
			CLOSE pos_cursor
			DEALLOCATE pos_cursor
			
			--Update the other records where [IsMergedTrade] may = ''Y'', but haven''t updated their LoadState because they didn''t form part of the SELECT criteria
			--flip processed flag in source table.
			UPDATE [BancoSantander_HOSTTRN]
			SET [LoadState] = 2
			WHERE [FileName] = @LocationPath
				AND [LoadState] = 1

			UPDATE ib_ImportFile 
			SET AsOfDate = CAST(CONVERT(CHAR(10), @SelectedAsOfDate, 101) AS DATETIME)  
			WHERE ImportFileId = @ImportFileId

		COMMIT TRAN T1

	DROP TABLE #temp1
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Report_CreateReport]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Report_CreateReport]
	@ReportType VARCHAR(100)
	, @CreateUserName VARCHAR(50)
	, @UserId UNIQUEIDENTIFIER
	, @@ReportId INT OUTPUT
	, @Notes VARCHAR(255) = NULL
	, @TemplateId INT = NULL
AS
SET NOCOUNT ON

	--	Description: Inserts a new record in the ib_Report in the default status/stage

	--	04 Aug 2006		LaurM		Creation
	--	15 Aug 2006		LaurM		Added the userId and set the siteId 
	--	08 Dec 2006		amk			Optionally take in Notes too
	--	06 Jan 2011		amk			MBAL-17237: when stamping site be sure to get one that template is assigned to

	--fix the username
	if (@CreateUsername IS NULL)
		SET @CreateUsername = SUSER_NAME()

	INSERT INTO [dbo].[ib_Report]
			   ([ReportType]
			   ,[Status]
			   ,[Stage]
			   ,[CreateUsername]
				,[Notes])
		 VALUES
			   (@ReportType
			   ,''Added''
			   ,''Create record report''
			   ,@CreateUserName
				,@Notes)

	SELECT @@ReportId = SCOPE_IDENTITY()

	DECLARE @SiteID INT
	SET @SiteID = NULL

	IF @TemplateId IS NULL
		SELECT TOP 1 @SiteId = su.SiteId 
		FROM ib_SiteUser su
		WHERE su.UserId = @UserID 
		ORDER BY CASE WHEN su.IsPrimary = 1 THEN 0 ELSE 1 END	-- user''s primary first
	ELSE
		SELECT TOP 1 @SiteId = su.SiteId 
		FROM ib_SiteUser su
			JOIN ib_SiteTemplate st ON st.SiteId = su.SiteId
		WHERE su.UserId = @UserID 
			AND st.TemplateId = @TemplateId
		ORDER BY CASE WHEN su.IsPrimary = 1 THEN 0 ELSE 1 END	-- user''s primary first

	UPDATE [dbo].[ib_Report]
	SET [SiteId] = @SiteId
	WHERE ReportId = @@ReportId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_CloseoutReport_LoadTradedFromTrxs]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_CloseoutReport_LoadTradedFromTrxs]
(
	@CloseoutReportId INT
	, @AsOfDate DATETIME
	, @DataSourceCode VARCHAR(100)
)
AS
SET NOCOUNT ON
	-- 11 Aug 2010		amk		MBAL-16435: Creation
	-- 12 Aug 2010		amk		MBAL-16435: Only grab certain trade types (trades)

	UPDATE ib_CloseoutReportDetail
	SET 
		TradedBought = 
			IsNULL((SELECT SUM(t.QuantityLong)
				FROM ib_Trx t
					INNER JOIN ib_TrxType tt ON tt.Code = t.TrxTypeCode AND tt.DataSourceId = t.DataSourceId
				WHERE 
					t.DataSourceId = tc.DataSourceId
					AND t.ExchangeId = crd.ExchangeId
					AND t.FirmId = crd.FirmId
					AND t.AsOfDate = @AsOfDate
					AND t.InstrumentId = crd.InstrumentId
					AND t.ExpiryYear = crd.ExpiryYear
					AND t.ExpiryMonth = crd.ExpiryMonth
					AND t.ExpiryDay = crd.ExpiryDay
					AND ((t.StrikePrice = crd.StrikePrice) OR (t.StrikePrice IS NULL AND crd.StrikePrice IS NULL))
					AND ((t.OptionTypeCode = crd.OptionTypeCode) OR (t.OptionTypeCode IS NULL AND crd.OptionTypeCode IS NULL))
					AND t.AccountId = crd.AccountId
					AND (t.ClassId = crd.ClassId OR t.ClassId IS NULL AND crd.ClassId IS NULL) 
					AND tt.IsTrade = 1
			), 0) -- no columns matches the @Date?
		,TradedSold = 
			ISNULL((SELECT SUM(t.QuantityShort)
				FROM ib_Trx t
					INNER JOIN ib_TrxType tt ON tt.Code = t.TrxTypeCode AND tt.DataSourceId = t.DataSourceId
				WHERE
					t.DataSourceId = tc.DataSourceId
					AND t.ExchangeId = crd.ExchangeId
					AND t.FirmId = crd.FirmId
					AND t.AsOfDate = @AsOfDate
					AND t.InstrumentId = crd.InstrumentId
					AND t.ExpiryYear = crd.ExpiryYear
					AND t.ExpiryMonth = crd.ExpiryMonth
					AND t.ExpiryDay = crd.ExpiryDay
					AND ((t.StrikePrice = crd.StrikePrice) OR (t.StrikePrice IS NULL AND crd.StrikePrice IS NULL))
					AND ((t.OptionTypeCode = crd.OptionTypeCode) OR (t.OptionTypeCode IS NULL AND crd.OptionTypeCode IS NULL))
					AND t.AccountId = crd.AccountId
					AND (t.ClassId = crd.ClassId OR t.ClassId IS NULL AND crd.ClassId IS NULL) 
					AND tt.IsTrade = 1
			), 0) -- no columns matches the @Date?
	FROM ib_CloseoutReportDetail crd
		INNER JOIN ib_CloseoutReport cr ON cr.CloseoutReportId = crd.CloseoutReportId
		INNER JOIN ib_TemplateCompare tc 
			ON tc.TemplateId = cr.TemplateId 
				AND crd.FirmId = tc.FirmId
		INNER JOIN ib_DataSource ds ON tc.DataSourceId = ds.DataSourceId
	WHERE crd.CloseoutReportId = @CloseoutReportId
		AND ds.Code = @DataSourceCode
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_CloseoutReport_LoadTradedFromTrxs_Controller]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_CloseoutReport_LoadTradedFromTrxs_Controller]
(
	@CloseoutReportId INT
	, @AsOfDate DATETIME
)
AS
SET NOCOUNT ON
	-- 10 Jan 2011		amk		MBAL-17268: Creation (formerly data sources were hard-coded)
	
	DECLARE ds_cursor CURSOR FOR
	SELECT Code
	FROM ib_DataSource
	WHERE UseTrxsForTradedOnDay = 1

	OPEN ds_cursor

	DECLARE @DataSourceCode VARCHAR(100)

	FETCH NEXT FROM ds_cursor
	INTO @DataSourceCode

	WHILE @@FETCH_STATUS = 0
	BEGIN
		EXEC ib_CloseoutReport_LoadTradedFromTrxs @CloseoutReportId, @AsOfDate, @DataSourceCode

		FETCH NEXT FROM ds_cursor
		INTO @DataSourceCode
	END
			
	CLOSE ds_cursor
	DEALLOCATE ds_cursor
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_CloseoutReport_GatherAdjustments]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_CloseoutReport_GatherAdjustments]
	@Date DATETIME
	, @TemplateId INT
	, @CloseoutReportId INT
	, @CreateUsername VARCHAR(50)
AS
SET NOCOUNT ON
	--	20 Aug 2010		amk		Creation (extracted from ib_CloseoutReport_BuildReportPhase1)
	--	23 Aug 2010		amk		MBAL-16492: exclude settlement price adjustments
	--	23 Nov 2010		amk		MBAL-16994: 1) stamp custom username on extra rows added to CRD so can trace order
	--										2) match on adjustment date, not trade date
	--										3) bring across source match code so can categorize null account ones later
	--	24 Nov 2010		amk		MBAL-17076: bug fix - since CRD rows have 0 or null, cann''t do isnull 
	--										because that could match both and result in duplicate data
	--										follow pattern on buildreportphase1 and do exact match
	-- 01 May 2012		ED		MBAL 20398 and MBAL 20400 : add logic for family code and Omnibus

	UPDATE [dbo].[ib_CloseoutReportDetail]
		SET  
		InternalLong = 
		CASE WHEN tc.InternalExternalCode = ''I'' THEN 
			ISNULL( 
					(SELECT -- Internal
						CASE WHEN MIN(CAST(IsOmnibus AS Int)) = 1 THEN InternalLong + SUM(a.QuantityLong)
							ELSE
							CASE WHEN (InternalLong + SUM(a.QuantityLong)) > (InternalShort + SUM(a.QuantityShort)) -- This is Nett Long
								THEN (InternalLong + SUM(a.QuantityLong)) - (InternalShort + SUM(a.QuantityShort))
		 							ELSE 0 -- Not Internal
	 							END
	 						END
		 				FROM dbo.ib_Adjustment a 
		 					LEFT JOIN dbo.ib_Account ac ON ac.AccountId=a.AccountId
		 					LEFT JOIN ib_AdjustmentStatus [as] ON [as].AdjustmentStatusId=a.AdjustmentStatusId
		 					JOIN ib_AdjustmentHeader ah ON ah.AdjustmentHeaderId = a.AdjustmentHeaderId
		 					JOIN ib_AdjustmentType at ON at.AdjustmentTypeId = ah.AdjustmentTypeId
		 				WHERE a.DataSourceId = tc.DataSourceId
							AND [a].[ExchangeId] = [crd].[ExchangeId]
							AND [a].[FirmId] = [crd].[FirmId]
							AND [a].[AdjustmentDate] = @Date
							AND [a].[InstrumentId] = [crd].[InstrumentId]
							AND [a].[ExpiryYear] = [crd].[ExpiryYear]
							AND [a].[ExpiryMonth] = [crd].[ExpiryMonth]
							AND [a].[ExpiryDay] = [crd].[ExpiryDay]
							AND (([a].[StrikePrice] = [crd].[StrikePrice]) OR ([a].[StrikePrice] IS NULL AND [crd].[StrikePrice] IS NULL))
							AND (([a].[OptionTypeCode] = [crd].[OptionTypeCode]) OR ([a].[OptionTypeCode] IS NULL AND [crd].[OptionTypeCode] IS NULL))
							AND a.AccountId = [crd].[AccountId]
							AND ([a].[ClassId] = [crd].[ClassId] OR [a].[ClassId] IS NULL AND [crd].[ClassId] IS NULL) 
							AND a.InternalExternalCode = ''I'' 
							AND ([as].Code NOT IN (''A'',''M'') OR a.AdjustmentStatusId IS NULL)
							AND at.Code <> ''SP''
		 				GROUP BY a.ExchangeId, a.InstrumentId, a.FirmId, a.AccountId, a.ClassId,
						a.ExpiryYear, a.ExpiryMonth, a.ExpiryDay, a.OptionTypeCode, a.StrikePrice		
		 			)
		 		,InternalLong)
 			ELSE 0
		END
		,InternalShort = 
		CASE WHEN tc.InternalExternalCode = ''I'' THEN 
			ISNULL( 
					(SELECT -- Internal
						CASE WHEN MIN(CAST(IsOmnibus AS Int)) = 1 THEN InternalShort + SUM(a.QuantityShort)
							ELSE CASE WHEN (InternalShort + SUM(a.QuantityShort)) > (InternalLong + SUM(a.QuantityLong))   -- This is Nett Long
								THEN (InternalShort + SUM(a.QuantityShort)) - (InternalLong + SUM(a.QuantityLong))
		 							ELSE 0 -- Not Internal
		 						END
		 					END
		 				FROM dbo.ib_Adjustment a
		 					LEFT JOIN dbo.ib_Account ac ON ac.AccountId=a.AccountId
		 					LEFT JOIN ib_AdjustmentStatus [as] ON [as].AdjustmentStatusId=a.AdjustmentStatusId
		 					JOIN ib_AdjustmentHeader ah ON ah.AdjustmentHeaderId = a.AdjustmentHeaderId
		 					JOIN ib_AdjustmentType at ON at.AdjustmentTypeId = ah.AdjustmentTypeId
		 				WHERE a.DataSourceId = tc.DataSourceId
							AND [a].[ExchangeId] = [crd].[ExchangeId]
							AND [a].[FirmId] = [crd].[FirmId]
							AND [a].[AdjustmentDate] = @Date
							AND [a].[InstrumentId] = [crd].[InstrumentId]
							AND [a].[ExpiryYear] = [crd].[ExpiryYear]
							AND [a].[ExpiryMonth] = [crd].[ExpiryMonth]
							AND [a].[ExpiryDay] = [crd].[ExpiryDay]
							AND (([a].[StrikePrice] = [crd].[StrikePrice]) OR ([a].[StrikePrice] IS NULL AND [crd].[StrikePrice] IS NULL))
							AND (([a].[OptionTypeCode] = [crd].[OptionTypeCode]) OR ([a].[OptionTypeCode] IS NULL AND [crd].[OptionTypeCode] IS NULL))
							AND a.AccountId = [crd].[AccountId]
							AND ([a].[ClassId] = [crd].[ClassId] OR [a].[ClassId] IS NULL AND [crd].[ClassId] IS NULL) 
		 					AND a.InternalExternalCode = ''I'' 
		 					AND ([as].Code NOT IN (''A'',''M'') OR a.AdjustmentStatusId IS NULL) 
							AND at.Code <> ''SP''
		 				GROUP BY a.ExchangeId, a.InstrumentId, a.FirmId, a.AccountId, a.ClassId,
						a.ExpiryYear, a.ExpiryMonth, a.ExpiryDay, a.OptionTypeCode, a.StrikePrice		
		 			)
		 		,InternalShort)
 			ELSE 0
		END
		,[ExternalLong] = 
		CASE WHEN tc.InternalExternalCode = ''E'' THEN 
			ISNULL( 
					(SELECT [ExternalLong] + SUM(ISNULL(a.[QuantityLong],0)) 
 						FROM dbo.ib_Adjustment a 
	 						LEFT JOIN ib_AdjustmentStatus [as] ON [as].AdjustmentStatusId=a.AdjustmentStatusId
		 					JOIN ib_AdjustmentHeader ah ON ah.AdjustmentHeaderId = a.AdjustmentHeaderId
		 					JOIN ib_AdjustmentType at ON at.AdjustmentTypeId = ah.AdjustmentTypeId
 						WHERE a.DataSourceId = tc.DataSourceId
							AND [a].[ExchangeId] = [crd].[ExchangeId]
							AND [a].[FirmId] = [crd].[FirmId]
							AND [a].[AdjustmentDate] = @Date
							AND [a].[InstrumentId] = [crd].[InstrumentId]
							AND [a].[ExpiryYear] = [crd].[ExpiryYear]
							AND [a].[ExpiryMonth] = [crd].[ExpiryMonth]
							AND [a].[ExpiryDay] = [crd].[ExpiryDay]
							AND (([a].[StrikePrice] = [crd].[StrikePrice]) OR ([a].[StrikePrice] IS NULL AND [crd].[StrikePrice] IS NULL))
							AND (([a].[OptionTypeCode] = [crd].[OptionTypeCode]) OR ([a].[OptionTypeCode] IS NULL AND [crd].[OptionTypeCode] IS NULL))
							AND a.AccountId = [crd].[AccountId]
							AND ([a].[ClassId] = [crd].[ClassId] OR [a].[ClassId] IS NULL AND [crd].[ClassId] IS NULL) 
		 					AND a.InternalExternalCode = ''E'' 
		 					AND ([as].Code NOT IN (''A'',''M'') OR a.AdjustmentStatusId IS NULL)
							AND at.Code <> ''SP''
		 				GROUP BY a.ExchangeId, a.InstrumentId, a.FirmId, a.AccountId, a.ClassId,
						a.ExpiryYear, a.ExpiryMonth, a.ExpiryDay, a.OptionTypeCode, a.StrikePrice		
		 			)
		 		,[ExternalLong])
 			ELSE 0
			END
			, [ExternalShort] = 
			CASE WHEN tc.InternalExternalCode = ''E'' THEN 
			ISNULL( 
					(SELECT [ExternalShort] + SUM(ISNULL(a.[QuantityShort],0)) 
 						FROM dbo.ib_Adjustment a 
	 						LEFT JOIN ib_AdjustmentStatus [as] ON [as].AdjustmentStatusId=a.AdjustmentStatusId
		 					JOIN ib_AdjustmentHeader ah ON ah.AdjustmentHeaderId = a.AdjustmentHeaderId
		 					JOIN ib_AdjustmentType at ON at.AdjustmentTypeId = ah.AdjustmentTypeId
 						WHERE a.DataSourceId = tc.DataSourceId
							AND [a].[ExchangeId] = [crd].[ExchangeId]
							AND [a].[FirmId] = [crd].[FirmId]
							AND [a].[AdjustmentDate] = @Date
							AND [a].[InstrumentId] = [crd].[InstrumentId]
							AND [a].[ExpiryYear] = [crd].[ExpiryYear]
							AND [a].[ExpiryMonth] = [crd].[ExpiryMonth]
							AND [a].[ExpiryDay] = [crd].[ExpiryDay]
							AND (([a].[StrikePrice] = [crd].[StrikePrice]) OR ([a].[StrikePrice] IS NULL AND [crd].[StrikePrice] IS NULL))
							AND (([a].[OptionTypeCode] = [crd].[OptionTypeCode]) OR ([a].[OptionTypeCode] IS NULL AND [crd].[OptionTypeCode] IS NULL))
							AND a.AccountId = [crd].[AccountId]
							AND ([a].[ClassId] = [crd].[ClassId] OR [a].[ClassId] IS NULL AND [crd].[ClassId] IS NULL) 
		 					AND a.InternalExternalCode = ''E'' 
		 					AND ([as].Code NOT IN (''A'',''M'') OR a.AdjustmentStatusId IS NULL)
							AND at.Code <> ''SP''
		 				GROUP BY a.ExchangeId, a.InstrumentId, a.FirmId, a.AccountId, a.ClassId,
						a.ExpiryYear, a.ExpiryMonth, a.ExpiryDay, a.OptionTypeCode, a.StrikePrice		
		 			)
		 		,[ExternalShort])
 			ELSE 0
			END
			, [TradedBought] = 
			CASE WHEN tc.InternalExternalCode = ''E'' THEN 
			ISNULL( 
					(SELECT [TradedBought] + SUM(ISNULL(a.[QuantityLong],0)) 
 						FROM dbo.ib_Adjustment a 
	 						LEFT JOIN ib_AdjustmentStatus [as] ON [as].AdjustmentStatusId=a.AdjustmentStatusId
		 					JOIN ib_AdjustmentHeader ah ON ah.AdjustmentHeaderId = a.AdjustmentHeaderId
		 					JOIN ib_AdjustmentType at ON at.AdjustmentTypeId = ah.AdjustmentTypeId
 						WHERE a.DataSourceId = tc.DataSourceId
							AND [a].[ExchangeId] = [crd].[ExchangeId]
							AND [a].[FirmId] = [crd].[FirmId]
							AND [a].[AdjustmentDate] = @Date
							AND [a].[InstrumentId] = [crd].[InstrumentId]
							AND [a].[ExpiryYear] = [crd].[ExpiryYear]
							AND [a].[ExpiryMonth] = [crd].[ExpiryMonth]
							AND [a].[ExpiryDay] = [crd].[ExpiryDay]
							AND (([a].[StrikePrice] = [crd].[StrikePrice]) OR ([a].[StrikePrice] IS NULL AND [crd].[StrikePrice] IS NULL))
							AND (([a].[OptionTypeCode] = [crd].[OptionTypeCode]) OR ([a].[OptionTypeCode] IS NULL AND [crd].[OptionTypeCode] IS NULL))
							AND a.AccountId = [crd].[AccountId]
							AND ([a].[ClassId] = [crd].[ClassId] OR [a].[ClassId] IS NULL AND [crd].[ClassId] IS NULL) 
		 					AND a.InternalExternalCode = ''E'' 
		 					AND ([as].Code NOT IN (''A'',''M'') OR a.AdjustmentStatusId IS NULL)
							AND at.Code <> ''SP''
		 				GROUP BY a.ExchangeId, a.InstrumentId, a.FirmId, a.AccountId, a.ClassId,
						a.ExpiryYear, a.ExpiryMonth, a.ExpiryDay, a.OptionTypeCode, a.StrikePrice		
		 			)
		 		,[TradedBought])
 			ELSE 0
			END
			, [TradedSold] = 
			CASE WHEN tc.InternalExternalCode = ''E'' THEN 
			ISNULL( 
					(SELECT [TradedSold] + SUM(ISNULL(a.[QuantityShort],0)) 
 						FROM dbo.ib_Adjustment a 
	 						LEFT JOIN ib_AdjustmentStatus [as] ON [as].AdjustmentStatusId=a.AdjustmentStatusId
		 					JOIN ib_AdjustmentHeader ah ON ah.AdjustmentHeaderId = a.AdjustmentHeaderId
		 					JOIN ib_AdjustmentType at ON at.AdjustmentTypeId = ah.AdjustmentTypeId
 						WHERE a.DataSourceId = tc.DataSourceId
							AND [a].[ExchangeId] = [crd].[ExchangeId]
							AND [a].[FirmId] = [crd].[FirmId]
							AND [a].[AdjustmentDate] = @Date
							AND [a].[InstrumentId] = [crd].[InstrumentId]
							AND [a].[ExpiryYear] = [crd].[ExpiryYear]
							AND [a].[ExpiryMonth] = [crd].[ExpiryMonth]
							AND [a].[ExpiryDay] = [crd].[ExpiryDay]
							AND (([a].[StrikePrice] = [crd].[StrikePrice]) OR ([a].[StrikePrice] IS NULL AND [crd].[StrikePrice] IS NULL))
							AND (([a].[OptionTypeCode] = [crd].[OptionTypeCode]) OR ([a].[OptionTypeCode] IS NULL AND [crd].[OptionTypeCode] IS NULL))
							AND a.AccountId = [crd].[AccountId]
							AND ([a].[ClassId] = [crd].[ClassId] OR [a].[ClassId] IS NULL AND [crd].[ClassId] IS NULL) 
		 					AND a.InternalExternalCode = ''E'' 
		 					AND ([as].Code NOT IN (''A'',''M'') OR a.AdjustmentStatusId IS NULL)
							AND at.Code <> ''SP''
		 				GROUP BY a.ExchangeId, a.InstrumentId, a.FirmId, a.AccountId, a.ClassId
							, a.ExpiryYear, a.ExpiryMonth, a.ExpiryDay, a.OptionTypeCode, a.StrikePrice
		 			)
		 		, [TradedSold])
 			ELSE 0
			END
		FROM [dbo].[ib_CloseoutReportDetail] [crd]
			INNER JOIN [dbo].[ib_TemplateCompare] [tc] ON 
				[tc].[TemplateId] = @TemplateId 
					AND [crd].FirmId = [tc].FirmId
			INNER JOIN [dbo].[ib_DataSource] ds ON [tc].[DataSourceId] = [ds].[DataSourceId]
		WHERE [CloseoutReportId] = @CloseoutReportId
		
	---insert from adjustments the missing ones
	-- *** NOTE it is VERY IMPORTANT that subquery below do exact match on AccountId
	-- THIS MEANS that if outer query has null for account, the subquery will fail test 
	-- and records will be added into CRD.  That is what we want since above updates
	-- all match on AccountId so exclude rows where accountid is null.
	-- So even though we are adding in extra rows into CRD they will get aggregated correctly.
	-- The important bit is we are bringing in adjustment numbers that did not get caught above.
	INSERT INTO [dbo].[ib_CloseoutReportDetail]
		([CloseoutReportId], [ExchangeId], [InstrumentId]
		, [FirmId], [AccountId], [ClassId]
		, [ExpiryYear], [ExpiryMonth], [ExpiryDay]
		, [InstrumentTypeId], [OptionTypeCode], [UseNetForCloseOut], [StrikePrice]
		, [TradedBought], [TradedSold], [InternalLong], [InternalShort]
		, [ExternalLong], [ExternalShort], [CreateUsername]
		, SourceMatchCodeId
		)
	SELECT -- the rows (dates) from Position
		@CloseoutReportId, a.ExchangeId, 
		a.InstrumentId, a.FirmId, a.AccountId, a.ClassId, 
		a.ExpiryYear, a.ExpiryMonth, a.ExpiryDay, 
		i.InstrumentTypeId, a.OptionTypeCode, 0, a.StrikePrice 
		, [TradedBought] = CASE WHEN a.[InternalExternalCode] = ''E'' THEN -- Internal
				SUM(ISNULL(a.[QuantityLong], 0))
			ELSE 0 -- Not External
			END
		,[TradedSold] = CASE WHEN a.[InternalExternalCode] = ''E'' THEN -- Internal
				SUM(ISNULL(a.[QuantityShort], 0))
			ELSE 0 -- Not External
			END
		, [InternalLong] = CASE WHEN a.[InternalExternalCode] = ''I'' THEN -- Internal
				CASE WHEN a.AccountId IS NULL THEN
					SUM(ISNULL(a.[QuantityLong], 0))
				ELSE
					CASE WHEN SUM(ISNULL(a.[QuantityLong], 0)) > SUM(ISNULL(a.[QuantityShort], 0))
					THEN SUM(ISNULL(a.[QuantityLong], 0)) - SUM(ISNULL(a.[QuantityShort], 0))
					ELSE 0
					END
				END
			ELSE 0 -- Not Internal
			END
		, [InternalShort] = CASE WHEN a.[InternalExternalCode] = ''I'' THEN -- Internal
				CASE WHEN a.AccountId IS NULL THEN
					SUM(ISNULL(a.[QuantityShort], 0))
				ELSE
					CASE WHEN SUM(ISNULL(a.[QuantityShort], 0)) > SUM(ISNULL(a.[QuantityLong], 0))
					THEN SUM(ISNULL(a.[QuantityShort], 0)) - SUM(ISNULL(a.[QuantityLong], 0))
					ELSE 0
					END
				END
			ELSE 0 -- Not Internal
			END
		, [ExternalLong] = CASE WHEN a.[InternalExternalCode] = ''E'' THEN -- Internal
				SUM(ISNULL(a.[QuantityLong], 0))
			ELSE 0 -- Not External
			END
		, [ExternalShort] = CASE WHEN a.[InternalExternalCode] = ''E'' THEN -- Internal
				SUM(ISNULL(a.[QuantityShort], 0))
			ELSE 0 -- Not External
			END,
			CreateUsername = @CreateUsername + '' post adj appl''
			, a.MatchCodeId
		FROM dbo.ib_TemplateCompare tc 
			INNER JOIN dbo.ib_Adjustment a 
				ON tc.TemplateID = @TemplateId
					AND tc.FirmID = a.FirmID 
					AND tc.DataSourceId = a.DataSourceId 
					AND a.AdjustmentDate = @Date
			INNER JOIN ib_Exchange ex 
				ON a.ExchangeId = ex.ExchangeId 
					AND ex.RunCloseOutReport != 0
			INNER JOIN ib_Instrument i 
				ON a.InstrumentId = i.InstrumentId
			INNER JOIN ib_AdjustmentHeader ah ON ah.AdjustmentHeaderId = a.AdjustmentHeaderId
			INNER JOIN ib_AdjustmentType AT ON at.AdjustmentTypeId=ah.AdjustmentTypeId
			LEFT JOIN ib_AdjustmentStatus [as] ON [as].AdjustmentStatusId=a.AdjustmentStatusId
		WHERE at.Code IN (''TC'',''TI'', ''MI'') -- ONLY trade related adjs
			AND ([as].Code NOT IN (''A'',''M'') OR a.AdjustmentStatusId IS NULL)
			AND NOT EXISTS
			(
				SELECT CloseoutReportDetailId 
				FROM [dbo].[ib_CloseoutReportDetail] crd
				WHERE [a].[ExchangeId] = [crd].[ExchangeId]
					AND [a].[FirmId] = [crd].[FirmId]
					AND [a].[InstrumentId] = [crd].[InstrumentId]
					AND [a].[ExpiryYear] = [crd].[ExpiryYear]
					AND [a].[ExpiryMonth] = [crd].[ExpiryMonth]
					AND [a].[ExpiryDay] = [crd].[ExpiryDay]
					AND (([a].[StrikePrice] = [crd].[StrikePrice]) OR ([a].[StrikePrice] IS NULL AND [crd].[StrikePrice] IS NULL))
					AND (([a].[OptionTypeCode] = [crd].[OptionTypeCode]) OR ([a].[OptionTypeCode] IS NULL AND [crd].[OptionTypeCode] IS NULL))
					AND a.AccountId = [crd].[AccountId]	-- *** SEE IMPORTANT NOTE ABOVE THIS INSERT STMT
					AND ([a].[ClassId] = [crd].[ClassId] OR [a].[ClassId] IS NULL AND [crd].[ClassId] IS NULL) 
					AND [CloseoutReportId] = @CloseoutReportId
			)
		GROUP BY 
			a.ExchangeId, a.InstrumentId, a.FirmId, a.AccountId, a.ClassId
			, a.ExpiryYear, a.ExpiryMonth, a.ExpiryDay, i.InstrumentTypeId
			, a.OptionTypeCode, a.StrikePrice, a.InternalExternalCode
			, a.MatchCodeId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_CloseoutReport_BuildReportPhase1]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_CloseoutReport_BuildReportPhase1]
(
	@CreateUsername varchar(50) = NULL,
	@TemplateId int,
	@Date datetime,
	@UserId uniqueidentifier,
	@@ReportId int OUTPUT,
	@@CloseoutReportId int OUTPUT
)
AS
SET NOCOUNT ON

/*
<details>
	<summary> Generates the ib_CloseoutReportDetail records for the report Phase 1</summary>
	<created author="Laurentiu Macovei" Date="Monday, 02 October 2006" />
	<updated author="Anil Kripalani" Date="18 Dec 2006">
		BUG FIX 1: Option type code and strike price can be null so allow for that in joins
		BUG FIX 2: For update query, join templatecompare on firmid too
	</updated>
	<updated author="Anil Kripalani" Date="19 Dec 2006">
		BUG FIX: Only update ONE report record when setting target report, NOT ALL
	</updated>
	<updated author="Charles East" Date="17 Jan 2007">
		New feature: Insert and Group By UseNetForCloseOut
	</updated>
	<updated author="Anil Kripalani" Date="25 Jan 2007">
		Bug Fix: Honour usenetforcloseout when gathering stats
		Enhancement: Use new parent accounts
	</updated>
	<updated author="Anil Kripalani" Date="06 Feb 2007">
		1) More specific stage updates
		2) Change how we do account parenting (update accounts at end)
	</updated>
	<updated author="Alister McLeod" Date="29 Apr 2010">
		MBAL-15308 Correct the Internal Position Calculation by adding Netting code
		before further processing
	</updated>
	<updated author="ED" Date="28 May 2010">
		MBAL-13980 adjustments in closeout report
	</updated>
</details>
*/
	-- 02 Jun 2010		ED		MBAL-13980: fix the join on INSERT(to join on template compare)
	-- 25 Jun 2010		ED		MBAL-15949: don''t include manually matched adjustments
	-- 11 Aug 2010		amk		MBAL-16434: adjustment match should be on asofdate not tradedate	
	--							MBAL-16435: load in C21 traded figures from trxs as they 
	--										are not found on positions
	-- 12 Aug 2010		amk		MBAL-16435: load in ADM, Barclays, Citibank traded figures 
	--										from trxs as they are not found on positions
	-- 20 Aug 2010		amk		MBAL-16486: adjustments missing from report (add adj rows into shell at beginning)
	-- 06 Jan 2011		amk		MBAL-17237: ensure calls to add new report record carry template so site can be saved correctly
	-- 10 Jan 2011		amk		MBAL-17268: do not hard code data sources to pull trx data from (for traded on day)
	--										new col on data source instead - call controller to suss it out
	-- 01 May 2012		ED		MBAL 20398 and MBAL 20400 : add logic for family code and Omnibus

	IF @@ReportId IS NULL
		EXEC [dbo].[ib_Report_CreateReport] ''Closeout'', @CreateUserName, @UserId, @@ReportId OUTPUT
			, NULL, @TemplateId

	--update the report status
	UPDATE [dbo].[ib_Report]
	SET [Stage] = ''Phase 1: Validating''
	WHERE ReportId = @@ReportId

	--validate
	IF @Date IS NULL
		RAISERROR (N''The Date cannot be NULL!'', 11, 1)
	IF @TemplateId IS NULL
		RAISERROR (N''TemplateID cannot be NULL!'', 11, 3)

	--update the report status
	UPDATE [dbo].[ib_Report]
	SET [Stage] = ''Phase 1: Checking for matching data''
	WHERE ReportId = @@ReportId
	
	DECLARE @RowCount int
	SET @RowCount = 0
	--try to validate the input dates, so find if there is any records matching them
	SELECT TOP 1 @RowCount = 1 FROM [dbo].[ib_Position]
		WHERE AsOfDate = @Date
	--if no rows at all
	IF @RowCount = 0 
	BEGIN
		DECLARE @@Date varchar(30)
		SET @@Date = Cast(@Date as varchar(30))
		RAISERROR (N''Warning! There is not data matching the date ''''%s''''!'', 11, 4, @@Date)
	END

	--fix the username
	IF (@CreateUsername IS NULL)
		SET @CreateUsername = SUSER_NAME()
	
	--update the report status
	UPDATE [dbo].[ib_Report]
	SET [Stage] = ''Phase 1: Create the report header''
	WHERE ReportId = @@ReportId

	--create the ReportHeader
	INSERT INTO [dbo].[ib_CloseoutReport](TemplateId, Date, CreateUsername)
	SELECT @TemplateId, @Date, @CreateUsername
	FROM [dbo].ib_Template
	WHERE TemplateId = @TemplateId

	--check the creation
	IF @@RowCount = 0 
		RAISERROR (N''Specified Template with TemplateID ''''%d'''' does not exist!'', 11, 1, @TemplateId)

	--take the newly created ReportId
	SELECT @@CloseoutReportId = SCOPE_IDENTITY()

	--update parent''s refference
	UPDATE ib_Report 
	SET TargetReportId = @@CloseoutReportId
	WHERE ReportId = @@ReportId

	--update the report status
	UPDATE ib_Report
	SET Stage = ''Phase 1: Set parent account on all accounts''
	WHERE ReportId = @@ReportId

	-- this stored proc assumes 
	--		1) accountid set on all ib_position rows
	--		2) parentaccountid set on all ib_account rows
	--		(to satisfy #2, we''ll just do the following update)

	UPDATE ib_Account
	SET ParentAccountId = AccountId
	WHERE ParentAccountId IS NULL

	--update the report status
	UPDATE [dbo].[ib_Report]
	SET [Stage] = ''Phase 1: Load recs from positions for firms''
	WHERE ReportId = @@ReportId

	INSERT INTO [dbo].[ib_CloseoutReportDetail]
			   ([CloseoutReportId], [ExchangeId], [InstrumentId]
			   ,[FirmId], [AccountId], [ClassId]
			   ,[ExpiryYear], [ExpiryMonth], [ExpiryDay]
			   ,[InstrumentTypeId], [OptionTypeCode], [UseNetForCloseOut], [StrikePrice]
			   ,[TradedBought], [TradedSold], [InternalLong], [InternalShort]
			   ,[ExternalLong], [ExternalShort], [CreateUsername])
	SELECT -- the rows (dates) from Position
		@@CloseoutReportId, p.ExchangeId, 
		p.InstrumentId, p.FirmId, p.AccountId, p.ClassId, 
		p.ExpiryYear, p.ExpiryMonth, p.ExpiryDay, 
		i.InstrumentTypeId, p.OptionTypeCode, p.UseNetForCloseOut, p.StrikePrice, 
		[TradedBought] = 0, [TradedSold] = 0, [InternalLong] = 0, [InternalShort] = 0,
		[ExternalLong] = 0, [ExternalShort] = 0, CreateUsername = @CreateUsername
	FROM dbo.ib_TemplateCompare tc 
		INNER JOIN dbo.ib_Position p ON 
			tc.TemplateID = @TemplateId
			AND tc.FirmID = p.FirmID 
			AND tc.DataSourceId = p.DataSourceId 
			AND p.AsOfDate = @Date
		INNER JOIN ib_Exchange ex ON 
			p.ExchangeId = ex.ExchangeId 
		INNER JOIN ib_Instrument i ON
			p.InstrumentId = i.InstrumentId
		INNER JOIN ib_InstrumentDataSource ids ON ids.DataSourceId = p.DataSourceId AND ids.InstrumentId = p.InstrumentId
		WHERE ids.RunCloseOutReport = 1 OR ex.RunCloseOutReport = 1 -- excluding data that has RunCloseOutReport = 0
	GROUP BY 
		p.ExchangeId, p.InstrumentId, p.FirmId, p.AccountId, p.ClassId,
		p.ExpiryYear, p.ExpiryMonth, p.ExpiryDay, i.InstrumentTypeId,
		p.OptionTypeCode, p.UseNetForCloseOut, p.StrikePrice
	UNION
	SELECT -- the rows (dates) from Adjustment
		@@CloseoutReportId, p.ExchangeId, 
		p.InstrumentId, p.FirmId, p.AccountId, p.ClassId,
		p.ExpiryYear, p.ExpiryMonth, p.ExpiryDay, 
		i.InstrumentTypeId, p.OptionTypeCode, 0 AS UseNetForCloseOut, p.StrikePrice, 
		[TradedBought] = 0, [TradedSold] = 0, [InternalLong] = 0, [InternalShort] = 0,
		[ExternalLong] = 0, [ExternalShort] = 0, CreateUsername = @CreateUsername
	FROM dbo.ib_TemplateCompare tc 
		INNER JOIN dbo.ib_Adjustment p ON 
			tc.TemplateID = @TemplateId
			AND tc.FirmID = p.FirmID 
			AND tc.DataSourceId = p.DataSourceId 
			AND p.AdjustmentDate = @Date 
		INNER JOIN ib_Exchange ex ON p.ExchangeId = ex.ExchangeId 
		INNER JOIN ib_Instrument i ON p.InstrumentId = i.InstrumentId
		INNER JOIN ib_InstrumentDataSource ids ON ids.DataSourceId = p.DataSourceId AND ids.InstrumentId = p.InstrumentId
		WHERE ids.RunCloseOutReport = 1 OR ex.RunCloseOutReport = 1 -- excluding data that has RunCloseOutReport = 0
	GROUP BY 
		p.ExchangeId, p.InstrumentId, p.FirmId, p.AccountId, p.ClassId,
		p.ExpiryYear, p.ExpiryMonth, p.ExpiryDay, i.InstrumentTypeId,
		p.OptionTypeCode, p.StrikePrice
		
	--update the report status
	UPDATE ib_Report
	SET Stage = ''Phase 1: Gather figures from positions''
	WHERE ReportId = @@ReportId

	UPDATE [dbo].[ib_CloseoutReportDetail]
	SET 
		[InternalLong] = 
			CASE WHEN [tc].[InternalExternalCode] = ''I'' THEN -- perform only on internal values
				ISNULL(
					(SELECT 
						CASE WHEN MIN(CAST(IsOmnibus AS Int)) = 1 THEN SUM([p].[LongQuantity]) ELSE
							CASE WHEN (SUM([p].[LongQuantity]) > SUM([p].[ShortQuantity])) -- This is Nett Long
								THEN SUM([p].[LongQuantity]) - SUM([p].[ShortQuantity])
							ELSE 0 -- Netting the positions -- this will be Nett Short
							END
						END
					FROM [dbo].[ib_Position] [p]
					LEFT JOIN [dbo].[ib_Account] a ON p.AccountId = a.AccountId
					WHERE 
						[p].[DataSourceId] = [tc].[DataSourceId]
						AND [p].[ExchangeId] = [crd].[ExchangeId]
						AND [p].[FirmId] = [crd].[FirmId]
						AND [p].[AsOfDate] = @Date
						AND [p].[InstrumentId] = [crd].[InstrumentId]
						AND [p].[ExpiryYear] = [crd].[ExpiryYear]
						AND [p].[ExpiryMonth] = [crd].[ExpiryMonth]
						AND [p].[ExpiryDay] = [crd].[ExpiryDay]
						AND (([p].[StrikePrice] = [crd].[StrikePrice]) OR ([p].[StrikePrice] IS NULL AND [crd].[StrikePrice] IS NULL))
						AND (([p].[OptionTypeCode] = [crd].[OptionTypeCode]) OR ([p].[OptionTypeCode] IS NULL AND [crd].[OptionTypeCode] IS NULL))
						AND p.AccountId = [crd].[AccountId]
						AND ([p].[ClassId] = [crd].[ClassId] OR [p].[ClassId] IS NULL AND [crd].[ClassId] IS NULL) 
						AND p.UseNetForCloseOut = crd.UseNetForCloseOut
					  )
					  ,0) -- no columns matches the @Date?

			ELSE 0 -- not internal?
			END
			,[ExternalLong] = 
			CASE WHEN [tc].[InternalExternalCode] = ''E'' THEN -- perform only on external values
				ISNULL((SELECT SUM([p].[LongQuantity])
					FROM [dbo].[ib_Position] [p]
					WHERE 
						[p].[DataSourceId] = [tc].[DataSourceId]
						AND [p].[ExchangeId] = [crd].[ExchangeId]
						AND [p].[FirmId] = [crd].[FirmId]
						AND [p].[AsOfDate] = @Date
						AND [p].[InstrumentId] = [crd].[InstrumentId]
						AND [p].[ExpiryYear] = [crd].[ExpiryYear]
						AND [p].[ExpiryMonth] = [crd].[ExpiryMonth]
						AND [p].[ExpiryDay] = [crd].[ExpiryDay]
						AND (([p].[StrikePrice] = [crd].[StrikePrice]) OR ([p].[StrikePrice] IS NULL AND [crd].[StrikePrice] IS NULL))
						AND (([p].[OptionTypeCode] = [crd].[OptionTypeCode]) OR ([p].[OptionTypeCode] IS NULL AND [crd].[OptionTypeCode] IS NULL))
						AND p.AccountId = [crd].[AccountId]
						AND ([p].[ClassId] = [crd].[ClassId] OR [p].[ClassId] IS NULL AND [crd].[ClassId] IS NULL) 
						AND p.UseNetForCloseOut = crd.UseNetForCloseOut
				),0) -- no columns matches the @Date?

			ELSE 0 -- not external?
			END
			,[InternalShort] = 
			CASE WHEN [tc].[InternalExternalCode] = ''I'' THEN -- perform only on internal values
				ISNULL(
					(SELECT 
						CASE WHEN MIN(CAST(IsOmnibus AS Int)) = 1 THEN SUM([p].[ShortQuantity]) ELSE
							CASE WHEN (SUM([p].[ShortQuantity]) > SUM([p].[LongQuantity])) -- This is Nett Short
								THEN SUM([p].[ShortQuantity]) - SUM([p].[LongQuantity])
							ELSE 0 -- Netting the positions -- this will be Nett Long captured previously
							END
						END
					FROM [dbo].[ib_Position] [p]
					LEFT JOIN [dbo].[ib_Account] a ON p.AccountId = a.AccountId
					WHERE 
						[p].[DataSourceId] = [tc].[DataSourceId]
						AND [p].[ExchangeId] = [crd].[ExchangeId]
						AND [p].[FirmId] = [crd].[FirmId]
						AND [p].[AsOfDate] = @Date
						AND [p].[InstrumentId] = [crd].[InstrumentId]
						AND [p].[ExpiryYear] = [crd].[ExpiryYear]
						AND [p].[ExpiryMonth] = [crd].[ExpiryMonth]
						AND [p].[ExpiryDay] = [crd].[ExpiryDay]
						AND (([p].[StrikePrice] = [crd].[StrikePrice]) OR ([p].[StrikePrice] IS NULL AND [crd].[StrikePrice] IS NULL))
						AND (([p].[OptionTypeCode] = [crd].[OptionTypeCode]) OR ([p].[OptionTypeCode] IS NULL AND [crd].[OptionTypeCode] IS NULL))
						AND p.AccountId = [crd].[AccountId]
						AND ([p].[ClassId] = [crd].[ClassId] OR [p].[ClassId] IS NULL AND [crd].[ClassId] IS NULL) 
						AND p.UseNetForCloseOut = crd.UseNetForCloseOut
				),0) -- no columns matches the Date?
			ELSE 0 -- not internal?
			END
			,[ExternalShort] = 
			CASE WHEN [tc].[InternalExternalCode] = ''E'' THEN -- perform only on external values
				ISNULL((SELECT SUM([p].[ShortQuantity])
					FROM [dbo].[ib_Position] [p]
					WHERE 
						[p].[DataSourceId] = [tc].[DataSourceId]
						AND [p].[ExchangeId] = [crd].[ExchangeId]
						AND [p].[FirmId] = [crd].[FirmId]
						AND [p].[AsOfDate] = @Date
						AND [p].[InstrumentId] = [crd].[InstrumentId]
						AND [p].[ExpiryYear] = [crd].[ExpiryYear]
						AND [p].[ExpiryMonth] = [crd].[ExpiryMonth]
						AND [p].[ExpiryDay] = [crd].[ExpiryDay]
						AND (([p].[StrikePrice] = [crd].[StrikePrice]) OR ([p].[StrikePrice] IS NULL AND [crd].[StrikePrice] IS NULL))
						AND (([p].[OptionTypeCode] = [crd].[OptionTypeCode]) OR ([p].[OptionTypeCode] IS NULL AND [crd].[OptionTypeCode] IS NULL))
						AND p.AccountId = [crd].[AccountId]
						AND ([p].[ClassId] = [crd].[ClassId] OR [p].[ClassId] IS NULL AND [crd].[ClassId] IS NULL) 
						AND p.UseNetForCloseOut = crd.UseNetForCloseOut
				),0) -- no columns matches the @Date?
			ELSE 0 -- not external?
			END
			,[TradedBought] = 
				IsNULL((SELECT SUM([p].[TradedLongQuantity])
					FROM [dbo].[ib_Position] [p]
					WHERE 
						[p].[DataSourceId] = [tc].[DataSourceId]
						AND [p].[ExchangeId] = [crd].[ExchangeId]
						AND [p].[FirmId] = [crd].[FirmId]
						AND [p].[AsOfDate] = @Date
						AND [p].[InstrumentId] = [crd].[InstrumentId]
						AND [p].[ExpiryYear] = [crd].[ExpiryYear]
						AND [p].[ExpiryMonth] = [crd].[ExpiryMonth]
						AND [p].[ExpiryDay] = [crd].[ExpiryDay]
						AND (([p].[StrikePrice] = [crd].[StrikePrice]) OR ([p].[StrikePrice] IS NULL AND [crd].[StrikePrice] IS NULL))
						AND (([p].[OptionTypeCode] = [crd].[OptionTypeCode]) OR ([p].[OptionTypeCode] IS NULL AND [crd].[OptionTypeCode] IS NULL))
						AND p.AccountId = [crd].[AccountId]
						AND ([p].[ClassId] = [crd].[ClassId] OR [p].[ClassId] IS NULL AND [crd].[ClassId] IS NULL) 
						AND p.UseNetForCloseOut = crd.UseNetForCloseOut
				),0) -- no columns matches the @Date?
			,[TradedSold] = 
				ISNULL((SELECT SUM([p].[TradedShortQuantity])
					FROM [dbo].[ib_Position] [p]
					WHERE
						[p].[DataSourceId] = [tc].[DataSourceId]
						AND [p].[ExchangeId] = [crd].[ExchangeId]
						AND [p].[FirmId] = [crd].[FirmId]
						AND [p].[AsOfDate] = @Date
						AND [p].[InstrumentId] = [crd].[InstrumentId]
						AND [p].[ExpiryYear] = [crd].[ExpiryYear]
						AND [p].[ExpiryMonth] = [crd].[ExpiryMonth]
						AND [p].[ExpiryDay] = [crd].[ExpiryDay]
						AND (([p].[StrikePrice] = [crd].[StrikePrice]) OR ([p].[StrikePrice] IS NULL AND [crd].[StrikePrice] IS NULL))
						AND (([p].[OptionTypeCode] = [crd].[OptionTypeCode]) OR ([p].[OptionTypeCode] IS NULL AND [crd].[OptionTypeCode] IS NULL))
						AND p.AccountId = [crd].[AccountId]
						AND ([p].[ClassId] = [crd].[ClassId] OR [p].[ClassId] IS NULL AND [crd].[ClassId] IS NULL) 
						AND p.UseNetForCloseOut = crd.UseNetForCloseOut
				),0) -- no columns matches the @Date?
	FROM [dbo].[ib_CloseoutReportDetail] [crd]
		INNER JOIN [dbo].[ib_TemplateCompare] [tc] ON 
			[tc].[TemplateId] = @TemplateId 
			AND [crd].FirmId = [tc].FirmId
		INNER JOIN [dbo].[ib_DataSource] ds ON [tc].[DataSourceId] = [ds].[DataSourceId]
	WHERE [CloseoutReportId] = @@CloseoutReportId

	--update the report status
	UPDATE ib_Report
	SET Stage = ''Phase 1: Gather figures from transactions''
	WHERE ReportId = @@ReportId

	EXEC ib_CloseoutReport_LoadTradedFromTrxs_Controller @@CloseoutReportId, @Date

	--update the report status
	UPDATE ib_Report
	SET Stage = ''Phase 1: Gather figures from adjustments''
	WHERE ReportId = @@ReportId

	EXEC ib_CloseoutReport_GatherAdjustments @Date, @TemplateId, @@CloseoutReportId, @CreateUsername
	
		--Now set accounts on CRD to parent accounts
	UPDATE [dbo].[ib_Report]
	SET [Stage] = ''Phase 1: Set parent accounts''
	WHERE ReportId = @@ReportId

	UPDATE ib_CloseOutReportDetail
	SET AccountId = a.ParentAccountId
	FROM ib_CloseOutReportDetail crd
		JOIN ib_Account a ON a.AccountId = crd.AccountId

	--update the report status
	UPDATE [dbo].[ib_Report]
	SET [Stage] = ''Phase 1: Completed''
	WHERE ReportId = @@ReportId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[BancoSantander_HOSTOPN_Purge]''
');

GO
EXECUTE ('-- =============================================
-- Author:		A McLeod
-- Create date: 09 Oct 2012
-- Description:	Deletes from BancoSantander_HOSTOPN table all the records where the LoadState is 0 (Copied from RolfeNolan)
-- =============================================
CREATE PROCEDURE [dbo].[BancoSantander_HOSTOPN_Purge] 
	(
		@LoadState		TINYINT = 0,
		@FileName       VARCHAR (512)= NULL
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
		DELETE FROM [dbo].[BancoSantander_HOSTOPN] WHERE LoadState= @LoadState AND [FileName] = Coalesce(@FileName, [FileName])

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[is_HCollateralSecuritiesDetails_Add]''
');

GO
EXECUTE ('

/*
<Details>
<Summary>Inserts an item into the HCollateralSecuritiesDetails table</Summary>
<Created author="laurentiu.macovei" date="04/05/2006 16:33:06" />
</Details>
*/
CREATE PROCEDURE [dbo].[is_HCollateralSecuritiesDetails_Add]
	@CorporationCode varchar(4) = NULL,
	@PrincipalBrokerageId varchar(1) = NULL,
	@OfficeCode varchar(4) = NULL,
	@ACNo varchar(10) = NULL,
	@SecuritiesId varchar(2) = NULL,
	@BaseDate datetime = NULL,
	@CalcDate datetime = NULL,
	@CalcStartTime datetime = NULL,
	@DepositId varchar(2) = NULL,
	@ProductCode varchar(2) = NULL,
	@CompanyCode varchar(7) = NULL,
	@SeriesNo varchar(4) = NULL,
	@SubSeriesNo varchar(2) = NULL,
	@OldNewId varchar(1) = NULL,
	@DepositDate datetime = NULL,
	@WithdrawalDate datetime = NULL,
	@RecordNo varchar(5) = NULL,
	@Quantity decimal(15,0) = NULL,
	@MarketValue decimal(15,0) = NULL,
	@CollateralRate varchar(3) = NULL,
	@UnitValuePerCollateral decimal(15,0) = NULL,
	@EvaluationOfCollatSec decimal(15,0) = NULL,
	@CustodianCode varchar(3) = NULL,
	@DepositaryReceiptNo varchar(5) = NULL,
	@JasdecMemberCode varchar(7) = NULL,
	@DirectCustodian varchar(2) = NULL,
	@CustomerNameAbb varchar(35) = NULL,
	@SecNameInEnglish varchar(28) = NULL,
	@SecNameInKana varchar(24) = NULL
AS
SET NOCOUNT ON

SET NOCOUNT OFF

	DECLARE	@CalcDateStartTime DATETIME

	IF @BaseDate = ''01/01/1900 00:00:00'' 
		SET @BaseDate = NULL

	IF @CalcDate = ''01/01/1900 00:00:00'' 
		SET @CalcDate = NULL

	IF @CalcStartTime = ''01/01/1900 00:00:00'' 
		SET @CalcStartTime = NULL

	IF @DepositDate = ''01/01/1900 00:00:00'' 
		SET @DepositDate = NULL

	IF @WithdrawalDate = ''01/01/1900 00:00:00'' 
		SET @WithdrawalDate = NULL

	SET @CalcDateStartTime = CONVERT(DATETIME,CONVERT(VARCHAR(12), CONVERT(DATETIME,@CalcDate,112)) + '' '' + CONVERT(VARCHAR(8),RIGHT(@CalcStartTime,8)))


	INSERT INTO is_HCollateralSecuritiesDetails 
		(
			[CorporationCode], 
			[PrincipalBrokerageId], 
			[OfficeCode], 
			[ACNo], 
			[SecuritiesId], 
			[BaseDate], 
			[CalcDate], 
			[CalcStartTime], 
			[CalcDateStartTime], 
			[DepositId], 
			[ProductCode], 
			[CompanyCode], 
			[SeriesNo], 
			[SubSeriesNo], 
			[OldNewId], 
			[DepositDate], 
			[WithdrawalDate], 
			[RecordNo], 
			[Quantity], 
			[MarketValue], 
			[CollateralRate], 
			[UnitValuePerCollateral], 
			[EvaluationOfCollatSec], 
			[CustodianCode], 
			[DepositaryReceiptNo], 
			[JasdecMemberCode], 
			[DirectCustodian], 
			[CustomerNameAbb], 
			[SecNameInEnglish], 
			[SecNameInKana]
		) 
	VALUES
		(
			@CorporationCode, 
			@PrincipalBrokerageId, 
			@OfficeCode, 
			@ACNo, 
			@SecuritiesId, 
			@BaseDate, 
			@CalcDate, 
			@CalcStartTime,
			@CalcDateStartTime, 
			@DepositId, 
			@ProductCode, 
			@CompanyCode, 
			@SeriesNo, 
			@SubSeriesNo, 
			@OldNewId, 
			@DepositDate, 
			@WithdrawalDate, 
			@RecordNo, 
			@Quantity, 
			@MarketValue, 
			@CollateralRate, 
			@UnitValuePerCollateral, 
			@EvaluationOfCollatSec, 
			@CustodianCode, 
			@DepositaryReceiptNo, 
			@JasdecMemberCode, 
			@DirectCustodian, 
			@CustomerNameAbb, 
			@SecNameInEnglish, 
			@SecNameInKana
		);

Return Scope_Identity()
');

GO
EXECUTE ('PRINT N''Creating [dbo].[GetFixedSwiftStatementNumber]''
');

GO
EXECUTE ('CREATE FUNCTION [dbo].[GetFixedSwiftStatementNumber]
(@AccountCode VARCHAR (35), @FileStatementNumber VARCHAR (5))
RETURNS VARCHAR (5)
AS
BEGIN
	DECLARE @StatementNumberSeed INT
	SELECT @StatementNumberSeed=StatementNumberSeed FROM ib_SwiftStatementSeed sss
		INNER JOIN ib_Account a ON sss.AccountId=a.AccountId
		WHERE a.Code=@AccountCode
	IF @StatementNumberSeed IS NULL 
		SET @StatementNumberSeed=0
	SET @StatementNumberSeed = @StatementNumberSeed + CONVERT(INT, @FileStatementNumber)
	RETURN CONVERT(VARCHAR(5),@StatementNumberSeed)
END


');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Rule_GetMatchCountTypes]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Rule_GetMatchCountTypes]
AS
SET NOCOUNT ON
	SELECT
		MatchCountTypeId
		,Description
	FROM
		[dbo].[ib_MatchCountType]
	ORDER BY
		Description
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Instrument_GetInstumentsByKeyword]''
');

GO
EXECUTE ('


/*
<details>
 <summary> Filter the instruments by a specific code /summary>
 <created author="Laurentiu Macovei" Date="Thursday, 10 August 2006 13:31 GMT" /> 
 <tasks>
 </tasks>
</details>
-- 13 May 2014  ED  EIB 25499 - add IsActive flag to ib_Instrument
*/
CREATE PROCEDURE [dbo].[ib_Instrument_GetInstumentsByKeyword]
@Instrument varchar(100),
@FilterByStartOnly bit=0,
@Top int = 10
AS
SET NOCOUNT ON
DECLARE @Name nvarchar(1000)
DECLARE @Code nvarchar(1000)
if CHARINDEX(''['',@Instrument)>0
BEGIN
	SET @Name = SUBSTRING(@Instrument,0, CHARINDEX(''['',@Instrument)-1)
	SET @Code = SUBSTRING(@Instrument,CHARINDEX(''['',@Instrument)+2, 
			LEN(@Instrument)-CHARINDEX(''['',@Instrument)-2)
	IF @FilterByStartOnly = 1 
	BEGIN
		SELECT TOP (@Top) ltrim(rtrim([Name])) + '' [ '' + ltrim(rtrim([Code])) + '' ]'' as Name,[InstrumentId] 
		FROM [dbo].[ib_Instrument]
		WHERE [Name] LIKE @Name + ''%''
		and [Code] LIKE @Code + ''%'' AND IsActive = 1
		ORDER BY [Name]
	END
	ELSE 
	BEGIN
		SELECT TOP (@Top) ltrim(rtrim([Name])) + '' [ '' + ltrim(rtrim([Code])) + '' ]'' as Name,[InstrumentId] 
		FROM [dbo].[ib_Instrument]
		WHERE [Name] LIKE ''%''+@Name + ''%''
		and [Code] Like ''%''+@Code + ''%'' AND IsActive = 1
		ORDER BY [Name]
	END
	/*SELECT [InstrumentId]
		FROM ib_Instrument 
		WHERE ltrim(rtrim([Name])) = @Name
		AND ltrim(rtrim([Code])) = @Code*/
END
ELSE 
BEGIN
	IF @FilterByStartOnly = 1 
	BEGIN
		SELECT TOP (@Top) ltrim(rtrim([Name])) + '' [ '' + ltrim(rtrim([Code])) + '' ]'' as Name,[InstrumentId] 
		FROM [dbo].[ib_Instrument]
		WHERE ([Name] LIKE @Instrument + ''%'' OR [Code] LIKE @Instrument + ''%'') AND IsActive = 1
		ORDER BY [Name]
	END
	ELSE 
	BEGIN
		SELECT TOP (@Top) ltrim(rtrim([Name])) + '' [ '' + ltrim(rtrim([Code])) + '' ]'' as Name,[InstrumentId] 
		FROM [dbo].[ib_Instrument]
		WHERE ([Name] LIKE ''%''+@Instrument + ''%'' OR [Code] LIKE ''%''+ @Instrument + ''%'') AND IsActive = 1
		ORDER BY [Name]
	END
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_BancoSantander_HOSTTRN_V2_Load]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_BancoSantander_HOSTTRN_V2_Load]
	(
		  @LocationPath	varchar(512) = NULL
		, @ReceiveLocationSysId INT
		, @RunId INT
	)
AS
SET NOCOUNT ON
BEGIN

-- Defer Loading to the Master SP
-- 10 Jan 2014		ED			EIB 25004 - remove importLog table and use Log table

EXEC [dbo].[ib_BancoSantander_HOSTTRN_Load]  @LocationPath, @ReceiveLocationSysId, @RunId
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Class_GetClassById]''
');

GO
EXECUTE (' /*
<details>
 <summary> Selects a class from the ib_Class table by its id</summary>
 <created author="Laurentiu Macovei" Date=" Thursday 14 September 2006 9:26PM GMT" /> 
</details>
*/
create PROCEDURE [dbo].[ib_Class_GetClassById]
	@ClassId int
AS
SET NOCOUNT ON
SELECT * FROM [dbo].[ib_Class]
	WHERE ClassID = @ClassID
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_CloseoutReport_MarkVisited]''
');

GO
EXECUTE ('/*
<details>
	<summary> 
		Moves the data from #visitingReportDetails to #visitedItems and deletes all the record from #visitingReportDetails
	</summary>
	<created author="Laurentiu Macovei" Date="Tuesday, 03 October 2006 12:25 GMT" />
</details>
*/

create PROCEDURE [dbo].[ib_CloseoutReport_MarkVisited]
AS
SET NOCOUNT ON
--mark visited rows
INSERT INTO #visitedItems([CloseoutReportDetailId])--, [Description])
	SELECT [CloseoutReportDetailId]--, [Description] 
		FROM #visitingReportDetails
--clean visiting rows
DELETE FROM #visitingReportDetails
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_CloseoutReport_GroupByRule]''
');

GO
EXECUTE ('/*
<details>
	<summary>Filling the #results for a generic CloseOut Rule </summary>
	<created author="Laurentiu Macovei" Date="Tuesday, 03 October 2006" />	
	<updated author="Charles East" Date="17 Jan 1007">
		New feature: Insert and Group By UseNetForCloseOut
	</updated>
</details>
*/

CREATE PROCEDURE [dbo].[ib_CloseoutReport_GroupByRule]

AS
SET NOCOUNT ON

	INSERT INTO #results([ExchangeId], [InstrumentId], [FirmId], 
			[AccountId], [ClassId],
			[ExpiryMonth], [ExpiryYear], [ExpiryDay], 
			[InstrumentTypeId], [OptionTypeCode], [UseNetForCloseOut], 
			[StrikePrice], [TradedBought], [TradedSold],
			[InternalLong], [InternalShort], [ExternalLong],
			[ExternalShort], [Description])
		SELECT	[crd].[ExchangeId], [crd].[InstrumentId], [crd].[FirmId], 
				[crd].[AccountId], [crd].[ClassId],
				[crd].[ExpiryMonth], [crd].[ExpiryYear], [crd].[ExpiryDay], 
				[crd].[InstrumentTypeId], [crd].[OptionTypeCode], [crd].[UseNetForCloseOut], [crd].[StrikePrice],
				SUM([crd].[TradedBought])  [TradedBought], SUM([crd].[TradedSold])  [TradedSold], 
				SUM([crd].[InternalLong])  [InternalLong], SUM([crd].[InternalShort])  [InternalShort], 
				SUM([crd].[ExternalLong])  [ExternalLong], SUM([crd].[ExternalShort])  [ExternalShort],
				[vrd].[Description]
			FROM [dbo].[ib_CloseoutReportDetail] crd
				INNER JOIN #visitingReportDetails vrd ON [crd].[CloseoutReportDetailId] = [vrd].[CloseoutReportDetailId]		
			GROUP BY 
				[crd].[ExchangeId], [crd].[InstrumentId], [crd].[FirmId], 
				[crd].[AccountId], [crd].[ClassId], 
				[crd].[ExpiryMonth], [crd].[ExpiryYear], [crd].[ExpiryDay],
				[crd].[InstrumentTypeId], [crd].[OptionTypeCode], [crd].[UseNetForCloseOut],
				[crd].[StrikePrice], [vrd].[Description]

--mark&move visited rows
EXEC ib_CloseoutReport_MarkVisited
');

GO
EXECUTE ('PRINT N''Creating [dbo].[BancoSantander_HOSTTRN_Add]''
');

GO
EXECUTE ('-- =============================================
-- Author:		A McLeod
-- Create date: 09 Oct 2012
-- Description:	Insert into BancoSantander_HOSTTRN table. Copied from RolfeNolan.
--
-- Revision History
--

-- =============================================
CREATE PROCEDURE [dbo].[BancoSantander_HOSTTRN_Add]
	-- Add the parameters for the stored procedure here
	(
	@Filename				varchar(512)=NULL,
	@Type					varchar(3)=NULL,
	@Serial					varchar(5)=NULL,
	@Ledger					varchar(7)=NULL,
	@FASCurrency			varchar(3)=NULL,
	@Currency				varchar(3)=NULL,
	@BaseCurrency			varchar(3)=NULL,
	@Market					varchar(5)=NULL,
	@MarketCode				varchar(5)=NULL,
	@DummyField				varchar(3)=NULL,
	@RunDate				varchar(8)=NULL,
	@Serial2				varchar(10)=NULL,
	@PromptDate				varchar(8)=NULL,
	@StrikeShort			varchar(21)=NULL,
	@Strike					varchar(21)=NULL,
	@PutCall				varchar(2)=NULL,
	@Lots					varchar(21)=NULL,
	@Price					varchar(21)=NULL,
	@OpenClose				varchar(1)=NULL
    )
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

  INSERT INTO [dbo].[BancoSantander_HOSTTRN]
			( 
				[Filename]
				,[Type]
				,[Serial]
				,[Ledger]
				,[FASCurrency]
				,[Currency]
				,[BaseCurrency]
				,[Market]
				,[MarketCode]
				,[DummyField]
				,[RunDate]
				,[Serial2]
				,[PromptDate]
				,[StrikeShort]
				,[Strike]
				,[PutCall]
				,[Lots]
				,[Price]
				,[OpenClose] 
			)
    VALUES
			( 
				@Filename,
				@Type,
				@Serial,
				@Ledger,
				@FASCurrency,
				@Currency,
				@BaseCurrency,
				@Market,	
				@MarketCode,
				@DummyField,
				@RunDate,
				@Serial2,
				@PromptDate,
				@StrikeShort,
				@Strike,
				@PutCall,
				@Lots,
				@Price,
				@OpenClose
			)
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[GetLastBusinessDayOfTheMonth]''
');

GO
EXECUTE ('CREATE FUNCTION [dbo].[GetLastBusinessDayOfTheMonth]
(
	@Date DATETIME
)
RETURNS DATETIME
AS
BEGIN
-- Description: return last business day of the month
-- 10 Sep 2014  ED  EIB 25943 - created
	DECLARE @NewDate DATETIME
	-- first day of next month
	SET  @NewDate = DATEADD(mm, DATEDIFF(m, 0, @Date) + 1, 0)
	-- get previous business day
	SET @NewDate = dbo.GetPreviousBusinessDay(@NewDate)
	RETURN @NewDate
END

');

GO
EXECUTE ('PRINT N''Creating [dbo].[is_HCollateralSecuritiesMovement_Add]''
');

GO
EXECUTE ('


/*
<Details>
<Summary>Inserts an item into the HCollateralSecuritiesMovement table</Summary>
<Created author="laurentiu.macovei" date="04/05/2006 16:33:06" />
</Details>
*/
CREATE PROCEDURE [dbo].[is_HCollateralSecuritiesMovement_Add]
	@CorporationCode varchar(4) = NULL,
	@PrincipalBrokerageId varchar(1) = NULL,
	@OfficeCode varchar(4) = NULL,
	@ACNo varchar(10) = NULL,
	@SecuritiesId varchar(2) = NULL,
	@BaseDate datetime = NULL,
	@CalcDate datetime = NULL,
	@CalcStartTime datetime = NULL,
	@DepositId varchar(2) = NULL,
	@DateOfDepositWithdrawal datetime = NULL,
	@DepositWithdrawalId varchar(1) = NULL,
	@ProductCode varchar(2) = NULL,
	@CompanyCode varchar(7) = NULL,
	@SeriesNo varchar(4) = NULL,
	@SubSeriesNo varchar(2) = NULL,
	@OldNewId varchar(1) = NULL,
	@DepositDate datetime = NULL,
	@RecordNo varchar(5) = NULL,
	@Quantity decimal(15,0) = NULL,
	@MarketValue decimal(15,0) = NULL,
	@CollateralRate varchar(3) = NULL,
	@UnitValuePerCollateral decimal(15,0) = NULL,
	@EvaluationOfCollatSec decimal(15,0) = NULL,
	@CustodianCode varchar(3) = NULL,
	@DepositaryReceiptNo varchar(5) = NULL,
	@JasdecMemberCode varchar(7) = NULL,
	@DirectCustodian varchar(2) = NULL,
	@CustomerNameAbb varchar(35) = NULL,
	@SecNameInEnglish varchar(28) = NULL,
	@SecNameInKana varchar(24) = NULL
AS
SET NOCOUNT ON

SET NOCOUNT OFF

	DECLARE	@CalcDateStartTime DATETIME

	IF @BaseDate = ''01/01/1900 00:00:00'' 
		SET @BaseDate = NULL

	IF @CalcDate = ''01/01/1900 00:00:00'' 
		SET @CalcDate = NULL

	IF @CalcStartTime = ''01/01/1900 00:00:00'' 
		SET @CalcStartTime = NULL

	IF @DateOfDepositWithdrawal = ''01/01/1900 00:00:00'' 
		SET @DateOfDepositWithdrawal = NULL

	IF @DepositDate = ''01/01/1900 00:00:00'' 
		SET @DepositDate = NULL

	SET @CalcDateStartTime = CONVERT(DATETIME,CONVERT(VARCHAR(12), CONVERT(DATETIME,@CalcDate,112)) + '' '' + CONVERT(VARCHAR(8),RIGHT(@CalcStartTime,8)))

	INSERT INTO is_HCollateralSecuritiesMovement 
		(
			[CorporationCode], 
			[PrincipalBrokerageId], 
			[OfficeCode], 
			[ACNo], 
			[SecuritiesId], 
			[BaseDate], 
			[CalcDate], 
			[CalcStartTime], 
			[CalcDateStartTime], 
			[DepositId], 
			[DateOfDepositWithdrawal], 
			[DepositWithdrawalId], 
			[ProductCode], 
			[CompanyCode], 
			[SeriesNo], 
			[SubSeriesNo], 
			[OldNewId], 
			[DepositDate], 
			[RecordNo], 
			[Quantity], 
			[MarketValue], 
			[CollateralRate], 
			[UnitValuePerCollateral], 
			[EvaluationOfCollatSec], 
			[CustodianCode], 
			[DepositaryReceiptNo], 
			[JasdecMemberCode], 
			[DirectCustodian], 
			[CustomerNameAbb], 
			[SecNameInEnglish], 
			[SecNameInKana]
		) 
	VALUES
		(
			@CorporationCode, 
			@PrincipalBrokerageId, 
			@OfficeCode, 
			@ACNo, 
			@SecuritiesId, 
			@BaseDate, 
			@CalcDate,
			@CalcDateStartTime, 
			@CalcStartTime, 
			@DepositId, 
			@DateOfDepositWithdrawal, 
			@DepositWithdrawalId, 
			@ProductCode, 
			@CompanyCode, 
			@SeriesNo, 
			@SubSeriesNo, 
			@OldNewId, 
			@DepositDate, 
			@RecordNo, 
			@Quantity, 
			@MarketValue, 
			@CollateralRate, 
			@UnitValuePerCollateral, 
			@EvaluationOfCollatSec, 
			@CustodianCode, 
			@DepositaryReceiptNo, 
			@JasdecMemberCode, 
			@DirectCustodian, 
			@CustomerNameAbb, 
			@SecNameInEnglish, 
			@SecNameInKana
		);

Return Scope_Identity()
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Rule_GetOperator]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Rule_GetOperator]
	@fieldId int
AS
SET NOCOUNT ON
	SELECT
		O.Description, 
		OperatorId
	FROM
		ib_Operator O
	INNER JOIN
		ib_Field F ON F.DataTypeId = O.DataTypeId AND F.FieldId = @fieldId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[Broker_Position]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[Broker_Position]
(
[Broker_PositionID] [int] NOT NULL IDENTITY(1, 1),
[Serial_Number] [varchar] (11) NULL,
[Account] [varchar] (35) NULL,
[Currency] [varchar] (3) NULL,
[Market] [varchar] (5) NULL,
[Instrument_Code] [varchar] (50) NULL,
[Delivery_Month] [varchar] (8) NULL,
[Trade_Type] [varchar] (3) NULL,
[Option_Series] [varchar] (5) NULL,
[Opt_Dec_Date] [varchar] (8) NULL,
[Open_Close] [varchar] (1) NULL,
[Trade_Date] [varchar] (8) NULL,
[Cash_Val_Date] [varchar] (8) NULL,
[Sec_Val_Date] [varchar] (8) NULL,
[Lots] [varchar] (21) NULL,
[Lot_Size] [varchar] (21) NULL,
[Premium_Price] [varchar] (21) NULL,
[Premium_Value] [varchar] (21) NULL,
[Trade_Price] [varchar] (21) NULL,
[Settle_Price] [varchar] (21) NULL,
[Margin] [varchar] (21) NULL,
[In_Or_Out] [varchar] (3) NULL,
[In_Or_Out_Val] [varchar] (21) NULL,
[Commis_Rate] [varchar] (21) NULL,
[Commis_Curr] [varchar] (3) NULL,
[Commis_Val] [varchar] (21) NULL,
[Tax] [varchar] (21) NULL,
[Traded_Price_Val] [varchar] (21) NULL,
[Mark_To_Market_Val] [varchar] (21) NULL,
[Underlying_Price] [varchar] (21) NULL,
[Underlying_Val] [varchar] (21) NULL,
[Exercise_Val] [varchar] (21) NULL,
[Exercise_Lots] [varchar] (21) NULL,
[Pay_Hold] [varchar] (21) NULL,
[Post_Commis_Upfront] [varchar] (21) NULL,
[Last_Traded_Date] [varchar] (8) NULL,
[Inst_Desc] [varchar] (100) NULL,
[Exercise_Asn] [varchar] (2) NULL,
[Yest_Settle_Price] [varchar] (21) NULL,
[Yest_Martom_Val] [varchar] (21) NULL,
[Commod_Short_Descr] [varchar] (10) NULL,
[Dec_Time] [varchar] (8) NULL,
[Posted_Marktom] [varchar] (8) NULL,
[Run_Date] [varchar] (8) NULL,
[Rec_Type] [varchar] (3) NULL,
[Acn] [varchar] (5) NULL,
[FileName] [varchar] (512) NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_Broker_Position_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_Broker_Position_CreateDate] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_Broker_Position] on [dbo].[Broker_Position]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[Broker_Position] ADD CONSTRAINT [PK_Broker_Position] PRIMARY KEY CLUSTERED  ([Broker_PositionID])
');

GO
EXECUTE ('PRINT N''Creating index [IX_Broker_Position_Filename] on [dbo].[Broker_Position]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_Broker_Position_Filename] ON [dbo].[Broker_Position] ([FileName]) INCLUDE ([Broker_PositionID], [CreateDate])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Broker_Position_Load]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Broker_Position_Load] 
	(
		@LocationPath VARCHAR(100) = NULL
		,@ReceiveLocationSysId INT = NULL
		,@RunId INT = NULL
	)
AS
SET NOCOUNT ON

-- Description:	This stored procedure pulls data from the Broker_Position temp
-- table and inserts it into ib_Position
-- Whilst iterating through the records in Broker_Position, all 
-- of these inserts are wrapped in a transaction so that any failure causes
-- the changes to not commit.

-- 13 May 2009	petru	Creation
-- 24 Feb 2010	amk		MBAL-14804 use run date instead of trade date
--						MBAL-14819 use filename in query and update
-- 25 Feb 2010	amk		MBAL-14839 use margin instead of mark_to_market_val
--						MBAL-14836 adjust transaction isolation level
-- 23 Mar 2010	AAJM	Add QuantityLong and QuantityShort for populating ib_Position
-- 22 Apr 2010	AAJM	MBAL-14741 Save settlement prices from Settle_Price
-- 02 Jun 2010  ED      MBAL-15687 populate ib_ImportFile.AsOfDate
-- 11 Aug 2010	amk		MBAL-16427 stop duplicate files
-- 04 Mar 2011	amk		MBAL-17736 BUG FIX - can''t do any writes if err caught and xact_state is -1
--						raise proper error and abort
-- 09 Jan 2014	ED		EIB 25004 - remove importLog table and use Log table

CREATE TABLE #temp1
	(
		Broker_PositionID		int,
		Account					varchar(35),
		Currency				varchar(3),
		Market					varchar(5),
		Instrument_Code			varchar(50),
		Delivery_Month			varchar(8),
		Trade_Type				varchar(3),
		Option_Series			varchar(5),
		Trade_Date				varchar(8),
		Lots					varchar(21),
		Mark_To_Market_Val		varchar(21),
		Run_Date				varchar(8),
		Margin					VARCHAR(21),
		Settle_Price			VARCHAR(21)
	)

	DECLARE @DataSourceCd varchar(100)
	DECLARE @FirmCd varchar(100)

	SET @DataSourceCd = ''Broker''
	SET @FirmCd = ''Broker''

	IF @LocationPath Like ''%Barclays%'' 
	BEGIN
		SET @DataSourceCd = ''Barclays''
		SET @FirmCd = ''Barclays''
	END

	DECLARE @Output int
	DECLARE @Output2 int
	DECLARE @ReturnValue int
	DECLARE @DataSourceId int

	IF @LocationPath IS NULL SET @LocationPath = @DataSourceCd
	EXEC @ReturnValue= [_ib_DataSource_GetByCodeForOutput] @DataSourceCd, @OutPut output, @Output2 output
	SET @DataSourceId = @Output

	-- Duplicate file check										
	DECLARE @IsFileAlreadyLoaded INT
	EXEC @IsFileALreadyLoaded = HasFileBeenLoaded @LocationPath, @DataSourceId

	IF @IsFileAlreadyLoaded = 1
	BEGIN
		UPDATE [Broker_Position]
		SET LoadState = 3
		WHERE LoadState = 1
			AND FileName = @LocationPath -- Is there a Filename column?
		
		RETURN
	END
	
	-- Store ImportFile record to be associated with Settlement Price load
	DECLARE @ImportFileId INT
	EXEC ib_ImportFile_Add @DataSourceId, @LocationPath, @ImportFileId output
	DECLARE @SelectedAsOfDate DATETIME
	INSERT INTO #temp1
	(
		Broker_PositionID,
		Account,
		Currency,
		Market,
		Instrument_Code,
		Delivery_Month,
		Trade_Type,
		Option_Series,
		Trade_Date,
		Lots,
		Mark_To_Market_Val,
		Run_Date,
		Margin,
		Settle_Price
	)
	SELECT 	
		Broker_PositionID,
		Account,
		Currency,
		Market,
		Instrument_Code,
		Delivery_Month,
		Trade_Type,
		Option_Series,
		Trade_Date,
		Lots,
		Mark_To_Market_Val,
		Run_Date,
		Margin,
		Settle_Price
	FROM [dbo].[Broker_Position]
	WHERE LoadState = 1
		AND [Filename] = @LocationPath

	BEGIN TRAN T1

			-- BizTalk''s SQL Adapter uses more restrictive read serializable
			-- so this is necessary to relax it to something that is default
			-- and perfectly acceptable!
			SET TRANSACTION ISOLATION LEVEL READ COMMITTED

			DECLARE @Broker_PositionID			int
			DECLARE @Account					varchar(35)
			DECLARE @Currency					varchar(3)
			DECLARE @Market						varchar(5)
			DECLARE @Instrument_Code			varchar(50)
			DECLARE @Delivery_Month				varchar(8)
			DECLARE @Trade_Type					varchar(3)
			DECLARE @Option_Series				varchar(5)
			DECLARE @Trade_Date					varchar(8)
			DECLARE @Run_Date					varchar(8)
			DECLARE @Lots						varchar(21)
			DECLARE @Mark_To_Market_Val			varchar(21)
			DECLARE @Margin						varchar(21)
			DECLARE @Settle_Price				varchar(21)

			DECLARE pos_cursor CURSOR FOR
			SELECT	Broker_PositionID,
					account,
					currency,
					market,
					instrument_code,
					delivery_month,
					trade_type,
					option_series,
					trade_date,
					lots,
					mark_to_market_val,
					run_date,
					margin,
					Settle_Price
			FROM	#temp1

			OPEN pos_cursor

			FETCH NEXT FROM pos_cursor
			INTO 
					@Broker_PositionID,
					@Account,
					@Currency,
					@Market,
					@Instrument_Code,
					@Delivery_Month,
					@Trade_Type,
					@Option_Series,
					@Trade_Date,
					@Lots,
					@Mark_To_Market_Val,
					@Run_Date,
					@Margin,
					@Settle_Price

				-- Check @@FETCH_STATUS to see IF there are any more rows to fetch.
				WHILE @@FETCH_STATUS = 0
				BEGIN
					DECLARE		@AccountCd				varchar(100)
					DECLARE		@ExchangeCd				varchar(25)
					DECLARE		@AsOfDate				datetime
					DECLARE		@InstrumentCd			varchar(100)
					DECLARE		@Quantity				decimal(19,4)
					DECLARE		@MarketValue			decimal(19,4)
					DECLARE		@ExpYr					smallint
					DECLARE		@ExpMth					smallint
					DECLARE		@ExpDay					smallint
					DECLARE		@StrikePrice			decimal(19,4)
					DECLARE		@PriceDivisor			DECIMAL(19,4)
					DECLARE		@TrxTypeCd				varchar(25)
					DECLARE		@OptionTypeCd			varchar(25)
					DECLARE		@TrxDate				datetime
					DECLARE		@InstrumentTypeCd		varchar(100)
					DECLARE     @ErrorMessageForRecord	varchar(1024)
					DECLARE		@ErrorSeverity			INT
					DECLARE		@ErrorState				INT
					DECLARE		@QuantityLong			decimal(19,4)
					DECLARE		@QuantityShort			decimal(19,4)
					
					-- Temporary variables
                    DECLARE     @TempDate datetime
					DECLARE 	@Code varchar(100), @Code2 varchar(100)
					
			SET @AccountCd = @Account
			SET @StrikePrice = NULL
			SET	@ExchangeCd = @Market

			SET @InstrumentCd = @Instrument_Code 

			-- ExpiryDate = PromptDate, PromptDate is in yyyymmdd ISO 112 format
			BEGIN TRY
				SET @TempDate = CONVERT(datetime, @Delivery_Month, 112)
				SET @ExpYr = DATEPART(yyyy, @TempDate)
				SET @ExpMth = DATEPART(mm, @TempDate)			
				SET @ExpDay = DATEPART(dd, @TempDate)
			END TRY
			BEGIN CATCH
				SELECT @ErrorMessageForRecord = ERROR_MESSAGE()
					, @ErrorSeverity = ERROR_SEVERITY()
					, @ErrorState = ERROR_STATE()
				IF XACT_STATE() = -1
					BEGIN
						-- transaction must get rolled back so need to fail this whole operation
						-- rollback seems to work whether or not xact_abort is on
						ROLLBACK TRANSACTION

						-- Use RAISERROR inside the CATCH block to return error
						-- information about the original error that caused
						-- execution to jump to the CATCH block.
						RAISERROR (@ErrorMessageForRecord, @ErrorSeverity, @ErrorState);
						RETURN	-- can''t do any writes so no point continuing (otherwise need to check every write / commit)
					END
				ELSE
					EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @ErrorMessageForRecord, ''Success'', @Broker_PositionID, @RunId
			END CATCH
				
			-- Set the OptionTypeCode - From Trade Type (FT=Future, TP=Put TC=Call)
			IF @Trade_Type = ''FT'' 
			   BEGIN
					SET @OptionTypeCd = ''Future''
					-- InstrumentTypeCd
					SET @InstrumentTypeCd = ''F''			
			   END
			ELSE IF @Trade_Type <> ''FT''
				BEGIN
					-- StrikePrice = Series, Series have a value only for TP and TC Trade types.
					IF ISNUMERIC(@Option_Series) > 0 
									SET @StrikePrice = CONVERT(decimal(19,4), @Option_Series)
                        
					-- The InstrumentTypeCd value is based on the TradeType value
					-- We want to make sure that only in the case the TradeType value is correct we also set the InstrumentTypeCd value
					IF @Trade_Type = ''TP''
						BEGIN		
							SET @OptionTypeCd = ''P''
							SET @InstrumentTypeCd = ''O''
						END
					ELSE IF @Trade_Type = ''TC''
						BEGIN	
							SET @OptionTypeCd = ''C''
							SET @InstrumentTypeCd = ''O''
						END
				END
			
			-- We prefix the Instruments with the IntrumentTypeCode
			SET @InstrumentCd = @InstrumentTypeCd + @InstrumentCd 			

			-- Get Divisors
			SELECT @PriceDivisor = PriceDivisor
			FROM [dbo].[ib_InstrumentDataSource]
			WHERE DataSourceId = @DataSourceId
				AND DataSourceInstrumentCode = @InstrumentCd 	

			-- Set Settlement Price				
			IF @PriceDivisor IS NULL 
				SET @PriceDivisor = 1
					
			DECLARE @SettlementPrice DECIMAL(24,10)
			SET @SettlementPrice = CONVERT(DECIMAL(24,10), @Settle_Price) / @PriceDivisor
			
			-- Quantity = Lots
			SET @Quantity = 0
			SET @QuantityLong = 0
			SET @QuantityShort = 0
			
			IF ISNUMERIC(@Lots) > 0 
			BEGIN
					SET @Quantity = CONVERT(decimal(19,4), @Lots)

					-- Set QuantityLong and QuantityShort
					IF (@Quantity >= 0) -- Long
						BEGIN
							SET @QuantityLong = @Quantity
							SET @QuantityShort = 0
						END
					ELSE	-- Short
						BEGIN
							SET @QuantityShort = ABS(@Quantity)
							SET @QuantityLong = 0
						END
			END
			-- MarketValue = Lots * Price
			IF ISNUMERIC(@Margin) > 0
				BEGIN
					SET @MarketValue = CONVERT(decimal(19,4), @Margin)
				END

			SET @TrxTypeCd = ''POSITION''

			-- TrxDate
			SET @TrxDate = getdate()

			-- AsOfDate
			BEGIN TRY
				SET @AsOfDate = CONVERT(datetime, @Run_Date, 112)
				SET @SelectedAsOfDate = @AsOfDate
			END TRY
			BEGIN CATCH
				SELECT @ErrorMessageForRecord = ERROR_MESSAGE()
					, @ErrorSeverity = ERROR_SEVERITY()
					, @ErrorState = ERROR_STATE()
				IF XACT_STATE() = -1
					BEGIN
						-- transaction must get rolled back so need to fail this whole operation
						-- rollback seems to work whether or not xact_abort is on
						ROLLBACK TRANSACTION

						-- Use RAISERROR inside the CATCH block to return error
						-- information about the original error that caused
						-- execution to jump to the CATCH block.
						RAISERROR (@ErrorMessageForRecord, @ErrorSeverity, @ErrorState);
						RETURN	-- can''t do any writes so no point continuing (otherwise need to check every write / commit)
					END
				ELSE
					EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @ErrorMessageForRecord, ''Success'', @Broker_PositionID, @RunId

			END CATCH
			
			DECLARE @PositionId INT
			SET @PositionId = NULL
			
			EXEC [ib_Position_Load]
			@DataSourceCd,			
			@ExchangeCd,				
			@FirmCd,					
			@AccountCd,				
			@AsOfDate,				
			@InstrumentCd,			
			@Quantity,				
			@MarketValue,			
			@ExpYr,					
			@ExpMth,					
			@ExpDay,					
			@StrikePrice,			
			@TrxTypeCd,				
			@OptionTypeCd,			
			@TrxDate,				
			0,		-- This value is not used in the ib_Position_Load Stored Procedure, should be removed ?			
			@Broker_PositionID,
			@InstrumentTypeCd,		
			@LocationPath,
			@Currency,
			@LongQuantity = @QuantityLong,
			@ShortQuantity = @QuantityShort,
			@PositionId = @PositionId output, 
			@ReceiveLocationSysId = @ReceiveLocationSysId,
			@RunId = @RunId
			
			-- Add Settlement Price											
			EXEC ib_Price_AddFromPositionLoad
				@PositionId
				, @ImportFileId
				, @SettlementPrice 	
				
			--flip processed flag in source table.
			UPDATE [Broker_Position]
			SET [LoadState] = 2
			WHERE [Broker_PositionID] = @Broker_PositionID
				AND [LoadState] = 1

			FETCH NEXT FROM pos_cursor
			INTO 
					@Broker_PositionID,
					@Account,
					@Currency,
					@Market,
					@Instrument_Code,
					@Delivery_Month,
					@Trade_Type,
					@Option_Series,
					@Trade_Date,
					@Lots,
					@Mark_To_Market_Val,
					@Run_Date,
					@Margin,
					@Settle_Price

		END
			
			CLOSE pos_cursor
			DEALLOCATE pos_cursor

			UPDATE ib_ImportFile 
			SET AsOfDate = @SelectedAsOfDate 
			WHERE ImportFileId = @ImportFileId
			
		COMMIT TRAN T1

	DROP TABLE #temp1
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Class_GetClassCodesHintByKeyword]''
');

GO
EXECUTE ('
/*
<details>
 <summary> Returns the Classes hint for a specific code /summary>
 <created author="shilin" date="22 Feb 2011"/>  
 <tasks>
 </tasks>
</details>
*/
CREATE PROCEDURE [dbo].[ib_Class_GetClassCodesHintByKeyword]
@ClassCode varchar(100),
@HintByStartOnly bit = 0,
@HintLength int = 1
AS
SET NOCOUNT ON

DECLARE @len int
SET @len = LEN(@ClassCode)
IF @HintByStartOnly = 1
BEGIN
	SELECT DISTINCT SUBSTRING ([Code], @len, @HintLength) x
		FROM [dbo].[ib_Class]
		WHERE [Code] LIKE @ClassCode+''%''
		ORDER BY x

END
ELSE
BEGIN
	SELECT DISTINCT SUBSTRING ([Code], PATINDEX(''%''+@ClassCode+''%'', [Code]) + @len, @HintLength) x
		FROM [dbo].[ib_Class]
		WHERE [Code] LIKE ''%''+@ClassCode+''%''
		ORDER BY x
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[BancoSantander_HOSTTRN_LoadStateChange]''
');

GO
EXECUTE ('

-- =============================================
-- Author:		A McLeod
-- Create date: 09 Oct 2012
-- Description:	Copied from RolfeNolan. Changes the LoadState of the BancoSantander_HOSTTRN type table
-- =============================================
CREATE PROCEDURE [dbo].[BancoSantander_HOSTTRN_LoadStateChange] 
	-- Add the parameters for the stored procedure here
	(
		@OldLoadState	TINYINT,
		@NewLoadState	TINYINT,
		@RecordDate		DATETIME = NULL
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

		UPDATE [dbo].[BancoSantander_HOSTTRN] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[is_HProductTotal_Add]''
');

GO
EXECUTE ('



/*
<Details>
<Summary>Inserts an item into the HProductTotal table</Summary>
<Created author="laurentiu.macovei" date="04/05/2006 16:33:06" />
</Details>
*/
CREATE PROCEDURE [dbo].[is_HProductTotal_Add]
	@CorporationCode varchar(4) = NULL,
	@PrincipalBrokerageId varchar(1) = NULL,
	@OfficeCode varchar(4) = NULL,
	@ACNo varchar(10) = NULL,
	@SecuritiesId varchar(2) = NULL,
	@BaseDate datetime = NULL,
	@CalcDate datetime = NULL,
	@CalcStartTime datetime = NULL,
	@DerivativesCode varchar(10) = NULL,
	@QuantityOfBuyContract Decimal(10,0) = NULL,
	@QuantityOfSellContract Decimal(10,0) = NULL,
	@UnrealizedPLSign varchar(1) = NULL,
	@UnrealizedPL decimal(15,0) = NULL,
	@UnrealizedPLNonCalculableFlag varchar(1) = NULL,
	@AdjForThePreviousDaySTradeSign varchar(1) = NULL,
	@AdjForThePreviousDaySTrade decimal(15,0) = NULL,
	@AdjFuturesRealizedPLSign varchar(1) = NULL,
	@AdjFuturesRealizedPL decimal(15,0) = NULL,
	@AdjOptPremiumBuySign varchar(1) = NULL,
	@AdjOptPremiumBuy decimal(15,0) = NULL,
	@AdjOptPremiumSellSign varchar(1) = NULL,
	@AdjOptPremiumSell decimal(15,0) = NULL,
	@AdjNetStrikePriceOptExerciseSign varchar(1) = NULL,
	@AdjNetStrikePriceOptExercise decimal(15,0) = NULL,
	@AdjNetStrikePriceOptAssignmentSign varchar(1) = NULL,
	@AdjNetStrikePriceOptAssignment decimal(15,0) = NULL,
	@AdjCommissionSign varchar(1) = NULL,
	@AdjCommission decimal(15,0) = NULL,
	@AdjConsumptionTaxSign varchar(1) = NULL,
	@AdjConsumptionTax decimal(15,0) = NULL,
	@AdjExchangeTaxSign varchar(1) = NULL,
	@AdjExchangeTax decimal(15,0) = NULL,
	@SettlementAmntFromTradesSign varchar(1) = NULL,
	@SettlementAmntFromTrades decimal(15,0) = NULL,
	@FuturesRealizedPLOTDSign varchar(1) = NULL,
	@FuturesRealizedPLOTD decimal(15,0) = NULL,
	@OptPremiumOTDBuySign varchar(1) = NULL,
	@OptPremiumOTDBuy decimal(15,0) = NULL,
	@OptPremiumOTDSellSign varchar(1) = NULL,
	@OptPremiumOTDSell decimal(15,0) = NULL,
	@NetStrikePOTDOptExerciseSign varchar(1) = NULL,
	@NetStrikePOTDOptExercise decimal(15,0) = NULL,
	@NetStrikePOTDOptAssignmentSign varchar(1) = NULL,
	@NetStrikePOTDOptAssignment decimal(15,0) = NULL,
	@CommissionOTDSign varchar(1) = NULL,
	@CommissionOTD decimal(15,0) = NULL,
	@ConsumptionTaxOTDSign varchar(1) = NULL,
	@ConsumptionTaxOTD decimal(15,0) = NULL,
	@ExchangeTaxOTDSign varchar(1) = NULL,
	@ExchangeTaxOTD decimal(15,0) = NULL,
	@SecNameInEnglish varchar(28) = NULL,
	@SecNameInKana varchar(24) = NULL,
	@BuyOptValue decimal(15,0) = NULL,
	@SellOptValue decimal(15,0) = NULL
AS
SET NOCOUNT ON

SET NOCOUNT OFF

	DECLARE	@CalcDateStartTime						DATETIME
	DECLARE @UnrealizedPLSigned						DECIMAL(15,0)
	DECLARE @AdjForThePreviousDaySTradeSigned		DECIMAL(15,0)
	DECLARE @AdjFuturesRealizedPLSigned				DECIMAL(15,0)
	DECLARE @AdjOptPremiumBuySigned					DECIMAL(15,0)
	DECLARE @AdjOptPremiumSellSigned				DECIMAL(15,0)
	DECLARE @AdjNetStrikePriceOptExerciseSigned		DECIMAL(15,0)
	DECLARE @AdjNetStrikePriceOptAssignmentSigned	DECIMAL(15,0)
	DECLARE @AdjCommissionSigned					DECIMAL(15,0)
	DECLARE @AdjConsumptionTaxSigned				DECIMAL(15,0)
	DECLARE @AdjExchangeTaxSigned					DECIMAL(15,0)
	DECLARE @SettlementAmntFromTradesSigned			DECIMAL(15,0)
	DECLARE @FuturesRealizedPLOTDSigned				DECIMAL(15,0)
	DECLARE @OptPremiumOTDBuySigned					DECIMAL(15,0)
	DECLARE @OptPremiumOTDSellSigned				DECIMAL(15,0)
	DECLARE @NetStrikePOTDOptExerciseSigned			DECIMAL(15,0)
	DECLARE @NetStrikePOTDOptAssignmentSigned		DECIMAL(15,0)
	DECLARE @CommissionOTDSigned					DECIMAL(15,0)
	DECLARE @ConsumptionTaxOTDSigned				DECIMAL(15,0)
	DECLARE @ExchangeTaxOTDSigned					DECIMAL(15,0)



	IF @BaseDate = ''01/01/1900 00:00:00'' 
		SET @BaseDate = NULL

	IF @CalcDate = ''01/01/1900 00:00:00'' 
		SET @CalcDate = NULL

	IF @CalcStartTime = ''01/01/1900 00:00:00'' 
		SET @CalcStartTime = NULL

	SET @CalcDateStartTime = CONVERT(DATETIME,CONVERT(VARCHAR(12), CONVERT(DATETIME,@CalcDate,112)) + '' '' + CONVERT(VARCHAR(8),RIGHT(@CalcStartTime,8)))

	IF @UnrealizedPLSign = ''-'' 	
		SET @UnrealizedPLSigned = @UnrealizedPL * -1 
	ELSE	
		SET @UnrealizedPLSigned = @UnrealizedPL

	IF @AdjForThePreviousDaySTradeSign = ''-'' 	
		SET @AdjForThePreviousDaySTradeSigned = @AdjForThePreviousDaySTrade * -1 
	ELSE	
		SET @AdjForThePreviousDaySTradeSigned = @AdjForThePreviousDaySTrade

	IF @AdjFuturesRealizedPLSign = ''-'' 	
		SET @AdjFuturesRealizedPLSigned = @AdjFuturesRealizedPL * -1 
	ELSE	
		SET @AdjFuturesRealizedPLSigned = @AdjFuturesRealizedPL

	IF @AdjOptPremiumBuySign = ''-'' 	
		SET @AdjOptPremiumBuySigned = @AdjOptPremiumBuy * -1 
	ELSE	
		SET @AdjOptPremiumBuySigned = @AdjOptPremiumBuy

	IF @AdjOptPremiumSellSign = ''-'' 	
		SET @AdjOptPremiumSellSigned = @AdjOptPremiumSell * -1 
	ELSE	
		SET @AdjOptPremiumSellSigned = @AdjOptPremiumSell

	IF @AdjNetStrikePriceOptExerciseSign = ''-'' 	
		SET @AdjNetStrikePriceOptExerciseSigned = @AdjNetStrikePriceOptExercise * -1 
	ELSE	
		SET @AdjNetStrikePriceOptExerciseSigned = @AdjNetStrikePriceOptExercise

	IF @AdjNetStrikePriceOptAssignmentSign = ''-'' 	
		SET @AdjNetStrikePriceOptAssignmentSigned = @AdjNetStrikePriceOptAssignment * -1 
	ELSE	
		SET @AdjNetStrikePriceOptAssignmentSigned = @AdjNetStrikePriceOptAssignment

	IF @AdjCommissionSign = ''-'' 	
		SET @AdjCommissionSigned = @AdjCommission * -1 
	ELSE	
		SET @AdjCommissionSigned = @AdjCommission

	IF @AdjConsumptionTaxSign = ''-'' 	
		SET @AdjConsumptionTaxSigned = @AdjConsumptionTax * -1 
	ELSE	
		SET @AdjConsumptionTaxSigned = @AdjConsumptionTax

	IF @AdjExchangeTaxSign = ''-'' 	
		SET @AdjExchangeTaxSigned = @AdjExchangeTax * -1 
	ELSE	
		SET @AdjExchangeTaxSigned = @AdjExchangeTax

	IF @SettlementAmntFromTradesSign = ''-'' 	
		SET @SettlementAmntFromTradesSigned = @SettlementAmntFromTrades * -1 
	ELSE	
		SET @SettlementAmntFromTradesSigned = @SettlementAmntFromTrades

	IF @AdjExchangeTaxSign = ''-'' 	
		SET @AdjExchangeTaxSigned = @AdjExchangeTax * -1 
	ELSE	
		SET @AdjExchangeTaxSigned = @AdjExchangeTax

	IF @FuturesRealizedPLOTDSign = ''-'' 	
		SET @FuturesRealizedPLOTDSigned = @FuturesRealizedPLOTD * -1 
	ELSE	
		SET @FuturesRealizedPLOTDSigned = @FuturesRealizedPLOTD

	IF @OptPremiumOTDBuySign = ''-'' 	
		SET @OptPremiumOTDBuySigned = @OptPremiumOTDBuy * -1 
	ELSE	
		SET @OptPremiumOTDBuySigned = @OptPremiumOTDBuy

	IF @OptPremiumOTDSellSign = ''-'' 	
		SET @OptPremiumOTDSellSigned = @OptPremiumOTDSell * -1 
	ELSE	
		SET @OptPremiumOTDSellSigned = @OptPremiumOTDSell

	IF @NetStrikePOTDOptExerciseSign = ''-'' 	
		SET @NetStrikePOTDOptExerciseSigned = @NetStrikePOTDOptExercise * -1 
	ELSE	
		SET @NetStrikePOTDOptExerciseSigned = @NetStrikePOTDOptExercise

	IF @NetStrikePOTDOptAssignmentSign = ''-'' 	
		SET @NetStrikePOTDOptAssignmentSigned = @NetStrikePOTDOptAssignment * -1 
	ELSE	
		SET @NetStrikePOTDOptAssignmentSigned = @NetStrikePOTDOptAssignment
	
	IF @CommissionOTDSign = ''-'' 	
		SET @CommissionOTDSigned = @CommissionOTD * -1 
	ELSE	
		SET @CommissionOTDSigned = @CommissionOTD

	IF @ConsumptionTaxOTDSign = ''-'' 	
		SET @ConsumptionTaxOTDSigned = @ConsumptionTaxOTD * -1 
	ELSE	
		SET @ConsumptionTaxOTDSigned = @ConsumptionTaxOTD
	
	IF @ExchangeTaxOTDSign = ''-'' 	
		SET @ExchangeTaxOTDSigned = @ExchangeTaxOTD * -1 
	ELSE	
		SET @ExchangeTaxOTDSigned = @ExchangeTaxOTD


	INSERT INTO is_HProductTotal 
		(
			[CorporationCode], 
			[PrincipalBrokerageId], 
			[OfficeCode], 
			[ACNo], 
			[SecuritiesId], 
			[BaseDate], 
			[CalcDate], 
			[CalcStartTime], 
			[CalcDateStartTime], 
			[DerivativesCode], 
			[QuantityOfBuyContract], 
			[QuantityOfSellContract], 
			[UnrealizedPLSign], 
			[UnrealizedPL], 
			[UnrealizedPLSigned],
			[UnrealizedPLNonCalculableFlag], 
			[AdjForThePreviousDaySTradeSign], 
			[AdjForThePreviousDaySTradeSigned],
			[AdjForThePreviousDaySTrade], 
			[AdjFuturesRealizedPLSign], 
			[AdjFuturesRealizedPL], 
			[AdjFuturesRealizedPLSigned],
			[AdjOptPremiumBuySign], 
			[AdjOptPremiumBuy], 
			[AdjOptPremiumBuySigned], 
			[AdjOptPremiumSellSign], 
			[AdjOptPremiumSell], 
			[AdjOptPremiumSellSigned],
			[AdjNetStrikePriceOptExerciseSign], 
			[AdjNetStrikePriceOptExercise], 
			[AdjNetStrikePriceOptExerciseSigned], 
			[AdjNetStrikePriceOptAssignmentSign], 
			[AdjNetStrikePriceOptAssignment], 
			[AdjNetStrikePriceOptAssignmentSigned],
			[AdjCommissionSign], 
			[AdjCommission], 
			[AdjCommissionSigned], 
			[AdjConsumptionTaxSign], 
			[AdjConsumptionTax], 
			[AdjConsumptionTaxSigned], 
			[AdjExchangeTaxSign], 
			[AdjExchangeTax], 
			[AdjExchangeTaxSigned], 
			[SettlementAmntFromTradesSign], 
			[SettlementAmntFromTrades], 
			[SettlementAmntFromTradesSigned],
			[FuturesRealizedPLOTDSign], 
			[FuturesRealizedPLOTD], 
			[FuturesRealizedPLOTDSigned], 
			[OptPremiumOTDBuySign], 
			[OptPremiumOTDBuy], 
			[OptPremiumOTDBuySigned], 
			[OptPremiumOTDSellSign], 
			[OptPremiumOTDSell], 
			[OptPremiumOTDSellSigned],
			[NetStrikePOTDOptExerciseSign], 
			[NetStrikePOTDOptExercise], 
			[NetStrikePOTDOptExerciseSigned],
			[NetStrikePOTDOptAssignmentSign], 
			[NetStrikePOTDOptAssignment], 
			[NetStrikePOTDOptAssignmentSigned],
			[CommissionOTDSign], 
			[CommissionOTD], 
			[CommissionOTDSigned], 
			[ConsumptionTaxOTDSign], 
			[ConsumptionTaxOTD], 
			[ConsumptionTaxOTDSigned],
			[ExchangeTaxOTDSign], 
			[ExchangeTaxOTD], 
			[ExchangeTaxOTDSigned], 
			[SecNameInEnglish], 
			[SecNameInKana], 
			[BuyOptValue], 
			[SellOptValue]
		) 
	VALUES
		(	
			@CorporationCode, 
			@PrincipalBrokerageId, 
			@OfficeCode, 
			@ACNo, 
			@SecuritiesId, 
			@BaseDate, 
			@CalcDate, 
			@CalcStartTime, 
			@CalcDateStartTime, 
			@DerivativesCode, 
			@QuantityOfBuyContract, 
			@QuantityOfSellContract, 
			@UnrealizedPLSign, 
			@UnrealizedPL, 
			@UnrealizedPLSigned,
			@UnrealizedPLNonCalculableFlag, 
			@AdjForThePreviousDaySTradeSign, 
			@AdjForThePreviousDaySTrade, 
			@AdjForThePreviousDaySTradeSigned,
			@AdjFuturesRealizedPLSign, 
			@AdjFuturesRealizedPL, 
			@AdjFuturesRealizedPLSigned,
			@AdjOptPremiumBuySign, 
			@AdjOptPremiumBuy, 
			@AdjOptPremiumBuySigned,
			@AdjOptPremiumSellSign, 
			@AdjOptPremiumSell, 
			@AdjOptPremiumSellSigned, 
			@AdjNetStrikePriceOptExerciseSign, 
			@AdjNetStrikePriceOptExercise, 
			@AdjNetStrikePriceOptExerciseSigned, 
			@AdjNetStrikePriceOptAssignmentSign, 
			@AdjNetStrikePriceOptAssignment, 
			@AdjNetStrikePriceOptAssignmentSigned,
			@AdjCommissionSign, 
			@AdjCommission, 
			@AdjCommissionSigned, 
			@AdjConsumptionTaxSign, 
			@AdjConsumptionTax, 
			@AdjConsumptionTaxSigned,
			@AdjExchangeTaxSign, 
			@AdjExchangeTax, 
			@AdjExchangeTaxSigned, 
			@SettlementAmntFromTradesSign, 
			@SettlementAmntFromTrades, 
			@SettlementAmntFromTradesSigned, 
			@FuturesRealizedPLOTDSign, 
			@FuturesRealizedPLOTD, 
			@FuturesRealizedPLOTDSigned, 
			@OptPremiumOTDBuySign, 
			@OptPremiumOTDBuy, 
			@OptPremiumOTDBuySigned, 
			@OptPremiumOTDSellSign, 
			@OptPremiumOTDSell, 
			@OptPremiumOTDSellSigned,
			@NetStrikePOTDOptExerciseSign, 
			@NetStrikePOTDOptExercise, 
			@NetStrikePOTDOptExerciseSigned, 
			@NetStrikePOTDOptAssignmentSign, 
			@NetStrikePOTDOptAssignment, 
			@NetStrikePOTDOptAssignmentSigned,
			@CommissionOTDSign, 
			@CommissionOTD, 
			@CommissionOTDSigned, 	
			@ConsumptionTaxOTDSign, 
			@ConsumptionTaxOTD, 
			@ConsumptionTaxOTDSigned,
			@ExchangeTaxOTDSign, 
			@ExchangeTaxOTD, 
			@ExchangeTaxOTDSigned, 			
			@SecNameInEnglish, 
			@SecNameInKana, 
			@BuyOptValue, 
			@SellOptValue
		);

Return Scope_Identity()
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Rule_GetRuleById]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Rule_GetRuleById] ( @RuleId INT )
AS 
SET NOCOUNT ON

SELECT
    r.[RuleId]
   ,r.[RuleTypeId]
   ,RT.[Description] AS [RuleTypeDescription]
   
   ,r.[TemplateId]
   ,T.Description AS [TemplateIdDescription]
   ,r.[RuleNumber]
   
   ,r.[Name]
   ,r.[Description]
   
   ,r.[MatchCountTypeId]
   ,MT.Description AS [MatchCountTypeIdDescription]
   
   ,TT.ToleranceTypeId
   ,TT.[Description] AS [ToleranceTypeIdDescription]
   ,r.Tolerance
   ,r.[IsEnabled]
   
   ,r.[CreateDate]
   ,r.[CreateUsername]
   ,r.[UpdateDate]
   ,r.[UpdateUsername]
   
FROM
    [dbo].[ib_Rule] R
INNER JOIN
	[dbo].[ib_RuleType] RT ON RT.[RuleTypeId] = R.[RuleTypeId]
INNER JOIN
	[dbo].[ib_MatchCountType] MT ON MT.[MatchCountTypeId] = R.[MatchCountTypeId]
INNER JOIN
	[dbo].[ib_Template] T ON T.[TemplateId] = R.[TemplateId]
INNER JOIN
	[dbo].[ib_ToleranceType] TT ON TT.ToleranceTypeId = R.[ToleranceTypeId]
WHERE
    RuleId = @RuleId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Instrument_GetNameBaseById]''
');

GO
EXECUTE ('/*
<details>
 <summary> Gets an instrument''s name baseId and TickSize by its Id</summary>
 <created author="Laurentiu Macovei" Date="Thursday, 19 August 2006 11:33AM GMT" /> 
 <updated author="Anil Kripalani" Date="29 Nov 2006">
	Return PriceTypeCode too
 </updated>
</details>
*/
CREATE PROCEDURE [dbo].[ib_Instrument_GetNameBaseById]
@InstrumentId int
AS
SET NOCOUNT ON

SELECT [Name], [BaseId], [TickSize], PriceTypeCode
	FROM [dbo].[ib_Instrument] 
	WHERE [InstrumentId] = @InstrumentId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[Broker_Transaction]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[Broker_Transaction]
(
[Broker_TransactionID] [int] NOT NULL IDENTITY(1, 1),
[Serial_Number] [varchar] (11) NULL,
[Trade_Date] [varchar] (8) NULL,
[Trade_Time] [varchar] (8) NULL,
[Trade_Type] [varchar] (8) NULL,
[Account] [varchar] (35) NULL,
[Delivery_Month] [varchar] (8) NULL,
[Host_Instrument] [varchar] (35) NULL,
[Lots] [varchar] (21) NULL,
[Lot_Size] [varchar] (21) NULL,
[Exchange_Code] [varchar] (50) NULL,
[Call_Put] [varchar] (3) NULL,
[Strike_Price] [varchar] (21) NULL,
[Trade_Price] [varchar] (21) NULL,
[Currency] [varchar] (3) NULL,
[Amount_Paid] [varchar] (21) NULL,
[Expiration_Date] [varchar] (8) NULL,
[Broker_Code] [varchar] (50) NULL,
[Commission] [varchar] (21) NULL,
[Post_Date] [varchar] (8) NULL,
[Settlement_Date] [varchar] (8) NULL,
[Nominal_Value] [varchar] (35) NULL,
[Nominal_Amount] [varchar] (35) NULL,
[Exchange_Rate] [varchar] (21) NULL,
[Exchange_Rate_Ind] [varchar] (21) NULL,
[Run_Date] [varchar] (8) NULL,
[Record_Type] [varchar] (3) NULL,
[Link_Number] [varchar] (8) NULL,
[Comment] [varchar] (100) NULL,
[Fas_Acn] [varchar] (5) NULL,
[FileName] [varchar] (512) NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_Broker_Transaction_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_Broker_Transaction_CreateDate] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_Broker_Transaction] on [dbo].[Broker_Transaction]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[Broker_Transaction] ADD CONSTRAINT [PK_Broker_Transaction] PRIMARY KEY CLUSTERED  ([Broker_TransactionID])
');

GO
EXECUTE ('PRINT N''Creating index [IX_Broker_Transaction_Filename] on [dbo].[Broker_Transaction]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_Broker_Transaction_Filename] ON [dbo].[Broker_Transaction] ([FileName]) INCLUDE ([Broker_TransactionID], [CreateDate])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Broker_Transaction_Load]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Broker_Transaction_Load] 
	-- Add the parameters for the stored procedure here
	(
		@LocationPath VARCHAR(100) = NULL
		,@ReceiveLocationSysId INT = NULL
		,@RunId INT = NULL
	)
AS
SET NOCOUNT ON

-- Description:	This stored procedure pulls data from the Broker_Transaction temp
-- table and inserts it into ib_Trx
-- Whilst iterating through the records in Broker_Transaction, all 
-- of these inserts are wrapped in a transaction so that any failure causes
-- the changes to not commit.
--
-- 15 May 2009		petru	Creation
-- 16 Jul 2009		AAJM	Added DetailAccountId which is will be a duplicate of the AccountId - see MBAL-12454
-- 19 Feb 2010		AAJM	Add QuantityLong and QuantityShort for populating ib_Trx
-- 25 Feb 2010		amk		MBAL-14843: use amount_paid instead of nominal_value for marketvalue
--										for type 5 records
-- 20 May 2010		amk		MBAL-15566: move import log started entry to before transaction to minimize deadlocks
-- 21 Jun 2010		ED      MBAL 15718: price set to 24,10 from 19,4
-- 30 Jul 2010		amk		MBAL-16345: deletions should have negative quantity
-- 03 Aug 2010		amk		MBAL-16368: add record to import file table
-- 11 Aug 2010		amk		MBAL-16427 stop duplicate files
-- 04 Mar 2011		amk		MBAL-17736 BUG FIX - can''t do any writes if err caught and xact_state is -1
--							raise proper error and abort
-- 09 Jan 2014		ED		EIB 25004 - remove importLog table and use Log table	
		
DECLARE @DataSourceCd VARCHAR(100)
DECLARE @FirmCd VARCHAR(100)

SET @DataSourceCd = ''Broker''
SET @FirmCd = ''Broker''

IF @LocationPath Like ''%Barclays%'' 
BEGIN
	SET @DataSourceCd = ''Barclays''
	SET @FirmCd = ''Barclays''
END

DECLARE @ReturnValue INT
DECLARE @Output INT
DECLARE @Output2 INT
DECLARE @DataSourceId INT

IF @LocationPath IS NULL SET @LocationPath = @DataSourceCd
EXEC @ReturnValue = [_ib_DataSource_GetByCodeForOutput] @DataSourceCd, @OutPut OUTPUT, @Output2 OUTPUT
SET @DataSourceId = @Output

-- Duplicate file check										
DECLARE @IsFileAlreadyLoaded INT
EXEC @IsFileALreadyLoaded = HasFileBeenLoaded @LocationPath, @DataSourceId

IF @IsFileAlreadyLoaded = 1
BEGIN
	UPDATE [Broker_Transaction]
	SET LoadState = 3
	WHERE LoadState = 1
		AND FileName = @LocationPath -- Is there a Filename column?
	
	RETURN
END

DECLARE @ImportFileId INT
EXEC ib_ImportFile_Add @DataSourceId, @LocationPath, @ImportFileId OUTPUT
DECLARE @SelectedAsOfDate DATETIME

CREATE TABLE #temp1
	(
		Broker_TransactionID		int,
		[FileName]					varchar(512),
		Trade_Date					varchar(8),
		Trade_Type					varchar(8),
		Account						varchar(35),
		Delivery_Month				varchar(8),
		Host_Instrument				varchar(35),
		Lots						varchar(21),
		Lot_Size					varchar(21),
		Exchange_Code				varchar(50),
		Call_Put					varchar(3),
		Strike_Price				varchar(21),
		Trade_Price					varchar(21),
		Currency					varchar(3),
		Nominal_Value				varchar(35),
		Run_date					varchar(8),
		Amount_Paid					varchar(21)
		
	)

	INSERT INTO #temp1
	(
		Broker_TransactionID,
		[FileName],
		Trade_Date,
		Trade_Type,
		Account,
		Delivery_Month,
		Host_Instrument,
		Lots,
		Lot_Size,
		Exchange_Code,
		Call_Put,
		Strike_Price,
		Trade_Price,
		Currency,
		Nominal_Value,
		Run_date,
		Amount_Paid
	)
	SELECT 	
		Broker_TransactionID,
		[FileName],
		Trade_Date,
		Trade_Type,
		Account,
		Delivery_Month,
		Host_Instrument,
		Lots,
		Lot_Size,
		Exchange_Code,
		Call_Put,
		Strike_Price,
		Trade_Price,
		Currency,
		Nominal_Value,
		Run_date,
		Amount_Paid
	FROM [dbo].[Broker_Transaction]
	WHERE LoadState = 1
		AND [FileName] = @LocationPath

	BEGIN TRAN T1

			-- BizTalk''s SQL Adapter uses more restrictive read serializable
			-- so this is necessary to relax it to something that is default
			-- and perfectly acceptable!
			SET TRANSACTION ISOLATION LEVEL READ COMMITTED

			DECLARE @Broker_TransactionID		int
			DECLARE @FileName					varchar(512)
			DECLARE @Trade_Date					varchar(8)
			DECLARE @Trade_Type					varchar(8)
			DECLARE @Account					varchar(35)
			DECLARE @Delivery_Month				varchar(8)
			DECLARE @Host_Instrument			varchar(35)
			DECLARE @Lots						varchar(21)
			DECLARE @Lot_Size					varchar(21)
			DECLARE @Exchange_Code				varchar(50)
			DECLARE @Call_Put					varchar(3)
			DECLARE @Strike_Price				varchar(21)
			DECLARE @Trade_Price				varchar(21)
			DECLARE @Currency					varchar(3)
			DECLARE @Nominal_Value				varchar(35)
			DECLARE @Run_date					varchar(8)
			DECLARE @Amount_Paid				varchar(21)

			DECLARE pos_cursor CURSOR FOR
			SELECT Broker_TransactionID,
					[FileName],
					Trade_Date,
					Trade_Type,
					Account,
					Delivery_Month,
					Host_Instrument,
					Lots,
					Lot_Size,
					Exchange_Code,
					Call_Put,
					Strike_Price,
					Trade_Price,
					Currency,
					Nominal_Value,
					Run_date,
					Amount_Paid
			FROM #temp1

			OPEN pos_cursor

			FETCH NEXT FROM pos_cursor
			INTO 
					@Broker_TransactionID,
					@FileName,
					@Trade_Date,
					@Trade_Type,
					@Account,
					@Delivery_Month,
					@Host_Instrument,
					@Lots,
					@Lot_Size,
					@Exchange_Code,
					@Call_Put,
					@Strike_Price,
					@Trade_Price,
					@Currency,
					@Nominal_Value,
					@Run_date,
					@Amount_Paid

				-- Check @@FETCH_STATUS to see IF there are any more rows to fetch.
				WHILE @@FETCH_STATUS = 0
				BEGIN
					DECLARE		@AccountCd				varchar(100)
					DECLARE		@ExchangeCd				varchar(25)
					DECLARE		@AsOfDate				datetime
					DECLARE		@InstrumentCd			varchar(100)
					DECLARE		@Quantity				decimal(19,4)
					DECLARE		@MarketValue			decimal(19,4)
					DECLARE		@ExpYr					smallint
					DECLARE		@ExpMth					smallint
					DECLARE		@ExpDay					smallint
					DECLARE		@StrikePrice			decimal(19,4)
					DECLARE		@TrxTypeCd				varchar(25)
					DECLARE		@OptionTypeCd			varchar(25)
					DECLARE		@TrxDate				datetime
					DECLARE		@InstrumentTypeCd		varchar(100)
					DECLARE     @ErrorMessageForRecord	varchar(1024)
					DECLARE		@ErrorSeverity			INT
					DECLARE		@ErrorState				INT
					DECLARE     @Price					decimal(24,10)
					DECLARE		@QuantityLong			decimal(19,4)
					DECLARE		@QuantityShort			decimal(19,4)
					-- Temporary variables
                    DECLARE     @TempDate datetime
					DECLARE 	@Code varchar(100), @Code2 varchar(100)
					
			SET @AccountCd = @Account
			SET @StrikePrice = NULL
            
			SET	@ExchangeCd = @Exchange_Code

			SET @TrxTypeCd = @Trade_Type  

			-- ExpiryDate = @Delivery_Month, @Delivery_Month is in yyyymmdd ISO 112 format
			BEGIN TRY
				SET @TempDate = CONVERT(datetime, @Delivery_Month, 112)
				SET @ExpYr = DATEPART(yyyy, @TempDate)
				SET @ExpMth = DATEPART(mm, @TempDate)			
				SET @ExpDay = DATEPART(dd, @TempDate)
			END TRY
			BEGIN CATCH
				SELECT @ErrorMessageForRecord = ERROR_MESSAGE()
					, @ErrorSeverity = ERROR_SEVERITY()
					, @ErrorState = ERROR_STATE()
				IF XACT_STATE() = -1
					BEGIN
						-- transaction must get rolled back so need to fail this whole operation
						-- rollback seems to work whether or not xact_abort is on
						ROLLBACK TRANSACTION

						-- Use RAISERROR inside the CATCH block to return error
						-- information about the original error that caused
						-- execution to jump to the CATCH block.
						RAISERROR (@ErrorMessageForRecord, @ErrorSeverity, @ErrorState);
						RETURN	-- can''t do any writes so no point continuing (otherwise need to check every write / commit)
					END
				ELSE
					EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @ErrorMessageForRecord, ''Success'', @Broker_TransactionID, @RunId
			END CATCH
						
			IF @Call_Put IS NULL OR @Call_Put = '''' 
			   BEGIN
					
					SET @OptionTypeCd = ''Future''
					-- InstrumentTypeCd
					SET @InstrumentTypeCd = ''F''			
			   END
			ELSE IF @Call_Put IS NOT NULL AND @Call_Put <> ''''
				BEGIN
					-- StrikePrice = Strike, Series have a value only for TP and TC @PutCall types.
					IF ISNUMERIC(@Strike_Price) > 0 
									SET @StrikePrice = CONVERT(decimal(19,4), @Strike_Price)
                        
					-- The InstrumentTypeCd value is based on the @Call_Put value
					-- We want to make sure that only in the case the @Call_Put value is correct we also set the InstrumentTypeCd value
					IF @Call_Put = ''TP''
						BEGIN		
							SET @OptionTypeCd = ''P''
							SET @InstrumentTypeCd = ''O''
						END
					ELSE IF @Call_Put = ''TC''
						BEGIN	
							SET @OptionTypeCd = ''C''
							SET @InstrumentTypeCd = ''O''
						END
				END
			
			-- We prefix the Instruments with the IntrumentTypeCode
			SET @InstrumentCd = @InstrumentTypeCd + @Host_Instrument

			-- Quantity = Lots
			SET @Quantity = 0
			SET @QuantityLong = 0
			SET @QuantityShort = 0
			
			IF ISNUMERIC(@Lots) > 0 
			BEGIN
				SET @Quantity = CONVERT(decimal(19,4), @Lots)
					
				-- Set QuantityLong and QuantityShort
				IF (@Quantity >= 0) -- Long
					BEGIN
						SET @QuantityLong = @Quantity
						SET @QuantityShort = 0
					END
				ELSE	-- Short
					BEGIN
						SET @QuantityShort = ABS(@Quantity)
						SET @QuantityLong = 0
					END
			END
			
			-- ensure negative quantity for deletion 
			-- (important to do sign check above first to determine long/short)
			IF @TrxTypeCd = ''2'' 
			BEGIN
				IF @Quantity > 0
					SET @Quantity = @Quantity * -1
				IF @QuantityLong > 0
					SET @QuantityLong = @QuantityLong * -1
				IF @QuantityShort > 0
					SET @QuantityShort = @QuantityShort * -1
			END

			IF @TrxTypeCd = ''5''
			BEGIN
				IF ISNUMERIC(@Amount_Paid) > 0
					SET @MarketValue = CONVERT(decimal(19,4), @Amount_Paid)
			END
			ELSE
			BEGIN
				IF ISNUMERIC(@Nominal_Value) > 0
					SET @MarketValue = CONVERT(decimal(19,4), @Nominal_Value)
			END
								
			IF ISNUMERIC(@Trade_Price) > 0 
				SET @Price = CONVERT(decimal(24,10), @Trade_Price)
			
			-- TrxDate
			BEGIN TRY
				SET @TrxDate = CONVERT(datetime, @Trade_Date, 112)
			END TRY
			BEGIN CATCH
				SELECT @ErrorMessageForRecord = ERROR_MESSAGE()
					, @ErrorSeverity = ERROR_SEVERITY()
					, @ErrorState = ERROR_STATE()
				IF XACT_STATE() = -1
					BEGIN
						-- transaction must get rolled back so need to fail this whole operation
						-- rollback seems to work whether or not xact_abort is on
						ROLLBACK TRANSACTION

						-- Use RAISERROR inside the CATCH block to return error
						-- information about the original error that caused
						-- execution to jump to the CATCH block.
						RAISERROR (@ErrorMessageForRecord, @ErrorSeverity, @ErrorState);
						RETURN	-- can''t do any writes so no point continuing (otherwise need to check every write / commit)
					END
				ELSE
					EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @ErrorMessageForRecord, ''Success'', @Broker_TransactionID, @RunId
			END CATCH
			
			-- AsOfDate
			BEGIN TRY
				SET @AsOfDate = CONVERT(datetime, @Run_Date, 112)
				SET @SelectedAsOfDate = @AsOfDate
			END TRY
			BEGIN CATCH
				SELECT @ErrorMessageForRecord = ERROR_MESSAGE()
					, @ErrorSeverity = ERROR_SEVERITY()
					, @ErrorState = ERROR_STATE()
				IF XACT_STATE() = -1
					BEGIN
						-- transaction must get rolled back so need to fail this whole operation
						-- rollback seems to work whether or not xact_abort is on
						ROLLBACK TRANSACTION

						-- Use RAISERROR inside the CATCH block to return error
						-- information about the original error that caused
						-- execution to jump to the CATCH block.
						RAISERROR (@ErrorMessageForRecord, @ErrorSeverity, @ErrorState);
						RETURN	-- can''t do any writes so no point continuing (otherwise need to check every write / commit)
					END
				ELSE
					EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @ErrorMessageForRecord, ''Success'', @Broker_TransactionID, @RunId
			END CATCH
			
			EXEC [ib_Trx_Load]
				@DataSourceCd,			
				@ExchangeCd,				
				@FirmCd,					
				@AccountCd,	
				NULL, -- DetailAccountCd -- AAJM Added for MBAL-12454			
				@InstrumentCd,			
				@ExpYr,					
				@ExpMth,					
				@ExpDay,					
				@StrikePrice,			
				@TrxTypeCd,				
				@OptionTypeCd,
				@Quantity,			
				@TrxDate,				
				@Price,
				@Broker_TransactionID,
				@InstrumentTypeCd,
				@AsOfDate,		
				@LocationPath,
				@MarketValue,
				@Currency,
				@QuantityLong = @QuantityLong,
				@QuantityShort = @QuantityShort,
				@ReceiveLocationSysId = @ReceiveLocationSysId,
				@RunId = @RunId
			
			--flip processed flag in source table.
			UPDATE [Broker_Transaction]
			SET [LoadState] = 2
			WHERE [Broker_TransactionID] = @Broker_TransactionID
				AND [LoadState] = 1

			FETCH NEXT FROM pos_cursor
			INTO 
					@Broker_TransactionID,
					@FileName,
					@Trade_Date,
					@Trade_Type,
					@Account,
					@Delivery_Month,
					@Host_Instrument,
					@Lots,
					@Lot_Size,
					@Exchange_Code,
					@Call_Put,
					@Strike_Price,
					@Trade_Price,
					@Currency,
					@Nominal_Value,
					@Run_date,
					@Amount_Paid

		END
			
		CLOSE pos_cursor
		DEALLOCATE pos_cursor

		UPDATE ib_ImportFile 
		SET AsOfDate = @SelectedAsOfDate 
		WHERE ImportFileId = @ImportFileId

	COMMIT TRAN T1

DROP TABLE #temp1
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Class_GetClassDescriptionsHintByKeyword]''
');

GO
EXECUTE ('
/*
<details>
 <summary> Returns the Classes hint for a specific code /summary>
 <created author="shilin" date="22 Feb 2011"/>  
 <tasks>
 </tasks>
</details>
*/
CREATE PROCEDURE [dbo].[ib_Class_GetClassDescriptionsHintByKeyword]
@ClassDescription varchar(100),
@HintByStartOnly bit = 0,
@HintLength int = 1
AS
SET NOCOUNT ON

DECLARE @len int
SET @len = LEN(@ClassDescription)
IF @HintByStartOnly = 1
BEGIN
	SELECT DISTINCT SUBSTRING ([Description], @len, @HintLength) x
		FROM [dbo].[ib_Class]
		WHERE [Description] LIKE @ClassDescription+''%''
		ORDER BY x DESC

END
ELSE
BEGIN
	SELECT DISTINCT SUBSTRING ([Description], PATINDEX(''%''+@ClassDescription+''%'', [Description]) + @len, @HintLength) x
		FROM [dbo].[ib_Class]
		WHERE [Description] LIKE ''%''+@ClassDescription+''%''
		ORDER BY x DESC
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Currency_Delete]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Currency_Delete]
@CurrencyId int
AS
SET NOCOUNT ON

-- Deletes a currency by its id from the ib_Currency table

--	05 Sep 2006		laurentiu	Creation
--	15 Jul 2010		amk			MBAL-16177: Cascade delete to child tables
--	20 Jul 2010		amk			MBAL-16177: Cascade NULL to instrument data source
--	16 Apr 2014		ED			EIB 25500 - deactivate currencies
	BEGIN TRANSACTION

	BEGIN TRY
		DELETE FROM ib_PriceReportSummary
			WHERE CurrencyId =  @CurrencyId

		DELETE FROM ib_Price
			WHERE CurrencyId =  @CurrencyId

		DELETE FROM ib_CurrencyDataSource
			WHERE CurrencyId =  @CurrencyId

		UPDATE ib_InstrumentDataSource
			SET CurrencyId = NULL
			WHERE CurrencyId =  @CurrencyId

		UPDATE ib_Currency SET IsActive = 0, UpdateDate = GETDATE(), UpdateUsername = SUSER_SNAME()
			WHERE CurrencyId =  @CurrencyId

		COMMIT TRANSACTION
	END TRY
	BEGIN CATCH
		ROLLBACK TRANSACTION
		EXEC [dbo].[sp_RethrowError] ''Currency is currently in use.''
	END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[BancoSantander_HOSTTRN_Purge]''
');

GO
EXECUTE ('

-- =============================================
-- Author:		a McLeod
-- Create date: 09 Oct 2012
-- Description:	Copied from RolfeNolan. Deletes from BancoSantander_HOSTTRN table all the records where the LoadState is 0
-- =============================================
CREATE PROCEDURE [dbo].[BancoSantander_HOSTTRN_Purge] 
	(
		@LoadState		TINYINT = 0,
		@FileName       VARCHAR (512)= NULL
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
		DELETE FROM [dbo].[BancoSantander_HOSTTRN] WHERE LoadState= @LoadState AND [FileName] = Coalesce(@FileName, [FileName])

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[is_HRealizedProfitLossDetails_Add]''
');

GO
EXECUTE ('

/*
<Details>
<Summary>Inserts an item into the HRealizedProfitLossDetails table</Summary>
<Created author="laurentiu.macovei" date="04/05/2006 16:33:06" />
</Details>
*/
CREATE PROCEDURE [dbo].[is_HRealizedProfitLossDetails_Add]
	@CorporationCode varchar(4) = NULL,
	@PrincipalBrokerageId varchar(1) = NULL,
	@OfficeCode varchar(4) = NULL,
	@ACNo varchar(10) = NULL,
	@SecuritiesId varchar(2) = NULL,
	@BaseDate datetime = NULL,
	@CalcDate datetime = NULL,
	@CalcStartTime datetime = NULL,
	@TradeDateClose datetime = NULL,
	@ExecutionMarketCode varchar(2) = NULL,
	@DerivativesCode varchar(10) = NULL,
	@SecCode1 varchar(7) = NULL,
	@SecCode2 varchar(4) = NULL,
	@SecCode3 varchar(2) = NULL,
	@SecCode4 varchar(1) = NULL,
	@BuySellIdClose varchar(1) = NULL,
	@CanceledDataId varchar(1) = NULL,
	@InputDate datetime = NULL,
	@CancelInputDate datetime = NULL,
	@TradeCodeClose varchar(2) = NULL,
	@OptExerciseAssignmentIdClose varchar(1) = NULL,
	@TradeNoClose varchar(5) = NULL,
	@TradeSubNoClose varchar(3) = NULL,
	@AutomaticExerciseAssignmentId varchar(1) = NULL,
	@TradeDateOpen datetime = NULL,
	@BuySellIdOpen varchar(1) = NULL,
	@TradeCodeOpen varchar(2) = NULL,
	@OptExerciseAssignmentIdOpen varchar(1) = NULL,
	@TradeNoOpen varchar(5) = NULL,
	@TradeSubNoOpen varchar(3) = NULL,
	@ContractMonth varchar(7) = NULL,
	@StrikePrice decimal(11,4) = NULL,
	@Quantity decimal(15,0) = NULL,
	@UnitPriceOpen decimal(11,4) = NULL,
	@UnitPriceClose decimal(11,4) = NULL,
	@ExecutionAmntOpen decimal(15,0) = NULL,
	@ExecutionAmntClose decimal(15,0) = NULL,
	@RealizedPLGrossPlusMinusSign varchar(1) = NULL,
	@RealizedPLGross decimal(15,0) = NULL,
	@CommissionOpen decimal(11,4) = NULL,
	@CommissionClose decimal(11,4) = NULL,
	@ConsumptionTaxOpen decimal(15,0) = NULL,
	@ConsumptionTaxClose decimal(15,0) = NULL,
	@ExchangeTaxOpen decimal(11,4) = NULL,
	@ExchangeTaxClose decimal(15,0) = NULL,
	@RealizedPLNetSign varchar(1) = NULL,
	@RealizedPLNet decimal(15,0) = NULL,
	@CustomerNameAbb varchar(35) = NULL,
	@SecNameInEnglish varchar(28) = NULL,
	@SecNameInKana varchar(24) = NULL,
	@NightTradingIdOpen varchar(1) = NULL,
	@NightTradingIdClose varchar(1) = NULL,
	@TradeTypeOpen varchar(1) = NULL,
	@TradeTypeClose varchar(1) = NULL,
	@ExecutionDateOpen datetime = NULL,
	@ExecutionDateClose datetime = NULL,
	@CostPaymentMethod varchar(1) = NULL
AS
SET NOCOUNT ON

SET NOCOUNT OFF

	DECLARE	@CalcDateStartTime			DATETIME
	DECLARE @RealizedPLGrossSigned		DECIMAL(15,0)
	DECLARE @RealizedPLNetSigned		DECIMAL(15,0)
	
	IF @BaseDate = ''01/01/1900 00:00:00'' 
		SET @BaseDate = NULL

	IF @CalcDate = ''01/01/1900 00:00:00'' 
		SET @CalcDate = NULL

	IF @CalcStartTime = ''01/01/1900 00:00:00'' 
		SET @CalcStartTime = NULL

	IF @TradeDateClose = ''01/01/1900 00:00:00'' 
		SET @TradeDateClose = NULL

	IF @InputDate = ''01/01/1900 00:00:00'' 
		SET @InputDate = NULL

	IF @CancelInputDate = ''01/01/1900 00:00:00'' 
		SET @CancelInputDate = NULL

	IF @TradeDateOpen = ''01/01/1900 00:00:00'' 
		SET @TradeDateOpen = NULL

	IF @ExecutionDateOpen = ''01/01/1900 00:00:00'' 
		SET @ExecutionDateOpen = NULL

	IF @ExecutionDateClose = ''01/01/1900 00:00:00'' 
		SET @ExecutionDateClose = NULL

	IF @RealizedPLGrossPlusMinusSign= ''-'' 	
		SET @RealizedPLGrossSigned = @RealizedPLGross * -1 
	ELSE	
		SET @RealizedPLGrossSigned = @RealizedPLGross	

	IF @RealizedPLNetSign = ''-'' 	
		SET @RealizedPLNetSigned = @RealizedPLNet * -1 
	ELSE	
		SET @RealizedPLNetSigned = @RealizedPLNet

	SET @CalcDateStartTime = CONVERT(DATETIME,CONVERT(VARCHAR(12), CONVERT(DATETIME,@CalcDate,112)) + '' '' + CONVERT(VARCHAR(8),RIGHT(@CalcStartTime,8)))


	INSERT INTO is_HRealizedProfitLossDetails 
		(
			[CorporationCode], 
			[PrincipalBrokerageId], 
			[OfficeCode], 
			[ACNo], 
			[SecuritiesId], 
			[BaseDate], 
			[CalcDate], 
			[CalcStartTime],
 			[CalcDateStartTime],
			[TradeDateClose], 
			[ExecutionMarketCode], 
			[DerivativesCode], 
			[SecCode1], 
			[SecCode2], 
			[SecCode3], 
			[SecCode4], 
			[BuySellIdClose], 
			[CanceledDataId], 
			[InputDate], 
			[CancelInputDate], 
			[TradeCodeClose], 
			[OptExerciseAssignmentIdClose], 
			[TradeNoClose], 
			[TradeSubNoClose], 
			[AutomaticExerciseAssignmentId], 
			[TradeDateOpen], 
			[BuySellIdOpen], 
			[TradeCodeOpen], 
			[OptExerciseAssignmentIdOpen], 
			[TradeNoOpen], 
			[TradeSubNoOpen], 
			[ContractMonth], 
			[StrikePrice], 
			[Quantity], 
			[UnitPriceOpen], 
			[UnitPriceClose], 
			[ExecutionAmntOpen], 
			[ExecutionAmntClose], 
			[RealizedPLGrossPlusMinusSign], 
			[RealizedPLGross], 
			[RealizedPLGrossSigned],
			[CommissionOpen], 
			[CommissionClose], 
			[ConsumptionTaxOpen], 
			[ConsumptionTaxClose], 
			[ExchangeTaxOpen], 
			[ExchangeTaxClose], 
			[RealizedPLNetSign], 
			[RealizedPLNet],
			[RealizedPLNetSigned], 
			[CustomerNameAbb], 
			[SecNameInEnglish], 
			[SecNameInKana], 
			[NightTradingIdOpen], 
			[NightTradingIdClose], 
			[TradeTypeOpen], 
			[TradeTypeClose], 
			[ExecutionDateOpen], 
			[ExecutionDateClose], 
			[CostPaymentMethod]
		) 
	VALUES
		(
			@CorporationCode, 
			@PrincipalBrokerageId, 
			@OfficeCode, 
			@ACNo, 
			@SecuritiesId, 
			@BaseDate, 
			@CalcDate, 
			@CalcStartTime,
			@CalcDateStartTime, 
			@TradeDateClose, 
			@ExecutionMarketCode, 
			@DerivativesCode, 
			@SecCode1, 
			@SecCode2, 
			@SecCode3, 
			@SecCode4, 
			@BuySellIdClose, 
			@CanceledDataId, 
			@InputDate, 
			@CancelInputDate, 
			@TradeCodeClose, 
			@OptExerciseAssignmentIdClose, 
			@TradeNoClose, 
			@TradeSubNoClose, 
			@AutomaticExerciseAssignmentId, 
			@TradeDateOpen, 
			@BuySellIdOpen, 
			@TradeCodeOpen, 
			@OptExerciseAssignmentIdOpen, 
			@TradeNoOpen, 
			@TradeSubNoOpen, 
			@ContractMonth, 
			@StrikePrice, 
			@Quantity, 
			@UnitPriceOpen, 
			@UnitPriceClose, 
			@ExecutionAmntOpen, 
			@ExecutionAmntClose, 
			@RealizedPLGrossPlusMinusSign, 
			@RealizedPLGross,
			@RealizedPLGrossSigned, 
			@CommissionOpen, 
			@CommissionClose, 
			@ConsumptionTaxOpen, 
			@ConsumptionTaxClose, 
			@ExchangeTaxOpen, 
			@ExchangeTaxClose, 
			@RealizedPLNetSign, 
			@RealizedPLNet,
			@RealizedPLNetSigned, 
			@CustomerNameAbb, 
			@SecNameInEnglish, 
			@SecNameInKana, 
			@NightTradingIdOpen, 
			@NightTradingIdClose, 
			@TradeTypeOpen, 
			@TradeTypeClose, 
			@ExecutionDateOpen, 
			@ExecutionDateClose, 
			@CostPaymentMethod
		);

Return Scope_Identity()
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Rule_GetRulesByMatchCode]''
');

GO
EXECUTE ('/*
	Created By: Kirill Shilin
	Create On: 13.07.2011
	Issue: MBAL-18241 Screen#6
	Purpose: Returns A list of ordered Rules for a particular match code
	 -- This returns rules correctly sequenced when rules have been flagged as IsActive = 0
	 
	Updated By: Kirill Shilin
	Update On: 26.10.2011
	Issue: 19169 Rules for match code sequence numbering does not start at one
	Changes: valid Sequence numbers added. So now "Sequence" column is only used internaly for a correct order, but
		not for displaying. 
		
*/


CREATE PROCEDURE [dbo].[ib_Rule_GetRulesByMatchCode]
	@matchCode int
AS
SET NOCOUNT ON
	SELECT 
		Name,
		RuleNumber,
		ROW_NUMBER() OVER (ORDER BY SequenceNumber) AS SequenceNumber,
		-- This returns rules correctly sequenced when rules have been flagged as IsActive = 0
		R.RuleId AS RuleId
	FROM
		ib_Rule R
	INNER JOIN
		ib_RuleMatchCode RMC ON RMC.RuleId = R.RuleId AND RMC.MatchCodeId = @matchCode
	WHERE R.IsActive = 1
	ORDER BY
		SequenceNumber
');

GO
EXECUTE ('PRINT N''Creating [dbo].[udf_GetDaysInMonth]''
');

GO
EXECUTE ('CREATE FUNCTION [dbo].[udf_GetDaysInMonth]
(
	@Year INT
	, @Month INT
)
RETURNS INT
AS
BEGIN
	--	22 Apr 2010		amk		Creation

	-- Declare the return variable here
	DECLARE @Days INT

	DECLARE @NextMonth INT
	DECLARE @NextMonthsYear INT

	-- first get year and month of NEXT month
	SET @NextMonth = @Month + 1
	IF @NextMonth = 13
	BEGIN
		SET @NextMonth = 1
		SET @NextMonthsYear = @Year + 1
	END
	ELSE
		SET @NextMonthsYear = @Year

	-- now put that into a date (with 1st of month)
	DECLARE @FirstOfNextMonth DATETIME
	SET @FirstOfNextMonth = CONVERT(DATETIME
		, CONVERT(VARCHAR(2), @NextMonth) + ''/1/'' + CONVERT(VARCHAR(4), @NextMonthsYear)
		, 101)	

	DECLARE @LastDayOfGivenMonth DATETIME
	SET @LastDayOfGivenMonth = DATEADD(d, -1, @FirstOfNextMonth)

	SET @Days = DAY(@LastDayOfGivenMonth)

	-- Return the result of the function
	RETURN @Days

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[C21_ResumeLine]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[C21_ResumeLine]
(
[ResumeLineID] [int] NOT NULL IDENTITY(1, 1),
[OrgID] [varchar] (5) NULL,
[TMF] [varchar] (10) NULL,
[PA15] [varchar] (15) NULL,
[Guarantee] [varchar] (1) NULL,
[SettlementDate] [varchar] (8) NULL,
[ContractAliasName] [varchar] (3) NULL,
[ContractAliasExp1] [varchar] (1) NULL,
[ContractAliasExp2] [varchar] (1) NULL,
[ContractAliasExp3] [varchar] (1) NULL,
[ContractAliasExp4] [varchar] (1) NULL,
[ContractAliasStrike] [varchar] (8) NULL,
[ContractAliasCPF] [varchar] (1) NULL,
[ContractAliasFull] [varchar] (40) NULL,
[OPEBuyIFT] [varchar] (1) NULL,
[OPEBuyQMT] [varchar] (18) NULL,
[OPESellIFT] [varchar] (1) NULL,
[OPESellQMT] [varchar] (18) NULL,
[OPEIFTCredit] [varchar] (1) NULL,
[OPEQMTCredit] [varchar] (18) NULL,
[OPEIFTDebit] [varchar] (1) NULL,
[OPEQMTDebit] [varchar] (18) NULL,
[POSBuy] [varchar] (18) NULL,
[POSSell] [varchar] (18) NULL,
[POSIFTDebit] [varchar] (1) NULL,
[POSQMTDebit] [varchar] (18) NULL,
[POSIFTCredit] [varchar] (1) NULL,
[POSQMTCredit] [varchar] (18) NULL,
[LIQBuy] [varchar] (14) NULL,
[LIQSell] [varchar] (14) NULL,
[LIQIFTPrice] [varchar] (1) NULL,
[LIQQMTPrice] [varchar] (18) NULL,
[LIQIFTDebit] [varchar] (1) NULL,
[LIQQMTDebit] [varchar] (18) NULL,
[LIQIFTCredit] [varchar] (1) NULL,
[LIQQMTCredit] [varchar] (18) NULL,
[DCIND] [varchar] (1) NULL,
[IFTMargin] [varchar] (1) NULL,
[QMTMargin] [varchar] (18) NULL,
[BusinessDate] [varchar] (8) NULL,
[FileName] [varchar] (512) NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_C21_ResumeLine_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_C21_ResumeLine_CreateDate] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_C21_ResumeLine] on [dbo].[C21_ResumeLine]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[C21_ResumeLine] ADD CONSTRAINT [PK_C21_ResumeLine] PRIMARY KEY CLUSTERED  ([ResumeLineID])
');

GO
EXECUTE ('PRINT N''Creating index [IX_C21_ResumeLine_FileName] on [dbo].[C21_ResumeLine]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_C21_ResumeLine_FileName] ON [dbo].[C21_ResumeLine] ([FileName]) INCLUDE ([CreateDate], [ResumeLineID])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[C21_Header]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[C21_Header]
(
[HeaderID] [int] NOT NULL IDENTITY(1, 1),
[RecordType] [varchar] (5) NULL,
[FileType] [varchar] (50) NULL,
[DatetimeCreation] [varchar] (14) NULL,
[BusinessDate] [datetime] NULL,
[ClearingOrganisationID] [varchar] (5) NULL,
[ClearingMemberFirm] [varchar] (10) NOT NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_C21_Header_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_C21_Header_CreateDate] DEFAULT (getdate()),
[FileName] [varchar] (512) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_C21_Header] on [dbo].[C21_Header]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[C21_Header] ADD CONSTRAINT [PK_C21_Header] PRIMARY KEY CLUSTERED  ([HeaderID])
');

GO
EXECUTE ('PRINT N''Creating index [IX_FileName] on [dbo].[C21_Header]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_FileName] ON [dbo].[C21_Header] ([FileName])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[C21_Format_Decimal]''
');

GO
EXECUTE ('
-- =============================================
-- Author:		Lee Manifold
-- Create date: 13 Oct 2006
-- Description:	Gets the decimal place for a particular quantity. Divides by
--				a factor of X depending on what the decimal value is.
-- Note:		Did not use CASE statement as 0''s were not dropped off when CAST applied.
-- =============================================
CREATE proc [dbo].[C21_Format_Decimal]
	(
	@Code				varchar(1),
	@Quantity			decimal(30,9),	
	@FormattedQuantity	varchar(30) output
	)
AS
SET NOCOUNT ON

IF @Code = ''0'' SET @FormattedQuantity =  CAST(@Quantity AS Decimal(19,0))
IF @Code = ''1'' SET @FormattedQuantity =  CAST(@Quantity AS Decimal(19,1))
IF @Code = ''2'' SET @FormattedQuantity =  CAST(@Quantity/100 AS Decimal(19,2))
IF @Code = ''3'' SET @FormattedQuantity =  CAST(@Quantity/1000 AS Decimal(19,3))
IF @Code = ''4'' SET @FormattedQuantity =  CAST(@Quantity/10000 AS Decimal(19,4))
IF @Code = ''5'' SET @FormattedQuantity =  CAST(@Quantity/100000 AS Decimal(19,5))
IF @Code = ''6'' SET @FormattedQuantity =  CAST(@Quantity/1000000 AS Decimal(19,6))
IF @Code = ''7'' SET @FormattedQuantity =  CAST(@Quantity/10000000 AS Decimal(19,7))
IF @Code = ''8'' SET @FormattedQuantity =  CAST(@Quantity/100000000 AS Decimal(19,8))
IF @Code = ''9'' SET @FormattedQuantity =  CAST(@Quantity/1000000000 AS Decimal(19,9))
IF @Code = ''A'' SET @FormattedQuantity =  CAST(@Quantity/-1 AS Decimal(19,0))
IF @Code = ''B'' SET @FormattedQuantity =  CAST(@Quantity/-10 AS Decimal(19,1))
IF @Code = ''C'' SET @FormattedQuantity =  CAST(@Quantity/-100 AS Decimal(19,2))
IF @Code = ''D'' SET @FormattedQuantity =  CAST(@Quantity/-1000 AS Decimal(19,3))
IF @Code = ''E'' SET @FormattedQuantity =  CAST(@Quantity/-10000 AS Decimal(19,4))
IF @Code = ''F'' SET @FormattedQuantity =  CAST(@Quantity/-100000 AS Decimal(19,5))
IF @Code = ''G'' SET @FormattedQuantity =  CAST(@Quantity/-1000000 AS Decimal(19,6))
IF @Code = ''H'' SET @FormattedQuantity =  CAST(@Quantity/-10000000 AS Decimal(19,7))
IF @Code = ''I'' SET @FormattedQuantity =  CAST(@Quantity/-100000000 AS Decimal(19,8))
IF @Code = ''J'' SET @FormattedQuantity =  CAST(@Quantity/-1000000000 AS Decimal(19,9))
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_C21_Position_Load]''
');

GO
EXECUTE ('CREATE procedure [dbo].[ib_C21_Position_Load]
	(
		@LocationPath VARCHAR(100)
		,@ReceiveLocationSysId INT
		,@RunId INT
	)
AS
SET NOCOUNT ON

/*
Description:  This stored procedure pulls data from the C21 data table
table and inserts it into the ib_Position ./ ib_trx table.  Also, any
new values encountered for firm, account, instrument, and currency create
new values in the lookups, as well as new values in the data tables for
these values.

Whilst iterating through the records in C21 data tables, all 
of these inserts are wrapped in a transaction so that any failure causes
the changes to not commit.
*/

-- 11 Oct 2006	lm		Creation
-- 18 May 2009	Konrad	Added BusinessDate field which gives the value to the AsOfDate 
-- 20 May 2009	Konrad  Exp Day set to the last day of the Exp Month and Exp Year if Exp Month and Exp Year are valid
-- 16 Jul 2009	Konrad  Allow for MONEP futures bug fixed, included condition check for null values and
--						also redone the 30.04.2009 change which was lost on the 18.05.2009 change 
-- 22 Jul 2009	AAJM	MBAL-12377 use common source for default Strike Price Divisor
-- 23 Jul 2009	AAJM	MBAL-12486 Fix Expiry date being 10 years too early
-- 24 Jul 2009	AAJM	MBAL-12488 Fix Expiry Day always being set to 31
-- 24 Jul 2009	AAJM	MBAL-12589 MONEP swap year/month from reading YYMMDD to read MMYYDD
-- 26 Oct 2009	amk		MBAL-13614 Log importlog rows on start and end
-- 17 Feb 2010	AAJM	MBAL-13937 Stop same file being imported again
-- 03 Mar 2010	KevinP	MBAL-14819 Add ability to filter SELECT records by new [FileName] Column
-- 03 Mar 2010	amk		MBAL-14836 Change transaction isolation level
-- 23 Mar 2010	AAJM 	MBAL-15053 Ensure Instrument Type Code is correcly set
-- 29 Mar 2010	amk		MBAL-15098 bug fix: clear variable before setting debit/credit for marketvalue
-- 31 Mar 2010	amk		MBAL-15120 change fields used for market value calculation
-- 22 Apr 2010	AAJM	MBAL-14741 Save settlement prices
-- 02 Jun 2010  ED      MBAL-15687 populate ib_ImportFile.AsOfDate
-- 10 Aug 2010	amk		MBAL-16415 change loadstate here at start (improve concurrency)
-- 02 Jan 2014  RD		MBAL-24931 Added checking file age
-- 09 Jan 2014	ED		EIB 25004 - remove importLog table and use Log table
-- 14 Jan 2014  ED      EIB 25059 - refactor to check the AsOfDate outside of transaction
-- 25 Apr 2014  ED      EIB 25473 - raise error if file is too old and mark temp records as LoadState=3

	--Set the Datasource
	DECLARE @DataSourceCd VARCHAR(20)
	SET @DataSourceCd = ''Clearing21''

	DECLARE	@Output INT 
	DECLARE	@Output2 INT
	DECLARE @ReturnValue INT
	DECLARE @DataSourceId INT
	DECLARE @DefaultCurrencyId INT
	

	--Gets the DataSource and DefaultCurrencyId values
	EXEC @ReturnValue = [dbo].[_ib_DataSource_GetByCodeForOutput] @DataSourceCd, @OutPut output, @Output2 output	
	SET @DataSourceId = @Output
	SET @DefaultCurrencyId = @Output2

	UPDATE C21_ResumeLine
	SET LoadState = 1
	WHERE LoadState = 0
		AND Filename = @LocationPath

	-- Duplicate file check										
	DECLARE @IsFileAlreadyLoaded INT
	EXEC @IsFileALreadyLoaded = [HasFileBeenLoaded]  @LocationPath, @DataSourceId

	IF @IsFileAlreadyLoaded = 1
	BEGIN
		UPDATE [dbo].[C21_ResumeLine]
		SET [LoadState] = 3
		WHERE [LoadState] = 1
			AND [FileName] = @LocationPath
					
		RETURN
	END
	-- get business date from header
	DECLARE @HeaderAsOfDate DATETIME
	
	SELECT @HeaderAsOfDate = CAST(BusinessDate AS DateTime) 
	FROM [C21_Header] (NOLOCK)
	WHERE FileName = @LocationPath

	IF @@ROWCOUNT = 0
	BEGIN
		DECLARE @Message VARCHAR(255)
		SET @Message = ''Could not find C21_Header row for filename: '' + @LocationPath
		RAISERROR (@Message, 19, 1) WITH LOG
	END

	--rd - make sure the As Of Date is not older than acceptable
	DECLARE @IsAcceptable bit
	EXECUTE [dbo].[Load_IsFileTooOld] @DataSourceId, @LocationPath, @HeaderAsOfDate, @IsAcceptable OUTPUT, @ReceiveLocationSysId, @RunId
	IF (@IsAcceptable = 0)
	BEGIN
		UPDATE C21_ResumeLine SET [LoadState] = 3 WHERE [Filename] = @LocationPath
		RAISERROR (''File is too old.'', 18, 0)
		RETURN
	END

	-- Store ImportFile record to be associated with Settlement Price load
	DECLARE @ImportFileId INT
	EXEC ib_ImportFile_Add @DataSourceId, @LocationPath, @ImportFileId output
	DECLARE @SelectedAsOfDate DATETIME
	BEGIN TRAN T1

		-- BizTalk''s SQL Adapter uses more restrictive read serializable
		-- so this is necessary to relax it to something that is default
		-- and perfectly acceptable!
		SET TRANSACTION ISOLATION LEVEL READ COMMITTED

		DECLARE @ExchangeCd					varchar(25)
		DECLARE @FirmCd						varchar(100)
		DECLARE @AccountCd					varchar(100)
		DECLARE @AsOfDate					datetime
		DECLARE @InstrumentCd				varchar(100)
		DECLARE @QuantityPS					decimal(19,4)
		DECLARE @MarketValue				decimal(19,4)
		DECLARE @ExpiryDate					datetime
		DECLARE @StrikePrice				decimal(19,4)
		DECLARE @TrxTypeCd					varchar(25)
		DECLARE @OptionTypeCd				varchar(25)
		DECLARE @TrxDate					datetime
		DECLARE @Price						decimal(19,4)
		DECLARE @ExpYr						smallint
		DECLARE @ExpMth						smallint
		DECLARE @ExpDay						smallint
		DECLARE	@InstrumentTypeCd			varchar(100)
		DECLARE @ClassId					int
		DECLARE @LongQuantity				decimal(19,4) 
		DECLARE @ShortQuantity				decimal(19,4)
		DECLARE @TradedLongQuantity			decimal(19,4)
		DECLARE	@TradedShortQuantity		decimal(19,4)

		DECLARE	@Credit						decimal(19,4)
		DECLARE	@Debit						decimal(19,4)

		DECLARE	@Outputvarchar			varchar(50)				
		DECLARE @Code					varchar(100)
		DECLARE @Code2					varchar(100)
		DECLARE @InstrumentTypeId		int
		DECLARE @CurrencyId				int
		DECLARE @InstrumentId			int
		DECLARE @ExchangeId				int
		DECLARE	@StrikePriceDivisor		Decimal(19,4)
		DECLARE	@PriceDivisor			DECIMAL(19,4)

		DECLARE @tmpID						int
		DECLARE @tmpOrgID					Varchar(5)
		DECLARE	@tmpTMF						varchar(10)
		DECLARE	@tmpPA15					varchar(15)
		DECLARE	@tmpPOSBuy					decimal(19,4)
		DECLARE	@tmpPOSSell					decimal(19,4)
		DECLARE	@tmpLIQQMTCredit			decimal(19,4)
		DECLARE	@tmpLIQIFTCredit			varchar(1)
		DECLARE	@tmpLIQQMTDebit				decimal(19,4)
		DECLARE	@tmpLIQIFTDebit				varchar(1)
		DECLARE	@tmpSettlementDate			varchar(8)
		DECLARE	@tmpContractAliasName		varchar(3)
		DECLARE	@tmpContractAliasExp1		varchar(1)
		DECLARE	@tmpContractAliasExp2		varchar(1)
		DECLARE	@tmpContractAliasExp3		varchar(1)
		DECLARE	@tmpContractAliasExp4		varchar(1)
		DECLARE	@tmpContractAliasStrike		varchar(8)
		DECLARE	@tmpContractAliasCPF		varchar(1)
		DECLARE	@tmpContractAliasFull		varchar(40)
		DECLARE @tmpBusinessDate			varchar(8)
		DECLARE @ContractAliasFull			varchar(40)
		DECLARE	@CurrencyCd					varchar(10)
		DECLARE @ErrorMessageForRecord		varchar(1024)
		DECLARE @tmpLIQIFTPrice				varchar(1)
		DECLARE @tmpLIQQMTPrice				varchar(18)

		DECLARE pos_cursor CURSOR FOR
		SELECT 	[ResumeLineID] AS [ID],
				[OrgID],
				[TMF],
				[PA15],
				CAST([POSBuy]AS decimal(19,4)),
				CAST([POSSell] AS decimal(19,4)) ,
				CAST([LIQQMTCredit] AS decimal(19,4)) ,
				[LIQIFTCredit],
				CAST([LIQQMTDebit] AS decimal(19,4)),
				[LIQIFTDebit],
				[SettlementDate],
				[ContractAliasName],
				[ContractAliasExp1],
				[ContractAliasExp2],
				[ContractAliasExp3],
				[ContractAliasExp4],
				[ContractAliasStrike],
				[ContractAliasCPF],
				[ContractAliasFull],
				[BusinessDate],
				[LIQIFTPrice],  -- Decimal Places
				[LIQQMTPrice]	-- Settlement Price
		FROM [dbo].[C21_ResumeLine]
		WHERE [LoadState] = 1
			AND	[FileName] = @LocationPath

		OPEN pos_cursor

		FETCH NEXT FROM pos_cursor
		INTO	
			@tmpID,
			@tmpOrgID,
			@tmpTMF,
			@tmpPA15,
			@tmpPOSBuy,
			@tmpPOSSell,
			@tmpLIQQMTCredit,
			@tmpLIQIFTCredit,
			@tmpLIQQMTDebit,
			@tmpLIQIFTDebit,
			@tmpSettlementDate,
			@tmpContractAliasName,
			@tmpContractAliasExp1,
			@tmpContractAliasExp2,
			@tmpContractAliasExp3,
			@tmpContractAliasExp4,
			@tmpContractAliasStrike,
			@tmpContractAliasCPF,
			@tmpContractAliasFull,
			@tmpBusinessDate,
			@tmpLIQIFTPrice,
			@tmpLIQQMTPrice

		-- Check @@FETCH_STATUS to see if there are any more rows to fetch.
		WHILE @@FETCH_STATUS = 0
		BEGIN

			SET @Output				= NULL
			SET @Output2			= NULL

			--Gets the ExchangeID from the DataSourceExchangeCode from the OrgID
			EXEC @ReturnValue = [dbo].[ib_DataSourceExchange_GetByCode] @DataSourceId, @tmpOrgID, @Output output
			SET @ExchangeID	= @Output
			SET @Output		= NULL

			SET @FirmCd		= @tmpTMF

			SET @AccountCd = @tmpPA15 
			SET @AsofDate = GetDate()

			
			SET @AsofDate = CONVERT(datetime, @tmpBusinessDate, 112)
			SET @SelectedAsOfDate = @AsOfDate
		
			SET @QuantityPS = (@tmpPosBuy - @tmpPosSell)
						
			--Gets the decimal place of the QMTCredit using the IFTCredit
			SET @OutputVarchar = 0
			EXEC @ReturnValue	= [dbo].[C21_Format_Decimal] @tmpLIQIFTCredit, @tmpLIQQMTCredit, @OutputVarchar output
			SET @Credit			= @OutputVarchar
			SET @OutputVarchar	= NULL

			--Gets the decimal place of the QMTDebit using the IFTDebit
			SET @OutputVarchar = 0
			EXEC @ReturnValue	= [dbo].[C21_Format_Decimal] @tmpLIQIFTDebit, @tmpLIQQMTDebit, @OutputVarchar output
			SET @Debit			= @OutputVarchar
			SET @Output			= NULL

			SET @MarketValue			= (@Credit - @Debit)
			SET @TrxTypeCd				= ''POSITION''
			SET	@LongQuantity			= @tmpPosBuy
			SET @ShortQuantity			= @tmpPosSell
			SET @InstrumentTypeCd		= ''S''
			SET @ClassID				= NULL
			SET @TradedLongQuantity		= NULL
			SET @TradedShortQuantity	= NULL
			SET @ExchangeCd				= @tmpOrgID
			SET @CurrencyCd			= NULL
			
			--Differnt logic for InstrumentID,ExpiryYear, month, day, Strikeprice and OptiontypeCode
			--depending on Exchange type.
			IF @tmpOrgID = ''SBF''
				BEGIN
					SET @ExpYr	= CAST( DATEPART(YYYY,@tmpSettlementDate) AS Int)
					SET @ExpMth	= CAST( DATEPART(MM,@tmpSettlementDate) AS Int)
					SET @ExpDay	= CAST( DATEPART(DD,@tmpSettlementDate) AS Int)
					SET @OptionTypeCd = ''''		
					SET @StrikePrice = 0
					SET @ContractAliasFull = @tmpContractAliasName + @tmpContractAliasExp1 + @tmpContractAliasExp2 + @tmpContractAliasExp3 + @tmpContractAliasExp4 + @tmpContractAliasStrike + @tmpContractAliasCPF	
					SET @InstrumentCd = LEFT(@ContractAliasFull,12)
					
					DECLARE @tmpOptionTypeCode VARCHAR(1)
					SET @tmpOptionTypeCode = RIGHT(@ContractAliasFull, 1)
					
					IF (UPPER(@tmpOptionTypeCode) IN (''P'',''C''))
						SET @InstrumentTypeCd = ''O''
					ELSE
						SET @InstrumentTypeCd = ''F''

				END

			IF @tmpOrgID = ''MONEP''
				BEGIN
					IF LEN(RTRIM(LTRIM(SUBSTRING(@tmpContractAliasFull, 18, 1)))) = 1 -- we have P/C on this position, so it is a FLEX
						BEGIN
							SET @ExpYr			= CAST(@tmpContractAliasExp1 + @tmpContractAliasExp2 AS INT) + 2000
							SET @ExpMth			= @tmpContractAliasExp3 + @tmpContractAliasExp4
							SET @ExpDay			= LEFT(@tmpContractAliasStrike,2)
							SET @tmpContractAliasStrike = SUBSTRING(@tmpContractAliasFull, 9, 8)
							SET @tmpContractAliasCPF = SUBSTRING(@tmpContractAliasFull, 18, 1)
						END
					ELSE
						BEGIN
							SET @ExpYr			= CAST(@tmpContractAliasExp3 + @tmpContractAliasExp4 AS INT) + 2000
							SET @ExpMth			= @tmpContractAliasExp1 + @tmpContractAliasExp2
							SET @ExpDay			= dbo.udf_GetDaysInMonth(@ExpYr,@ExpMth)
						END
					
					SET @OptionTypeCd	= @tmpContractAliasCPF
					SET @InstrumentCd = ''O'' + @tmpContractAliasName
					SET @InstrumentTypeCd = ''O''

					IF LEN(RIGHT(@tmpContractAliasStrike,8)) > 0 
						SET @StrikePrice	=  RIGHT(@tmpContractAliasStrike,8)
						
					IF LEN(RIGHT(@tmpContractAliasStrike,8)) = 0 or @tmpContractAliasStrike is null
					BEGIN
						SET @StrikePrice	= 0
						IF LEN(@OptionTypeCd) = 0 or @OptionTypeCd is null
								BEGIN
									SET @InstrumentCd = ''F'' + @tmpContractAliasName
									SET @InstrumentTypeCd = ''F''
								END
					END

				END

			IF @tmpOrgID = ''MATIF''			
				BEGIN
	
					IF LEN(LTRIM(@tmpContractAliasStrike)) = 0 AND LEN(LTRIM(@tmpContractAliasCPF)) = 0
						BEGIN 
							SET @InstrumentCd = ''F''+ @tmpContractAliasName 
							SET @InstrumentTypeCd = ''F''
						END
					ELSE 
						BEGIN
							SET @InstrumentCd = ''O''+ @tmpContractAliasName
							SET @InstrumentTypeCd = ''O''
						END

					SET @OptionTypeCd	= RIGHT(@tmpContractAliasStrike,1)
					SET @StrikePrice =  CAST(@tmpContractAliasExp3 + @tmpContractAliasExp4 + LEFT(@tmpContractAliasStrike,3) AS INT)

					SET @ExpYr	= 2000 +  CAST(@tmpContractAliasExp2 AS INT)
					
					DECLARE @CurrentYear SMALLINT
					SET @CurrentYear = YEAR(GETDATE())
										
					WHILE @ExpYr < @CurrentYear
						SET @ExpYr = @ExpYr + 10

					SELECT @ExpMth	= 
						CASE UPPER(@tmpContractAliasExp1)
							WHEN ''F'' THEN 1--''JAN''
							WHEN ''G'' THEN 2--''FEB''
							WHEN ''H'' THEN 3--''MAR''
							WHEN ''J'' THEN 4--''APR''
							WHEN ''K'' THEN 5--''MAY''
							WHEN ''M'' THEN 6--''JUN''
							WHEN ''N'' THEN 7--''JUL''
							WHEN ''Q'' THEN 8--''AUG''
							WHEN ''U'' THEN 9--''SEP''
							WHEN ''V'' THEN 10--''OCT''
							WHEN ''X'' THEN 11--''NOV''
							WHEN ''Z'' THEN 12--''DEC''
						END
			
					-- MBAL-12488
					-- Reset @ExpDay to zero to ensure that the previous value is not 
					-- sent through to dbo.udf_OnLoad_ExpiryDate_Get_Day
			
					SET @ExpDay = 0
					
				END
	
			--Get the StrikePrice Divisor and divide strikeprice by it
			SELECT	@StrikePriceDivisor	= StrikePriceDivisor
				, @PriceDivisor = PriceDivisor
			FROM	[dbo].[ib_InstrumentDataSource]
			WHERE	DataSourceId = @DataSourceId
			AND		DataSourceInstrumentCode = @InstrumentCd 			
			
			IF @StrikePriceDivisor IS NULL
			BEGIN
				SET @StrikePriceDivisor = [dbo].[udf_GetDefaultStrikePriceDivisor](@DataSourceId, NULL)
			END
			
			SET @StrikePrice = (CAST(@StrikePrice as decimal(19,4))/@StrikePriceDivisor)

			-- Set Settlement Price				
			IF @PriceDivisor IS NULL 
				SET @PriceDivisor = 1
					
			DECLARE @SettlementPrice DECIMAL(24,10)
			DECLARE @Outputvchr VARCHAR(30)
			
			--Gets the decimal places of the LIQQMTPrice using the LIQIFTPrice
			EXEC @ReturnValue = [dbo].[C21_Format_Decimal] @tmpLIQIFTPrice, @tmpLIQQMTPrice, @Outputvchr output
			
			SET @SettlementPrice = CONVERT(DECIMAL(24,10), @Outputvchr) / @PriceDivisor
			SET @Outputvchr = NULL
			
			--Gets the InstrumentTypeID from the InstrumentTypeCode ???Obsolete
			EXEC @ReturnValue		= [dbo].[ib_InstrumentType_AddAsNeeded] @DataSourceId, @InstrumentTypeCd, @Output output
			SET @InstrumentTypeID	= @Output
			SET @Output				= NULL		

			SET @ExpDay = dbo.udf_OnLoad_ExpiryDate_Get_Day(@ExpYr,@ExpMth,@ExpDay)
			
			DECLARE @PositionId INT
			SET @PositionId = NULL
			
			EXEC	[dbo].[ib_Position_Load]
					@DataSourceCd,
					@ExchangeCd,
					@FirmCd,
					@AccountCd,	
					@AsOfDate,
					@InstrumentCd,
					@QuantityPS,
					@MarketValue,
					@ExpYr,
					@ExpMth,
					@ExpDay,
					@StrikePrice,
					@TrxTypeCd,
					@OptionTypeCd,
					@TrxDate,
					@Price,
					@tmpID,
					@InstrumentTypeCd,
					@LocationPath,
					@CurrencyCd,
					@LongQuantity, 
					@ShortQuantity, 
					@TradedLongQuantity, 
					@TradedShortQuantity,
					@ClassId,
					@PositionId = @PositionId OUTPUT, 
					@ReceiveLocationSysId = @ReceiveLocationSysId,
					@RunId = @RunId

			-- Add Settlement Price											
			EXEC ib_Price_AddFromPositionLoad
				@PositionId
				, @ImportFileId
				, @SettlementPrice 	

			--flip processed flag in source table.
			UPDATE [dbo].[C21_ResumeLine]
			SET [LoadState] = 2
			WHERE [ResumeLineID] = @tmpID
				AND [LoadState] = 1

			FETCH NEXT FROM pos_cursor
			INTO 
				@tmpID,
				@tmpOrgID,
				@tmpTMF,
				@tmpPA15,
				@tmpPOSBuy,
				@tmpPOSSell,
				@tmpLIQQMTCredit,
				@tmpLIQIFTCredit,
				@tmpLIQQMTDebit,
				@tmpLIQIFTDebit,
				@tmpSettlementDate,
				@tmpContractAliasName,
				@tmpContractAliasExp1,
				@tmpContractAliasExp2,
				@tmpContractAliasExp3,
				@tmpContractAliasExp4,
				@tmpContractAliasStrike,
				@tmpContractAliasCPF,
				@tmpContractAliasFull,
				@tmpBusinessDate,
				@tmpLIQIFTPrice,
				@tmpLIQQMTPrice

		END

		CLOSE pos_cursor
		DEALLOCATE pos_cursor

		UPDATE ib_ImportFile SET AsOfDate= @SelectedAsOfDate WHERE ImportFileId=@ImportFileId
	COMMIT TRAN T1
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Currency_Update]''
');

GO
EXECUTE (' /*
<details>
 <summary>Updates a currency from the ib_Currency table by its id</summary>
 <created author="Laurentiu Macovei" Date=" Wednesday, 6 September 2006 2:26AM GMT" /> 
</details>
*/
create PROCEDURE [dbo].[ib_Currency_Update]
	@CurrencyId int,
	@Code varchar(100),
	@Description varchar(100),
	@IsApproved varchar(200),
	@UpdateUsername varchar(50)
AS
SET NOCOUNT ON

BEGIN TRY
--check for duplicates 
EXEC [dbo].[ib_Currency_CheckForDuplicate] @Code, @Description, @CurrencyId

UPDATE [dbo].[ib_Currency]
	SET [Code] = @Code
        ,[Description] = @Description
        ,[IsApproved] = @IsApproved
        ,[UpdateUsername] = @UpdateUsername
	WHERE CurrencyID = @CurrencyID

END TRY
BEGIN CATCH
	EXEC [dbo].[sp_RethrowError]
END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[BancoSantander_HOSTTRN_V2_Add]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[BancoSantander_HOSTTRN_V2_Add]
	@Filename				varchar(512)=NULL,
	@Type					varchar(3)=NULL,
	@Serial					varchar(5)=NULL,
	@Ledger					varchar(7)=NULL,
	@FASCurrency			varchar(3)=NULL,
	@Currency				varchar(3)=NULL,
	@BaseCurrency			varchar(3)=NULL,
	@Market					varchar(5)=NULL,
	@MarketCode				varchar(5)=NULL,
	@DummyField				varchar(3)=NULL,
	@RunDate				varchar(8)=NULL,
	@RecordType_Field1		VARCHAR(100)=NULL,
	@RecordType_Field2		VARCHAR(100)=NULL,
	@RecordType_Field3		VARCHAR(100)=NULL,
	@RecordType_Field4		VARCHAR(100)=NULL,
	@RecordType_Field5		VARCHAR(100)=NULL,
	@RecordType_Field6		VARCHAR(100)=NULL,
	@RecordType_Field7		VARCHAR(100)=NULL,
	@RecordType_Field8		VARCHAR(100)=NULL,
	@RecordType_Field9		varchar(100)=NULL,
	@RecordType_Field10		varchar(100)=NULL,
	@RecordType_Field11		varchar(100)=NULL,
	@RecordType_Field12		varchar(100)=NULL,
	@RecordType_Field13		varchar(100)=NULL, -- NOT used as @ 08 Mar 2010. Only here for possible expansion in the future.
	@RecordType_Field14		varchar(100)=NULL, -- NOT used as @ 08 Mar 2010. Only here for possible expansion in the future.
	@RecordType_Field15		varchar(100)=NULL  -- NOT used as @ 08 Mar 2010. Only here for possible expansion in the future.
AS
SET NOCOUNT ON;

/*
Author		Date			Description
AlisterM	09 Oct 2012		Creation
*/

DECLARE @StrikeShort VARCHAR(21)
DECLARE @Strike VARCHAR(21)
DECLARE @PutCall VARCHAR(2)
DECLARE @Lots VARCHAR(21)
DECLARE @Price VARCHAR(21)
DECLARE @OpenClose VARCHAR(1)
DECLARE @PostingAmount VARCHAR(20)
DECLARE @IsMergedTrade CHAR(1)
DECLARE @Serial2 VARCHAR(10)
DECLARE @PromptDate VARCHAR(8)

--Used for 003, 004,020,093,006,007,012,013
DECLARE @Series VARCHAR(20)
DECLARE @FullSeries VARCHAR(20)
DECLARE @Premium VARCHAR(20)

--This is just to make sure that we dont add record types we don''t know about...
DECLARE @IsValidToInsertRecord BIT
SET @IsValidToInsertRecord = 0

-- Used for 005 only
DECLARE @IsCashSettlingOption CHAR(1)

IF	@Type = ''001'' OR 
	@Type = ''002'' OR
	@Type = ''014'' OR 
	@Type = ''018'' OR 
	@Type = ''019'' OR 
	@Type = ''091'' 
BEGIN
	SET @Serial2= @RecordType_Field1
	SET @PromptDate = @RecordType_Field2
	SET @Lots = @RecordType_Field3
	SET @Price = @RecordType_Field4
	SET @PostingAmount = @RecordType_Field5
	SET @OpenClose = @RecordType_Field6
	SET @IsMergedTrade = @RecordType_Field7
	SET @Strike = 0
	SET @StrikeShort = NULL
	SET @PutCall = NULL
	SET @IsValidToInsertRecord = 1
END


IF	@Type = ''003'' OR 
	@Type = ''004'' OR
	@Type = ''020'' OR 
	@Type = ''093'' 
BEGIN
	SET @Serial2= @RecordType_Field1
	SET @PromptDate = @RecordType_Field2
	SET @Series = @RecordType_Field3
	SET @PutCall = @RecordType_Field4
	SET @Lots = @RecordType_Field5
	SET @Price = @RecordType_Field6
	SET @Premium = @RecordType_Field7
	SET @Strike = @RecordType_Field3 -- We get this from Series Column because Price doesn''t hold anything...
	SET @PostingAmount = @RecordType_Field9
	SET @OpenClose = @RecordType_Field10
	SET @IsMergedTrade = @RecordType_Field11
	SET @FullSeries = @RecordType_Field12
	SET @IsValidToInsertRecord = 1
END

IF	@Type = ''005'' 
BEGIN
	SET @Serial2= @RecordType_Field1
	SET @Lots = @RecordType_Field2
	SET @PromptDate = @RecordType_Field3
	SET @PostingAmount = @RecordType_Field4
	SET @IsCashSettlingOption = @RecordType_Field5
	SET @PutCall = NULL -- N/A for 005 Record Types.
	SET @Price = NULL -- N/A
	SET @Strike = NULL -- N/A
	SET @StrikeShort = NULL --N/A
	SET @IsValidToInsertRecord = 1
END

IF	@Type = ''006'' 
BEGIN
	SET @Serial2= @RecordType_Field1
	SET @PromptDate = @RecordType_Field2
	SET @Series = @RecordType_Field3
	SET @PutCall = @RecordType_Field4
	SET @Lots = @RecordType_Field5
	SET @Price = @RecordType_Field6 -- NB:- Price will actuall hold the value in the Premium Rate Column
	SET @Premium = @RecordType_Field7
	SET @PostingAmount = @RecordType_Field8 
	SET @Strike = @RecordType_Field3 --NB:- We get this from Series Column because Price doesn''t hold anything...
	SET @OpenClose = @RecordType_Field10
	SET @FullSeries = @RecordType_Field11
	SET @StrikeShort = NULL --N/A
	SET @IsValidToInsertRecord = 1
END

IF	@Type = ''007'' 
BEGIN
	SET @Serial2= @RecordType_Field3
	SET @Lots = @RecordType_Field4
	SET @PromptDate = @RecordType_Field5
	SET @PostingAmount = @RecordType_Field6
	SET @Series = @RecordType_Field7
	SET @PutCall = @RecordType_Field8
	SET @FullSeries = @RecordType_Field10

	SET @Price = NULL
	SET @Premium = NULL
	SET @Strike = @RecordType_Field7
	SET @OpenClose = NULL
	SET @StrikeShort = NULL --N/A
	SET @IsValidToInsertRecord = 1
END

IF	@Type = ''012'' OR
	@Type = ''013''
BEGIN
	SET @Serial2= @RecordType_Field1
	SET @PromptDate = @RecordType_Field2
	SET @Series = @RecordType_Field3
	SET @PutCall = @RecordType_Field4
	SET @Lots = @RecordType_Field5
	SET @Price = @RecordType_Field6
	SET @Premium = @RecordType_Field7
	SET @PostingAmount = @RecordType_Field8
	SET @Strike = @RecordType_Field3 -- We get this from Series Column because Price doesn''t hold anything...
	SET @OpenClose = @RecordType_Field10
	SET @FullSeries = @RecordType_Field11	
	SET @StrikeShort = NULL --N/A
	SET @IsValidToInsertRecord = 1
END


IF @IsValidToInsertRecord = 1
BEGIN
	INSERT INTO [dbo].[BancoSantander_HOSTTRN]
				( 
					[Filename]
					,[Type]
					,[Serial]
					,[Ledger]
					,[FASCurrency]
					,[Currency]
					,[BaseCurrency]
					,[Market]
					,[MarketCode]
					,[DummyField]
					,[RunDate]
					,[Serial2]
					,[PromptDate]
					,[StrikeShort]
					,[Strike]
					,[PutCall]
					,[Lots]
					,[Price]
					,[OpenClose]
					,[PostingAmount]
					,[IsMergedTrade]
					,[Series]
					,[FullSeries]
					,[Premium]
					,[IsCashSettlingOption]
				)
		VALUES
				( 
					@Filename,
					@Type,
					@Serial,
					@Ledger,
					@FASCurrency,
					@Currency,
					@BaseCurrency,
					@Market,	
					@MarketCode,
					@DummyField,
					@RunDate,
					@Serial2,
					@PromptDate,
					@StrikeShort,
					@Strike,
					@PutCall,
					@Lots,
					@Price,
					@OpenClose,
					@PostingAmount,
					@IsMergedTrade,
					@Series,
					@FullSeries,
					@Premium,
					@IsCashSettlingOption
				)
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[is_HReceiptPaymentDetails_Add]''
');

GO
EXECUTE ('

/*
<Details>
<Summary>Inserts an item into the HReceiptPaymentDetails table</Summary>
<Created author="laurentiu.macovei" date="04/05/2006 16:33:06" />
</Details>
*/
CREATE PROCEDURE [dbo].[is_HReceiptPaymentDetails_Add]
	@CorporationCode varchar(4) = NULL,
	@PrincipalBrokerageId varchar(1) = NULL,
	@OfficeCode varchar(4) = NULL,
	@ACNo varchar(10) = NULL,
	@SecuritiesId varchar(2) = NULL,
	@BaseDate datetime = NULL,
	@CalcDate datetime = NULL,
	@CalcStartTime datetime = NULL,
	@MarginId varchar(2) = NULL,
	@Currency varchar(3) = NULL,
	@PostDate datetime = NULL,
	@PaymentReceiptNo varchar(5) = NULL,
	@DetailsOfCashFlow varchar(1) = NULL,
	@PaymentReceiptId varchar(1) = NULL,
	@CancellationId varchar(1) = NULL,
	@AmntMoved decimal(15,0) = NULL,
	@EntryDate datetime = NULL,
	@InternalBankCode varchar(3) = NULL,
	@CheckNo varchar(6) = NULL
AS
SET NOCOUNT ON

SET NOCOUNT OFF

	DECLARE	@CalcDateStartTime DATETIME

	IF @BaseDate = ''01/01/1900 00:00:00'' 
		SET @BaseDate = NULL

	IF @CalcDate = ''01/01/1900 00:00:00'' 
		SET @CalcDate = NULL

	IF @CalcStartTime = ''01/01/1900 00:00:00'' 
		SET @CalcStartTime = NULL

	IF @PostDate = ''01/01/1900 00:00:00'' 
		SET @PostDate = NULL

	IF @EntryDate = ''01/01/1900 00:00:00'' 
		SET @EntryDate = NULL

	SET @CalcDateStartTime = CONVERT(DATETIME,CONVERT(VARCHAR(12), CONVERT(DATETIME,@CalcDate,112)) + '' '' + CONVERT(VARCHAR(8),RIGHT(@CalcStartTime,8)))

	INSERT INTO is_HReceiptPaymentDetails 
		(
			[CorporationCode], 
			[PrincipalBrokerageId], 
			[OfficeCode], 
			[ACNo], 
			[SecuritiesId], 
			[BaseDate], 
			[CalcDate], 
			[CalcStartTime], 
			[MarginId], 
			[Currency], 
			[PostDate], 
			[PaymentReceiptNo], 
			[DetailsOfCashFlow], 
			[PaymentReceiptId], 
			[CancellationId], 
			[AmntMoved], 
			[EntryDate], 
			[InternalBankCode], 
			[CheckNo]
		) 
	VALUES
		(
			@CorporationCode, 
			@PrincipalBrokerageId, 
			@OfficeCode, 
			@ACNo, 
			@SecuritiesId, 
			@BaseDate, 
			@CalcDate, 
			@CalcStartTime, 
			@MarginId, 
			@Currency, 
			@PostDate, 
			@PaymentReceiptNo, 
			@DetailsOfCashFlow, 
			@PaymentReceiptId, 
			@CancellationId, 
			@AmntMoved, 
			@EntryDate, 
			@InternalBankCode, 
			@CheckNo
		);

Return Scope_Identity()
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Instrument_Update_Id]''
');

GO
EXECUTE ('
/*
Programmer:		Lee Manifold
Date:			22/12/2006

Purpose:  This sp updates all tables with a instrumentId with a new InstrumentID
Revision History:
*/
CREATE PROCEDURE [dbo].[ib_Instrument_Update_Id]
	(
	@InstrumentId		int,
	@InstrumentId_New	int,
	@DataSourceId		int
	)
AS
SET NOCOUNT ON
	BEGIN TRAN
		--check for duplicates 
		UPDATE [dbo].[ib_Position] SET  [InstrumentId] = @InstrumentId_New WHERE [InstrumentId] = @InstrumentId
		UPDATE [dbo].[ib_Trx] SET  [InstrumentId] = @InstrumentId_New WHERE [InstrumentId] = @InstrumentId
		UPDATE [dbo].[ib_CloseOutReportDetail] SET  [InstrumentId] = @InstrumentId_New WHERE [InstrumentId] = @InstrumentId
		UPDATE [dbo].[ib_Trx] SET  [InstrumentId] = @InstrumentId_New WHERE [InstrumentId] = @InstrumentId
		UPDATE [dbo].[ib_TemplateGroup] SET  [InstrumentId] = @InstrumentId_New WHERE [InstrumentId] = @InstrumentId
		UPDATE [dbo].[ib_ImbalanceReportDetail] SET  [InstrumentId] = @InstrumentId_New WHERE [InstrumentId] = @InstrumentId
		UPDATE [dbo].[ib_CloseOutReportSummary] SET  [InstrumentId] = @InstrumentId_New WHERE [InstrumentId] = @InstrumentId
		UPDATE [dbo].[ib_ImbalanceReportSummary] SET  [InstrumentId] = @InstrumentId_New WHERE [InstrumentId] = @InstrumentId
		UPDATE [dbo].[ib_InstrumentDataSource] SET  [InstrumentId] = @InstrumentId_New WHERE [InstrumentId] = @InstrumentId
		UPDATE [dbo].[ib_Adjustment] SET  [InstrumentId] = @InstrumentId_New WHERE [InstrumentId] = @InstrumentId
		UPDATE [dbo].[ib_InstrumentDetail] SET  [InstrumentId] = @InstrumentId_New WHERE [InstrumentId] = @InstrumentId

		DELETE FROM [dbo].[ib_InstrumentDataSource] WHERE [InstrumentId] = @InstrumentId AND [DataSourceId] = @DataSourceId
		DELETE FROM [dbo].[ib_Instrument] WHERE [InstrumentId] = @InstrumentId

	COMMIT TRAN
');

GO
EXECUTE ('PRINT N''Creating [dbo].[C21_PreviousDayLine]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[C21_PreviousDayLine]
(
[PreviousDayLineID] [int] NOT NULL IDENTITY(1, 1),
[OrgID] [varchar] (5) NULL,
[TMF] [varchar] (10) NULL,
[PA] [varchar] (15) NULL,
[Guarantee] [varchar] (1) NULL,
[SettlementDate] [varchar] (8) NOT NULL,
[ContractAliasName] [varchar] (3) NULL,
[ContractAliasExp1] [varchar] (1) NULL,
[ContractAliasExp2] [varchar] (1) NULL,
[ContractAliasExp3] [varchar] (1) NULL,
[ContractAliasExp4] [varchar] (1) NULL,
[ContractAliasStrike] [varchar] (8) NULL,
[ContractAliasCPF] [varchar] (1) NULL,
[ContractAliasFull] [varchar] (40) NULL,
[IFTPrice] [varchar] (1) NULL,
[QMTPrice] [varchar] (18) NULL,
[BuyQty] [int] NULL,
[SellQty] [int] NULL,
[IFTDebit] [varchar] (1) NULL,
[QMTDebit] [varchar] (18) NULL,
[IFTCredit] [varchar] (1) NULL,
[QMTCredit] [varchar] (18) NULL,
[ISINCode] [varchar] (12) NULL,
[TradeCode] [varchar] (40) NULL,
[FileName] [varchar] (512) NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_C21_PreviousDayLine_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_C21_PreviousDayLine_CreateDate] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_C21_PreviousDayLine] on [dbo].[C21_PreviousDayLine]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[C21_PreviousDayLine] ADD CONSTRAINT [PK_C21_PreviousDayLine] PRIMARY KEY CLUSTERED  ([PreviousDayLineID])
');

GO
EXECUTE ('PRINT N''Creating index [IX_C21_PreviousDayLine_FileName] on [dbo].[C21_PreviousDayLine]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_C21_PreviousDayLine_FileName] ON [dbo].[C21_PreviousDayLine] ([FileName])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[C21_DetailLine]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[C21_DetailLine]
(
[DetailLineID] [int] NOT NULL IDENTITY(1, 1),
[SettlementDate] [varchar] (8) NULL,
[TMF] [varchar] (50) NULL,
[PA15] [varchar] (15) NULL,
[OrgID] [varchar] (5) NULL,
[Busdate] [varchar] (8) NULL,
[Wording] [varchar] (15) NULL,
[TradingEngine] [varchar] (5) NULL,
[c21TradeLegID] [varchar] (50) NULL,
[ExtTradeLegID] [varchar] (50) NULL,
[SendingMbr] [varchar] (50) NULL,
[BuyQtyIFT] [varchar] (1) NULL,
[BuyQtyQMT] [varchar] (18) NULL,
[SellQtyIFT] [varchar] (1) NULL,
[SellQtyQMT] [varchar] (18) NULL,
[IFTPrice] [varchar] (1) NULL,
[QMTPrice] [varchar] (18) NULL,
[C21ID] [varchar] (50) NULL,
[CorrectionType] [varchar] (1) NULL,
[InstructionType] [varchar] (1) NULL,
[Instruction] [varchar] (2) NULL,
[OCind] [varchar] (1) NULL,
[BuyQtyUpdateIFT] [varchar] (1) NULL,
[BuyQtyUpdateQMT] [varchar] (18) NULL,
[SellQtyUpdateIFT] [varchar] (1) NULL,
[SellQtyUpdateQMT] [varchar] (18) NULL,
[IFTDebit] [varchar] (1) NULL,
[QMTDebit] [varchar] (18) NULL,
[IFTCredit] [varchar] (1) NULL,
[QMTCredit] [varchar] (18) NULL,
[ContractAliasName] [varchar] (3) NULL,
[ContractAliasExp1] [varchar] (1) NULL,
[ContractAliasExp2] [varchar] (1) NULL,
[ContractAliasExp3] [varchar] (1) NULL,
[ContractAliasExp4] [varchar] (1) NULL,
[ContractAliasStrike] [varchar] (8) NULL,
[ContractAliasCPF] [varchar] (1) NULL,
[ContractAliasFull] [varchar] (40) NULL,
[FileName] [varchar] (512) NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_C21_DetailLine_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_C21_DetailLine_CreateDate] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_C21_DetailLine] on [dbo].[C21_DetailLine]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[C21_DetailLine] ADD CONSTRAINT [PK_C21_DetailLine] PRIMARY KEY CLUSTERED  ([DetailLineID])
');

GO
EXECUTE ('PRINT N''Creating index [IX_C21_DetailLine_FileName] on [dbo].[C21_DetailLine]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_C21_DetailLine_FileName] ON [dbo].[C21_DetailLine] ([FileName]) INCLUDE ([CreateDate], [DetailLineID])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_C21_Transaction_Load]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_C21_Transaction_Load]
	(
		@LocationPath VARCHAR(100)
		,@ReceiveLocationSysId INT
		,@RunId INT
	)
AS
SET NOCOUNT ON

/*
Description:  This stored procedure pulls data from the C21 data table
table and inserts it into the ib_Position ./ ib_trx table.  Also, any
new values encountered for firm, account, instrument, and currency create
new values in the lookups, as well as new values in the data tables for
these values.

Whilst iterating through the records in C21 data tables, all 
of these inserts are wrapped in a transaction so that any failure causes
the changes to not commit.

Note

For the values that come out of [C21_Format_Decimal], the results of these are
all converted to decimal(19,4).  This may / may not prove a problem for values 
@QuantityTR, @MarketValue and @Price.

*/
--
-- 12 Oct 2006	lm		Creation
-- 30 Apr 2009	Konrad	MONEP For Empty Strike Price and Empty option Type Code set the record to Future - Instrument= ''F'' + InstrumentCode and IntrumentType=''f''
-- 20 May 2009	Konrad  Exp Day set to the last day of the Exp Month and Exp Year if Exp Month and Exp Year are valid
-- 16 Jul 2009	AAJM	Update to account for new DetailAccountId column in ib_Trx table - see MBAL-12454
-- 16.07.2009	Konrad  Allow for MONEP futures bug fixed, included condition check for null values, left the instrumentTypeCd as different from ''f''
-- 22 Jul 2009	AAJM	MBAL-12377 use common source for default Strike Price Divisor
-- 23 Jul 2009	AAJM	MBAL-12486 Fix Expiry date being 10 years too early
-- 24 Jul 2009	AAJM	MBAL-12488 Fix Expiry Day always being set to 31
-- 24 Jul 2009	AAJM	MBAL-12589 MONEP swap year/month from reading YYMMDD to read MMYYDD
-- 28 Jul 2009	AAJM	MBAL-12623 Include QuantityLong and QuantityShort
-- 20 Oct 2009	amk		MBAL-13508 Use business date for As Of Date, not today
-- 26 Oct 2009	amk		MBAL-13614 Log importlog rows on start and end
-- 17 Feb 2010	AAJM	MBAL-13937 Stop same file being imported again
-- 03 Mar 2010	KevinP	MBAL-14819 Add ability to filter SELECT records by new [FileName] Column
-- 03 Mar 2010	amk		MBAL-14836 Change transaction isolation level
-- 23 Mar 2010	AAJM 	MBAL-15053 Ensure Instrument Type Code is correcly set
-- 29 Mar 2010	amk		MBAL-15100 bug fix: fix marketvalue calc so it''s not null
-- 16 Apr 2010	amk		MBAL-15151: Use header business date for As Of date (not date on detail line)
-- 13 Jul 2010  ED		MBAL-16126: fixes to assign, aband and underlying trade types
-- 14 Jul 2010  ED		MBAL 16126: fix underlying price
-- 15 Jul 2010  amk		MBAL-16126: REALLY fix underlying price (always positive)
-- 16 Jul 2010	amk		MBAL-16180: use different quantity fields for exercise, unassignment, and offset
-- 10 Aug 2010	amk		MBAL-16415: bug fix	1) Use nolock hint when selecting from c21_header
--											2) Only touch this file''s records when updating 
--												previousdayline records at end
--											3) Change loadstate here at start (improve concurrency)
-- 02 Jan 2014  RD		MBAL-24931 Added checking file age
-- 09 Jan 2014	ED		EIB 25004 - remove importLog table and use Log table
-- 25 Apr 2014	ED		EIB 25473 - raise error if file is too old and mark temp records as LoadState=3

	--Set the Datasource
	DECLARE @DataSourceCd VARCHAR(20)
	SET @DataSourceCd = ''Clearing21''

	DECLARE @DefaultCurrencyId INT
	DECLARE @ReturnValue INT
	DECLARE	@Output INT
	DECLARE	@Output2 INT
	DECLARE @DataSourceId INT

	--Gets the DataSource and DefaultCurrencyId values
	EXEC @ReturnValue = [dbo].[_ib_DataSource_GetByCodeForOutput] @DataSourceCd, @OutPut output, @Output2 output	
	SET @DataSourceId = @Output
	SET @DefaultCurrencyId = @Output2

	UPDATE C21_DetailLine
	SET LoadState = 1
	WHERE LoadState = 0
		AND Filename = @LocationPath

	UPDATE C21_PreviousDayLine
	SET LoadState = 1
	WHERE LoadState = 0
		AND Filename = @LocationPath

	-- Duplicate file check										
	DECLARE @IsFileAlreadyLoaded INT
	EXEC @IsFileALreadyLoaded = [HasFileBeenLoaded] @LocationPath, @DataSourceId

	IF @IsFileAlreadyLoaded = 1
	BEGIN
		UPDATE [dbo].[C21_DetailLine]
		SET [LoadState] = 3
		WHERE [LoadState] = 1
			AND [Filename] = @LocationPath
		
		UPDATE [dbo].[C21_PreviousDayLine]
		SET [LoadState] = 3
		WHERE [LoadState] = 1
			AND [Filename] = @LocationPath
			
		RETURN
	END

	-- get business date from header
	DECLARE @AsOfDate DATETIME
	
	SELECT @AsOfDate = CAST(BusinessDate AS DateTime) 
	FROM [C21_Header] (NOLOCK)
	WHERE FileName = @LocationPath

	IF @@ROWCOUNT = 0
	BEGIN
		DECLARE @Message VARCHAR(255)
		SET @Message = ''Could not find C21_Header row for filename: '' + @LocationPath
		RAISERROR (@Message, 19, 1) WITH LOG
	END

	--rd - make sure the As Of Date is not older than acceptable
	DECLARE @IsAcceptable bit
	EXECUTE [dbo].[Load_IsFileTooOld] @DataSourceId,@LocationPath,@AsOfDate,@IsAcceptable OUTPUT, @ReceiveLocationSysId, @RunId
	IF (@IsAcceptable = 0)
	BEGIN
		UPDATE [dbo].[C21_DetailLine] SET [LoadState] = 3 WHERE  [Filename] = @LocationPath
		UPDATE [dbo].[C21_PreviousDayLine] SET [LoadState] = 3 WHERE  [Filename] = @LocationPath
		RAISERROR (''File is too old.'', 18, 0)
		RETURN
	END

	BEGIN TRAN T1

		-- BizTalk''s SQL Adapter uses more restrictive read serializable
		-- so this is necessary to relax it to something that is default
		-- and perfectly acceptable!
		SET TRANSACTION ISOLATION LEVEL READ COMMITTED

		DECLARE @ExchangeCd					varchar(25)
		DECLARE @FirmCd						varchar(100)
		DECLARE @AccountCd					varchar(100)		
		DECLARE @InstrumentCd				varchar(100)
		DECLARE @QuantityTR					decimal(19,4)
		DECLARE @MarketValue				decimal(19,4)
		DECLARE @ExpiryDate					datetime
		DECLARE @StrikePrice				decimal(19,4)
		DECLARE @TrxTypeCd					varchar(25)
		DECLARE @OptionTypeCd				varchar(25)
		DECLARE @TrxDate					datetime
		DECLARE @Price						decimal(19,4)
		DECLARE @ExpYr						smallint
		DECLARE @ExpMth						smallint
		DECLARE @ExpDay						smallint
		DECLARE	@InstrumentTypeCd			varchar(100)
		DECLARE @ClassId					int
		DECLARE @QuantityLong				int
		DECLARE @QuantityShort				int
		DECLARE @TradedLongQuantity			decimal(19,4)
		DECLARE	@TradedShortQuantity		decimal(19,4)

		DECLARE	@Outputvchr					varchar(50)
		DECLARE @Code						varchar(100)
		DECLARE @Code2						varchar(100)
		DECLARE @InstrumentTypeId			int
		DECLARE @CurrencyId					int
		DECLARE @InstrumentId				int
		DECLARE @ExchangeId					int
		DECLARE	@StrikePriceDivisor			Decimal(19,4)
		DECLARE @ContractAliasFull			varchar(40)
		DECLARE @BuyQty						Decimal(19,4)
		DECLARE	@SellQty					Decimal(19,4)
		DECLARE @Credit						Decimal(19,4)
		DECLARE	@Debit						Decimal(19,4)
		DECLARE	@CurrencyCd					varchar(10)

		DECLARE @tmpID						int
		DECLARE @tmpOrgID					varchar(5)
		DECLARE	@tmpTMF						varchar(10)
		DECLARE	@tmpPA15					varchar(15)
		DECLARE @tmpBusDate					varchar(8)
		DECLARE @tmpBuyQtyQMT				decimal(19,4)		
		DECLARE	@tmpBuyQtyIFT				varchar(1)
		DECLARE	@tmpSellQtyQMT				decimal(19,4)
		DECLARE @tmpSellQtyIFT				varchar(1)
		DECLARE @tmpQMTCredit				varchar(30)		
		DECLARE @tmpIFTCredit				varchar(1)
		DECLARE @tmpQMTDebit				varchar(30)
		DECLARE @tmpIFTDebit				varchar(1)				
		DECLARE	@tmpIFTPrice				varchar(1)
		DECLARE	@tmpQMTPrice				decimal(19,4)
		DECLARE	@tmpSettlementDate			varchar(8)
		DECLARE	@tmpContractAliasName		varchar(3)
		DECLARE	@tmpContractAliasExp1		varchar(1)
		DECLARE	@tmpContractAliasExp2		varchar(1)
		DECLARE	@tmpContractAliasExp3		varchar(1)
		DECLARE	@tmpContractAliasExp4		varchar(1)
		DECLARE	@tmpContractAliasStrike		varchar(8)
		DECLARE	@tmpContractAliasCPF		varchar(1)
		DECLARE	@tmpContractAliasFull		varchar(40)
		DECLARE	@tmpWording			varchar(15)
		DECLARE @tmpBuyQtyUpdateQMT		decimal(19,4)		
		DECLARE	@tmpBuyQtyUpdateIFT		varchar(1)
		DECLARE	@tmpSellQtyUpdateQMT		decimal(19,4)
		DECLARE @tmpSellQtyUpdateIFT		varchar(1)
		DECLARE @TradingEngine			varchar(5)
		
		DECLARE pos_cursor CURSOR FOR
		SELECT 	[DetailLineID] AS [ID],
				[OrgID],
				[TMF],
				[PA15],
				[BusDate],
				CAST([BuyQtyQMT] AS Decimal(19,4)),
				[BuyQtyIFT],
				CAST([SellQtyQMT] AS Decimal(19,4)),
				[SellQtyIFT],
				[QMTCredit],
				[IFTCredit],
				[QMTDebit],
				[IFTDebit],
				[IFTPrice],
				CAST([QMTPrice] AS Decimal(19,4)),
				[SettlementDate],
				[ContractAliasName],
				[ContractAliasExp1],
				[ContractAliasExp2],
				[ContractAliasExp3],
				[ContractAliasExp4],
				[ContractAliasStrike],
				[ContractAliasCPF],
				[ContractAliasFull],
				[Wording],
				CAST([BuyQtyUpdateQMT] AS Decimal(19,4)),
				[BuyQtyUpdateIFT],
				CAST([SellQtyUpdateQMT] AS Decimal(19,4)),
				[SellQtyUpdateIFT],
				[TradingEngine]
		FROM [dbo].[C21_DetailLine]
		WHERE [LoadState] = 1
			AND [FileName] = @LocationPath

		OPEN pos_cursor

		FETCH NEXT FROM pos_cursor
		INTO	
			@tmpID,
			@tmpOrgID,
			@tmpTMF,
			@tmpPA15,
			@tmpBusDate,
			@tmpBuyQtyQMT,	
			@tmpBuyQtyIFT,
			@tmpSellQtyQMT,
			@tmpSellQtyIFT,
			@tmpQMTCredit,	
			@tmpIFTCredit,
			@tmpQMTDebit,
			@tmpIFTDebit,				
			@tmpIFTPrice,
			@tmpQMTPrice,
			@tmpSettlementDate,
			@tmpContractAliasName,
			@tmpContractAliasExp1,
			@tmpContractAliasExp2,
			@tmpContractAliasExp3,
			@tmpContractAliasExp4,
			@tmpContractAliasStrike,
			@tmpContractAliasCPF,
			@tmpContractAliasFull,
			@tmpWording,
			@tmpBuyQtyUpdateQMT,	
			@tmpBuyQtyUpdateIFT,
			@tmpSellQtyUpdateQMT,
			@tmpSellQtyUpdateIFT,
			@TradingEngine

		-- Check @@FETCH_STATUS to see if there are any more rows to fetch.
		WHILE @@FETCH_STATUS = 0
		BEGIN

			SET @Output = NULL
			SET @Output2 = NULL

			--Gets the ExchangeID from the DataSourceExchangeCode from the OrgID
			EXEC @ReturnValue = [dbo].[ib_DataSourceExchange_GetByCode] @DataSourceId, @tmpOrgID, @Output output
			SET @ExchangeID = @Output
			SET @Output = NULL

			SET @FirmCd = @tmpTMF
			SET @AccountCd = @tmpPA15 
			SET @TrxDate = CAST(@tmpBusDate AS DateTime) 

			SET @Outputvchr = NULL

			IF (@tmpWording = ''ASSIGNMENT'') 
				OR (@tmpWording = ''ABANDONMENT'')
				OR (@tmpWording = ''UNDERLYING'') 
				OR (@tmpWording = ''EXERCISE'') 
				OR (@tmpWording = ''UNASSIGNMENT'') 
				OR (@tmpWording = ''OFFSET'') 
			BEGIN
				--Gets the decimal places of the BuyQtyQMT using the BuyQtyIFT
				EXEC @ReturnValue = [dbo].[C21_Format_Decimal] @tmpBuyQtyUpdateIFT, @tmpBuyQtyUpdateQMT, @Outputvchr output
				SET @BuyQty = @Outputvchr
				SET @Outputvchr = NULL

				--Gets the decimal place of the SellQtyQMT using the SellQtyIFT
				EXEC @ReturnValue = [dbo].[C21_Format_Decimal] @tmpSellQtyUpdateIFT, @tmpSellQtyUpdateQMT, @Outputvchr output
				SET @SellQty = @Outputvchr
				SET @Outputvchr = NULL
			END
			ELSE
			BEGIN
				--Gets the decimal places of the BuyQtyQMT using the BuyQtyIFT
				EXEC @ReturnValue = [dbo].[C21_Format_Decimal] @tmpBuyQtyIFT, @tmpBuyQtyQMT, @Outputvchr output
				SET @BuyQty = @Outputvchr
				SET @Outputvchr = NULL

				--Gets the decimal place of the SellQtyQMT using the SellQtyIFT
				EXEC @ReturnValue = [dbo].[C21_Format_Decimal] @tmpSellQtyIFT, @tmpSellQtyQMT, @Outputvchr output
				SET @SellQty = @Outputvchr
				SET @Outputvchr = NULL
			END

			SET @QuantityLong = CONVERT(INT, ISNULL(@BuyQty, 0))
			SET @QuantityShort = CONVERT(INT, ISNULL(@SellQty, 0))
			SET @QuantityTR = @QuantityLong - @QuantityShort

			--Gets the decimal place of the QMTCredit using the IFTCredit
			IF LEN(@tmpQMTCredit) = 0  
				SET @tmpQMTCredit = 0

			SET @Outputvchr = 0
			EXEC @ReturnValue = [dbo].[C21_Format_Decimal] @tmpIFTCredit, @tmpQMTCredit, @Outputvchr output
			SET @Credit = @Outputvchr
			SET @Outputvchr = NULL

			--Gets the decimal place of the QMTDebit using the IFTDebit
			IF LEN(@tmpQMTDebit)= 0  
				SET @tmpQMTDebit = 0			

			SET @Outputvchr = 0
			EXEC @ReturnValue = [dbo].[C21_Format_Decimal] @tmpIFTDebit, @tmpQMTDebit, @Outputvchr output
			SET @Debit = @Outputvchr
			SET @Outputvchr = NULL

			SET @MarketValue = (@Credit - @Debit)

			--Gets the decimal place of the PriceIFT and PriceQMT
			EXEC @ReturnValue = [dbo].[C21_Format_Decimal]  @tmpIFTPrice, @tmpQMTPrice, @Outputvchr output
			SET @Price = @Outputvchr
			SET @Outputvchr = NULL

			SET @TrxTypeCd = @tmpWording
			SET @InstrumentTypeCd = ''S''
			SET @ClassID = NULL
			SET @TradedLongQuantity = NULL
			SET @TradedShortQuantity = NULL
			SET @ExchangeCd = @tmpOrgID

			--Different logic for InstrumentID,ExpiryYear, month, day, Strikeprice and OptiontypeCode
			--depending on Exchange type.
			IF @tmpOrgID = ''SBF''
				BEGIN
					SET @ExpYr = CAST( DATEPART(YYYY,@tmpSettlementDate) AS Int)
					SET @ExpMth	= CAST( DATEPART(MM,@tmpSettlementDate) AS Int)
					SET @ExpDay	= CAST( DATEPART(DD,@tmpSettlementDate) AS Int)
					SET @OptionTypeCd = ''''		
					SET @StrikePrice = 0
					SET @ContractAliasFull = @tmpContractAliasName + @tmpContractAliasExp1 + @tmpContractAliasExp2 + @tmpContractAliasExp3 + @tmpContractAliasExp4 + @tmpContractAliasStrike + @tmpContractAliasCPF	
					SET @InstrumentCd = LEFT(@ContractAliasFull,12)
					
					DECLARE @tmpOptionTypeCode VARCHAR(1)
					SET @tmpOptionTypeCode = RIGHT(@ContractAliasFull, 1)
					
					IF (UPPER(@tmpOptionTypeCode) IN (''P'',''C''))
						SET @InstrumentTypeCd = ''O''
					ELSE
						SET @InstrumentTypeCd = ''F''

				END
		
			IF @tmpOrgID = ''MONEP''
				BEGIN
					IF (@TradingEngine = ''FLEX'')
						BEGIN
							SET @ExpYr			= CAST(@tmpContractAliasExp1 + @tmpContractAliasExp2 AS INT) + 2000
							SET @ExpMth			= @tmpContractAliasExp3 + @tmpContractAliasExp4
							SET @ExpDay			= LEFT(@tmpContractAliasStrike,2)
							SET @tmpContractAliasStrike = SUBSTRING(@tmpContractAliasFull, 9, 8)
							SET @tmpContractAliasCPF = SUBSTRING(@tmpContractAliasFull, 18, 1)
						END
					ELSE
						BEGIN
							SET @ExpYr = CAST(@tmpContractAliasExp3 + @tmpContractAliasExp4 AS INT) + 2000
							SET @ExpMth = @tmpContractAliasExp1 + @tmpContractAliasExp2
							SET @ExpDay			= dbo.udf_GetDaysInMonth(@ExpYr,@ExpMth)
						END

					SET @OptionTypeCd = @tmpContractAliasCPF
					SET @InstrumentCd = ''O'' + @tmpContractAliasName
					SET @InstrumentTypeCd = ''O''

					IF LEN(RIGHT(@tmpContractAliasStrike,8)) > 0 
						SET @StrikePrice =  RIGHT(@tmpContractAliasStrike,8)

					IF LEN(RIGHT(@tmpContractAliasStrike,8)) = 0 or @tmpContractAliasStrike is null
						BEGIN
							SET @StrikePrice	= 0
							IF LEN(@OptionTypeCd) = 0 or @OptionTypeCd is null
								BEGIN
									
									SET @InstrumentCd = ''F'' + @tmpContractAliasName
									SET @InstrumentTypeCd = ''O''
								END
						END

				END
			
			IF @tmpOrgID = ''MATIF''			
				BEGIN

					IF LEN(LTRIM(@tmpContractAliasStrike)) = 0 AND LEN(LTRIM(@tmpContractAliasCPF)) = 0 
						BEGIN
							SET @InstrumentCd = ''F''+ @tmpContractAliasName 
							SET @InstrumentTypeCd = ''F''
						END
					ELSE 
						BEGIN
							SET @InstrumentCd = ''O''+ @tmpContractAliasName
							SET @InstrumentTypeCd = ''O''
						END

					SET @OptionTypeCd = RIGHT(@tmpContractAliasStrike,1)
					
					SET @StrikePrice = CAST(@tmpContractAliasExp3 + @tmpContractAliasExp4 + LEFT(@tmpContractAliasStrike,3) AS INT)
					SET @ExpYr = 2000 + CAST(@tmpContractAliasExp2 AS INT)
					
					DECLARE @CurrentYear SMALLINT
					SET @CurrentYear = YEAR(GETDATE())
										
					WHILE @ExpYr < @CurrentYear
						SET @ExpYr = @ExpYr + 10
						
					SELECT @ExpMth	= 
						CASE UPPER(@tmpContractAliasExp1)
							WHEN ''F'' THEN 1--''JAN''
							WHEN ''G'' THEN 2--''FEB''
							WHEN ''H'' THEN 3--''MAR''
							WHEN ''J'' THEN 4--''APR''
							WHEN ''K'' THEN 5--''MAY''
							WHEN ''M'' THEN 6--''JUN''
							WHEN ''N'' THEN 7--''JUL''
							WHEN ''Q'' THEN 8--''AUG''
							WHEN ''U'' THEN 9--''SEP''
							WHEN ''V'' THEN 10--''OCT''
							WHEN ''X'' THEN 11--''NOV''
							WHEN ''Z'' THEN 12--''DEC''
						END
			
					-- MBAL-12488
					-- Reset @ExpDay to zero to ensure that the previous value is not 
					-- sent through to dbo.udf_OnLoad_ExpiryDate_Get_Day
			
					SET @ExpDay = 0
				END
	
			--Get the StrikePrice Divisor and divide strikeprice by it if not null
			SELECT @StrikePriceDivisor	= StrikePriceDivisor
			FROM [dbo].[ib_InstrumentDataSource]
			WHERE DataSourceId = @DataSourceId
				AND DataSourceInstrumentCode = @InstrumentCd 	
			-- MBAL	16126 - 2a2 - set the price if uderlying 		
			IF @tmpWording = ''UNDERLYING''
			BEGIN	
				DECLARE @TickValue DECIMAL(25,10)
				SET @TickValue = (SELECT i.TickSize 
									FROM ib_Instrument i
									INNER JOIN [ib_InstrumentDataSource] ids 
										ON ids.InstrumentId = i.InstrumentId
									WHERE DataSourceId = @DataSourceId
										AND DataSourceInstrumentCode = @InstrumentCd
									)
				IF @TickValue IS NULL
					SET @TickValue = 1
				SET @Price = ABS(@MarketValue / ( @QuantityTR * @TickValue ))
			END
			IF @StrikePriceDivisor IS NULL
				BEGIN
					SET @StrikePriceDivisor = [dbo].[udf_GetDefaultStrikePriceDivisor](@DataSourceId, NULL)
				END

			SET @StrikePrice = CAST(@StrikePrice as decimal(19,4)) / @StrikePriceDivisor

			--Gets the InstrumentTypeID from the InstrumentTypeCode
			EXEC @ReturnValue = [dbo].[ib_InstrumentType_AddAsNeeded] @DataSourceId, @InstrumentTypeCd, @Output output
			SET @InstrumentTypeID = @Output
			SET @Output = NULL		

			SET @CurrencyCd = NULL
			SET @ExpDay = dbo.udf_OnLoad_ExpiryDate_Get_Day(@ExpYr,@ExpMth,@ExpDay)

			EXEC [dbo].[ib_Trx_Load]
					@DataSourceCd,
					@ExchangeCd,
					@FirmCd,
					@AccountCd,
					NULL, -- DetailAccountCd -- AAJM Added for MBAL-12454	
					@InstrumentCd,
					@ExpYr,
					@ExpMth,
					@ExpDay,
					@StrikePrice,
					@TrxTypeCd,
					@OptionTypeCd,
					@QuantityTR,
					@TrxDate,
					@Price,
					@tmpID,
					@InstrumentTypeCd,
					@AsOfDate,
					@LocationPath,
					@MarketValue,
					@CurrencyCd,
					@ClassId,
					@QuantityLong = @QuantityLong,
					@QuantityShort = @QuantityShort,
					@ReceiveLocationSysId = @ReceiveLocationSysId,
					@RunId = @RunId
			
			--flip processed flag in source table.
			UPDATE [dbo].[C21_DetailLine]
			SET [LoadState] = 2
			WHERE [DetailLineID] = @tmpID
				AND [LoadState] = 1

			FETCH NEXT FROM pos_cursor
			INTO 
				@tmpID,
				@tmpOrgID,
				@tmpTMF,
				@tmpPA15,
				@tmpBusDate,
				@tmpBuyQtyQMT,	
				@tmpBuyQtyIFT,
				@tmpSellQtyQMT,
				@tmpSellQtyIFT,
				@tmpQMTCredit,	
				@tmpIFTCredit,
				@tmpQMTDebit,
				@tmpIFTDebit,				
				@tmpIFTPrice,
				@tmpQMTPrice,
				@tmpSettlementDate,
				@tmpContractAliasName,
				@tmpContractAliasExp1,
				@tmpContractAliasExp2,
				@tmpContractAliasExp3,
				@tmpContractAliasExp4,
				@tmpContractAliasStrike,
				@tmpContractAliasCPF,
				@tmpContractAliasFull,
				@tmpWording,
				@tmpBuyQtyUpdateQMT,	
				@tmpBuyQtyUpdateIFT,
				@tmpSellQtyUpdateQMT,
				@tmpSellQtyUpdateIFT,
				@TradingEngine

		END

		CLOSE pos_cursor
		DEALLOCATE pos_cursor
	
		--Update the Previous day line data (for completeness)
		UPDATE [dbo].[C21_PreviousDayLine]
		SET [LoadState] = 2
		WHERE [LoadState] = 1
			AND [Filename] = @LocationPath

	COMMIT TRAN T1
');

GO
EXECUTE ('PRINT N''Creating [dbo].[BancoSantander_HOSTTRN_V2_LoadStateChange]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[BancoSantander_HOSTTRN_V2_LoadStateChange]
		@OldLoadState	TINYINT,
		@NewLoadState	TINYINT,
		@FileName VARCHAR(512) = NULL
AS
BEGIN
/*
Author		Date			Description
AlisterM	09 Oct 2012		Creation
*/


	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	UPDATE [dbo].[BancoSantander_HOSTTRN] SET LoadState = @NewLoadState   
	WHERE LoadState= @OldLoadState
	  AND [FileName] = COALESCE(@FileName, [FileName])
	
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[is_HTradeDetails_Add]''
');

GO
EXECUTE ('


/*
<Details>
<Summary>Inserts an item into the HTradeDetails table</Summary>
<Created author="laurentiu.macovei" date="04/05/2006 16:33:06" />
</Details>
*/
CREATE PROCEDURE [dbo].[is_HTradeDetails_Add]
	@CorporationCode varchar(4) = NULL,
	@PrincipalBrokerageId varchar(1) = NULL,
	@OfficeCode varchar(4) = NULL,
	@ACNo varchar(10) = NULL,
	@SecuritiesId varchar(2) = NULL,
	@BaseDate datetime = NULL,
	@CalcDate datetime = NULL,
	@CalcStartTime datetime = NULL,
	@TradeDate datetime = NULL,
	@ExecutionMarketCode varchar(2) = NULL,
	@DerivativesCode varchar(10) = NULL,
	@SecCode1 varchar(7) = NULL,
	@SecCode2 varchar(4) = NULL,
	@SecCode3 varchar(2) = NULL,
	@SecCode4 varchar(1) = NULL,
	@TradeCode varchar(2) = NULL,
	@BuySellId varchar(1) = NULL,
	@CancelDataId varchar(1) = NULL,
	@InputDate datetime = NULL,
	@CancelInputDate datetime = NULL,
	@OptExerciseAllotmentId varchar(1) = NULL,
	@SpreadNo varchar(5) = NULL,
	@AutomaticExerciseAllotmentId varchar(1) = NULL,
	@TradeNo varchar(5) = NULL,
	@SubTradeNo varchar(3) = NULL,
	@ContractMonth varchar(7) = NULL,
	@StrikePrice decimal(15,0) = NULL,
	@Quantity decimal(11,4) = NULL,
	@UnitPrice decimal(11,2) = NULL,
	@ExecutionAmnt decimal(15,0) = NULL,
	@Commission decimal(15,0) = NULL,
	@ConsumptionTax decimal(15,0) = NULL,
	@ExchangeTax decimal(15,0) = NULL,
	@NetAmnt decimal(15,0) = NULL,
	@Remarks1 varchar(45) = NULL,
	@Remarks2 varchar(45) = NULL,
	@LocalCustomerInformation varchar(12) = NULL,
	@CustomerNameAbb varchar(35) = NULL,
	@SecNameInEnglish varchar(28) = NULL,
	@SecNameInKana varchar(24) = NULL,
	@NightTradingId varchar(1) = NULL,
	@TradeType varchar(1) = NULL,
	@ExecutionDate datetime = NULL,
	@CostPaymentMethod varchar(1) = NULL,
	@MemberCode varchar(4) = NULL
AS
SET NOCOUNT ON

SET NOCOUNT OFF

	DECLARE	@CalcDateStartTime DATETIME

	
	IF @BaseDate = ''01/01/1900 00:00:00'' 
		SET @BaseDate = NULL

	IF @CalcDate = ''01/01/1900 00:00:00'' 
		SET @CalcDate = NULL

	IF @CalcStartTime = ''01/01/1900 00:00:00'' 
		SET @CalcStartTime = NULL

	IF @TradeDate = ''01/01/1900 00:00:00'' 
		SET @TradeDate = NULL

	IF @InputDate = ''01/01/1900 00:00:00'' 
		SET @InputDate = NULL

	IF @CancelInputDate = ''01/01/1900 00:00:00'' 
		SET @CancelInputDate = NULL

	IF @ExecutionDate = ''01/01/1900 00:00:00'' 
		SET @ExecutionDate = NULL

	SET @CalcDateStartTime = CONVERT(DATETIME,CONVERT(VARCHAR(12), CONVERT(DATETIME,@CalcDate,112)) + '' '' + CONVERT(VARCHAR(8),RIGHT(@CalcStartTime,8)))

	INSERT INTO is_HTradeDetails 
		(
			[CorporationCode], 
			[PrincipalBrokerageId], 
			[OfficeCode], 
			[ACNo], 
			[SecuritiesId], 
			[BaseDate], 
			[CalcDate], 
			[CalcStartTime], 
			[CalcDateStartTime],
			[TradeDate], 
			[ExecutionMarketCode], 
			[DerivativesCode], 
			[SecCode1], 
			[SecCode2], 
			[SecCode3], 
			[SecCode4], 
			[TradeCode], 
			[BuySellId], 
			[CancelDataId], 
			[InputDate], 
			[CancelInputDate], 
			[OptExerciseAllotmentId], 
			[SpreadNo], 
			[AutomaticExerciseAllotmentId], 
			[TradeNo], 
			[SubTradeNo], 
			[ContractMonth], 
			[StrikePrice], 
			[Quantity], 
			[UnitPrice], 
			[ExecutionAmnt], 
			[Commission], 
			[ConsumptionTax], 
			[ExchangeTax], 
			[NetAmnt], 
			[Remarks1], 
			[Remarks2], 
			[LocalCustomerInformation], 
			[CustomerNameAbb], 
			[SecNameInEnglish], 
			[SecNameInKana], 
			[NightTradingId], 
			[TradeType], 
			[ExecutionDate], 
			[CostPaymentMethod], 
			[MemberCode]
		) 
	VALUES
		(
			@CorporationCode, 
			@PrincipalBrokerageId, 
			@OfficeCode, 
			@ACNo, 
			@SecuritiesId, 
			@BaseDate, 
			@CalcDate,
			@CalcDateStartTime,
			@CalcStartTime, 
			@TradeDate, 
			@ExecutionMarketCode, 
			@DerivativesCode, 
			@SecCode1, 
			@SecCode2, 
			@SecCode3, 
			@SecCode4, 
			@TradeCode, 
			@BuySellId, 
			@CancelDataId, 
			@InputDate, 
			@CancelInputDate, 
			@OptExerciseAllotmentId, 
			@SpreadNo, 
			@AutomaticExerciseAllotmentId, 
			@TradeNo, 
			@SubTradeNo, 
			@ContractMonth, 
			@StrikePrice, 
			@Quantity, 
			@UnitPrice, 
			@ExecutionAmnt, 
			@Commission, 
			@ConsumptionTax, 
			@ExchangeTax, 
			@NetAmnt, 
			@Remarks1, 
			@Remarks2, 
			@LocalCustomerInformation, 
			@CustomerNameAbb, 
			@SecNameInEnglish, 
			@SecNameInKana, 
			@NightTradingId, 
			@TradeType, 
			@ExecutionDate, 
			@CostPaymentMethod, 
			@MemberCode
		);

Return Scope_Identity()
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_CloseoutReport_BuildReportPhase2]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_CloseoutReport_BuildReportPhase2]
	@ReportId INT
	, @CloseoutReportId INT
AS
SET NOCOUNT ON

--	We have data populated in the ib_CloseoutReportDetail table from [ib_CloseoutReport_BuildReportPhase1],
--	we need to take that and group it (e.g. Consolidate it) suitable for output on the report.
--
--	 3 Oct 2006		lm		Creation
--	18 Dec 2006		amk		1) BUG FIX: Populate ClassId in #tg temp table
--							2) Collapse 0/null''s/empty strings in OptionTypeCode and StrikePrice
--	17 Jan 2007		ce		New feature: Insert and Group By UseNetForCloseOut
--										, and add mathmetical processing at the end
--	25 Jan 2007		amk		Per Martin, don''t include any Unknown records for the moment
--	29 Apr 2010		am		MBAL-15308: Correct the Internal Position Calculation
--										Remove Charle''s code that does mathmatical processing at the end
--	23 Nov 2010		amk		MBAL-16994: 1) remove some commented out code
--										2) reformat indents
--										3) bring in adjustments without an account by slyly crafting the match code
-- 24 Nov 2010		amk		MBAL-17072: bug fix: if class null on adjustment, see if it''s on account
--										this fix really belongs in manual adjustment add but easy to 
--										patch here
-- 01 May 2012		ED		MBAL 20398 and MBAL 20400 : add logic for family code and Omnibus
	--update the report status
	UPDATE [dbo].[ib_Report]
	SET [Stage] = ''Phase 2: Preparing temporary tables''
	WHERE ReportId = @ReportId

	--Create the TemplateGroup #tg Temporary table with only needed records
	CREATE TABLE #tg
	(	
		[ExchangeId] int, 
		[FirmId] int, 
		[AccountId] int, 
		[InstrumentID] int, 
		[ClassId] int,
		[Description] varchar(100)
	)
	--Create the table for storing visited items
	CREATE TABLE #visitedItems
	(	
		[CloseoutReportDetailId] int
	)
	--Create the table for storing visiting items
	CREATE TABLE #visitingReportDetails
	(	
		[CloseoutReportDetailId] int NOT NULL,
		[Description] varchar(100) NOT NULL
	)

	--Create a temporary table to store & compare results
	CREATE TABLE #results 
	(
		[ExchangeId] [int] NOT NULL,
		[InstrumentId] [int] NOT NULL,
		[FirmId] [int] NOT NULL,
		[AccountId] [int] NULL,
		[ClassId] [int] NULL,
		[ExpiryYear] [smallint] NOT NULL,
		[ExpiryMonth] [smallint] NOT NULL,
		[ExpiryDay] [smallint] NULL,
		[InstrumentTypeId] [int] NOT NULL,
		[OptionTypeCode] [varchar](25) COLLATE Latin1_General_CI_AS NULL,
		[UseNetForCloseOut] [bit] NOT NULL,
		[StrikePrice] [decimal](19, 4) NULL,
		[TradedBought] [decimal](19, 4) NOT NULL,
		[TradedSold] [decimal](19, 4) NOT NULL,
		[InternalLong] [decimal](19, 4) NOT NULL,
		[InternalShort] [decimal](19, 4) NOT NULL,
		[ExternalLong] [decimal](19, 4) NOT NULL,
		[ExternalShort] [decimal](19, 4) NOT NULL,
		[Description] varchar(100),
		[Exchange] varchar(50) NULL,
		[Currency] varchar(100) NULL,
		[Instrument] varchar(100) NULL
	)

	--TESTING
	DELETE FROM ib_CloseoutReportSummary 
	WHERE CloseoutReportId = @CloseOutReportId

	--update the report status
	UPDATE [dbo].[ib_Report]
	SET [Stage] = ''Phase 2: Updating class''
	WHERE ReportId = @ReportId

	UPDATE ib_CloseoutReportDetail
	SET ClassId = a.ClassId
	FROM ib_CloseoutReportDetail crd
		JOIN ib_Account a ON crd.AccountId = a.AccountId
	WHERE crd.ClassId IS NULL
		AND a.ClassId IS NOT NULL
		AND crd.CloseoutReportId = @CloseoutReportId

	--update the report status
	UPDATE [dbo].[ib_Report]
	SET [Stage] = ''Phase 2: Gathering data without account''
	WHERE ReportId = @ReportId

	DECLARE @MatchCodeSuffix VARCHAR(100)
	SET @MatchCodeSuffix = '' CLOSEOUT''

	INSERT INTO #visitingReportDetails([CloseoutReportDetailId], [Description])
	SELECT crd.CloseoutReportDetailId, mc.MatchCode + @MatchCodeSuffix
	FROM ib_CloseoutReportDetail crd 
		INNER JOIN ib_CloseoutReport ir ON ir.CloseoutReportId = @CloseoutReportId 
			AND ir.CloseoutReportId = crd.CloseoutReportId
			AND crd.CloseoutReportDetailId NOT IN 
					(SELECT CloseoutReportDetailId FROM #visitedItems) --exclude previous items
		INNER JOIN ib_MatchCode mc ON mc.MatchCodeId = crd.SourceMatchCodeId
	WHERE crd.AccountId IS NULL
		AND EXISTS (SELECT *
					FROM ib_TemplateGroup tg
					WHERE tg.TemplateId = ir.TemplateId
						AND tg.Description = mc.MatchCode + @MatchCodeSuffix)

	EXEC ib_CloseoutReport_GroupByRule

	--update the report status
	UPDATE [dbo].[ib_Report]
	SET [Stage] = ''Phase 2: Gathering Template Groups''
	WHERE ReportId = @ReportId

	--INSERT Template Group elements for the specified TemplateID of the provided CloseoutReportId
	INSERT INTO #tg(ExchangeId, FirmId, AccountId, InstrumentID, Description, ClassId)
	SELECT tg.ExchangeId, tg.FirmId, tg.AccountId, tg.InstrumentID, tg.Description, tg.ClassId 
	FROM ib_TemplateGroup tg
		INNER JOIN ib_CloseoutReport ir ON ir.CloseoutReportId = @CloseoutReportId 
			AND tg.TemplateId = ir.TemplateId

	--update the report status
	UPDATE [dbo].[ib_Report]
	SET [Stage] = ''Phase 2: Gathering records matching rule 1 of 5''
	WHERE ReportId = @ReportId

	--MARTIN''s MATRIX RULE #1 (Firm Exchange Account Instrument)
	--INSERT records that mach Martin''s rule #1 (Firm Exchange Account Instrument)
	INSERT INTO #visitingReportDetails([CloseoutReportDetailId], [Description])
	SELECT [crd].[CloseoutReportDetailId], [tg].[Description]
	FROM [dbo].[ib_CloseoutReportDetail] crd 
		INNER JOIN [ib_CloseoutReport] ir ON 
			ir.CloseoutReportId = @CloseoutReportId 
		AND ir.CloseoutReportId = crd.CloseoutReportId
		AND [crd].[CloseoutReportDetailId] NOT IN (SELECT CloseoutReportDetailId FROM #visitedItems) --exclude previous items
		INNER JOIN #tg tg ON
			[tg].[ClassId] = [crd].[ClassId]
		AND	[tg].[FirmId] = [crd].[FirmId]
		AND [tg].[ExchangeId] = [crd].[ExchangeId]
		AND [tg].[AccountId] = [crd].[AccountId]
		AND [tg].[InstrumentId] = [crd].[InstrumentId]

	EXEC [dbo].[ib_CloseoutReport_GroupByRule]

	INSERT INTO #visitingReportDetails([CloseoutReportDetailId], [Description])
	SELECT	[crd].[CloseoutReportDetailId], [tg].[Description]
	FROM [dbo].[ib_CloseoutReportDetail] crd 
		INNER JOIN [ib_CloseoutReport] ir ON 
			ir.CloseoutReportId = @CloseoutReportId 
		AND ir.CloseoutReportId = crd.CloseoutReportId
		AND [crd].[CloseoutReportDetailId] NOT IN (SELECT CloseoutReportDetailId FROM #visitedItems) --exclude previous items
		INNER JOIN #tg tg ON
			[tg].[ClassId] IS NULL 
		AND	[tg].[FirmId] = [crd].[FirmId]
		AND [tg].[ExchangeId] = [crd].[ExchangeId] 
		AND [tg].[AccountId] = [crd].[AccountId]
		AND [tg].[InstrumentId] = [crd].[InstrumentId]

	EXEC [dbo].[ib_CloseoutReport_GroupByRule]

	--update the report status
	UPDATE [dbo].[ib_Report]
	SET [Stage] = ''Phase 2: Gathering records matching rule 2 of 5''
	WHERE ReportId = @ReportId

	--MARTIN''s MATRIX RULE #2 (Firm Exchange Account)
	--Select records that mach Martin''s rule #2 (Firm Exchange Account), BUT excluding duplicates from already existing record (rule #1)
	--These will be appended to the previous records (rule #1)
	INSERT INTO #visitingReportDetails([CloseoutReportDetailId], [Description])
	SELECT [crd].[CloseoutReportDetailId], [tg].[Description]
	FROM [dbo].[ib_CloseoutReportDetail] crd
		INNER JOIN [ib_CloseoutReport] ir ON
			ir.CloseoutReportId = @CloseoutReportId
		AND ir.CloseoutReportId = crd.CloseoutReportId
		AND [crd].[CloseoutReportDetailId] NOT IN (SELECT CloseoutReportDetailId FROM #visitedItems) --exclude previous items
		INNER JOIN #tg tg ON
			[tg].[ClassId] = [crd].[ClassId] 
		AND	[tg].[FirmId] = [crd].[FirmId]
		AND [tg].[ExchangeId] = [crd].[ExchangeId]
		AND [tg].[AccountId] = [crd].[AccountId]
		AND [tg].[InstrumentId] IS NULL

	EXEC [dbo].[ib_CloseoutReport_GroupByRule]

	INSERT INTO #visitingReportDetails([CloseoutReportDetailId], [Description])
	SELECT	[crd].[CloseoutReportDetailId], [tg].[Description]
	FROM [dbo].[ib_CloseoutReportDetail] crd 
		INNER JOIN [ib_CloseoutReport] ir ON 
			ir.CloseoutReportId = @CloseoutReportId 
		AND ir.CloseoutReportId = crd.CloseoutReportId
		AND [crd].[CloseoutReportDetailId] NOT IN (SELECT CloseoutReportDetailId FROM #visitedItems) --exclude previous items
		INNER JOIN #tg tg ON
			[tg].[ClassId] IS NULL 
		AND	[tg].[FirmId] = [crd].[FirmId]
		AND [tg].[ExchangeId] = [crd].[ExchangeId]
		AND [tg].[AccountId] = [crd].[AccountId]
		AND [tg].[InstrumentId] IS NULL

	EXEC [dbo].[ib_CloseoutReport_GroupByRule]

	--update the report status
	UPDATE [dbo].[ib_Report]
	SET [Stage] = ''Phase 2: Gathering records matching rule 3 of 5''
	WHERE ReportId = @ReportId

	--MARTIN''s MATRIX RULE #3 (Firm Account)
	--Select records that mach Martin''s rule #3 (Firm Account), BUT excluding duplicates from already existing record (rule #1 and rule #2)
	--These will be appended to the previous records ((rule #1 UNION rule #2)''s records)
	INSERT INTO #visitingReportDetails([CloseoutReportDetailId], [Description])
	SELECT [crd].[CloseoutReportDetailId], [tg].[Description]
	FROM [dbo].[ib_CloseoutReportDetail] crd
		INNER JOIN [ib_CloseoutReport] ir ON
			ir.CloseoutReportId = @CloseoutReportId
		AND ir.CloseoutReportId = crd.CloseoutReportId
		AND [crd].[CloseoutReportDetailId] NOT IN (SELECT CloseoutReportDetailId FROM #visitedItems) --exclude previous items
		INNER JOIN #tg tg ON
			[tg].[ClassId] = [crd].[ClassId] 
		AND	[tg].[FirmId] = [crd].[FirmId]
		AND [tg].[ExchangeId] IS NULL
		AND [tg].[AccountId] = [crd].[AccountId]
		AND [tg].[InstrumentId] IS NULL

	EXEC [dbo].[ib_CloseoutReport_GroupByRule]

	INSERT INTO #visitingReportDetails([CloseoutReportDetailId], [Description])
	SELECT	[crd].[CloseoutReportDetailId], [tg].[Description]
	FROM [dbo].[ib_CloseoutReportDetail] crd 
		INNER JOIN [ib_CloseoutReport] ir ON 
			ir.CloseoutReportId = @CloseoutReportId 
		AND ir.CloseoutReportId = crd.CloseoutReportId
		AND [crd].[CloseoutReportDetailId] NOT IN (SELECT CloseoutReportDetailId FROM #visitedItems) --exclude previous items
		INNER JOIN #tg tg ON
			[tg].[ClassId] IS NULL 
		AND	[tg].[FirmId] = [crd].[FirmId]
		AND [tg].[ExchangeId] IS NULL
		AND [tg].[AccountId] = [crd].[AccountId]
		AND [tg].[InstrumentId] IS NULL

	EXEC [dbo].[ib_CloseoutReport_GroupByRule]

	--update the report status
	UPDATE [dbo].[ib_Report]
	SET [Stage] = ''Phase 2: Gathering records matching rule 4 of 5''
	WHERE ReportId = @ReportId

	--MARTIN''s MATRIX RULE #4 (Firm Exchange)
	--Select records that mach Martin''s rule #4 (Firm Exchange), BUT excluding duplicates from already existing record (rule #1, rule #2 and rule #3)
	--These will be appended to the previous records ((rule #1 UNION #2 UNION r3)''s records)
	INSERT INTO #visitingReportDetails([CloseoutReportDetailId], [Description])
	SELECT [crd].[CloseoutReportDetailId], [tg].[Description]
	FROM [dbo].[ib_CloseoutReportDetail] crd
		INNER JOIN [ib_CloseoutReport] ir ON
			ir.CloseoutReportId = @CloseoutReportId
		AND ir.CloseoutReportId = crd.CloseoutReportId
		AND [crd].[CloseoutReportDetailId] NOT IN (SELECT CloseoutReportDetailId FROM #visitedItems) --exclude previous items
		INNER JOIN #tg tg ON
			[tg].[ClassId] = [crd].[ClassId] 
		AND	[tg].[FirmId] = [crd].[FirmId]
		AND [tg].[ExchangeId] = [crd].[ExchangeId]
		AND [tg].[AccountId] IS NULL
		AND [tg].[InstrumentId] IS NULL

	EXEC [dbo].[ib_CloseoutReport_GroupByRule]

	INSERT INTO #visitingReportDetails([CloseoutReportDetailId], [Description])
	SELECT	[crd].[CloseoutReportDetailId], [tg].[Description]
	FROM [dbo].[ib_CloseoutReportDetail] crd 
		INNER JOIN [ib_CloseoutReport] ir ON 
			ir.CloseoutReportId = @CloseoutReportId 
		AND ir.CloseoutReportId = crd.CloseoutReportId
		AND [crd].[CloseoutReportDetailId] NOT IN (SELECT CloseoutReportDetailId FROM #visitedItems) --exclude previous items
		INNER JOIN #tg tg ON
			[tg].[ClassId] IS NULL 
		AND	[tg].[FirmId] = [crd].[FirmId]
		AND [tg].[ExchangeId] = [crd].[ExchangeId]
		AND [tg].[AccountId] IS NULL
		AND [tg].[InstrumentId] IS NULL

	EXEC [dbo].[ib_CloseoutReport_GroupByRule]

	--update the report status
	UPDATE [dbo].[ib_Report]
	SET [Stage] = ''Phase 2: Gathering records matching rule 5 of 5''
	WHERE ReportId = @ReportId

	--MARTIN''s MATRIX RULE #5 (Firm)
	--Select records that mach Martin''s rule #5 (Firm), BUT excluding duplicates from already existing record (rule #1, rule #2 and rule #3 and rule #4)
	--These will be appended to the previous records ((rule #1 UNION #2 UNION r3 UNION r4)''s records)
	INSERT INTO #visitingReportDetails([CloseoutReportDetailId], [Description])
	SELECT [crd].[CloseoutReportDetailId], [tg].[Description]
	FROM [dbo].[ib_CloseoutReportDetail] crd
		INNER JOIN [ib_CloseoutReport] ir ON
			ir.CloseoutReportId = @CloseoutReportId
		AND ir.CloseoutReportId = crd.CloseoutReportId
		AND [crd].[CloseoutReportDetailId] NOT IN (SELECT CloseoutReportDetailId FROM #visitedItems) --exclude previous items
		INNER JOIN #tg tg ON
			[tg].[ClassId] = [crd].[ClassId] 
		AND	[tg].[FirmId] = [crd].[FirmId]
		AND [tg].[ExchangeId] IS NULL
		AND [tg].[AccountId] IS NULL
		AND [tg].[InstrumentId] IS NULL

	EXEC [dbo].[ib_CloseoutReport_GroupByRule]

	INSERT INTO #visitingReportDetails([CloseoutReportDetailId], [Description])
	SELECT	[crd].[CloseoutReportDetailId], [tg].[Description]
	FROM [dbo].[ib_CloseoutReportDetail] crd 
		INNER JOIN [ib_CloseoutReport] ir ON 
			ir.CloseoutReportId = @CloseoutReportId 
		AND ir.CloseoutReportId = crd.CloseoutReportId
		AND [crd].[CloseoutReportDetailId] NOT IN (SELECT CloseoutReportDetailId FROM #visitedItems) --exclude previous items
		INNER JOIN #tg tg ON
			[tg].[ClassId] IS NULL 
		AND	[tg].[FirmId] = [crd].[FirmId]
		AND [tg].[ExchangeId] IS NULL
		AND [tg].[AccountId] IS NULL
		AND [tg].[InstrumentId] IS NULL

	EXEC [dbo].[ib_CloseoutReport_GroupByRule]

	--update the report status
	UPDATE [dbo].[ib_Report]
	SET [Stage] = ''Phase 2: Gathering the remaining ungrouped through a template items''
	WHERE ReportId = @ReportId

/*

DON''T INCLUDE ''UNKNOWN'' RECORDS FOR THE MOMENT

--APPEND those rows wich doesn''t map to any of the MARTIN''s MATRIX RULES, BUT excluding duplicates from already existing record (all Martin''s matrix rules)
--These will be appended to the previous records (all of the MARTIN''s MATRIX RULES)
	INSERT INTO #visitingReportDetails([CloseoutReportDetailId], [Description])
		SELECT	[crd].[CloseoutReportDetailId], ''Unknown''
			FROM [dbo].[ib_CloseoutReportDetail] crd 
				INNER JOIN [ib_CloseoutReport] ir ON 
					ir.CloseoutReportId = @CloseoutReportId 
				AND ir.CloseoutReportId = crd.CloseoutReportId
				AND [crd].[CloseoutReportDetailId] NOT IN (SELECT CloseoutReportDetailId FROM #visitedItems) --exclude previous items
				AND [crd].[ClassId] IS NOT NULL 

	EXEC [dbo].[ib_CloseoutReport_GroupByRule]

	INSERT INTO #visitingReportDetails([CloseoutReportDetailId], [Description])
		SELECT [crd].[CloseoutReportDetailId], ''Unknown''
			FROM [dbo].[ib_CloseoutReportDetail] crd 
				INNER JOIN [ib_CloseoutReport] ir ON 
					ir.CloseoutReportId = @CloseoutReportId 
				AND ir.CloseoutReportId = crd.CloseoutReportId
				AND [crd].[CloseoutReportDetailId] NOT IN (SELECT CloseoutReportDetailId FROM #visitedItems) --exclude previous items
				AND [crd].[ClassId] IS NULL 

	EXEC [dbo].[ib_CloseoutReport_GroupByRule]

*/

	--update the report status
	UPDATE [dbo].[ib_Report]
	SET [Stage] = ''Phase 2: Updating exchange, currency and instrument information''
	WHERE ReportId = @ReportId

	--UPDATE the Exchange and instrument
	UPDATE #results 
	SET [Exchange] = 
	(SELECT [e].[Name] 
		FROM [dbo].[ib_Exchange] e
		WHERE [e].[ExchangeId] = [r].[ExchangeID]),
	[Instrument] =
	(SELECT [i].[Code] 
		FROM [dbo].[ib_Instrument] i
		WHERE [i].[InstrumentId] = [r].[InstrumentID])
	FROM #results r

	-- fix null vs. empty string in option type code
	UPDATE #results
	SET OptionTypeCode = ''''
	WHERE OptionTypeCode IS NULL

	-- fix null vs. 0 in strike price
	UPDATE #results
	SET StrikePrice = 0
	WHERE StrikePrice IS NULL

	--update the report status
	UPDATE [dbo].[ib_Report]
	SET [Stage] = ''Phase 2: Collapsing data to summary''
	WHERE ReportId = @ReportId

--collapse data into summary
--INSERT INTO ib_CloseOutReportSummary(
--	[CloseOutReportId], [ExchangeId], [InstrumentId],
--	[ExpiryYear], [ExpiryMonth], [ExpiryDay],
--	[InstrumentTypeId], [OptionTypeCode], [UseNetForCloseOut], [StrikePrice],
--	[TradedBought], [TradedSold], [InternalLong], [InternalShort],
--	[ExternalLong], [ExternalShort], [Description],
--	[CloseOutLong], [CloseOutShort], [Imbalance],
--	[ExchangeCode], [InstrumentTypeCode])
--SELECT @CloseoutReportId, r.[ExchangeId], r.[InstrumentId],
--	[ExpiryYear], [ExpiryMonth], [ExpiryDay],
--	r.[InstrumentTypeId], [OptionTypeCode], [UseNetForCloseOut], [StrikePrice], 
--	SUM([TradedBought]), SUM([TradedSold]), 
--	SUM([InternalLong]), SUM([InternalShort]),
--	SUM([ExternalLong]), SUM([ExternalShort]), 
--	[Description], 0, 0, 0,
--	e.[Code] as ExchangeCode, it.Code as InstrumentTypeCode
--	FROM #results r
--		INNER JOIN ib_Exchange e ON e.ExchangeId = r.ExchangeId
--		INNER JOIN ib_InstrumentType it ON it.InstrumentTypeId = r.InstrumentTypeId
--	GROUP BY r.[ExchangeId], r.[InstrumentId], r.[InstrumentTypeId],
--			 [ExpiryMonth], [ExpiryYear], [ExpiryDay], 
--			 [OptionTypeCode], [UseNetForCloseOut], [StrikePrice], [Description],
--			 e.[Code], it.[Code]

-- insert rows that has omnibus or no family code set

	INSERT INTO ib_CloseOutReportSummary(
		[CloseOutReportId], [ExchangeId], [InstrumentId],
		[ExpiryYear], [ExpiryMonth], [ExpiryDay],
		[InstrumentTypeId], [OptionTypeCode], [UseNetForCloseOut], [StrikePrice],
		[TradedBought], [TradedSold], [InternalLong], [InternalShort],
		[ExternalLong], [ExternalShort], [Description],
		[CloseOutLong], [CloseOutShort], [Imbalance],
		[ExchangeCode], [InstrumentTypeCode])
	SELECT @CloseoutReportId, r.[ExchangeId], r.[InstrumentId],
		[ExpiryYear], [ExpiryMonth], [ExpiryDay],
		r.[InstrumentTypeId], [OptionTypeCode], [UseNetForCloseOut], [StrikePrice], 
		[TradedBought], [TradedSold], 
		[InternalLong], [InternalShort],
		[ExternalLong], [ExternalShort], 
		[Description], 0, 0, 0,
		e.[Code] as ExchangeCode, it.Code as InstrumentTypeCode
	FROM #results r
		INNER JOIN ib_Exchange e ON e.ExchangeId = r.ExchangeId
		INNER JOIN ib_InstrumentType it ON it.InstrumentTypeId = r.InstrumentTypeId
		LEFT JOIN ib_Account a ON a.AccountId = r.AccountId
	WHERE a.IsOmnibus = 1 OR a.FamilyCode IS NULL

-- insert the ones that have family code so we need to group by it

	INSERT INTO ib_CloseOutReportSummary(
		[CloseOutReportId], [ExchangeId], [InstrumentId],
		[ExpiryYear], [ExpiryMonth], [ExpiryDay],
		[InstrumentTypeId], [OptionTypeCode], [UseNetForCloseOut], [StrikePrice],
		[TradedBought], [TradedSold], [InternalLong], [InternalShort],
		[ExternalLong], [ExternalShort], [Description],
		[CloseOutLong], [CloseOutShort], [Imbalance],
		[ExchangeCode], [InstrumentTypeCode])
	SELECT @CloseoutReportId, r.[ExchangeId], r.[InstrumentId],
		[ExpiryYear], [ExpiryMonth], [ExpiryDay],
		r.[InstrumentTypeId], [OptionTypeCode], [UseNetForCloseOut], [StrikePrice], 
		SUM([TradedBought]), SUM([TradedSold]), 
		CASE WHEN SUM([InternalLong]) > SUM([InternalShort]) 
			THEN SUM([InternalLong]) - SUM([InternalShort]) 
			ELSE 0
		END AS InternalLong, 
		CASE WHEN SUM([InternalShort]) > SUM([InternalLong]) 
			THEN SUM([InternalShort]) - SUM([InternalLong]) 
			ELSE 0
		END AS InternalShort,
		SUM([ExternalLong]), SUM([ExternalShort]), 
		[Description], 0, 0, 0,
		e.[Code] as ExchangeCode, it.Code as InstrumentTypeCode
	FROM #results r
		INNER JOIN ib_Exchange e ON e.ExchangeId = r.ExchangeId
		INNER JOIN ib_InstrumentType it ON it.InstrumentTypeId = r.InstrumentTypeId
		LEFT JOIN ib_Account a ON a.AccountId = r.AccountId
	WHERE (a.IsOmnibus = 0 OR a.IsOmnibus IS NULL) AND a.FamilyCode IS NOT NULL
	GROUP BY r.[ExchangeId], r.[InstrumentId],
		[ExpiryYear], [ExpiryMonth], [ExpiryDay],
		r.[InstrumentTypeId], [OptionTypeCode], [UseNetForCloseOut], [StrikePrice],
		[Description], e.Code, it.Code, FamilyCode

	--update the report status
	UPDATE [dbo].[ib_Report]
	SET [Stage] = ''Phase 2: Sending data to output...''
	WHERE ReportId = @ReportId

	--drop temporary tables
	DROP TABLE #tg
	DROP TABLE #results
	DROP TABLE #visitedItems
	DROP TABLE #visitingReportDetails

	--update the report status
	UPDATE [dbo].[ib_Report]
	SET [Stage] = ''Phase 2: Completed''
	WHERE ReportId = @ReportId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[GetMonthName]''
');

GO
EXECUTE ('CREATE FUNCTION [dbo].[GetMonthName]
(@Month SMALLINT)
RETURNS VARCHAR (4)
AS
BEGIN
	-- 31 Aug 2010		amk		Creation (extract from closeoutreport build)
	--							MBAL-16554 - fix bug where can''t convert 99 to month name

	DECLARE @MonthName VARCHAR(4)

	IF @Month < 1 OR @Month > 12
		SET @MonthName = CONVERT(VARCHAR(4), @Month)
	ELSE
		SET @MonthName =  
			SUBSTRING(
				DATENAME(MONTH, 
					CONVERT(DATETIME, ''2007-'' 
						+ CAST(@Month AS VARCHAR(2)) 
					+ ''-01'', 120)
				)
			, 0, 4)

	RETURN @MonthName
END


');

GO
EXECUTE ('PRINT N''Creating [dbo].[GetExchangeInstrumentCodeByMatchCodeInstrumentId]''
');

GO
EXECUTE ('CREATE FUNCTION [dbo].[GetExchangeInstrumentCodeByMatchCodeInstrumentId]
(@MatchCode VARCHAR (100), @InstrumentId INT)
RETURNS VARCHAR (255)
AS
BEGIN
-- Description: Get Exchange Instrument Code formated for the CloseOut Report
-- 02 Jul 2010 ED Created

	DECLARE @ExchangeInstrumentCode VARCHAR(255)
	
	DECLARE @DataSourceId INT
	DECLARE @Ids TABLE (Id INT)
	INSERT INTO @Ids(Id)
	SELECT  DISTINCT DataSourceId FROM    ib_TemplateCompare 
		WHERE  FirmId IN (SELECT  DISTINCT FirmId FROM    ib_TemplateGroup WHERE Description=@MatchCode)
				AND InternalExternalCode=''E''
	SET @DataSourceId = (SELECT TOP 1 Id FROM @Ids)

	SET @ExchangeInstrumentCode = (SELECT DataSourceInstrumentCode FROM  ib_InstrumentDataSource WHERE DataSourceId=@DataSourceId AND InstrumentId=@InstrumentId)
	SET @ExchangeInstrumentCode = (SELECT CASE WHEN CHARINDEX(''_'',@ExchangeInstrumentCode) > 0 THEN
												RTRIM(SUBSTRING(@ExchangeInstrumentCode,LEN(@ExchangeInstrumentCode) - CHARINDEX(''_'', REVERSE(@ExchangeInstrumentCode))+2,100))
												ELSE @ExchangeInstrumentCode END)
	RETURN @ExchangeInstrumentCode
END


');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_CloseoutReport_BuildReport]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_CloseoutReport_BuildReport]
	@CreateUsername varchar(50) = NULL,
	@UserId uniqueidentifier,
	@TemplateId int,
	@Date datetime,
	@IncludeRowsInBalance bit = 0,
	@Refresh bit=0,
	@@ReportId int OUTPUT, 
	@@CloseoutReportId int OUTPUT

AS
SET NOCOUNT ON

/*

<details>
	<summary> Generates the CloseOut Report by calling both Phase 1 and Phase 2, and store the results in the Report table</summary>
	<created author="Laurentiu Macovei" Date="Monday, 2 October 2006" />
	<updated author="Anil Kripalani" Date="18 Dec 2006">
		BUG FIX 1: Return Instrument Code, not Instrument Type Code
		BUG FIX 2: Order results set
	</updated>
	<updated author="Anil Kripalani" Date="19 Dec 2006">
		BUG FIX 1: Set TargetReportId when report is cached
		BUG FIX 2: Select proper ReportId when report is cached
	</updated>
	<updated author="Anil Kripalani" Date="20 Dec 2006">
		Support for new parameter: IncludeRowsInBalance
	</updated>
	<updated author="Charles East" Date="">
		Removed group by PK
	</updated>
	<updated author="KevinP" Date="02 Mar 2010">
		Changed how the report record was being created/updated. All for Issue : MBAL-13114
	</updated>
</details>
*/
--	02 Jul 2010		ED		MBAL-15309: Improvements to CloseOut Report
--	12 Aug 2010		amk		More stage updates
--	20 Aug 2010		amk		Indicates in notes if rows in balance included
--	31 Aug 2010		amk		MBAL-16554: Fix bug converting expiry month to month name if bad month number
--							extract to udf to make easier to read and since called twice
--	06 Jan 2011		amk		MBAL-17237: ensure calls to add new report record carry template so site can be saved correctly
--  21 May 2012		ED		MBAL 20866 - throw custom error if duplicate InstrumentDataSource
--	14 Jun 2012		ED		MBAL 21013 - fix collate for temp table
--fix the problem when sending zero values to these paramaters
IF @@ReportId <= 0
	SET @@ReportId = null
IF @@CloseoutReportId <= 0
	SET @@CloseoutReportId = null

--fix the username
IF (@CreateUsername IS NULL)
	SET @CreateUsername = SUSER_NAME()

IF @@ReportId IS NULL
	EXEC [dbo].[ib_Report_CreateReport] ''CloseOut'', @CreateUserName, @UserID, @@ReportId OUTPUT
		, NULL, @TemplateId

--validate the reportId
SELECT @@ReportId = ReportId FROM [dbo].[ib_Report]
	WHERE @@ReportId = ReportId AND ReportType = ''CloseOut''
IF @@RowCount = 0 
	RAISERROR (N''The specified reportId ''''%d'''' does not exist or is not a ''''CloseOut'''' report!'', 12, 1, @@ReportId)
--validate the report status
SELECT @@ReportId = ReportId FROM [dbo].[ib_Report]
	WHERE @@ReportId = ReportId AND ReportType = ''CloseOut'' --AND Status = ''Added''
IF @@RowCount = 0 
	RAISERROR (N''The specified reportId ''''%d'''' is not found. Operation cannot continue.'', 12, 1, @@ReportId)

--EXECUTE everything in a TRY/CATCH
BEGIN TRY

DECLARE @SiteID int	
SET @SiteID = -1


--FIND the siteId for the provided userID that matches the first template
SELECT TOP 1 @SiteId = su.SiteId 
	FROM [dbo].[ib_SiteUser] su
	INNER JOIN [dbo].[ib_SiteTemplate] st ON  su.UserId = @UserID AND st.SiteID = su.SiteId AND st.TemplateId = @TemplateID

IF @SiteId = -1
BEGIN

	--Find the SiteId for the provided userId
	SELECT TOP 1 @SiteId = SiteId FROM ib_SiteUser
		WHERE UserId = @UserID AND IsPrimary = 1

	IF @SiteId = -1
	BEGIN
		--	Try to find a non-isPrimary SiteId for the speicified user
		SELECT TOP 1 @SiteId = SiteId FROM ib_SiteUser
			WHERE UserId = @UserID
		--if still not found, throw error
		IF @SiteId = -1
		BEGIN
			DECLARE @@UserId varchar(100)
			SET @@UserId = Cast(@UserId as varchar(100))
			RAISERROR (N''Provided userId ''''%s'''' does not have an associated site!'', 11, 1, @@UserId)
		END	
	END
END

IF @Refresh = 0
BEGIN
	SET @Refresh = 1
	SELECT TOP 1 @@CloseOutReportId = cr.[CloseOutReportId], @Refresh = 0 
	FROM [dbo].[ib_CloseOutReport] cr 
		INNER JOIN [dbo].[ib_Report] r ON cr.[CloseOutReportId] = r.[TargetReportId]
			AND r.[ReportType] = ''CloseOut''
			AND cr.[TemplateId] = @TemplateId 
			AND cr.[Date] = @Date
			AND cr.[CreateDate] IN 
				(SELECT MAX([CreateDate]) 
					FROM [dbo].[ib_CloseOutReport]
					WHERE [TemplateId] = @TemplateId 
						AND [Date] = @Date)
	ORDER BY r.ReportId DESC

	IF @Refresh = 0
		UPDATE ib_Report
		SET TargetReportId = @@CloseOutReportId
		WHERE ReportId = @@ReportId
END

IF @Refresh = 1
BEGIN
	--update the report status
	UPDATE [dbo].[ib_Report]
		SET [Status] = ''Building'',
			[Stage] = ''Calling Step 1'',
			[SiteId] = @SiteId
		WHERE ReportId = @@ReportId

	--SET @@CloseoutReportId = 16
	EXEC [dbo].[ib_CloseoutReport_BuildReportPhase1] 
		@CreateUsername,
		@TemplateId,
		@Date,
		@UserId,
		@@ReportId,
		@@CloseoutReportId OUTPUT

	EXEC [dbo].[ib_CloseoutReport_BuildReportPhase2] 
		@@ReportId,
		@@CloseoutReportId
END

UPDATE [dbo].[ib_Report]
SET [Stage] = ''Final assembly''
WHERE ReportId = @@ReportId

CREATE TABLE #CloseOutReport
(
	CloseOutReportId int,
	ExchangeId int, InstrumentId int, ExpiryYear smallint, ExpiryMonth smallint,
	ExpiryDay smallint, InstrumentTypeId int, OptionTypeCode varchar(25), StrikePrice decimal(19, 4),
	TradedBought decimal(19, 4), TradedSold decimal(19, 4), InternalLong decimal(19, 4),
	InternalShort decimal(19, 4), ExternalLong decimal(19, 4), ExternalShort decimal(19, 4), 
	CloseOutLong decimal(19, 4), CloseOutShort decimal(19, 4), Imbalance decimal(19, 4), 
	Description varchar(100) COLLATE database_default, ExchangeCode varchar(50), InstrumentTypeCode varchar(100)
)


	INSERT INTO #CloseOutReport (
	CloseOutReportId, ExchangeId, InstrumentId, ExpiryYear, ExpiryMonth, ExpiryDay, 
	InstrumentTypeId, OptionTypeCode, StrikePrice, TradedBought, TradedSold, InternalLong,
	InternalShort, ExternalLong, ExternalShort,	CloseOutLong, CloseOutShort, Imbalance, 
	Description, ExchangeCode, InstrumentTypeCode)
	SELECT  c.[CloseOutReportId],
			c.[ExchangeId], c.[InstrumentId], c.[ExpiryYear], c.[ExpiryMonth],
			c.[ExpiryDay], c.[InstrumentTypeId], c.[OptionTypeCode], c.[StrikePrice],
			sum(c.[TradedBought]) TradedBought, sum(c.[TradedSold]) TradedSold, 
			sum(c.[InternalLong]) InternalLong, sum(c.[InternalShort]) InternalShort,
			sum(c.[ExternalLong]) ExternalLong, sum(c.[ExternalShort]) ExternalShort, 
			sum(c.[CloseOutLong]) CloseOutLong, sum(c.[CloseOutShort]) CloseOutShort,
			sum(c.[Imbalance]) Imbalance, c.[Description], c.[ExchangeCode]
			, i.[Code] AS [InstrumentTypeCode]
		FROM [dbo].[ib_CloseOutReportSummary] c
			JOIN ib_Instrument i ON c.InstrumentId = i.InstrumentId
		WHERE CloseOutReportId = @@CloseOutReportId
		GROUP BY c.[CloseOutReportId],
			c.[ExchangeId], c.[InstrumentId], c.[ExpiryYear], c.[ExpiryMonth],
			c.[ExpiryDay], c.[InstrumentTypeId], c.[OptionTypeCode], c.[StrikePrice], c.[Description], 
			c.[ExchangeCode], i.[Code]

UPDATE [dbo].[ib_Report]
SET [Stage] = ''Calculate imbalance''
WHERE ReportId = @@ReportId

--Update Totals
UPDATE #CloseOutReport
	SET [CloseOutLong] = [InternalLong] - [ExternalLong],
		[CloseOutShort] = [InternalShort] - [ExternalShort],
		[Imbalance] = ([InternalLong ] - [ExternalLong]) - ([InternalShort] - [ExternalShort])

UPDATE [dbo].[ib_Report]
SET [Stage] = ''Return data''
WHERE ReportId = @@ReportId


DECLARE @Ids TABLE (DataSourceId INT,InstrumentId INT)
INSERT INTO @Ids(DataSourceId,InstrumentId)
	SELECT DISTINCT tc.DataSourceId, cor.InstrumentId 
		FROM #CloseOutReport cor 
		INNER JOIN ib_TemplateGroup tg ON tg.Description = cor.Description
		INNER JOIN ib_TemplateCompare tc ON tc.FirmId = tg.FirmId AND tc.InternalExternalCode = ''E''
		WHERE @IncludeRowsInBalance <> 0 OR ((CloseOutLong <> 0 OR CloseOutShort <> 0))


DECLARE @DataSourceId INT, @InstrumentId INT
SELECT TOP 1 @DataSourceId=ids.DataSourceId, @InstrumentId=ids.InstrumentId 
		FROM ib_InstrumentDataSource ids
		INNER JOIN @Ids cor ON ids.DataSourceId = cor.DataSourceId AND ids.InstrumentId = cor.InstrumentId
		GROUP BY ids.DataSourceId,ids.InstrumentId HAVING COUNT(*)>1
IF @DataSourceId IS NOT NULL AND @InstrumentId IS NOT NULL
BEGIN
	DECLARE @DataSource varchar(100), @Instrument varchar(100)
	SET @DataSource = (SELECT Code FROM ib_DataSource WHERE DataSourceId = @DataSourceId)
	SET @Instrument = (SELECT Code FROM ib_Instrument WHERE InstrumentId = @InstrumentId)
			RAISERROR(N''Lookup of ExchangeInstrumentCode failed for Instrument (%s) because more than one DataSource Instrument Code exists for DataSource (%s)'',
					 11,1,@Instrument, @DataSource) 
END

--Select values back
IF @IncludeRowsInBalance = 0
	SELECT CloseOutReportId, ExchangeId, InstrumentId, ExpiryYear, dbo.GetMonthName(ExpiryMonth) ExpiryMonth, ExpiryDay, 
		InstrumentTypeId, OptionTypeCode, StrikePrice, TradedBought, TradedSold, InternalLong,
		InternalShort, ExternalLong, ExternalShort,	
		CASE WHEN ABS(CASE WHEN ABS(CloseOutLong)>ABS(CloseOutShort) THEN CloseOutShort ELSE CloseOutLong END) > (TradedSold + TradedBought)
		THEN (CASE WHEN (CASE WHEN ABS(CloseOutLong)>ABS(CloseOutShort) THEN CloseOutShort ELSE CloseOutLong END) > 0 THEN 1 ELSE -1 END)*(TradedSold + TradedBought)  
		ELSE CloseOutLong END CloseOutLong, 
		CASE WHEN ABS(CASE WHEN ABS(CloseOutLong)>ABS(CloseOutShort) THEN CloseOutShort ELSE CloseOutLong END) > (TradedSold + TradedBought)
		THEN (CASE WHEN (CASE WHEN ABS(CloseOutLong)>ABS(CloseOutShort) THEN CloseOutShort ELSE CloseOutLong END) > 0 THEN 1 ELSE -1 END)*(TradedSold + TradedBought)  
		ELSE CloseOutShort END CloseOutShort, 
		Imbalance, 
		Description, ExchangeCode, 
		InstrumentTypeCode, [dbo].[GetExchangeInstrumentCodeByMatchCodeInstrumentId](Description, InstrumentId) ExchangeInstrumentCode,
		CASE WHEN ABS(CASE WHEN ABS(CloseOutLong)>ABS(CloseOutShort) THEN CloseOutShort ELSE CloseOutLong END) > (TradedSold + TradedBought)
		THEN 1 ELSE 0 END IsAdjusted
		,cor.ExpiryMonth ExpiryMonthNumber
	FROM #CloseOutReport cor
	WHERE (CloseOutLong <> 0 OR CloseOutShort <> 0)
	ORDER BY ExchangeCode, Description, ExchangeInstrumentCode, 
		 ExpiryYear, cor.ExpiryMonth, ExpiryDay
		, OptionTypeCode, StrikePrice

ELSE
	SELECT CloseOutReportId, ExchangeId, InstrumentId, ExpiryYear, dbo.GetMonthName(ExpiryMonth) ExpiryMonth, ExpiryDay, 
		InstrumentTypeId, OptionTypeCode, StrikePrice, TradedBought, TradedSold, InternalLong,
		InternalShort, ExternalLong, ExternalShort,	
		CASE WHEN ABS(CASE WHEN ABS(CloseOutLong)>ABS(CloseOutShort) THEN CloseOutShort ELSE CloseOutLong END) > (TradedSold + TradedBought)
		THEN (CASE WHEN (CASE WHEN ABS(CloseOutLong)>ABS(CloseOutShort) THEN CloseOutShort ELSE CloseOutLong END) > 0 THEN 1 ELSE -1 END)*(TradedSold + TradedBought)  
		ELSE CloseOutLong END CloseOutLong, 
		CASE WHEN ABS(CASE WHEN ABS(CloseOutLong)>ABS(CloseOutShort) THEN CloseOutShort ELSE CloseOutLong END) > (TradedSold + TradedBought)
		THEN (CASE WHEN (CASE WHEN ABS(CloseOutLong)>ABS(CloseOutShort) THEN CloseOutShort ELSE CloseOutLong END) > 0 THEN 1 ELSE -1 END)*(TradedSold + TradedBought)  
		ELSE CloseOutShort END CloseOutShort, 
		Imbalance, 
		Description, ExchangeCode, 
		InstrumentTypeCode, [dbo].[GetExchangeInstrumentCodeByMatchCodeInstrumentId](Description, InstrumentId) ExchangeInstrumentCode,
		CASE WHEN ABS(CASE WHEN ABS(CloseOutLong)>ABS(CloseOutShort) THEN CloseOutShort ELSE CloseOutLong END) > (TradedSold + TradedBought)
		THEN 1 ELSE 0 END IsAdjusted
		,cor.ExpiryMonth ExpiryMonthNumber
	FROM #CloseOutReport cor
	ORDER BY ExchangeCode, Description, ExchangeInstrumentCode, 
		 ExpiryYear, cor.ExpiryMonth, ExpiryDay
		, OptionTypeCode, StrikePrice

DROP TABLE #CloseOutReport

--build Notes

DECLARE @TemplateName VARCHAR(100)
SELECT @TemplateName = Description 
FROM ib_Template 
WHERE TemplateId = @TemplateId

DECLARE @Notes VARCHAR(255)
SET @Notes = @TemplateName
	+ '', '' + CONVERT(VARCHAR(10), @Date, 103)
	
IF @IncludeRowsInBalance = 1
	SET @Notes = @Notes + '', includes rows in balance''
ELSE
	SET @Notes = @Notes + '', excludes rows in balance''

--update the report status
UPDATE [dbo].[ib_Report]
	SET [Status] = ''Complete''
		, [Stage] = ''''
		, [Notes] = @Notes
	WHERE ReportId = @@ReportId

END TRY
BEGIN CATCH
	DECLARE @ErrorMessage NVARCHAR(4000);
	SET @ErrorMessage = ERROR_MESSAGE()
	--update the error
	UPDATE [dbo].[ib_Report]
		SET Status = ''Error'',
			ErrorMessage = @ErrorMessage,
			ErrorDetails = ''The error was thrown in the '' + ERROR_PROCEDURE() + '' stored procedure at line '' + CAST(ERROR_LINE() as varchar(10)) + '' with severity '' + CAST(ERROR_SEVERITY() as varchar(10)) + '', state '' + CAST(ERROR_STATE() as varchar(10)) + '' and error number '' + Cast(ERROR_NUMBER() as varchar(10))
	WHERE ReportId = @@ReportId
	--RAISERROR (@ErrorMessage, 11, 10) WITH LOG
END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Class_GetCodeAndIdForAllClasss]''
');

GO
EXECUTE ('   /*
<details>
 <summary>Returns code and id columns for all the Classs</summary>
 <created author="laurentiu.macovei" date="Tue, 26 Sep 2006 12:24:22 GMT"/>
</details>
*/
create PROCEDURE [dbo].[ib_Class_GetCodeAndIdForAllClasss]
AS
SET NOCOUNT ON
SELECT Code, ClassId 
	FROM ib_Class
');

GO
EXECUTE ('PRINT N''Creating [dbo].[Broker_Position_Add]''
');

GO
EXECUTE ('


-- =============================================
-- Author:		Petru Konrad Bercea
-- Create date: 13.05.2009
-- Description:	Insert into Broker_Position table
--
-- Revision History
--
-- =============================================
CREATE PROCEDURE [dbo].[Broker_Position_Add]
	-- Add the parameters for the stored procedure here
	(
		@FileName varchar(512) = NULL,
		@serial_number varchar(11) = NULL,
		@account varchar(35) = NULL,
		@currency varchar(3) = NULL,
		@market varchar(5) = NULL,
		@instrument_code varchar(50) = NULL,
		@delivery_month varchar(8) = NULL,
		@trade_type varchar(3) = NULL,
		@option_series varchar(5) = NULL,
		@opt_dec_date varchar(8) = NULL,
		@open_close varchar(1) = NULL,
		@trade_date varchar(8) = NULL,
		@cash_val_date varchar(8) = NULL,
		@sec_val_date varchar(8) = NULL,
		@lots varchar(21) = NULL,
		@lot_size varchar(21) = NULL,
		@premium_price varchar(21) = NULL,
		@premium_value varchar(21) = NULL,
		@trade_price varchar(21) = NULL,
		@settle_price varchar(21) = NULL,
		@margin varchar(21) = NULL,
		@in_or_out varchar(3) = NULL,
		@in_or_out_val varchar(21) = NULL,
		@commis_rate varchar(21) = NULL,
		@commis_curr varchar(3) = NULL,
		@commis_val varchar(21) = NULL,
		@tax varchar(21) = NULL,
		@traded_price_val varchar(21) = NULL,
		@mark_to_market_val varchar(21) = NULL,
		@underlying_price varchar(21) = NULL,
		@underlying_val varchar(21) = NULL,
		@exercise_val varchar(21) = NULL,
		@exercise_lots varchar(21) = NULL,
		@pay_hold varchar(21) = NULL,
		@post_commis_upfront varchar(21) = NULL,
		@last_traded_date varchar(8) = NULL,
		@inst_desc varchar(100) = NULL,
		@exercise_asn varchar(2) = NULL,
		@yest_settle_price varchar(21) = NULL,
		@yest_martom_val varchar(21) = NULL,
		@commod_short_descr varchar(10) = NULL,
		@dec_time varchar(8) = NULL,
		@posted_marktom varchar(8) = NULL,
		@run_date varchar(8) = NULL,
		@rec_type varchar(3) = NULL,
		@acn varchar(5) 
    )
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

  INSERT INTO [dbo].[Broker_Position]
			( 
				[FileName],
				[serial_number],
				[account],
				[currency],
				[market],
				[instrument_code],
				[delivery_month],
				[trade_type],
				[option_series],
				[opt_dec_date],
				[open_close],
				[trade_date],
				[cash_val_date],
				[sec_val_date],
				[lots],
				[lot_size],
				[premium_price],
				[premium_value],
				[trade_price],
				[settle_price],
				[margin],
				[in_or_out],
				[in_or_out_val],
				[commis_rate],
				[commis_curr],
				[commis_val],
				[tax],
				[traded_price_val],
				[mark_to_market_val],
				[underlying_price],
				[underlying_val],
				[exercise_val],
				[exercise_lots],
				[pay_hold],
				[post_commis_upfront],
				[last_traded_date],
				[inst_desc],
				[exercise_asn],
				[yest_settle_price],
				[yest_martom_val],
				[commod_short_descr],
				[dec_time],
				[posted_marktom],
				[run_date],
				[rec_type],
				[acn]
			)
    VALUES
			( 
				@FileName,
				@serial_number,
				@account,
				@currency,
				@market,
				@instrument_code,
				@delivery_month,
				@trade_type,
				@option_series,
				@opt_dec_date,
				@open_close,
				@trade_date,
				@cash_val_date,
				@sec_val_date,
				@lots,
				@lot_size,
				@premium_price,
				@premium_value,
				@trade_price,
				@settle_price,
				@margin,
				@in_or_out,
				@in_or_out_val,
				@commis_rate,
				@commis_curr,
				@commis_val,
				@tax,
				@traded_price_val,
				@mark_to_market_val,
				@underlying_price,
				@underlying_val,
				@exercise_val,
				@exercise_lots,
				@pay_hold,
				@post_commis_upfront,
				@last_traded_date,
				@inst_desc,
				@exercise_asn,
				@yest_settle_price,
				@yest_martom_val,
				@commod_short_descr,
				@dec_time,
				@posted_marktom,
				@run_date,
				@rec_type,
				@acn
			)
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[is_HUnsettledContractDetails_Add]''
');

GO
EXECUTE ('


/*
<Details>
<Summary>Inserts an item into the HUnsettledContractDetails table</Summary>
<Created author="laurentiu.macovei" date="04/05/2006 16:33:06" />
</Details>
*/
CREATE PROCEDURE [dbo].[is_HUnsettledContractDetails_Add]
	@CorporationCode varchar(4) = NULL,
	@PrincipalBrokerageId varchar(1) = NULL,
	@OfficeCode varchar(4) = NULL,
	@ACNo varchar(10) = NULL,
	@SecuritiesId varchar(2) = NULL,
	@BaseDate datetime = NULL,
	@CalcDate datetime = NULL,
	@CalcStartTime datetime = NULL,
	@MarketCode varchar(2) = NULL,
	@DerivativesCode varchar(10) = NULL,
	@SecCode1 varchar(7) = NULL,
	@SecCode2 varchar(4) = NULL,
	@SecCode3 varchar(2) = NULL,
	@SecCode4 varchar(1) = NULL,
	@BuySellContractId varchar(2) = NULL,
	@TradeDate datetime = NULL,
	@UnitPrice decimal(11,4) = NULL,
	@ContractMonth varchar(7) = NULL,
	@StrikePrice decimal(11,4) = NULL,
	@FinalTradeDate datetime = NULL,
	@Quantity decimal(15,0) = NULL,
	@ExecutionAmnt decimal(15,0) = NULL,
	@MarketPrice decimal(11,2) = NULL,
	@MarketValue decimal(15,0) = NULL,
	@UnrealzedPLPlusMinusSign varchar(1) = NULL,
	@UnrealizedPL decimal(15,0) = NULL,
	@Commission decimal(15,0) = NULL,
	@ConsumptionTax decimal(15,0) = NULL,
	@ExchangeTax decimal(15,0) = NULL,
	@TradeNo varchar(5) = NULL,
	@TradeSubNo varchar(3) = NULL,
	@OptExerciseAllotmentId varchar(1) = NULL,
	@CustomerNameAbb varchar(35) = NULL,
	@SecNameInEnglish varchar(28) = NULL,
	@SecNameInKana varchar(24) = NULL,
	@TradeCodeClose varchar(2) = NULL,
	@NightTradingId varchar(1) = NULL,
	@TradeType varchar(1) = NULL,
	@ExecutionDate datetime = NULL,
	@CostPaymentMethod varchar(1) = NULL
AS
SET NOCOUNT ON

SET NOCOUNT OFF


	DECLARE	@UnrealizedPLSigned		DECIMAL(15,0)
	DECLARE	@CalcDateStartTime DATETIME

	IF @BaseDate = ''01/01/1900 00:00:00'' 
		SET @BaseDate = NULL

	IF @CalcDate = ''01/01/1900 00:00:00'' 
		SET @CalcDate = NULL

	IF @CalcStartTime = ''01/01/1900 00:00:00'' 
		SET @CalcStartTime = NULL

	IF @TradeDate = ''01/01/1900 00:00:00'' 
		SET @TradeDate = NULL

	IF @FinalTradeDate = ''01/01/1900 00:00:00'' 
		SET @FinalTradeDate = NULL

	IF @ExecutionDate = ''01/01/1900 00:00:00'' 
		SET @ExecutionDate = NULL

	SET @CalcDateStartTime = CONVERT(DATETIME,CONVERT(VARCHAR(12), CONVERT(DATETIME,@CalcDate,112)) + '' '' + CONVERT(VARCHAR(8),RIGHT(@CalcStartTime,8)))


	IF @UnrealzedPLPlusMinusSign = ''-'' 
		SET @UnrealizedPLSigned = @UnrealizedPL * -1
	ELSE
		SET @UnrealizedPLSigned = @UnrealizedPL

	INSERT INTO [dbo].[is_HUnsettledContractDetails ]
		(
			[CorporationCode], 
			[PrincipalBrokerageId], 
			[OfficeCode], 
			[ACNo], 
			[SecuritiesId], 
			[BaseDate], 
			[CalcDate], 
			[CalcStartTime], 
			[CalcDateStartTime], 
			[MarketCode], 
			[DerivativesCode], 
			[SecCode1], 
			[SecCode2], 
			[SecCode3], 
			[SecCode4], 
			[BuySellContractId], 
			[TradeDate], 
			[UnitPrice], 
			[ContractMonth], 
			[StrikePrice], 
			[FinalTradeDate], 
			[Quantity], 
			[ExecutionAmnt], 
			[MarketPrice], 
			[MarketValue], 
			[UnrealzedPLPlusMinusSign], 
			[UnrealizedPL], 
			[UnrealizedPLSigned], 
			[Commission], 
			[ConsumptionTax], 
			[ExchangeTax], 
			[TradeNo], 
			[TradeSubNo], 
			[OptExerciseAllotmentId], 
			[CustomerNameAbb], 
			[SecNameInEnglish], 
			[SecNameInKana], 
			[TradeCodeClose], 
			[NightTradingId], 
			[TradeType], 
			[ExecutionDate], 
			[CostPaymentMethod]
		) 
		VALUES
		(
			@CorporationCode, 
			@PrincipalBrokerageId, 
			@OfficeCode, 
			@ACNo, 
			@SecuritiesId, 
			@BaseDate, 
			@CalcDate, 
			@CalcStartTime, 
			@CalcDateStartTime, 
			@MarketCode, 
			@DerivativesCode, 
			@SecCode1, 
			@SecCode2, 
			@SecCode3, 
			@SecCode4, 
			@BuySellContractId, 
			@TradeDate, 
			@UnitPrice, 
			@ContractMonth, 
			@StrikePrice, 
			@FinalTradeDate, 
			@Quantity, 
			@ExecutionAmnt, 
			@MarketPrice, 
			@MarketValue, 
			@UnrealzedPLPlusMinusSign, 
			@UnrealizedPL,
			@UnrealizedPLSigned, 
			@Commission, 
			@ConsumptionTax, 
			@ExchangeTax, 
			@TradeNo, 
			@TradeSubNo, 
			@OptExerciseAllotmentId, 
			@CustomerNameAbb, 
			@SecNameInEnglish, 
			@SecNameInKana, 
			@TradeCodeClose, 
			@NightTradingId, 
			@TradeType, 
			@ExecutionDate, 
			@CostPaymentMethod
		);

Return Scope_Identity()
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Rule_GetRuleTypes]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Rule_GetRuleTypes]
AS
SET NOCOUNT ON
	SELECT
		RuleTypeId
		,Description
	FROM
		[dbo].[ib_RuleType]
	ORDER BY
		Description
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_InstrumentDataSource_Delete]''
');

GO
EXECUTE ('/*
<details>
 <summary>Deletes an instrument data source by its id from the ib_InstrumentDataSource table</summary>
 <created author="Laurentiu Macovei" Date=" Sunday, 10 September 2006 1:20PM GMT" /> 
</details>
*/
create PROCEDURE [dbo].[ib_InstrumentDataSource_Delete]
(
	@InstrumentDataSourceId int
)
AS
SET NOCOUNT ON

DELETE FROM [dbo].[ib_InstrumentDataSource]
      WHERE InstrumentDataSourceId = @InstrumentDataSourceId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[CreditSuisse_Position]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[CreditSuisse_Position]
(
[CreditSuisse_PositionID] [int] NOT NULL IDENTITY(1, 1),
[PRECID] [varchar] (1) NULL,
[PFIRM] [varchar] (1) NULL,
[POFFIC] [varchar] (3) NULL,
[PACCT] [varchar] (5) NULL,
[PCTYM] [varchar] (6) NULL,
[PSBCUS] [varchar] (2) NULL,
[PSTYPE] [varchar] (2) NULL,
[PSUBTY] [varchar] (1) NULL,
[PSTYP2] [varchar] (1) NULL,
[PSTRIK] [varchar] (15) NULL,
[PEXPDT] [varchar] (8) NULL,
[PSUBAC] [varchar] (10) NULL,
[PTDATE] [varchar] (8) NULL,
[PTPRIC] [varchar] (15) NULL,
[PBS] [varchar] (1) NULL,
[PBROKR] [varchar] (2) NULL,
[PTRACE] [varchar] (10) NULL,
[PICODE] [varchar] (3) NULL,
[PREFNO] [varchar] (12) NULL,
[PCLASS] [varchar] (1) NULL,
[PSUBCL] [varchar] (1) NULL,
[PQTY] [varchar] (15) NULL,
[PPRTQ] [varchar] (15) NULL,
[PSDSC1] [varchar] (3) NULL,
[PMKVAL] [varchar] (15) NULL,
[PSDATE] [varchar] (8) NULL,
[PEXCH] [varchar] (2) NULL,
[PFC] [varchar] (2) NULL,
[PTYPE] [varchar] (1) NULL,
[PSYMBL] [varchar] (6) NULL,
[PSUBEX] [varchar] (1) NULL,
[PPRTPR] [varchar] (11) NULL,
[PCLOSE] [varchar] (15) NULL,
[PPRCDT] [varchar] (8) NULL,
[PPRTCP] [varchar] (11) NULL,
[PPRICE] [varchar] (12) NULL,
[PCURSY] [varchar] (3) NULL,
[PGROSS] [varchar] (15) NULL,
[FileName] [varchar] (512) NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_CreditSuisse_Position_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_CreditSuisse_Position_CreateDate] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_CreditSuisse_Position] on [dbo].[CreditSuisse_Position]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[CreditSuisse_Position] ADD CONSTRAINT [PK_CreditSuisse_Position] PRIMARY KEY CLUSTERED  ([CreditSuisse_PositionID])
');

GO
EXECUTE ('PRINT N''Creating index [IX_CreditSuisse_Position_Filename] on [dbo].[CreditSuisse_Position]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_CreditSuisse_Position_Filename] ON [dbo].[CreditSuisse_Position] ([FileName]) INCLUDE ([CreateDate], [CreditSuisse_PositionID])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_CreditSuisse_Position_Load]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_CreditSuisse_Position_Load] 
	(
		@LocationPath VARCHAR(100)
		,@ReceiveLocationSysId INT
		,@RunId INT
	)
AS
SET NOCOUNT ON

-- Description:	This stored procedure pulls data from the CreditSuisse_Position temp
-- table and inserts it into ib_Position
-- Whilst iterating through the records in CreditSuisse_Position, all 
-- of these inserts are wrapped in a transaction so that any failure causes
-- the changes to not commit.

-- 06 Apr 2011	AAJM	Creation
-- 07 Apr 2011	AAJM	MBAL-17385 Fix getting AsOfDate from Filename
-- 08 Apr 2011	AAJM	MBAL-17385 Fix wrong number of into variables
-- 18 Apr 2011	AAJM	Fix divisors not working, using wrong instrument code
--						Fix day coming out as zero
-- 17 May 2011	AAJM	Add Sub Exchange Code to Exchange Code & Instrument Code
-- 18 May 2011	AAJM	Use PPRTCP instead of PCLOSE for Settlement Price
-- 02 Jan 2014  RD		MBAL-24931 Added checking file age
-- 09 Jan 2014	ED		EIB 25004 - remove importLog table and use Log table
-- 25 Apr 2014	ED		EIB 25473 - raise error if file is too old and mark temp records as LoadState=3
BEGIN

	DECLARE @Message			VARCHAR(1024)
	DECLARE @AddCount			INT
	SET @AddCount = 0
					
	DECLARE @DataSourceCode VARCHAR(100)

	--Set the Datasource	
	EXEC [ib_GMI_GetDataSource] @LocationPath, @DataSourceCode OUTPUT

	DECLARE @Output INT
	DECLARE @Output2 INT
	DECLARE @ReturnValue INT
	DECLARE @DataSourceId INT

	IF @LocationPath IS NULL SET @LocationPath = @DataSourceCode
	EXEC @ReturnValue= [_ib_DataSource_GetByCodeForOutput] @DataSourceCode, @OutPut output, @Output2 output
	SET @DataSourceId = @Output

	-- Duplicate file check										
	DECLARE @IsFileAlreadyLoaded INT
	EXEC @IsFileALreadyLoaded = HasFileBeenLoaded @LocationPath, @DataSourceId

	IF @IsFileAlreadyLoaded = 1
	BEGIN
		UPDATE [CreditSuisse_Position]
		SET LoadState = 3
		WHERE LoadState = 1
			AND FileName = @LocationPath		
		RETURN
	END
	
	-- Set AsOfDate from Filename
	DECLARE @AsOfDate DATETIME
	EXEC [dbo].[TryParseYYYYMMDDFromEndOfFilename] @LocationPath, @AsOfDate OUTPUT
	
	--rd - make sure the As Of Date is not older than acceptable
	DECLARE @IsAcceptable bit
	EXECUTE [dbo].[Load_IsFileTooOld] @DataSourceId,@LocationPath,@AsOfDate,@IsAcceptable OUTPUT, @ReceiveLocationSysId, @RunId
	IF (@IsAcceptable = 0)
	BEGIN
		UPDATE CreditSuisse_Position SET [LoadState] = 3 WHERE [Filename] = @LocationPath
		RAISERROR (''File is too old.'', 18, 0)
		RETURN 0
	END

	-- Store ImportFile record to be associated with Settlement Price load
	DECLARE @ImportFileId INT
	EXEC ib_ImportFile_Add @DataSourceId, @LocationPath, @ImportFileId output
	
	--Gets the defaultStrikePriceDivisor
	DECLARE	@DefaultStrikePriceDivisor	DECIMAL(19,6)
	SET @DefaultStrikePriceDivisor = [dbo].[udf_GetDefaultStrikePriceDivisor](@DataSourceId, NULL)
	
	IF OBJECT_ID(''tempdb..#temp4'') IS NOT NULL 
		DROP TABLE #temp4
		
	CREATE TABLE #temp4
	(
		CreditSuisse_PositionID		INT
		, FirmCode					VARCHAR(1)
		, Account					VARCHAR(5)
		, Currency					VARCHAR(3)
		, AsOfDateChr				VARCHAR(8)
		, Exchange					VARCHAR(2)
		, SubExchange				VARCHAR(1)
		, Instrument_Code			VARCHAR(2)
		, QuantityChr				VARCHAR(15)
		, BuySell					VARCHAR(1)
		, MarketValueChr			VARCHAR(15)
		, ContractYearMonth			VARCHAR(6)
		, ContractDay				VARCHAR(2)
		, StrikePriceChr			VARCHAR(15)
		, TrxTypeCode				VARCHAR(1)
		, OptionTypeCode			VARCHAR(1)
		, SettlementPriceChr		VARCHAR(11)
		, InstrumentType			VARCHAR(1)
	)

	INSERT INTO #temp4
	(
		CreditSuisse_PositionID
		, FirmCode
		, Account
		, Currency
		, AsOfDateChr
		, Exchange
		, SubExchange
		, Instrument_Code
		, QuantityChr
		, BuySell
		, MarketValueChr
		, ContractYearMonth
		, ContractDay
		, StrikePriceChr
		, TrxTypeCode
		, OptionTypeCode
		, SettlementPriceChr
		, InstrumentType
	)
	SELECT 	
		[CreditSuisse_PositionID]
		, [PFIRM]
		, LTRIM(RTRIM([PACCT]))
		, LTRIM(RTRIM([PCURSY]))
		, [PPRCDT]
		, LTRIM(RTRIM([PEXCH]))
		, LTRIM(RTRIM([PSUBEX]))
		, LTRIM(RTRIM([PFC]))
		, [PQTY]
		, [PBS]
		, [PMKVAL]
		, [PCTYM]
		, [PSBCUS]
		, [PSTRIK]
		, [PRECID]
		, [PSUBTY]
		, [PPRTCP]
		, [PSUBTY]
	FROM [dbo].[CreditSuisse_Position]
	WHERE LoadState = 1
		AND [Filename] = @LocationPath
		AND [PRECID]=''P'' -- Only Positions

	SET XACT_ABORT ON 

	BEGIN TRAN T1

		-- BizTalk''s SQL Adapter uses more restrictive read serializable
		-- so this is necessary to relax it to something that is default
		-- and perfectly acceptable!
		SET TRANSACTION ISOLATION LEVEL READ COMMITTED

		BEGIN TRY
		
			DECLARE @CreditSuisse_PositionID	INT
			DECLARE @FirmCode					VARCHAR(1)
			DECLARE @Account					VARCHAR(5)
			DECLARE @Currency					VARCHAR(3)
			DECLARE @AsOfDateChr				VARCHAR(8)
			DECLARE @ExchangeCode				VARCHAR(2)
			DECLARE @SubExchangeCode			VARCHAR(1)
			DECLARE @InstrumentCode				VARCHAR(2)
			DECLARE @QuantityChr				VARCHAR(15)
			DECLARE @BuySell					VARCHAR(1)
			DECLARE @MarketValueChr				VARCHAR(15)
			DECLARE @ContractYearMonth			VARCHAR(6)
			DECLARE @ContractDay				VARCHAR(2)
			DECLARE @StrikePriceChr				VARCHAR(15)
			DECLARE @TrxTypeCode				VARCHAR(1)
			DECLARE @OptionTypeCode				VARCHAR(1)
			DECLARE @SettlementPriceChr			VARCHAR(11)
			DECLARE @InstrumentType				VARCHAR(1)

			DECLARE pos_cursor CURSOR FOR
			SELECT	CreditSuisse_PositionID
				    , FirmCode
					, Account
					, Currency
					, AsOfDateChr
					, Exchange
					, SubExchange
					, Instrument_Code
					, QuantityChr
					, BuySell
					, MarketValueChr
					, ContractYearMonth
					, ContractDay
					, StrikePriceChr
					, TrxTypeCode
					, OptionTypeCode
					, SettlementPriceChr
					, InstrumentType
			FROM	#temp4

			OPEN pos_cursor

			FETCH NEXT FROM pos_cursor
			INTO 
					@CreditSuisse_PositionID
					, @FirmCode
					, @Account
					, @Currency
					, @AsOfDateChr
					, @ExchangeCode
					, @SubExchangeCode
					, @InstrumentCode
					, @QuantityChr
					, @BuySell
					, @MarketValueChr
					, @ContractYearMonth
					, @ContractDay
					, @StrikePriceChr
					, @TrxTypeCode
					, @OptionTypeCode
					, @SettlementPriceChr
					, @InstrumentType

				-- Check @@FETCH_STATUS to see IF there are any more rows to fetch.
				WHILE @@FETCH_STATUS = 0
				BEGIN
					DECLARE		@AccountCd				VARCHAR(100)
					DECLARE		@ExchangeCd				VARCHAR(25)
					DECLARE		@AsOfDateFromRecord		DATETIME
					DECLARE		@InstrumentCd			VARCHAR(100)
					DECLARE		@Quantity				DECIMAL(19,4)
					DECLARE		@MarketValueDec			DECIMAL(19,4)
					DECLARE		@ExpYr					SMALLINT
					DECLARE		@ExpMth					SMALLINT
					DECLARE		@ExpDay					SMALLINT
					DECLARE		@StrikePrice			DECIMAL(19,4)
					DECLARE		@PriceDivisor			DECIMAL(19,4)
					DECLARE		@StrikePriceDivisor		DECIMAL(19,4)
					DECLARE		@MarketValueDivisor		DECIMAL(19,4)
					DECLARE		@SettlementPrice		DECIMAL(24,10)
					DECLARE		@TrxTypeCd				VARCHAR(25)
					DECLARE		@TrxDate				DATETIME
					DECLARE		@InstrumentTypeCd		VARCHAR(100)
					DECLARE     @ErrorMessageForRecord	VARCHAR(1024)
					DECLARE		@ErrorSeverity			INT
					DECLARE		@ErrorState				INT
					DECLARE		@QuantityLong			DECIMAL(19,4)
					DECLARE		@QuantityShort			DECIMAL(19,4)
					DECLARE		@SignedQuantity			DECIMAL(19,4)
					
					-- Temporary variables
                    DECLARE     @TempDate DATETIME
					DECLARE 	@Code VARCHAR(100), @Code2 VARCHAR(100)
					
			SET @AccountCd = @Account
			SET	@ExchangeCd = @ExchangeCode + ISNULL(@SubExchangeCode, '''')
		
			-- Set ExpiryDate
			SET @ExpYr = LEFT(@ContractYearMonth, 4)
			SET @ExpMth = RIGHT(@ContractYearMonth, 2)
			
			SET @ContractDay = LTRIM(RTRIM(@ContractDay))
			
			IF NULLIF(@ContractDay,'''') IS NULL OR @ContractDay = ''0''
				BEGIN
					-- Get the last day of the month
					SET @ExpDay = dbo.udf_OnLoad_ExpiryDate_Get_Day(@ExpYr,@ExpMth,@ContractDay)
				END
			ELSE
				SET @ExpDay = CAST(@ContractDay AS SMALLINT)
		
			-- Set InstrumentTypeCd
			IF @InstrumentType IN (''P'', ''C'')
				SET @InstrumentTypeCd = ''O''
			ELSE -- It will be blank
				SET @InstrumentTypeCd = ''F''
			
			-- We prefix the Instruments with the IntrumentTypeCode
			SET @InstrumentCd = @InstrumentTypeCd + ''_'' + @ExchangeCd + ''_'' + @InstrumentCode

			-- Get Divisors						
			SET @StrikePriceDivisor = NULL
			SET	@PriceDivisor = NULL
			SET	@MarketValueDivisor = NULL
								
			SELECT @StrikePriceDivisor = ids.StrikePriceDivisor
					, @PriceDivisor = ids.PriceDivisor
					, @MarketValueDivisor = ids.MarketValueDivisor
			FROM [dbo].[ib_InstrumentDataSource] ids
			WHERE ids.DataSourceId = @DataSourceId
				AND ids.DataSourceInstrumentCode = @InstrumentCd
					
			-- Set Settlement Price				
			IF @PriceDivisor IS NULL 
				SET @PriceDivisor = 1				

			SET @SettlementPrice = CONVERT(DECIMAL(24,10), @SettlementPriceChr) / @PriceDivisor
			
			-- Set StrikePrice
			SET @StrikePrice = NULL
			
			IF @StrikePriceDivisor IS NULL
				BEGIN
					SET @StrikePrice = CAST(@StrikePriceChr AS DECIMAL(19,4)) / ISNULL(@DefaultStrikePriceDivisor, 1)
				END
			ELSE
				BEGIN
					SET @StrikePrice = CAST(@StrikePriceChr AS DECIMAL(19,4)) / @StrikePriceDivisor
				END			
			
			-- Set TrxTypeCd
			--SET @TrxTypeCd = @TrxTypeCode
			SET @TrxTypeCd = ''POSITION''
						
			-- Set Quantity 
			SET @Quantity = 0
			SET @QuantityLong = 0
			SET @QuantityShort = 0
			
			SET @Quantity = CONVERT(DECIMAL(19,4), @QuantityChr)
			
			SET @SignedQuantity = @Quantity
							
			-- Set QuantityLong
			IF (@BuySell = ''1'')
				BEGIN
					SET @QuantityLong = @Quantity
				END
			ELSE
					SET @QuantityLong = 0
								
			-- Set QuantityShort
			IF (@BuySell = ''2'')
				BEGIN
					SET @QuantityShort = @Quantity
					SET @SignedQuantity = @Quantity * (-1)
				END	
			ELSE
				SET @QuantityShort = 0
				
				
			-- Set Market Value
			IF @MarketValueDivisor IS NULL 
				SET @MarketValueDivisor = 1
			
			SET @MarketValueDec = CONVERT(DECIMAL(19,4), @MarketValueChr) / @MarketValueDivisor

			-- TrxDate
			SET @TrxDate = GETDATE()  -- This is not actually used

			SET @AsOfDateFromRecord = CONVERT(DATETIME, @AsOfDateChr, 112)
			
			-- Now check that the file AsOfDate matches that of the record
			
			IF (@AsOfDateFromRecord IS NULL OR @AsOfDate <> [dbo].[udf_GetDatePart](@AsOfDateFromRecord))
				BEGIN
				
					SET @ErrorMessageForRecord = ''AsOfDate on Position record does not match AsOfDate from Filename''
					EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @ErrorMessageForRecord, ''Success'', @CreditSuisse_PositionID, @RunId
				END
			
			DECLARE @PositionId INT
			SET @PositionId = NULL
			
			EXEC [ib_Position_Load]
			@DataSourceCode			
			, @ExchangeCd
			, @FirmCode -- Firm will be added if not present					
			, @AccountCd				
			, @AsOfDate				
			, @InstrumentCd			
			, @SignedQuantity			
			, @MarketValueDec			
			, @ExpYr					
			, @ExpMth					
			, @ExpDay	
			, @StrikePrice			
			, @TrxTypeCd				
			, @OptionTypeCode	
			, @TrxDate 			
			, @SettlementPrice -- This value is NOT actually used in the ib_Position_Load Stored Procedure, should be removed ?			
			, @CreditSuisse_PositionID
			, @InstrumentTypeCd		
			, @LocationPath
			, @Currency
			, @LongQuantity = @QuantityLong
			, @ShortQuantity = @QuantityShort
			, @PositionId = @PositionId output
			, @ReceiveLocationSysId = @ReceiveLocationSysId
			, @RunId = @RunId
			
			-- Add Settlement Price											
			EXEC ib_Price_AddFromPositionLoad
				@PositionId
				, @ImportFileId
				, @SettlementPrice 	
				
			--flip processed flag in source table.
			UPDATE [CreditSuisse_Position] 
			WITH (ROWLOCK)
			SET [LoadState] = 2
			WHERE [CreditSuisse_PositionID] = @CreditSuisse_PositionID 
				AND [LoadState] = 1
				
			SET @AddCount = @AddCount + 1

			FETCH NEXT FROM pos_cursor
			INTO 
					@CreditSuisse_PositionID
					, @FirmCode
					, @Account
					, @Currency
					, @AsOfDateChr
					, @ExchangeCode
					, @SubExchangeCode
					, @InstrumentCode
					, @QuantityChr
					, @BuySell
					, @MarketValueChr
					, @ContractYearMonth
					, @ContractDay
					, @StrikePriceChr
					, @TrxTypeCode
					, @OptionTypeCode
					, @SettlementPriceChr
					, @InstrumentType
		END
			
			CLOSE pos_cursor
			DEALLOCATE pos_cursor

			SET @Message = @DataSourceCode + '' position loader ended ('' 
				+ CONVERT(VARCHAR(10), @AddCount) + '' added)'' 
		
			EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @Message, ''Success'', '''', @RunId
			
			UPDATE ib_ImportFile
			SET AsOfDate = @AsOfDate
			WHERE ImportFileId = @ImportFileId
			
		COMMIT TRAN T1

	DROP TABLE #temp4
	
	END TRY
	BEGIN CATCH 

		IF XACT_STATE() = -1 
			ROLLBACK TRANSACTION
	
		SET @Message = @DataSourceCode + '' position loader failed'' 		
		
		EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @Message, ''Error'', '''', @RunId
		
		EXEC [dbo].[sp_RethrowError]
		
	END CATCH 

	SET XACT_ABORT OFF
	
END

RETURN 0
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_CurrencyDataSource_Update]''
');

GO
EXECUTE (' /*
<details>
 <summary>Updates a currency data source from the ib_CurrencyDataSource table by its id</summary>
 <created author="Laurentiu Macovei" Date="Friday, 8 September 2006 10:57PM GMT" /> 
</details>
*/
create PROCEDURE [dbo].[ib_CurrencyDataSource_Update]
(
	@CurrencyDataSourceId int,
	@CurrencyId int,
    @DataSourceId int,
    @DataSourceCurrencyCode varchar(100),
    @UpdateUsername varchar(50)
)
AS 
SET NOCOUNT ON


BEGIN TRY
--check for duplicates 
EXEC [dbo].[ib_CurrencyDataSource_CheckForDuplicate] @CurrencyId, @DataSourceId, @DataSourceCurrencyCode, @CurrencyDataSourceId

UPDATE [dbo].[ib_CurrencyDataSource]
   SET [CurrencyId] = @CurrencyId,
       [DataSourceId] = @DataSourceId,
       [DataSourceCurrencyCode] = @DataSourceCurrencyCode,
       [UpdateUsername] = @UpdateUsername
 WHERE CurrencyDataSourceId = @CurrencyDataSourceId
 
END TRY
BEGIN CATCH
	EXEC [dbo].[sp_RethrowError]
END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[Broker_Position_LoadStateChange]''
');

GO
EXECUTE ('



-- =============================================
-- Author:		Petru Konrad Bercea
-- Create date: 13.05.2009
-- Description:	Changes the LoadState of the Broker_Position type table
-- =============================================
CREATE PROCEDURE [dbo].[Broker_Position_LoadStateChange] 
	-- Add the parameters for the stored procedure here
	(
		@OldLoadState	TINYINT,
		@NewLoadState	TINYINT
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

		UPDATE [dbo].[Broker_Position] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[LCH_TypeNT]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[LCH_TypeNT]
(
[LCH_TypeNTID] [int] NOT NULL IDENTITY(1, 1),
[Exchange] [varchar] (3) NULL,
[DownloadNumber] [varchar] (4) NULL,
[TradingDay] [varchar] (6) NULL,
[TenderDeletionDay] [varchar] (6) NULL,
[NewTenderDeletionDay] [varchar] (6) NULL,
[TradingDayOfTrade] [varchar] (6) NULL,
[OriginatingMemberName] [varchar] (3) NULL,
[OriginatingTraderName] [varchar] (3) NULL,
[OriginatingClearerName] [varchar] (3) NULL,
[AccountCode] [varchar] (1) NULL,
[MarginingAccount] [varchar] (1) NULL,
[TradeChargeIndicator] [varchar] (1) NULL,
[LongOrShort] [varchar] (1) NULL,
[PhysicalCommodity] [varchar] (3) NULL,
[LogicalCommodity] [varchar] (3) NULL,
[ContractType] [varchar] (1) NULL,
[GenericContractType] [varchar] (1) NULL,
[LongExpiryDate] [varchar] (8) NULL,
[ExercisePrice] [varchar] (9) NULL,
[NotificationSlipType] [varchar] (1) NULL,
[ClearingSlipID] [varchar] (10) NULL,
[VolumeToAdjust] [varchar] (11) NULL,
[ValuationPrice] [varchar] (9) NULL,
[CounterpartyMemberName] [varchar] (3) NULL,
[CounterpartyTraderName] [varchar] (3) NULL,
[DateEntered] [varchar] (8) NULL,
[TimeEntered] [varchar] (6) NULL,
[TimeLastModified] [varchar] (6) NULL,
[TimeMatched] [varchar] (6) NULL,
[OperatorReference] [varchar] (12) NULL,
[UserSpecifiedData] [varchar] (14) NULL,
[CounternoteSlipNumber] [varchar] (10) NULL,
[ClosingTradeSlipNumber] [varchar] (10) NULL,
[ClosingTradeSubNumber] [varchar] (3) NULL,
[ClosingTradeVolume] [varchar] (11) NULL,
[AllLotsIndicator] [varchar] (1) NULL,
[NotificationSource] [varchar] (1) NULL,
[NotificationStatus] [varchar] (2) NULL,
[LotSize] [varchar] (5) NULL,
[PositionType] [varchar] (1) NULL,
[TradingDayOfNotificationProcessing] [varchar] (6) NULL,
[ActionFlag] [varchar] (1) NULL,
[FileName] [varchar] (512) NOT NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_LCH_TypeNT_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_LCH_TypeNT_CreateDate] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_LCH_TypeNT] on [dbo].[LCH_TypeNT]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[LCH_TypeNT] ADD CONSTRAINT [PK_LCH_TypeNT] PRIMARY KEY CLUSTERED  ([LCH_TypeNTID])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[LCH_TypeNT_Add]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[LCH_TypeNT_Add]
	(
	@Exchange VARCHAR(3),
	@DownloadNumber VARCHAR(4),
	@TradingDay VARCHAR(6),
	@TenderDeletionDay VARCHAR(6),
	@NewTenderDeletionDay VARCHAR(6),
	@TradingDayOfTrade VARCHAR(6),
	@OriginatingMemberName VARCHAR(3),
	@OriginatingTraderName VARCHAR(3),
	@OriginatingClearerName VARCHAR(3),
	@AccountCode VARCHAR(1),
	@MarginingAccount VARCHAR(1),
	@TradeChargeIndicator VARCHAR(1),
	@LongOrShort VARCHAR(1),
	@PhysicalCommodity VARCHAR(3),
	@LogicalCommodity VARCHAR(3),
	@ContractType VARCHAR(1),
	@GenericContractType VARCHAR(1),
	@LongExpiryDate VARCHAR(8),
	@ExercisePrice VARCHAR(9),
	@NotificationSlipType VARCHAR(1),
	@ClearingSlipID VARCHAR(10),
	@VolumeToAdjust VARCHAR(11),
	@ValuationPrice VARCHAR(9),
	@CounterPartyMemberName VARCHAR(3),
	@CounterpartyTraderName VARCHAR(3),
	@DateEntered VARCHAR(8),
	@TimeEntered VARCHAR(6),
	@TimeLastModified VARCHAR(6),
	@TimeMatched VARCHAR(6),
	@OperatorReference VARCHAR(12),
	@UserSpecifiedData VARCHAR(14),
	@CounternoteSlipNumber VARCHAR(10),
	@ClosingTradeSlipNumber VARCHAR(10),
	@ClosingTradeSubNumber VARCHAR(3),
	@ClosingTradeVolume VARCHAR(11),
	@AllLotsIndicator VARCHAR(1),
	@NotificationSource VARCHAR(1),
	@NotificationStatus VARCHAR(2),
	@LotSize VARCHAR(5),
	@PositionType VARCHAR(1),
	@TradingDayOfNotificationProcessing VARCHAR(6),
	@ActionFlag VARCHAR(1),
	@FileName VARCHAR (512)
	)
AS
BEGIN
	--	22 Mar 2010		amk		Creation

	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON

	INSERT INTO [dbo].[LCH_TypeNT]
			(
			Exchange,
			DownloadNumber,
			TradingDay,
			TenderDeletionDay,
			NewTenderDeletionDay,
			TradingDayOfTrade,
			OriginatingMemberName,
			OriginatingTraderName,
			OriginatingClearerName,
			AccountCode,
			MarginingAccount,
			TradeChargeIndicator,
			LongOrShort,
			PhysicalCommodity,
			LogicalCommodity,
			ContractType,
			GenericContractType,
			LongExpiryDate,
			ExercisePrice,
			NotificationSlipType,
			ClearingSlipID,
			VolumeToAdjust,
			ValuationPrice,
			CounterPartyMemberName,
			CounterpartyTraderName,
			DateEntered,
			TimeEntered,
			TimeLastModified,
			TimeMatched,
			OperatorReference,
			UserSpecifiedData,
			CounternoteSlipNumber,
			ClosingTradeSlipNumber,
			ClosingTradeSubNumber,
			ClosingTradeVolume,
			AllLotsIndicator,
			NotificationSource,
			NotificationStatus,
			LotSize,
			PositionType,
			TradingDayOfNotificationProcessing,
			ActionFlag,
			FileName
			)
	VALUES
			(
			@Exchange,
			@DownloadNumber,
			@TradingDay,
			@TenderDeletionDay,
			@NewTenderDeletionDay,
			@TradingDayOfTrade,
			@OriginatingMemberName,
			@OriginatingTraderName,
			@OriginatingClearerName,
			@AccountCode,
			@MarginingAccount,
			@TradeChargeIndicator,
			@LongOrShort,
			@PhysicalCommodity,
			@LogicalCommodity,
			@ContractType,
			@GenericContractType,
			@LongExpiryDate,
			@ExercisePrice,
			@NotificationSlipType,
			@ClearingSlipID,
			@VolumeToAdjust,
			@ValuationPrice,
			@CounterPartyMemberName,
			@CounterpartyTraderName,
			@DateEntered,
			@TimeEntered,
			@TimeLastModified,
			@TimeMatched,
			@OperatorReference,
			@UserSpecifiedData,
			@CounternoteSlipNumber,
			@ClosingTradeSlipNumber,
			@ClosingTradeSubNumber,
			@ClosingTradeVolume,
			@AllLotsIndicator,
			@NotificationSource,
			@NotificationStatus,
			@LotSize,
			@PositionType,
			@TradingDayOfNotificationProcessing,
			@ActionFlag,
			@FileName
			)

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Rule_GetSecondFields]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Rule_GetSecondFields]
	@fieldId int, 
	@operatorId int
AS
SET NOCOUNT ON
	SELECT DISTINCT
		SF.Description, SF.FieldId, SF.DataTypeId
	FROM
		ib_Field SF
	INNER JOIN
		ib_Operator O ON O.DataTypeId = SF.DataTypeId 
		AND O.RequiresField2 = 1
		AND O.OperatorId = @operatorId
	INNER JOIN
		ib_Field F ON O.DataTypeId = F.DataTypeId AND F.FieldId = @fieldId
		
SELECT * FROM ib_Operator
');

GO
EXECUTE ('PRINT N''Creating [dbo].[CreditSuisse_Transaction]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[CreditSuisse_Transaction]
(
[CreditSuisse_TransactionID] [int] NOT NULL IDENTITY(1, 1),
[PRECID] [varchar] (1) NULL,
[PFIRM] [varchar] (1) NULL,
[POFFIC] [varchar] (3) NULL,
[PACCT] [varchar] (5) NULL,
[PCTYM] [varchar] (6) NULL,
[PSBCUS] [varchar] (2) NULL,
[PSTYPE] [varchar] (2) NULL,
[PSUBTY] [varchar] (1) NULL,
[PSTYP2] [varchar] (1) NULL,
[PSTRIK] [varchar] (15) NULL,
[PEXPDT] [varchar] (8) NULL,
[PSUBAC] [varchar] (10) NULL,
[PTDATE] [varchar] (8) NULL,
[PTPRIC] [varchar] (15) NULL,
[PBS] [varchar] (1) NULL,
[PBROKR] [varchar] (2) NULL,
[PTRACE] [varchar] (10) NULL,
[PICODE] [varchar] (3) NULL,
[PREFNO] [varchar] (12) NULL,
[PCLASS] [varchar] (1) NULL,
[PSUBCL] [varchar] (1) NULL,
[PQTY] [varchar] (15) NULL,
[PPRTQ] [varchar] (15) NULL,
[PSDSC1] [varchar] (3) NULL,
[PMKVAL] [varchar] (15) NULL,
[PSDATE] [varchar] (8) NULL,
[PEXCH] [varchar] (2) NULL,
[PFC] [varchar] (2) NULL,
[PTYPE] [varchar] (1) NULL,
[PSYMBL] [varchar] (6) NULL,
[PSUBEX] [varchar] (1) NULL,
[PPRTPR] [varchar] (11) NULL,
[PCLOSE] [varchar] (15) NULL,
[PPRCDT] [varchar] (8) NULL,
[PPRTCP] [varchar] (11) NULL,
[PPRICE] [varchar] (12) NULL,
[PCURSY] [varchar] (3) NULL,
[PGROSS] [varchar] (15) NULL,
[FileName] [varchar] (512) NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_CreditSuisse_Transaction_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_CreditSuisse_Transaction_CreateDate] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_CreditSuisse_Transaction] on [dbo].[CreditSuisse_Transaction]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[CreditSuisse_Transaction] ADD CONSTRAINT [PK_CreditSuisse_Transaction] PRIMARY KEY CLUSTERED  ([CreditSuisse_TransactionID])
');

GO
EXECUTE ('PRINT N''Creating index [IX_CreditSuisse_Transaction_Filename] on [dbo].[CreditSuisse_Transaction]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_CreditSuisse_Transaction_Filename] ON [dbo].[CreditSuisse_Transaction] ([FileName]) INCLUDE ([CreateDate], [CreditSuisse_TransactionID])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_CreditSuisse_Transaction_Load]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_CreditSuisse_Transaction_Load] 
	-- Add the parameters for the stored procedure here
	(
		@LocationPath VARCHAR(100)
		,@ReceiveLocationSysId INT
		,@RunId INT
	)
AS
SET NOCOUNT ON

-- Description:	This stored procedure pulls data from the CreditSuisse_Transaction temp
-- table and inserts it into ib_Trx
-- Whilst iterating through the records in CreditSuisse_Transaction, all 
-- of these inserts are wrapped in a transaction so that any failure causes
-- the changes to not commit.
--
-- 06 Apr 2011	AAJM	Creation
-- 07 Apr 2011	AAJM	MBAL-17385 Fix getting AsOfDate from Filename
-- 08 Apr 2011	AAJM	MBAL-17385 Fix wrong number of into variables
-- 18 Apr 2011	AAJM	Fix divisors not working, using wrong instrument code.
--						Fix day coming out as zero
-- 17 May 2011	AAJM	Add Sub Exchange Code to Exchange Code & Instrument Code
-- 18 May 2011	AAJM	Change Price to use PPRTPR not PPRICE
-- 27 May 2011	AAJM	Exclude adjustments where Price is null
-- 27 May 2011	AAJM	Update State of all temporary Transactions not loaded
-- 21 Jul 2011  AAJM	Fix updating state of temp transactions affecting simultaneous loads
-- 02 Jan 2014  RD		MBAL-24931 Added checking file age
-- 09 Jan 2014	ED		EIB 25004 - remove importLog table and use Log table
-- 25 Apr 2014	ED		EIB 25473 - raise error if file is too old and mark temp records as LoadState=3

BEGIN

	DECLARE @Message			VARCHAR(1024)
	DECLARE @AddCount			INT
	SET @AddCount = 0
		
	DECLARE @DataSourceCode VARCHAR(100)

	--Set the Datasource	
	EXEC [ib_GMI_GetDataSource] @LocationPath, @DataSourceCode OUTPUT 

	DECLARE @Output INT
	DECLARE @Output2 INT
	DECLARE @ReturnValue INT
	DECLARE @DataSourceId INT

	IF @LocationPath IS NULL SET @LocationPath = @DataSourceCode
	EXEC @ReturnValue= [_ib_DataSource_GetByCodeForOutput] @DataSourceCode, @OutPut output, @Output2 output
	SET @DataSourceId = @Output

	-- Duplicate file check										
	DECLARE @IsFileAlreadyLoaded INT
	EXEC @IsFileALreadyLoaded = HasFileBeenLoaded @LocationPath, @DataSourceId

	IF @IsFileAlreadyLoaded = 1
	BEGIN
		UPDATE [CreditSuisse_Transaction]
		SET LoadState = 3
		WHERE LoadState = 1
			AND FileName = @LocationPath		
		RETURN
	END
	
	-- Set AsOfDate from Filename
	DECLARE @AsOfDate DATETIME
	EXEC [dbo].[TryParseYYYYMMDDFromEndOfFilename] @LocationPath, @AsOfDate OUTPUT
	
	--rd - make sure the As Of Date is not older than acceptable
	DECLARE @IsAcceptable bit
	EXECUTE [dbo].[Load_IsFileTooOld] @DataSourceId,@LocationPath,@AsOfDate,@IsAcceptable OUTPUT, @ReceiveLocationSysId, @RunId
	IF (@IsAcceptable = 0)
	BEGIN
		UPDATE CreditSuisse_Transaction SET [LoadState] = 3 WHERE [Filename] = @LocationPath
		RAISERROR (''File is too old.'', 18, 0)
		RETURN 0
	END

	-- Store ImportFile record
	DECLARE @ImportFileId INT
	EXEC ib_ImportFile_Add @DataSourceId, @LocationPath, @ImportFileId output
	
	--Gets the defaultStrikePriceDivisor
	DECLARE	@DefaultStrikePriceDivisor	DECIMAL(19,6)
	SET @DefaultStrikePriceDivisor = [dbo].[udf_GetDefaultStrikePriceDivisor](@DataSourceId, NULL)
	
	IF OBJECT_ID(''tempdb..#temp3'') IS NOT NULL 
	DROP TABLE #temp3
		
	CREATE TABLE #temp3
	(
		CreditSuisse_TransactionID		INT
		, FirmCode					VARCHAR(1)
		, Account					VARCHAR(5)
		, Currency					VARCHAR(3)
		, TrxDateChr				VARCHAR(8)
		, Exchange					VARCHAR(2)
		, SubExchange				VARCHAR(1)
		, Instrument_Code			VARCHAR(2)
		, QuantityChr				VARCHAR(15)
		, BuySell					VARCHAR(1)
		, MarketValueChr			VARCHAR(15)
		, PriceChr					VARCHAR(11)
		, ContractYearMonth			VARCHAR(6)
		, ContractDay				VARCHAR(2)
		, StrikePriceChr			VARCHAR(15)
		, TrxTypeCode				VARCHAR(1)
		, OptionTypeCode			VARCHAR(1)
		, InstrumentType			VARCHAR(1)
	)

	INSERT INTO #temp3
	(
		CreditSuisse_TransactionID
		, FirmCode
		, Account
		, Currency
		, TrxDateChr	
		, Exchange
		, SubExchange
		, Instrument_Code
		, QuantityChr
		, BuySell
		, MarketValueChr
		, PriceChr
		, ContractYearMonth
		, ContractDay
		, StrikePriceChr
		, TrxTypeCode
		, OptionTypeCode
		, InstrumentType
	)
	SELECT 	
		[CreditSuisse_TransactionID]
		, [PFIRM]
		, LTRIM(RTRIM([PACCT]))
		, LTRIM(RTRIM([PCURSY]))
		, [PTDATE]
		, LTRIM(RTRIM([PEXCH]))
		, LTRIM(RTRIM([PSUBEX]))
		, LTRIM(RTRIM([PFC]))
		, [PQTY]
		, [PBS]
		, [PGROSS]
		, [PPRTPR]
		, [PCTYM]
		, [PSBCUS]
		, [PSTRIK]
		, [PRECID]
		, [PSUBTY]
		, [PSUBTY]
	FROM [dbo].[CreditSuisse_Transaction]
	WHERE LoadState = 1
		AND [Filename] = @LocationPath
		AND [PRECID] IN (''T'',''A'',''B'',''E'',''J'',''L'',''P'',''Q'',''R'',''S'',''U'',''V'',''X'',''Y'',''Z'')
		AND NOT ([PRECID] = ''A'' AND [PPRTPR] = '''')
	SET XACT_ABORT ON 

	BEGIN TRAN T1

		-- BizTalk''s SQL Adapter uses more restrictive read serializable
		-- so this is necessary to relax it to something that is default
		-- and perfectly acceptable!
		SET TRANSACTION ISOLATION LEVEL READ COMMITTED

		BEGIN TRY

			DECLARE @CreditSuisse_TransactionID	INT
			DECLARE @FirmCode					VARCHAR(1)
			DECLARE @Account					VARCHAR(5)
			DECLARE @Currency					VARCHAR(3)
			DECLARE @TrxDateChr					VARCHAR(8)
			DECLARE @ExchangeCode				VARCHAR(2)
			DECLARE @SubExchangeCode			VARCHAR(1)
			DECLARE @InstrumentCode				VARCHAR(2)
			DECLARE @QuantityChr				VARCHAR(15)
			DECLARE @BuySell					VARCHAR(1)
			DECLARE @MarketValueChr				VARCHAR(15)
			DECLARE @PriceChr					VARCHAR(11)
			DECLARE @ContractYearMonth			VARCHAR(6)
			DECLARE @ContractDay				VARCHAR(2)
			DECLARE @StrikePriceChr				VARCHAR(15)
			DECLARE @TrxTypeCode				VARCHAR(1)
			DECLARE @OptionTypeCode				VARCHAR(1)
			DECLARE @InstrumentType				VARCHAR(1)

			DECLARE trx_cursor CURSOR FOR
			SELECT CreditSuisse_TransactionID
					, FirmCode
					, Account
					, Currency
					, TrxDateChr
					, Exchange
					, SubExchange
					, Instrument_Code
					, QuantityChr
					, BuySell
					, MarketValueChr
					, PriceChr
					, ContractYearMonth
					, ContractDay
					, StrikePriceChr
					, TrxTypeCode
					, OptionTypeCode
					, InstrumentType
			FROM #temp3

			OPEN trx_cursor

			FETCH NEXT FROM trx_cursor
			INTO 
					@CreditSuisse_TransactionID
					, @FirmCode
					, @Account
					, @Currency
					, @TrxDateChr
					, @ExchangeCode
					, @SubExchangeCode
					, @InstrumentCode
					, @QuantityChr
					, @BuySell
					, @MarketValueChr
					, @PriceChr
					, @ContractYearMonth
					, @ContractDay
					, @StrikePriceChr
					, @TrxTypeCode
					, @OptionTypeCode
					, @InstrumentType

				-- Check @@FETCH_STATUS to see IF there are any more rows to fetch.
				WHILE @@FETCH_STATUS = 0
				BEGIN
					DECLARE		@AccountCd				VARCHAR(100)
					DECLARE		@ExchangeCd				VARCHAR(25)
					DECLARE		@InstrumentCd			VARCHAR(100)
					DECLARE		@Quantity				DECIMAL(19,4)
					DECLARE		@MarketValueDec			DECIMAL(19,4)
					DECLARE		@ExpYr					SMALLINT
					DECLARE		@ExpMth					SMALLINT
					DECLARE		@ExpDay					SMALLINT
					DECLARE		@StrikePrice			DECIMAL(19,4)
					DECLARE		@PriceDivisor			DECIMAL(19,4)
					DECLARE		@StrikePriceDivisor		DECIMAL(19,4)
					DECLARE		@MarketValueDivisor		DECIMAL(19,4)
					DECLARE		@Price					DECIMAL(24,10)
					DECLARE		@TrxDate				DATETIME
					DECLARE		@InstrumentTypeCd		VARCHAR(100)
					DECLARE     @ErrorMessageForRecord	VARCHAR(1024)
					DECLARE		@ErrorSeverity			INT
					DECLARE		@ErrorState				INT
					DECLARE		@QuantityLong			DECIMAL(19,4)
					DECLARE		@QuantityShort			DECIMAL(19,4)
					DECLARE		@SignedQuantity			DECIMAL(19,4)
					
					-- Temporary variables
                    DECLARE     @TempDate DATETIME
					DECLARE 	@Code VARCHAR(100), @Code2 VARCHAR(100)
					
			SET @AccountCd = @Account
			SET	@ExchangeCd = @ExchangeCode + ISNULL(@SubExchangeCode, '''')
					
			-- Set ExpiryDate
			SET @ExpYr = LEFT(@ContractYearMonth, 4)
			SET @ExpMth = RIGHT(@ContractYearMonth, 2)
			
			SET @ContractDay = LTRIM(RTRIM(@ContractDay))
			
			IF NULLIF(@ContractDay,'''') IS NULL OR @ContractDay = ''0''
				BEGIN
					-- Get the last day of the month
					SET @ExpDay = dbo.udf_OnLoad_ExpiryDate_Get_Day(@ExpYr,@ExpMth,@ContractDay)
				END
			ELSE
				SET @ExpDay = CAST(@ContractDay AS SMALLINT)
				
			-- Set InstrumentTypeCd
			IF @InstrumentType IN (''P'', ''C'')
				SET @InstrumentTypeCd = ''O''
			ELSE -- It will be blank
				SET @InstrumentTypeCd = ''F''
	

			-- We prefix the Instruments with the IntrumentTypeCode
			SET @InstrumentCd = @InstrumentTypeCd + ''_'' + @ExchangeCd + ''_'' + @InstrumentCode

			-- Get Divisors						
			SET @StrikePriceDivisor = NULL
			SET	@PriceDivisor = NULL
			SET	@MarketValueDivisor = NULL
								
			SELECT @StrikePriceDivisor = ids.StrikePriceDivisor
					, @PriceDivisor = ids.PriceDivisor
					, @MarketValueDivisor = ids.MarketValueDivisor
			FROM [dbo].[ib_InstrumentDataSource] ids
			WHERE ids.DataSourceId = @DataSourceId
				AND ids.DataSourceInstrumentCode = @InstrumentCd

			-- Set Price				
			IF @PriceDivisor IS NULL 
				SET @PriceDivisor = 1				

			SET @Price = CONVERT(DECIMAL(24,10), @PriceChr) / @PriceDivisor
			
			-- Adjust Price for other Trx Types
			IF (UPPER(@TrxTypeCode) = ''X'')
				SET @Price = 0
					
			-- Set StrikePrice
			SET @StrikePrice = NULL
			
			IF @StrikePriceDivisor IS NULL
				BEGIN
					SET @StrikePrice = CAST(@StrikePriceChr AS DECIMAL(19,4)) / ISNULL(@DefaultStrikePriceDivisor, 1)
				END
			ELSE
				BEGIN
					SET @StrikePrice = CAST(@StrikePriceChr AS DECIMAL(19,4)) / @StrikePriceDivisor
				END			
				
			-- Set Quantity 
			SET @Quantity = 0
			SET @QuantityLong = 0
			SET @QuantityShort = 0
			
			-- Set Quantity (throw an error if not convertible)
			
			SET @Quantity = CONVERT(DECIMAL(19,4), @QuantityChr)
			
			SET @SignedQuantity = @Quantity
						
			-- Set QuantityLong
			IF (@BuySell = ''1'')
				BEGIN
					SET @QuantityLong = @Quantity
				END
			ELSE
					SET @QuantityLong = 0
								
			-- Set QuantityShort
			IF (@BuySell = ''2'')
				BEGIN
					SET @QuantityShort = @Quantity
					SET @SignedQuantity = @Quantity * (-1)
				END	
			ELSE
				SET @QuantityShort = 0
				
			-- X and E Transactions should have a negative quantity
				IF (UPPER(@TrxTypeCode) = ''X'' OR UPPER(@TrxTypeCode) = ''E'')
				BEGIN
					SET @SignedQuantity = @SignedQuantity * (-1)					
					SET @QuantityLong = @QuantityLong * (-1)
					SET @QuantityShort = @QuantityShort * (-1)
				END
				
			-- Set Market Value
			IF @MarketValueDivisor IS NULL 
				SET @MarketValueDivisor = 1
			
			SET @MarketValueDec = CONVERT(DECIMAL(19,4), @MarketValueChr) / @MarketValueDivisor
			
			-- TrxDate
			
			SET @TrxDate = CONVERT(DATETIME, @TrxDateChr, 112)
					
			EXEC [ib_Trx_Load]
				@DataSourceCode			
				, @ExchangeCd				
				, @FirmCode -- Firm will be added if not present					
				, @AccountCd	
				, NULL -- DetailAccountCd		
				, @InstrumentCd			
				, @ExpYr					
				, @ExpMth 					
				, @ExpDay 					
				, @StrikePrice			
				, @TrxTypeCode				
				, @OptionTypeCode
				, @SignedQuantity			
				, @TrxDate				
				, @Price 
				, @CreditSuisse_TransactionID
				, @InstrumentTypeCd
				, @AsOfDate		
				, @LocationPath
				, @MarketValueDec
				, @Currency
				, @QuantityLong = @QuantityLong 
				, @QuantityShort = @QuantityShort
				, @ReceiveLocationSysId = @ReceiveLocationSysId
				, @RunId = @RunId
			
			--flip processed flag in source table.
			UPDATE [CreditSuisse_Transaction]
			WITH (ROWLOCK)
			SET [LoadState] = 2
			WHERE [CreditSuisse_TransactionID] = @CreditSuisse_TransactionID
				AND [LoadState] = 1

			SET @AddCount = @AddCount + 1
			
			FETCH NEXT FROM trx_cursor
			INTO 
					@CreditSuisse_TransactionID
					, @FirmCode
					, @Account
					, @Currency
					, @TrxDateChr
					, @ExchangeCode
					, @SubExchangeCode
					, @InstrumentCode
					, @QuantityChr
					, @BuySell
					, @MarketValueChr
					, @PriceChr
					, @ContractYearMonth
					, @ContractDay
					, @StrikePriceChr
					, @TrxTypeCode
					, @OptionTypeCode
					, @InstrumentType
		END
			
		CLOSE trx_cursor
		DEALLOCATE trx_cursor

			-- Now update state of any left-over temporary transaction records
			-- so there are no ''left-overs''
			UPDATE [CreditSuisse_Transaction]
			WITH (ROWLOCK)
			SET [LoadState] = 2
			WHERE [LoadState] = 1 AND [FileName] = @LocationPath

			SET @Message = @DataSourceCode + '' transaction loader ended ('' 
			+ CONVERT(VARCHAR(10), @AddCount) + '' added)'' 
		
			EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @Message, ''Success'', '''', @RunId

			UPDATE ib_ImportFile
			SET AsOfDate = @AsOfDate
			WHERE ImportFileId = @ImportFileId
			
		COMMIT TRAN T1

		DROP TABLE #temp3
	
	END TRY
	BEGIN CATCH 

		IF XACT_STATE() = -1 
			ROLLBACK TRANSACTION
	
		SET @Message = @DataSourceCode + '' transaction loader failed'' 		
		EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @Message, ''Error'', '''', @RunId
	
		EXEC [dbo].[sp_RethrowError]
		
	END CATCH 

	SET XACT_ABORT OFF

END

RETURN 0
');

GO
EXECUTE ('PRINT N''Creating [dbo].[RolfeNolan_HOSTTRN]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[RolfeNolan_HOSTTRN]
(
[RolfeNolan_HOSTTRNID] [int] NOT NULL IDENTITY(1, 1),
[Type] [varchar] (3) NULL,
[Serial] [varchar] (5) NULL,
[Ledger] [varchar] (10) NULL,
[FASCurrency] [varchar] (3) NULL,
[Currency] [varchar] (3) NULL,
[BaseCurrency] [varchar] (3) NULL,
[Market] [varchar] (5) NULL,
[MarketCode] [varchar] (5) NULL,
[DummyField] [varchar] (3) NULL,
[RunDate] [varchar] (8) NULL,
[Serial2] [varchar] (10) NULL,
[PromptDate] [varchar] (8) NULL,
[StrikeShort] [varchar] (21) NULL,
[Strike] [varchar] (21) NULL,
[PutCall] [varchar] (2) NULL,
[Lots] [varchar] (21) NULL,
[Price] [varchar] (21) NULL,
[OpenClose] [varchar] (1) NULL,
[PostingAmount] [varchar] (20) NULL,
[IsMergedTrade] [char] (1) NULL,
[Series] [varchar] (20) NULL,
[FullSeries] [varchar] (20) NULL,
[Premium] [varchar] (20) NULL,
[IsCashSettlingOption] [char] (1) NULL,
[Filename] [varchar] (512) NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_RolfeNolan_HOSTTRN_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_RolfeNolan_HOSTTRN_CreateDate] DEFAULT (getdate()),
[UTI] [varchar] (100) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_RolfeNolan_HOSTTRN] on [dbo].[RolfeNolan_HOSTTRN]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[RolfeNolan_HOSTTRN] ADD CONSTRAINT [PK_RolfeNolan_HOSTTRN] PRIMARY KEY CLUSTERED  ([RolfeNolan_HOSTTRNID])
');

GO
EXECUTE ('PRINT N''Creating index [IX_RolfeNolan_HOSTTRN_FileName] on [dbo].[RolfeNolan_HOSTTRN]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_RolfeNolan_HOSTTRN_FileName] ON [dbo].[RolfeNolan_HOSTTRN] ([Filename]) INCLUDE ([CreateDate], [RolfeNolan_HOSTTRNID])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[RolfeNolan_HOSTOPN]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[RolfeNolan_HOSTOPN]
(
[RolfeNolan_HOSTOPNID] [int] NOT NULL IDENTITY(1, 1),
[Ledger] [varchar] (11) NULL,
[HostCurrency] [varchar] (21) NULL,
[BaseCurrency] [varchar] (3) NULL,
[Market] [varchar] (5) NULL,
[MarketCode] [varchar] (5) NULL,
[HostInstrument] [varchar] (21) NULL,
[PromptDate] [varchar] (8) NULL,
[TradeType] [varchar] (4) NULL,
[Series] [varchar] (6) NULL,
[Lots] [varchar] (21) NULL,
[PremiumRate] [varchar] (21) NULL,
[Price] [varchar] (21) NULL,
[Filename] [varchar] (512) NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_RolfeNolan_HOSTOPN_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_RolfeNolan_HOSTOPN_CreateDate] DEFAULT (getdate()),
[MarketRate] [varchar] (21) NULL,
[Margin] [varchar] (21) NULL,
[Strike] [varchar] (7) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_RolfeNolan_HOSTOPN] on [dbo].[RolfeNolan_HOSTOPN]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[RolfeNolan_HOSTOPN] ADD CONSTRAINT [PK_RolfeNolan_HOSTOPN] PRIMARY KEY CLUSTERED  ([RolfeNolan_HOSTOPNID])
');

GO
EXECUTE ('PRINT N''Creating index [IX_RolfeNolan_HOSTOPN_FileName] on [dbo].[RolfeNolan_HOSTOPN]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_RolfeNolan_HOSTOPN_FileName] ON [dbo].[RolfeNolan_HOSTOPN] ([Filename]) INCLUDE ([CreateDate], [RolfeNolan_HOSTOPNID])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[RBC_Transaction]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[RBC_Transaction]
(
[RBC_TransactionID] [int] NOT NULL IDENTITY(1, 1),
[Type] [varchar] (3) NULL,
[Serial] [varchar] (5) NULL,
[Ledger] [varchar] (7) NULL,
[FASCurrency] [varchar] (3) NULL,
[Currency] [varchar] (3) NULL,
[BaseCurrency] [varchar] (3) NULL,
[Market] [varchar] (5) NULL,
[MarketCode] [varchar] (5) NULL,
[DummyField] [varchar] (3) NULL,
[RunDate] [varchar] (8) NULL,
[Serial2] [varchar] (10) NULL,
[PromptDate] [varchar] (8) NULL,
[StrikeShort] [varchar] (21) NULL,
[Strike] [varchar] (21) NULL,
[PutCall] [varchar] (2) NULL,
[Lots] [varchar] (21) NULL,
[Price] [varchar] (21) NULL,
[OpenClose] [varchar] (1) NULL,
[PostingAmount] [varchar] (20) NULL,
[IsMergedTrade] [char] (1) NULL,
[Series] [varchar] (20) NULL,
[FullSeries] [varchar] (20) NULL,
[Premium] [varchar] (20) NULL,
[IsCashSettlingOption] [char] (1) NULL,
[Filename] [varchar] (512) NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_RBC_Transaction_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_RBC_Transaction_CreateDate] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_RBC_Transaction] on [dbo].[RBC_Transaction]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[RBC_Transaction] ADD CONSTRAINT [PK_RBC_Transaction] PRIMARY KEY CLUSTERED  ([RBC_TransactionID])
');

GO
EXECUTE ('PRINT N''Creating index [IX_RBC_Transaction_Filename] on [dbo].[RBC_Transaction]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_RBC_Transaction_Filename] ON [dbo].[RBC_Transaction] ([Filename]) INCLUDE ([CreateDate], [RBC_TransactionID])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[RBC_Position]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[RBC_Position]
(
[RBC_PositionID] [int] NOT NULL IDENTITY(1, 1),
[Ledger] [varchar] (7) NULL,
[HostCurrency] [varchar] (21) NULL,
[BaseCurrency] [varchar] (3) NULL,
[Market] [varchar] (5) NULL,
[MarketCode] [varchar] (5) NULL,
[HostInstrument] [varchar] (21) NULL,
[PromptDate] [varchar] (8) NULL,
[TradeType] [varchar] (4) NULL,
[Series] [varchar] (6) NULL,
[Lots] [varchar] (21) NULL,
[PremiumRate] [varchar] (21) NULL,
[Price] [varchar] (21) NULL,
[Filename] [varchar] (512) NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_RBC_Position_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_RBC_Position_CreateDate] DEFAULT (getdate()),
[MarketRate] [varchar] (21) NULL,
[Margin] [varchar] (21) NULL,
[Strike] [varchar] (7) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_RBC_Position] on [dbo].[RBC_Position]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[RBC_Position] ADD CONSTRAINT [PK_RBC_Position] PRIMARY KEY CLUSTERED  ([RBC_PositionID])
');

GO
EXECUTE ('PRINT N''Creating index [IX_RBC_Position_Filename] on [dbo].[RBC_Position]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_RBC_Position_Filename] ON [dbo].[RBC_Position] ([Filename]) INCLUDE ([CreateDate], [RBC_PositionID])
');

GO
EXECUTE ('PRINT N''Creating [stage].[MGETrade]''
');

GO
EXECUTE ('CREATE TABLE [stage].[MGETrade]
(
[MGETradeId] [int] NOT NULL IDENTITY(1, 1),
[MessageId] [varchar] (3) NULL,
[MessageVersion] [varchar] (1) NULL,
[MessageTime] [varchar] (8) NULL,
[TrexId] [varchar] (8) NULL,
[MessageLength] [varchar] (4) NULL,
[ActionCode] [varchar] (1) NULL,
[TradeRoute] [varchar] (1) NULL,
[TradeDate] [date] NULL,
[ExchangeId] [varchar] (5) NULL,
[ClearingFirm] [varchar] (5) NULL,
[ExecutingBroker] [varchar] (5) NULL,
[TransactionType] [varchar] (2) NULL,
[BuySell] [varchar] (1) NULL,
[CommodityCode] [varchar] (5) NULL,
[ContractYearMonth] [varchar] (6) NULL,
[PutCall] [varchar] (1) NULL,
[StrikePrice] [decimal] (16, 8) NULL,
[StrikeSign] [varchar] (1) NULL,
[OppositeMember] [varchar] (5) NULL,
[OppositeBroker] [varchar] (5) NULL,
[TradePrice] [decimal] (22, 8) NULL,
[PriceSign] [varchar] (1) NULL,
[Quantity] [int] NULL,
[TimeBracketCode] [varchar] (3) NULL,
[AccountNumber] [varchar] (10) NULL,
[CTICode] [varchar] (1) NULL,
[OriginCode] [varchar] (2) NULL,
[OrderId] [varchar] (8) NULL,
[FeeCode] [varchar] (2) NULL,
[CTRCardSequence] [varchar] (6) NULL,
[OpenCloseIndicator] [varchar] (1) NULL,
[TradeIdSeqNumber] [varchar] (6) NULL,
[TradeIdSourceCode] [varchar] (3) NULL,
[TradeIdCycleCode] [varchar] (2) NULL,
[OrderType] [varchar] (2) NULL,
[FloorBroker] [varchar] (5) NULL,
[Cabinet] [varchar] (1) NULL,
[TransferReason] [varchar] (2) NULL,
[OppositeOrigin] [varchar] (2) NULL,
[OppositeOpenClose] [varchar] (1) NULL,
[CancelIndicator] [varchar] (1) NULL,
[AuthorizationCode] [varchar] (3) NULL,
[APSIndicator] [varchar] (1) NULL,
[APSGroupId] [varchar] (5) NULL,
[OrderExecutionTime] [varchar] (6) NULL,
[BusinessCycleCode] [varchar] (5) NULL,
[BlockA8] [varchar] (2) NULL,
[ResidualAmount] [int] NULL,
[GroupCode] [varchar] (5) NULL,
[AveragePrice] [decimal] (18, 7) NULL,
[ExtendedPrice] [decimal] (28, 12) NULL,
[Filename] [varchar] (512) NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF__MGETrade__LoadSt__377FED54] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF__MGETrade__Create__3874118D] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_MGETrade] on [stage].[MGETrade]''
');

GO
EXECUTE ('ALTER TABLE [stage].[MGETrade] ADD CONSTRAINT [PK_MGETrade] PRIMARY KEY CLUSTERED  ([MGETradeId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_MGETrade_LoadState_Filename] on [stage].[MGETrade]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_MGETrade_LoadState_Filename] ON [stage].[MGETrade] ([LoadState], [Filename])
');

GO
EXECUTE ('PRINT N''Creating [stage].[MGEPosition]''
');

GO
EXECUTE ('CREATE TABLE [stage].[MGEPosition]
(
[MGEPositionId] [int] NOT NULL IDENTITY(1, 1),
[FirmCode] [varchar] (3) NOT NULL,
[CustomerHouse] [varchar] (1) NOT NULL,
[FuturesOptions] [varchar] (1) NOT NULL,
[CommodityCode] [varchar] (2) NOT NULL,
[ContractYear] [varchar] (4) NOT NULL,
[ContractMonth] [varchar] (2) NOT NULL,
[PutCall] [varchar] (1) NOT NULL,
[StrikePrice] [decimal] (13, 8) NOT NULL,
[Long] [int] NOT NULL,
[Short] [int] NOT NULL,
[Pay] [decimal] (20, 10) NOT NULL,
[Collect] [decimal] (20, 10) NOT NULL,
[Currency] [varchar] (3) NOT NULL,
[StrikeSign] [varchar] (1) NULL,
[Filename] [varchar] (512) NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF__MGEPositi__LoadS__3597A4E2] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF__MGEPositi__Creat__368BC91B] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_MGEPosition] on [stage].[MGEPosition]''
');

GO
EXECUTE ('ALTER TABLE [stage].[MGEPosition] ADD CONSTRAINT [PK_MGEPosition] PRIMARY KEY CLUSTERED  ([MGEPositionId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_MGEePosition_LoadState_Filename] on [stage].[MGEPosition]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_MGEePosition_LoadState_Filename] ON [stage].[MGEPosition] ([LoadState], [Filename])
');

GO
EXECUTE ('PRINT N''Creating [stage].[MacquarieTrade]''
');

GO
EXECUTE ('CREATE TABLE [stage].[MacquarieTrade]
(
[MacquarieTradeId] [int] NOT NULL IDENTITY(1, 1),
[BusinessDate] [date] NOT NULL,
[ClientCode] [varchar] (100) NOT NULL,
[Description] [varchar] (255) NULL,
[GroupCode] [varchar] (100) NULL,
[Currency] [varchar] (3) NOT NULL,
[Category] [varchar] (10) NOT NULL,
[CommodityCode] [varchar] (100) NOT NULL,
[DeliveryMonth] [varchar] (4) NOT NULL,
[FuturesOrOption] [varchar] (1) NULL,
[PutCall] [varchar] (1) NULL,
[TradeDate] [date] NOT NULL,
[BoughtSold] [varchar] (1) NOT NULL,
[Quantity] [int] NOT NULL,
[BoughtPrice] [money] NOT NULL,
[BoughtPriceNum] [money] NULL,
[SoldPrice] [money] NOT NULL,
[SoldPriceNum] [money] NULL,
[CurrentPrice] [money] NULL,
[MarginVariance] [money] NOT NULL,
[ExecutingBrokerCode] [varchar] (100) NULL,
[ExercisePrice] [money] NOT NULL,
[ExercisePriceNum] [money] NULL,
[CommissionAmount] [money] NULL,
[CommOnlyAmount] [money] NULL,
[FeesAmount] [money] NULL,
[InstrumentType] [varchar] (10) NOT NULL,
[LineNumber] [int] NULL,
[CommissionGstAmount] [money] NULL,
[FeesGstAmount] [money] NULL,
[CommissionExGst] [money] NULL,
[FeesExGst] [money] NULL,
[SettlementAmount] [money] NULL,
[BoughtClientDealId] [varchar] (100) NULL,
[SoldClientDealId] [varchar] (100) NULL,
[StrategyCode] [varchar] (255) NULL,
[DateFrom] [date] NULL,
[DateTo] [date] NULL,
[DeliveryDate] [date] NULL,
[TickValue] [decimal] (10, 5) NULL,
[TickSize] [decimal] (10, 5) NULL,
[LastTradeDate] [date] NOT NULL,
[Event] [varchar] (100) NULL,
[Action] [varchar] (100) NULL,
[Filename] [varchar] (512) NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF__Macquarie__LoadS__33CCF5FC] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF__Macquarie__Creat__34C11A35] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_MacquarieTrade] on [stage].[MacquarieTrade]''
');

GO
EXECUTE ('ALTER TABLE [stage].[MacquarieTrade] ADD CONSTRAINT [PK_MacquarieTrade] PRIMARY KEY CLUSTERED  ([MacquarieTradeId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_MacquarieTrade_LoadState_Filename] on [stage].[MacquarieTrade]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_MacquarieTrade_LoadState_Filename] ON [stage].[MacquarieTrade] ([LoadState], [Filename])
');

GO
EXECUTE ('PRINT N''Creating [stage].[MacquariePosition]''
');

GO
EXECUTE ('CREATE TABLE [stage].[MacquariePosition]
(
[MacquariePositionId] [int] NOT NULL IDENTITY(1, 1),
[BusinessDate] [date] NOT NULL,
[GroupCode] [varchar] (100) NULL,
[ClientCode] [varchar] (100) NOT NULL,
[CommodityCode] [varchar] (100) NOT NULL,
[DeliveryMonth] [varchar] (4) NOT NULL,
[ExercisePrice] [money] NOT NULL,
[PutCall] [varchar] (1) NULL,
[BoughtLots] [int] NOT NULL,
[SoldLots] [int] NOT NULL,
[NetLots] [int] NOT NULL,
[VarMargin] [money] NOT NULL,
[OpenPrice] [money] NULL,
[CurrentPrice] [money] NOT NULL,
[LastTradeDate] [date] NULL,
[Currency] [varchar] (3) NOT NULL,
[ExercisePriceNum] [money] NULL,
[AsxCode] [varchar] (255) NULL,
[TickValue] [decimal] (10, 5) NULL,
[TickSize] [decimal] (10, 5) NULL,
[Filename] [varchar] (512) NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF__Macquarie__LoadS__31E4AD8A] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF__Macquarie__Creat__32D8D1C3] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_MacquariePosition] on [stage].[MacquariePosition]''
');

GO
EXECUTE ('ALTER TABLE [stage].[MacquariePosition] ADD CONSTRAINT [PK_MacquariePosition] PRIMARY KEY CLUSTERED  ([MacquariePositionId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_MacquariePosition_LoadState_Filename] on [stage].[MacquariePosition]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_MacquariePosition_LoadState_Filename] ON [stage].[MacquariePosition] ([LoadState], [Filename])
');

GO
EXECUTE ('PRINT N''Creating [stage].[LmeTrade]''
');

GO
EXECUTE ('CREATE TABLE [stage].[LmeTrade]
(
[LmeTradeId] [int] NOT NULL IDENTITY(1, 1),
[ReportDate] [date] NOT NULL,
[AccountCode] [varchar] (100) NOT NULL,
[TradeStatus] [varchar] (5) NOT NULL,
[Contract] [char] (3) NOT NULL,
[Commodity] [char] (2) NOT NULL,
[CurrencyCode] [char] (3) NOT NULL,
[ContractTypeCode] [varchar] (25) NOT NULL,
[SubContractType] [varchar] (1) NOT NULL,
[ForwardDate] [date] NULL,
[UniqueProductId] [varchar] (100) NULL,
[TradeDate] [date] NOT NULL,
[TradePrice] [decimal] (19, 5) NOT NULL,
[StrikePrice] [decimal] (19, 5) NULL,
[IsBuy] [bit] NOT NULL CONSTRAINT [DF__LmeTrade__IsBuy__5B5AF912] DEFAULT ((0)),
[Lots] [int] NOT NULL,
[ExchangeReference] [varchar] (100) NULL,
[ExchangeTradeType] [varchar] (100) NULL,
[UTI] [varchar] (100) NOT NULL,
[Filename] [varchar] (512) NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF__LmeTrade__LoadSt__5C4F1D4B] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF__LmeTrade__Create__5D434184] DEFAULT (getdate()),
[ForwardMonth] [varchar] (6) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_LmeTrade] on [stage].[LmeTrade]''
');

GO
EXECUTE ('ALTER TABLE [stage].[LmeTrade] ADD CONSTRAINT [PK_LmeTrade] PRIMARY KEY CLUSTERED  ([LmeTradeId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_LmeTrade_Filename_CreateDate] on [stage].[LmeTrade]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_LmeTrade_Filename_CreateDate] ON [stage].[LmeTrade] ([Filename]) INCLUDE ([CreateDate])
');

GO
EXECUTE ('PRINT N''Creating index [IX_LmeTrade_LoadState_Filename] on [stage].[LmeTrade]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_LmeTrade_LoadState_Filename] ON [stage].[LmeTrade] ([LoadState], [Filename])
');

GO
EXECUTE ('PRINT N''Creating [stage].[LmePositionsRealisedCash]''
');

GO
EXECUTE ('CREATE TABLE [stage].[LmePositionsRealisedCash]
(
[LmePositionsRealisedCashId] [int] NOT NULL IDENTITY(1, 1),
[ReportDate] [date] NOT NULL,
[AccountCode] [varchar] (100) NOT NULL,
[CollateralAccount] [varchar] (25) NOT NULL,
[Product] [varchar] (5) NULL,
[Currency] [char] (3) NOT NULL,
[TransactionType] [varchar] (100) NOT NULL,
[PromptDate] [date] NULL,
[Strike] [money] NULL,
[CallOrPut] [varchar] (5) NULL,
[TransactionValue] [money] NOT NULL,
[Filename] [varchar] (512) NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF__LmePositi__LoadS__5972B0A0] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF__LmePositi__Creat__5A66D4D9] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_LmePositionsRealisedCash] on [stage].[LmePositionsRealisedCash]''
');

GO
EXECUTE ('ALTER TABLE [stage].[LmePositionsRealisedCash] ADD CONSTRAINT [PK_LmePositionsRealisedCash] PRIMARY KEY CLUSTERED  ([LmePositionsRealisedCashId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_LmePositionsRealisedCash_Filename_CreateDate] on [stage].[LmePositionsRealisedCash]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_LmePositionsRealisedCash_Filename_CreateDate] ON [stage].[LmePositionsRealisedCash] ([Filename]) INCLUDE ([CreateDate])
');

GO
EXECUTE ('PRINT N''Creating index [IX_LmePositionsRealisedCash_LoadState_Filename] on [stage].[LmePositionsRealisedCash]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_LmePositionsRealisedCash_LoadState_Filename] ON [stage].[LmePositionsRealisedCash] ([LoadState], [Filename])
');

GO
EXECUTE ('PRINT N''Creating [stage].[LmePosition]''
');

GO
EXECUTE ('CREATE TABLE [stage].[LmePosition]
(
[LmePositionId] [int] NOT NULL IDENTITY(1, 1),
[ReportDate] [date] NOT NULL,
[AccountCode] [varchar] (100) NOT NULL,
[Contract] [char] (3) NOT NULL,
[Commodity] [char] (2) NOT NULL,
[CurrencyCode] [char] (3) NOT NULL,
[ContractTypeCode] [varchar] (25) NOT NULL,
[SubContractType] [varchar] (1) NOT NULL,
[ForwardDate] [date] NULL,
[UniqueProductId] [varchar] (100) NULL,
[TradePrice] [money] NULL,
[StrikePrice] [money] NULL,
[LongQuantity] [int] NULL,
[ShortQuantity] [int] NULL,
[ClosingPrice] [money] NOT NULL,
[FuturesMarketValue] [money] NULL,
[OptionsMarketValue] [money] NULL,
[UTI] [varchar] (100) NULL,
[ForwardValue] [money] NULL,
[TradeDate] [date] NULL,
[Filename] [varchar] (512) NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF__LmePositi__LoadS__578A682E] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF__LmePositi__Creat__587E8C67] DEFAULT (getdate()),
[ForwardMonth] [varchar] (6) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_LmePosition] on [stage].[LmePosition]''
');

GO
EXECUTE ('ALTER TABLE [stage].[LmePosition] ADD CONSTRAINT [PK_LmePosition] PRIMARY KEY CLUSTERED  ([LmePositionId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_LmePosition_Filename_CreateDate] on [stage].[LmePosition]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_LmePosition_Filename_CreateDate] ON [stage].[LmePosition] ([Filename]) INCLUDE ([CreateDate])
');

GO
EXECUTE ('PRINT N''Creating index [IX_LmePosition_LoadState_Filename] on [stage].[LmePosition]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_LmePosition_LoadState_Filename] ON [stage].[LmePosition] ([LoadState], [Filename])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[Liffe_TradeReport]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[Liffe_TradeReport]
(
[Liffe_TradeReportId] [int] NOT NULL IDENTITY(1, 1),
[RowId] [varchar] (19) NOT NULL,
[System] [varchar] (7) NOT NULL,
[Version] [varchar] (3) NULL,
[RecType] [varchar] (3) NOT NULL,
[Exchange] [varchar] (1) NOT NULL,
[ExchangeMnemonic] [varchar] (5) NOT NULL,
[ClearingSlipId] [varchar] (19) NOT NULL,
[TrdId] [varchar] (50) NOT NULL,
[SubTradeSequence] [varchar] (19) NOT NULL,
[ParentTrdId] [varchar] (50) NOT NULL,
[SlipType] [varchar] (1) NOT NULL,
[TrdSubTyp] [varchar] (3) NOT NULL,
[TrdTyp] [varchar] (3) NOT NULL,
[TradeType] [varchar] (1) NOT NULL,
[StrtPrmNme] [varchar] (1) NOT NULL,
[CrossType] [varchar] (1) NOT NULL,
[Status] [varchar] (2) NOT NULL,
[OrgClearer] [varchar] (3) NOT NULL,
[OrgMember] [varchar] (3) NOT NULL,
[OrgTrader] [varchar] (3) NOT NULL,
[CptyTrader] [varchar] (3) NOT NULL,
[CptyMember] [varchar] (3) NOT NULL,
[BuySell] [varchar] (1) NOT NULL,
[ContractType] [varchar] (1) NOT NULL,
[GenContractType] [varchar] (1) NOT NULL,
[Commodity] [varchar] (3) NOT NULL,
[LogCommodity] [varchar] (3) NOT NULL,
[MonthCode] [varchar] (1) NOT NULL,
[ExpiryMonth] [varchar] (5) NOT NULL,
[ExpiryDate] [varchar] (10) NOT NULL,
[LongExpiryDate] [varchar] (10) NOT NULL,
[Strike] [varchar] (24) NOT NULL,
[Price] [varchar] (24) NOT NULL,
[Volume] [varchar] (19) NOT NULL,
[Account] [varchar] (25) NOT NULL,
[AllTrader] [varchar] (3) NOT NULL,
[AllMember] [varchar] (3) NOT NULL,
[OpenClose] [varchar] (1) NOT NULL,
[EnteredDate] [varchar] (10) NOT NULL,
[EnteredTime] [varchar] (8) NOT NULL,
[TradeTime] [varchar] (8) NOT NULL,
[ModifiedTime] [varchar] (8) NOT NULL,
[AssignedTime] [varchar] (8) NOT NULL,
[TimeMatched] [varchar] (8) NOT NULL,
[TRSOperator] [varchar] (50) NOT NULL,
[OrderSlipId] [varchar] (19) NOT NULL,
[TraderCardReference] [varchar] (100) NOT NULL,
[UserSpecifiedData] [varchar] (100) NOT NULL,
[PMA] [varchar] (25) NULL,
[MarginAccount] [varchar] (1) NOT NULL,
[TradeDate] [varchar] (10) NOT NULL,
[TimeBracket] [varchar] (2) NOT NULL,
[TradingEnv] [varchar] (1) NOT NULL,
[CTrdSlipId] [varchar] (19) NOT NULL,
[CntraTrdId] [varchar] (5) NOT NULL,
[CtrdSubAcc] [varchar] (4) NOT NULL,
[CounterclaimSlipId] [varchar] (50) NOT NULL,
[RemClearer] [varchar] (4) NOT NULL,
[TransferInd] [varchar] (1) NOT NULL,
[OffsetDate] [varchar] (2) NOT NULL,
[StrategyCode] [varchar] (1) NOT NULL,
[DesignatedAccount] [varchar] (50) NOT NULL,
[PostingCode] [varchar] (19) NOT NULL,
[SessionId] [varchar] (19) NOT NULL,
[CustomerReference] [varchar] (256) NOT NULL,
[Aggressor] [varchar] (1) NOT NULL,
[VenuTyp] [varchar] (1) NOT NULL,
[RptSideCntraClaimTrdId] [varchar] (50) NOT NULL,
[RptSideCntraTrdId] [varchar] (50) NOT NULL,
[HalfTradeId] [varchar] (50) NOT NULL,
[TradeClipId] [varchar] (19) NOT NULL,
[ReportTime] [varchar] (19) NOT NULL,
[FileName] [varchar] (512) NOT NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_Liffe_TradeReport_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_Liffe_TradeReport_CreateDate] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_Liffe_TradeReport] on [dbo].[Liffe_TradeReport]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[Liffe_TradeReport] ADD CONSTRAINT [PK_Liffe_TradeReport] PRIMARY KEY CLUSTERED  ([Liffe_TradeReportId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_Liffe_TradeReport_Filename] on [dbo].[Liffe_TradeReport]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_Liffe_TradeReport_Filename] ON [dbo].[Liffe_TradeReport] ([FileName]) INCLUDE ([CreateDate], [Liffe_TradeReportId])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[Liffe_Position]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[Liffe_Position]
(
[Liffe_PositionId] [int] NOT NULL IDENTITY(1, 1),
[RowId] [varchar] (19) NOT NULL,
[System] [varchar] (7) NOT NULL,
[Version] [varchar] (3) NULL,
[RecType] [varchar] (3) NOT NULL,
[Exchange] [varchar] (1) NOT NULL,
[ExchangeMnemonic] [varchar] (5) NOT NULL,
[MarginTime] [varchar] (8) NOT NULL,
[MarginRunSeqNo] [varchar] (19) NOT NULL,
[MarginType] [varchar] (1) NOT NULL,
[TradingDayTrade] [varchar] (19) NOT NULL,
[TradingDate] [varchar] (10) NOT NULL,
[TDD] [varchar] (19) NOT NULL,
[OrgClearer] [varchar] (3) NOT NULL,
[OrgMember] [varchar] (3) NOT NULL,
[OrgTrader] [varchar] (3) NOT NULL,
[Account] [varchar] (25) NOT NULL,
[PMA] [varchar] (25) NULL,
[MarginAccount] [varchar] (1) NOT NULL,
[Commodity] [varchar] (3) NOT NULL,
[LogCommodity] [varchar] (3) NOT NULL,
[ContractType] [varchar] (1) NOT NULL,
[GenContractType] [varchar] (1) NOT NULL,
[ContractTypeAll] [varchar] (1) NOT NULL,
[MonthCode] [varchar] (1) NOT NULL,
[ExpiryMonth] [varchar] (5) NOT NULL,
[ExpiryDate] [varchar] (10) NOT NULL,
[LongExpiryDate] [varchar] (10) NOT NULL,
[Strike] [varchar] (24) NOT NULL,
[ValPrice] [varchar] (24) NOT NULL,
[LongPositionVol] [varchar] (19) NOT NULL,
[ShortPositionVol] [varchar] (19) NOT NULL,
[LongAdjustedVolume] [varchar] (19) NOT NULL,
[ShortAdjustedVolume] [varchar] (19) NOT NULL,
[LongNonMargVol] [varchar] (19) NOT NULL,
[ShortNonMargVol] [varchar] (19) NOT NULL,
[LongAdjustedNonMarginableVolume] [varchar] (19) NOT NULL,
[ShortAdjustedNonMarginableVolume] [varchar] (19) NOT NULL,
[ProfitLoss] [varchar] (24) NOT NULL,
[LongContractsTraded] [varchar] (19) NOT NULL,
[ShortContractsTraded] [varchar] (19) NOT NULL,
[LongTradedVol] [varchar] (19) NOT NULL,
[ShortTradedVol] [varchar] (19) NOT NULL,
[LongResultAssignment] [varchar] (19) NOT NULL,
[ShortResultAssignment] [varchar] (19) NOT NULL,
[LongResultExercise] [varchar] (19) NOT NULL,
[ShortResultExercise] [varchar] (19) NOT NULL,
[ContingentPrice] [varchar] (24) NOT NULL,
[ContingentMargin] [varchar] (24) NOT NULL,
[Premium] [varchar] (24) NOT NULL,
[ManExeVolume] [varchar] (19) NOT NULL,
[AutoExeVolume] [varchar] (19) NOT NULL,
[ManDelVolume] [varchar] (19) NOT NULL,
[AutoDelVolume] [varchar] (19) NOT NULL,
[ManualStl] [varchar] (19) NOT NULL,
[AutoSettleOpen] [varchar] (100) NOT NULL,
[ExpLongVolume] [varchar] (19) NOT NULL,
[ExpShortVolume] [varchar] (19) NOT NULL,
[LongTransIn] [varchar] (19) NOT NULL,
[LongTransOut] [varchar] (19) NOT NULL,
[ShortTransIn] [varchar] (19) NOT NULL,
[ShortTransOut] [varchar] (19) NOT NULL,
[AssignedVol] [varchar] (19) NOT NULL,
[LotSize] [varchar] (19) NOT NULL,
[RemClearer] [varchar] (4) NOT NULL,
[PositionType] [varchar] (1) NOT NULL,
[OptionAbandon] [varchar] (100) NOT NULL,
[Currency] [varchar] (3) NOT NULL,
[NetLiquidating] [varchar] (24) NOT NULL,
[CabinetTradeValue] [varchar] (24) NOT NULL,
[ReportTime] [varchar] (19) NOT NULL,
[FileName] [varchar] (512) NOT NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_Liffe_Position_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_Liffe_Position_CreateDate] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_Liffe_Position] on [dbo].[Liffe_Position]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[Liffe_Position] ADD CONSTRAINT [PK_Liffe_Position] PRIMARY KEY CLUSTERED  ([Liffe_PositionId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_Liffe_Position_Filename] on [dbo].[Liffe_Position]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_Liffe_Position_Filename] ON [dbo].[Liffe_Position] ([FileName]) INCLUDE ([CreateDate], [Liffe_PositionId])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[Liffe_Notification]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[Liffe_Notification]
(
[Liffe_NotificationId] [int] NOT NULL IDENTITY(1, 1),
[RowId] [varchar] (19) NOT NULL,
[System] [varchar] (7) NOT NULL,
[Version] [varchar] (3) NULL,
[RecType] [varchar] (3) NOT NULL,
[Exchange] [varchar] (1) NOT NULL,
[ExchangeMnemonic] [varchar] (5) NOT NULL,
[TradingDate] [varchar] (10) NOT NULL,
[TDD] [varchar] (19) NOT NULL,
[NewTDD] [varchar] (19) NOT NULL,
[TradingDayTrade] [varchar] (19) NOT NULL,
[OrgClearer] [varchar] (3) NOT NULL,
[OrgMember] [varchar] (3) NOT NULL,
[OrgTrader] [varchar] (3) NOT NULL,
[Account] [varchar] (25) NOT NULL,
[PMA] [varchar] (25) NULL,
[MarginAccount] [varchar] (1) NOT NULL,
[ChargeInd] [varchar] (1) NOT NULL,
[LongShort] [varchar] (1) NOT NULL,
[Commodity] [varchar] (3) NOT NULL,
[LogCommodity] [varchar] (3) NOT NULL,
[ContractType] [varchar] (1) NOT NULL,
[GenContractType] [varchar] (1) NOT NULL,
[ExpiryMonth] [varchar] (5) NOT NULL,
[LongExpiryDate] [varchar] (10) NOT NULL,
[Strike] [varchar] (24) NOT NULL,
[NotificationSlipType] [varchar] (1) NOT NULL,
[ClearingSlipId] [varchar] (19) NOT NULL,
[VolumeToAdjust] [varchar] (100) NOT NULL,
[ValPrice] [varchar] (24) NOT NULL,
[CptyMember] [varchar] (3) NOT NULL,
[CptyTrader] [varchar] (3) NOT NULL,
[MatchedTime] [varchar] (19) NOT NULL,
[TRSOperator] [varchar] (50) NOT NULL,
[UserSpecifiedData] [varchar] (100) NOT NULL,
[CounternoteSlipNumber] [varchar] (19) NOT NULL,
[ClosingTradeSlipNumber] [varchar] (19) NOT NULL,
[ClosingTradeSubNumber] [varchar] (19) NOT NULL,
[ClosingTradeVolume] [varchar] (100) NOT NULL,
[AllLotsIndicator] [varchar] (1) NOT NULL,
[NotificationSource] [varchar] (1) NOT NULL,
[NotificationStatus] [varchar] (2) NOT NULL,
[LotSize] [varchar] (19) NOT NULL,
[PositionType] [varchar] (1) NOT NULL,
[TradingDayNotificationProcessing] [varchar] (19) NOT NULL,
[EnteredDate] [varchar] (10) NOT NULL,
[ModifiedTime] [varchar] (8) NOT NULL,
[PositionMaintenanceId] [varchar] (100) NOT NULL,
[ReportTime] [varchar] (19) NOT NULL,
[FileName] [varchar] (512) NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_Liffe_Notification_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_Liffe_Notification_CreateDate] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_Liffe_Notification] on [dbo].[Liffe_Notification]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[Liffe_Notification] ADD CONSTRAINT [PK_Liffe_Notification] PRIMARY KEY CLUSTERED  ([Liffe_NotificationId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_Liffe_Notification_Filename] on [dbo].[Liffe_Notification]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_Liffe_Notification_Filename] ON [dbo].[Liffe_Notification] ([FileName]) INCLUDE ([CreateDate], [Liffe_NotificationId])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[LCH_TypeTR]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[LCH_TypeTR]
(
[LIFFE_TRID] [int] NOT NULL IDENTITY(1, 1),
[Exchange] [varchar] (3) NULL,
[SequenceNumber] [varchar] (5) NULL,
[DownloadNumber] [varchar] (10) NULL,
[RecordType] [varchar] (10) NULL,
[ClearingSlipID] [varchar] (10) NULL,
[SubTradeSequenceNumber] [varchar] (3) NULL,
[ClearingSlipType] [varchar] (1) NULL,
[TradeType] [varchar] (1) NULL,
[CrossType] [varchar] (1) NULL,
[HalfTradeStatus] [varchar] (2) NULL,
[TraderCardReference] [varchar] (16) NULL,
[OriginatingTraderName] [varchar] (3) NULL,
[OriginatingMemberName] [varchar] (3) NULL,
[OriginatingClearerName] [varchar] (3) NULL,
[CounterPartyTraderName] [varchar] (3) NULL,
[CounterpartyMemberName] [varchar] (3) NULL,
[BuyorSell] [varchar] (1) NULL,
[ContractType] [varchar] (1) NULL,
[GenericContractType] [varchar] (1) NULL,
[PhysicalCommodity] [varchar] (3) NULL,
[LogicalCommodity] [varchar] (3) NULL,
[DeliveryMonth] [varchar] (1) NULL,
[LongExpiryDate] [varchar] (8) NULL,
[ExercisePrice] [varchar] (9) NULL,
[Price] [varchar] (9) NULL,
[Volume] [varchar] (6) NULL,
[TradeChargeIndicator] [varchar] (1) NULL,
[AccountCode] [varchar] (1) NULL,
[AllocationTraderName] [varchar] (3) NULL,
[AllocationMemberName] [varchar] (3) NULL,
[OpenorClose] [varchar] (1) NULL,
[DateEntered] [varchar] (8) NULL,
[TimeEntered] [varchar] (6) NULL,
[TimeTraded] [varchar] (6) NULL,
[TimeLastModified] [varchar] (6) NULL,
[TimeAssignment] [varchar] (6) NULL,
[TimeMatched] [varchar] (6) NULL,
[OperatorReference] [varchar] (12) NULL,
[UserSpecifiedData] [varchar] (14) NULL,
[MarginingAccount] [varchar] (1) NULL,
[TradingDay] [varchar] (6) NULL,
[OrderSlipID] [varchar] (8) NULL,
[CustomerTypeIndicator] [varchar] (1) NULL,
[TimeBracket] [varchar] (2) NULL,
[TradingEnvironment] [varchar] (1) NULL,
[CountertradeSlipNumber] [varchar] (10) NULL,
[CountertradeSubNumber] [varchar] (3) NULL,
[CounterclaimSlipNumber] [varchar] (10) NULL,
[SubAccount] [varchar] (4) NULL,
[TransferIndicator] [varchar] (1) NULL,
[CalandarDayOffset] [varchar] (2) NULL,
[OtisFba] [varchar] (3) NULL,
[ConnectStrategyCode] [varchar] (1) NULL,
[DesignatedAccount] [varchar] (1) NULL,
[PostingCode] [int] NULL,
[SessionId] [int] NULL,
[TradeClipId] [varchar] (10) NULL,
[CustomerReference] [varchar] (14) NULL,
[ConnectOrderId] [varchar] (20) NULL,
[Aggresor] [varchar] (1) NULL,
[ActionFlag] [varchar] (1) NULL,
[FileName] [varchar] (512) NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_LCH_TypeTR_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_LIFFE_TypeTR_CreationDate] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_LIFFE_TypeTR] on [dbo].[LCH_TypeTR]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[LCH_TypeTR] ADD CONSTRAINT [PK_LIFFE_TypeTR] PRIMARY KEY CLUSTERED  ([LIFFE_TRID])
');

GO
EXECUTE ('PRINT N''Creating index [IX_LCH_TypeTR_FileName] on [dbo].[LCH_TypeTR]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_LCH_TypeTR_FileName] ON [dbo].[LCH_TypeTR] ([LIFFE_TRID], [FileName]) INCLUDE ([CreateDate])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[LCH_TypePS_0101]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[LCH_TypePS_0101]
(
[LCH_TypePS_0101_ID] [int] NOT NULL IDENTITY(1, 1),
[Exchange] [varchar] (3) NULL,
[DownloadNumber] [varchar] (4) NULL,
[TradingDay] [varchar] (6) NULL,
[TenderDeletionDay] [varchar] (6) NULL,
[OriginatingClearerName] [varchar] (3) NULL,
[OriginatingMemberName] [varchar] (3) NULL,
[OriginatingTraderName] [varchar] (3) NULL,
[AccountCode] [varchar] (1) NULL,
[MarginingAccount] [varchar] (1) NULL,
[PhysicalCommodity] [varchar] (3) NULL,
[LogicalCommodity] [varchar] (3) NULL,
[ContractType] [varchar] (1) NULL,
[GenericContractType] [varchar] (1) NULL,
[LongExpiryDate] [varchar] (8) NULL,
[ExercisePrice] [varchar] (9) NULL,
[ValuationPrice] [varchar] (9) NULL,
[LongAccountVolume] [varchar] (11) NULL,
[ShortAccountVolume] [varchar] (11) NULL,
[LongAdjustedVolume] [varchar] (11) NULL,
[ShortAdjustedVolume] [varchar] (11) NULL,
[LongNonMarginableVolume] [varchar] (11) NULL,
[ShortNonMarginableVolume] [varchar] (11) NULL,
[LongAdjustedNonMarginableVolume] [varchar] (11) NULL,
[ShortAdjustedNonMarginalVolume] [varchar] (11) NULL,
[PayCollect] [varchar] (15) NULL,
[LongContractsTraded] [varchar] (7) NULL,
[ShortContractsTraded] [varchar] (7) NULL,
[LongLotsTraded] [varchar] (7) NULL,
[ShortLotsTraded] [varchar] (7) NULL,
[ContingentMargin] [varchar] (15) NULL,
[PremiumPayCollect] [varchar] (15) NULL,
[ContigentPrice] [varchar] (9) NULL,
[ManuallyExercisedLots] [varchar] (7) NULL,
[AutoExercisedLots] [varchar] (7) NULL,
[ManuallyDeliveredLots] [varchar] (7) NULL,
[AutoDeliveredLots] [varchar] (7) NULL,
[ManuallySettledLots] [varchar] (7) NULL,
[AutoSettledLots] [varchar] (7) NULL,
[LongExpiredLots] [varchar] (7) NULL,
[ShortExpiredLots] [varchar] (7) NULL,
[LongTransferredIn] [varchar] (7) NULL,
[LongTransferredOut] [varchar] (7) NULL,
[ShortTransferredIn] [varchar] (7) NULL,
[ShortTransferredOut] [varchar] (7) NULL,
[AssignedLots] [varchar] (7) NULL,
[LotsSize] [varchar] (5) NULL,
[PositionType] [varchar] (1) NULL,
[FileName] [varchar] (512) NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_LCH_TypePS_0101_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_LCH_TypePS_0101_CreationDate] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_LCH_TypePS_0101] on [dbo].[LCH_TypePS_0101]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[LCH_TypePS_0101] ADD CONSTRAINT [PK_LCH_TypePS_0101] PRIMARY KEY CLUSTERED  ([LCH_TypePS_0101_ID])
');

GO
EXECUTE ('PRINT N''Creating index [IX_LCH_TypePS_010_FileName] on [dbo].[LCH_TypePS_0101]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_LCH_TypePS_010_FileName] ON [dbo].[LCH_TypePS_0101] ([LCH_TypePS_0101_ID], [FileName]) INCLUDE ([CreateDate])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ICE_TrdCaptRpt]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ICE_TrdCaptRpt]
(
[ICE_TrdCaptRptID] [int] NOT NULL IDENTITY(1, 1),
[AsOfInd] [nvarchar] (1) NULL,
[AvgPx] [nvarchar] (9) NULL,
[AvgPxInd] [nvarchar] (1) NULL,
[BizDt] [nvarchar] (10) NULL,
[Currency] [nvarchar] (3) NULL,
[CopyMsgInd] [nvarchar] (1) NULL,
[LastPx] [decimal] (24, 10) NULL,
[LastQty] [int] NULL,
[MtchStat] [nvarchar] (1) NULL,
[ExecType] [nvarchar] (1) NULL,
[TradeDate] [nvarchar] (11) NULL,
[TradeId] [bigint] NULL,
[TradeReportType] [int] NULL,
[VenueType] [nvarchar] (1) NULL,
[TradeSubType] [tinyint] NULL,
[TradeType] [tinyint] NULL,
[TrdTyp2] [tinyint] NULL,
[TrxTime] [nvarchar] (24) NULL,
[ExecId] [nvarchar] (16) NULL,
[TransferReason] [nvarchar] (4) NULL,
[OrigTradeId] [bigint] NULL,
[InstrExchange] [nvarchar] (25) NULL,
[InstrumentType] [nvarchar] (100) NULL,
[CommodityId] [nvarchar] (3) NULL,
[MaturityMonthYear] [nvarchar] (8) NULL,
[PutCall] [bit] NULL,
[StrikePrice] [decimal] (19, 4) NULL,
[SideBuySellFlag] [tinyint] NULL,
[ClearingHouse] [nvarchar] (4) NULL,
[Exchange] [nvarchar] (4) NULL,
[TradingMember] [nvarchar] (3) NULL,
[Trader] [nvarchar] (4) NULL,
[ClearingMember] [nvarchar] (3) NULL,
[OppTradingMember] [nvarchar] (3) NULL,
[OppTrader] [nvarchar] (4) NULL,
[CustomerAccount] [nvarchar] (14) NULL,
[PositionAccount] [nvarchar] (1) NULL,
[SettlementAccount] [int] NULL,
[AllocationQty] [int] NULL,
[AllocationExchange] [nvarchar] (4) NULL,
[AllocationClearingHouse] [nvarchar] (4) NULL,
[AllocTradingMember] [nvarchar] (3) NULL,
[AllocationTrader] [nvarchar] (4) NULL,
[FileName] [nvarchar] (512) NOT NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_ICE_TrdCaptRpt_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_ICE_TrdCaptRpt_CreateDate] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_ICE_TrdCaptRpt] on [dbo].[ICE_TrdCaptRpt]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ICE_TrdCaptRpt] ADD CONSTRAINT [PK_ICE_TrdCaptRpt] PRIMARY KEY CLUSTERED  ([ICE_TrdCaptRptID])
');

GO
EXECUTE ('PRINT N''Creating index [IX_ICE_TrdCaptRpt_LoadState_FileName] on [dbo].[ICE_TrdCaptRpt]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_ICE_TrdCaptRpt_LoadState_FileName] ON [dbo].[ICE_TrdCaptRpt] ([LoadState], [FileName])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ICE_PosRpt]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ICE_PosRpt]
(
[ICE_PosRptID] [int] NOT NULL IDENTITY(1, 1),
[BizDt] [nvarchar] (10) NULL,
[SettlementPrice] [decimal] (24, 10) NULL,
[SettPriceType] [nvarchar] (1) NULL,
[ContingentPrice] [decimal] (24, 10) NULL,
[SettlementCurrency] [nvarchar] (3) NULL,
[InstrumentType] [nvarchar] (100) NULL,
[PutCall] [bit] NULL,
[InstrExchange] [nvarchar] (25) NULL,
[CommodityId] [nvarchar] (3) NULL,
[MaturityMonthYear] [nvarchar] (8) NULL,
[StrikePrice] [decimal] (19, 4) NULL,
[FactorLotSize] [decimal] (19, 4) NULL,
[PosQtyType] [nvarchar] (3) NULL,
[QtyLong] [int] NULL,
[QtyShort] [int] NULL,
[VolLongNonMargin] [int] NULL,
[VolShortNonMargin] [int] NULL,
[TradedLongLots] [int] NULL,
[TradedShortLots] [int] NULL,
[QtySettlementLong] [int] NULL,
[QtySettlementShort] [int] NULL,
[QtyTransferInLong] [int] NULL,
[QtyTransferInShort] [int] NULL,
[QtyTransferOutLong] [int] NULL,
[QtyTransferOutShort] [int] NULL,
[QtyDeliveryIssuedLong] [int] NULL,
[QtyDeliveryIssuedShort] [int] NULL,
[QtyStoppedLong] [int] NULL,
[QtyStoppedShort] [int] NULL,
[QtyOptionExercLong] [int] NULL,
[QtyOptionExercShort] [int] NULL,
[QtyOptionsAssignLong] [int] NULL,
[QtyOptionsAssignShort] [int] NULL,
[QtyExpOptionLong] [int] NULL,
[QtyExpOptionShort] [int] NULL,
[PayCollectAmt] [decimal] (19, 10) NULL,
[PayCollectCcy] [nvarchar] (3) NULL,
[PremPayCollectAmt] [decimal] (19, 10) NULL,
[PremPayCollectCcy] [nvarchar] (3) NULL,
[FCBAAmt] [decimal] (19, 10) NULL,
[FCBACcy] [nvarchar] (3) NULL,
[ContingentMarginAmt] [decimal] (19, 10) NULL,
[ContingentMarginCcy] [nvarchar] (3) NULL,
[TradingMember] [nvarchar] (3) NULL,
[ClearingFirm] [nvarchar] (3) NULL,
[ClearingMember] [nvarchar] (3) NULL,
[ClearingHouse] [nvarchar] (4) NULL,
[Exchange] [nvarchar] (4) NULL,
[PositionAccount] [nvarchar] (1) NULL,
[MarginingAccount] [int] NULL,
[FileName] [nvarchar] (512) NOT NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_ICE_PosRpt_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_ICE_PosRpt_CreateDate] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_ICE_PosRpt] on [dbo].[ICE_PosRpt]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ICE_PosRpt] ADD CONSTRAINT [PK_ICE_PosRpt] PRIMARY KEY CLUSTERED  ([ICE_PosRptID])
');

GO
EXECUTE ('PRINT N''Creating index [IX_ICE_PosRpt_LoadState_Filename] on [dbo].[ICE_PosRpt]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_ICE_PosRpt_LoadState_Filename] ON [dbo].[ICE_PosRpt] ([LoadState], [FileName])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ICE_AsgnRpt]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ICE_AsgnRpt]
(
[ICE_AsgnRptID] [int] NOT NULL IDENTITY(1, 1),
[BizDt] [nvarchar] (10) NULL,
[SettlementPrice] [decimal] (24, 10) NULL,
[SettlementCurrency] [nvarchar] (3) NULL,
[InstrumentType] [nvarchar] (100) NULL,
[PutCall] [bit] NULL,
[InstrExchange] [nvarchar] (25) NULL,
[CommodityId] [nvarchar] (3) NULL,
[MaturityMonthYear] [nvarchar] (8) NULL,
[StrikePrice] [decimal] (19, 4) NULL,
[FactorLotSize] [decimal] (19, 4) NULL,
[PosQtyType] [nvarchar] (3) NULL,
[QtyLong] [int] NULL,
[QtyShort] [int] NULL,
[QtyDate] [nvarchar] (10) NULL,
[ClearingHouse] [nvarchar] (4) NULL,
[Exchange] [nvarchar] (4) NULL,
[TradingMember] [nvarchar] (3) NULL,
[Trader] [nvarchar] (4) NULL,
[ClearingMember] [nvarchar] (3) NULL,
[UserAccountInfo] [nvarchar] (14) NULL,
[PositionAccount] [nvarchar] (1) NULL,
[MarginingAccount] [int] NULL,
[FileName] [nvarchar] (512) NOT NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_ICE_AsgnRpt_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_ICE_AsgnRpt_CreateDate] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_ICE_AsgnRpt] on [dbo].[ICE_AsgnRpt]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ICE_AsgnRpt] ADD CONSTRAINT [PK_ICE_AsgnRpt] PRIMARY KEY CLUSTERED  ([ICE_AsgnRptID])
');

GO
EXECUTE ('PRINT N''Creating index [IX_ICE_AsgnRpt_LoadState_Filename_PosQtyType] on [dbo].[ICE_AsgnRpt]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_ICE_AsgnRpt_LoadState_Filename_PosQtyType] ON [dbo].[ICE_AsgnRpt] ([LoadState], [FileName], [PosQtyType])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Price_Delete_ForFile]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Price_Delete_ForFile]
	@DataSourceId INT
	, @FileName VARCHAR(512)
AS
SET NOCOUNT ON
	--	03 Aug 2010		amk		Creation (extracted from file rollback stored proc)

	-- Delete Prices (cascade NULL to ib_PriceReportSummary) 
	DELETE prs 	
	FROM [dbo].[ib_PriceReportSummary] prs
		INNER JOIN ib_Price pr ON pr.PriceId = prs.External_PriceId
		INNER JOIN [dbo].[ib_ImportFile] [if] ON pr.ImportFileId = [if].ImportFileId
	WHERE [if].DataSourceId = @DataSourceId 
		AND [if].[Filename] = @FileName

	DELETE prs
	FROM [dbo].[ib_PriceReportSummary] prs
		INNER JOIN ib_Price pr ON pr.PriceId = prs.Internal_PriceId
		INNER JOIN [dbo].[ib_ImportFile] [if] ON pr.ImportFileId = [if].ImportFileId
	WHERE [if].DataSourceId = @DataSourceId 
		AND [if].[Filename] = @FileName

	-- Delete adjustments and adjustments headers, too
	DELETE adj
	FROM [dbo].[ib_Adjustment] adj
		INNER JOIN [dbo].ib_AdjustmentHeader adjh 
			ON adjh.AdjustmentHeaderId = adj.AdjustmentHeaderId
		INNER JOIN [dbo].ib_Price pr ON pr.PriceId = adjh.PriceId
		INNER JOIN [dbo].[ib_ImportFile] [if] ON pr.ImportFileId = [if].ImportFileId
	WHERE [if].DataSourceId = @DataSourceId 
		AND [if].[Filename] = @FileName
	
	DELETE adjh 
	FROM [dbo].ib_AdjustmentHeader adjh
		INNER JOIN [dbo].ib_Price pr ON pr.PriceId = adjh.PriceId
		INNER JOIN [dbo].[ib_ImportFile] [if] ON pr.ImportFileId = [if].ImportFileId
	WHERE [if].DataSourceId = @DataSourceId 
		AND [if].[Filename] = @FileName
	
	DELETE pr
	FROM [dbo].[ib_Price] pr
		INNER JOIN [dbo].[ib_ImportFile] [if] ON pr.ImportFileId = [if].ImportFileId
	WHERE [if].DataSourceId = @DataSourceId 
		AND [if].[Filename] = @FileName
');

GO
EXECUTE ('PRINT N''Creating [dbo].[_ib_Adjustment_DeleteWithNotes]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[_ib_Adjustment_DeleteWithNotes]
	@AdjustmentId INT
AS
SET NOCOUNT ON
	-- delete adjustment

	-- 03 Jun 2010		ED		Created
	-- 06 Aug 2010		amk		MBAL-16420: delete header if it''s last adj record being deleted

BEGIN TRY
	BEGIN TRAN
	--break link
	UPDATE ib_TradeReconciliationDetail 
	SET AdjustmentId = NULL 
	WHERE AdjustmentId = @AdjustmentId

	DECLARE @Notes VARCHAR(255)
	SET @Notes = ''Matched partner deleted ( rollback , '' 
		+ CONVERT(CHAR(10), CURRENT_TIMESTAMP, 103)
		+ '' '' + CONVERT(CHAR(5), CURRENT_TIMESTAMP, 114) + '') ''

	UPDATE ib_Adjustment
	SET MatchingAdjustmentId = NULL,
		AdjustmentStatusId = NULL,
		Description = @Notes + Description
	WHERE MatchingAdjustmentId = @AdjustmentId

	DELETE 
	FROM ib_Adjustment 
	WHERE AdjustmentId = @AdjustmentId

	DELETE
	FROM ib_AdjustmentHeader
	WHERE NOT EXISTS (SELECT * 
						FROM ib_Adjustment a 
						WHERE a.AdjustmentHeaderId = ib_AdjustmentHeader.AdjustmentHeaderId)

	COMMIT TRAN
END TRY
BEGIN CATCH
	ROLLBACK TRAN
	EXEC [dbo].[sp_RethrowError]
END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Adjustment_Delete_AsOf]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Adjustment_Delete_AsOf]
	@AsOfDate DATETIME
	, @DataSourceId INT
AS
SET NOCOUNT ON
BEGIN
	--	03 Aug 2010		amk		Creation (extracted from file rollback stored proc)
	--							MBAL-16346: delete CQ''s too
	--							MBAL-16346: don''t unmatch T - 1 data
	--	05 Aug 2010		amk		MBAL-16394: delete all adjustments not just certain types
	--	17 Jan 2011		amk		MBAL-17219: only rollback adjustments for selected templates
	--  21 Jul 2014		ED		EIB 25826 - logic for UM rollback

	--DECREASE AsOfDate
	DECLARE @PreviousAsOfDate DATETIME
	SET @PreviousAsOfDate = dbo.GetPreviousBusinessDay(@AsOfDate)

	--get list of templates
	SELECT DISTINCT t.TemplateId
	INTO #templates
	FROM ib_Template t
		JOIN ib_TemplateCompare tc ON tc.TemplateId = t.TemplateId
	WHERE TypeCode = ''Imbalance Report''
		AND tc.DataSourceId = @DataSourceId

	--fix any rolled over adjustments
	UPDATE t 
	SET MatchingAdjustmentId = NULL
	FROM ib_Trx t
		JOIN ib_Adjustment a ON a.AdjustmentId = t.MatchingAdjustmentId
	WHERE t.MatchingAdjustmentId IS NOT NULL 
		AND t.AsOfDate >= @AsOfDate
		AND a.TemplateId IN (SELECT TemplateId FROM #templates)
	
	UPDATE a 
	SET a.AdjustmentStatusId = NULL
	FROM ib_Adjustment a
		INNER JOIN ib_AdjustmentStatus [as] 
			ON [as].AdjustmentStatusId = a.AdjustmentStatusId 
				AND a.AdjustmentDate = @PreviousAsOfDate 
				AND ([as].Code = ''R'')
	WHERE a.TemplateId IN (SELECT TemplateId FROM #templates)

	--set replaces adj id to null, so it will not affect delete
	UPDATE ib_Adjustment
	SET ReplacesAdjustmentId = NULL
	WHERE ReplacesAdjustmentId IN (SELECT a.AdjustmentId 
				FROM ib_Adjustment a (NOLOCK)
					INNER JOIN ib_AdjustmentHeader ah ON ah.AdjustmentHeaderId = a.AdjustmentHeaderId
					INNER JOIN ib_AdjustmentType [at] ON [at].AdjustmentTypeId = ah.AdjustmentTypeId
				WHERE [a].AdjustmentDate >= @AsOfDate 
				)
		AND TemplateId IN (SELECT TemplateId FROM #templates)
	
	DECLARE @AdjustmentId INT
	
	DECLARE adjDelete_cursor CURSOR FOR
	SELECT a.AdjustmentId 
	FROM ib_Adjustment a (NOLOCK)
		INNER JOIN ib_AdjustmentHeader ah ON ah.AdjustmentHeaderId = a.AdjustmentHeaderId
		INNER JOIN ib_AdjustmentType [at] ON [at].AdjustmentTypeId = ah.AdjustmentTypeId
		LEFT JOIN ib_trx t ON t.MatchingAdjustmentId = a.AdjustmentId AND t.IsUnmatched = 1
	WHERE a.AdjustmentDate >= @AsOfDate 
		AND a.TemplateId IN (SELECT TemplateId FROM #templates)
		AND t.TrxId IS NULL

	OPEN adjDelete_cursor

	FETCH NEXT FROM adjDelete_cursor
	INTO @AdjustmentId
	WHILE @@FETCH_STATUS = 0
	BEGIN
		EXEC _ib_Adjustment_DeleteWithNotes @AdjustmentId
		FETCH NEXT FROM adjDelete_cursor
		INTO @AdjustmentId
	END
	
	CLOSE adjDelete_cursor
	DEALLOCATE adjDelete_cursor
	
	DROP TABLE #templates
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[HKFE_TP001_Type02]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[HKFE_TP001_Type02]
(
[RecordType02_Id] [int] NOT NULL IDENTITY(1, 1),
[RecordType] [varchar] (2) NULL,
[ParticipantCode] [varchar] (5) NULL,
[AccountID] [varchar] (50) NULL,
[SeriesName] [varchar] (15) NULL,
[TradeNumber] [varchar] (50) NULL,
[OrigTradeNumber] [varchar] (50) NULL,
[TradeAccount] [varchar] (10) NULL,
[Movement] [varchar] (15) NULL,
[BuySell] [varchar] (1) NULL,
[OpenClose] [varchar] (1) NULL,
[Long] [varchar] (8) NULL,
[Short] [varchar] (8) NULL,
[TradePrice] [varchar] (12) NULL,
[Premium] [varchar] (15) NULL,
[VariationAdjustment] [varchar] (19) NULL,
[Market] [varchar] (5) NULL,
[Currency] [varchar] (3) NULL,
[BusinessDate] [datetime] NULL,
[FileName] [varchar] (512) NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_HKFE_Type02_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_HKFE_Type02_CreateDate] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_HKFE_Type02] on [dbo].[HKFE_TP001_Type02]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[HKFE_TP001_Type02] ADD CONSTRAINT [PK_HKFE_Type02] PRIMARY KEY CLUSTERED  ([RecordType02_Id])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[HKFE_TP001_Type01]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[HKFE_TP001_Type01]
(
[RecordType01_Id] [int] NOT NULL IDENTITY(1, 1),
[RecordType] [varchar] (2) NULL,
[ParticipantCode] [varchar] (5) NULL,
[AccountID] [varchar] (50) NULL,
[SeriesName] [varchar] (15) NULL,
[ParticipantName] [varchar] (32) NULL,
[Market] [varchar] (5) NULL,
[MarketName] [varchar] (32) NULL,
[Underlying] [varchar] (6) NULL,
[UnderlyingName] [varchar] (32) NULL,
[Currency] [varchar] (3) NULL,
[PrevPositionLong] [varchar] (8) NULL,
[PrevPositionShort] [varchar] (8) NULL,
[PrevSettlementPrice] [varchar] (12) NULL,
[PrevVariationAdjustment] [varchar] (19) NULL,
[CurrentPositionLong] [varchar] (8) NULL,
[CurrentPositionShort] [varchar] (8) NULL,
[CurrentSettlementPrice] [varchar] (12) NULL,
[BusinessDate] [datetime] NULL,
[FileName] [varchar] (512) NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_HKFE_Type01_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_HKFE_Type01_CreateDate] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_HKFE_Type01] on [dbo].[HKFE_TP001_Type01]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[HKFE_TP001_Type01] ADD CONSTRAINT [PK_HKFE_Type01] PRIMARY KEY CLUSTERED  ([RecordType01_Id])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[GMI_EXTF1]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[GMI_EXTF1]
(
[GMI_EXTF1ID] [int] NOT NULL IDENTITY(1, 1),
[RecordType] [varchar] (1) NOT NULL,
[TransactionType] [varchar] (1) NOT NULL,
[Tracer] [varchar] (10) NOT NULL,
[GmiFirmIdent] [varchar] (1) NOT NULL,
[OfficeIdent] [varchar] (3) NOT NULL,
[AccountIdent] [varchar] (5) NOT NULL,
[Exchange] [varchar] (2) NOT NULL,
[FuturesCodeSymbolCusip] [varchar] (6) NOT NULL,
[PutCallCode] [varchar] (1) NOT NULL,
[StrikeOrCusip] [varchar] (17) NOT NULL,
[SecurityType] [varchar] (1) NOT NULL,
[ContractYearMonth] [varchar] (6) NOT NULL,
[ContractDay] [varchar] (2) NOT NULL,
[TradeDate] [varchar] (8) NOT NULL,
[InputTradePrice] [decimal] (19, 8) NOT NULL,
[BuySell] [varchar] (1) NOT NULL,
[Quantity] [decimal] (19, 4) NOT NULL,
[Spread] [varchar] (1) NOT NULL,
[OpenCloseCode] [varchar] (1) NOT NULL,
[SettlementDate] [varchar] (8) NOT NULL,
[CalculationTradePrice] [decimal] (19, 8) NOT NULL,
[PrintableTradePrice] [varchar] (11) NOT NULL,
[Salesman] [varchar] (5) NOT NULL,
[AccountType] [varchar] (2) NOT NULL,
[CommentCode1] [varchar] (1) NOT NULL,
[CommentCode2] [varchar] (1) NOT NULL,
[CommentCode3] [varchar] (1) NOT NULL,
[CurrencySymbol] [varchar] (3) NOT NULL,
[CurrencyCode] [varchar] (2) NOT NULL,
[DeltaFactor] [decimal] (9, 4) NOT NULL,
[InstrumentCode] [varchar] (1) NOT NULL,
[ChargeControlCodeCommissionFees] [varchar] (1) NOT NULL,
[ChargeControlCodePremiumPAndSPrincipal] [varchar] (1) NOT NULL,
[ContractMultiplier] [decimal] (19, 7) NOT NULL,
[LocationCode] [varchar] (1) NOT NULL,
[SubexchangeCode] [varchar] (1) NOT NULL,
[AccountTypeCurrencyCodeSymbol] [varchar] (3) NOT NULL,
[CUSIP2] [varchar] (12) NOT NULL,
[UnusedButCanContainCUSIP] [varchar] (9) NOT NULL,
[ExecutingBroker] [varchar] (5) NOT NULL,
[OpposingBroker] [varchar] (5) NOT NULL,
[OpposingFirm] [varchar] (5) NOT NULL,
[CardNumber] [varchar] (4) NOT NULL,
[OrderNumber] [varchar] (25) NOT NULL,
[ChitNumber] [varchar] (15) NOT NULL,
[ClearingFeeCode] [varchar] (1) NOT NULL,
[ExchangeFeeCode] [varchar] (1) NOT NULL,
[CTICode] [varchar] (1) NOT NULL,
[OrderTypeCode] [varchar] (1) NOT NULL,
[OrderTime] [varchar] (6) NOT NULL,
[TimeBracket] [varchar] (2) NOT NULL,
[TradeTypeCode] [varchar] (1) NOT NULL,
[GiveInGiveOutCode] [varchar] (2) NOT NULL,
[GiveInGiveOutFirm] [varchar] (5) NOT NULL,
[InterExchangeCode] [varchar] (2) NOT NULL,
[InterExchangeFirm] [varchar] (5) NOT NULL,
[ReferredSalesman] [varchar] (5) NOT NULL,
[MarketValueOrOpenTradeEquity] [decimal] (19, 2) NOT NULL,
[PriorMarketValueOrOpenTradeEquity] [decimal] (19, 2) NOT NULL,
[NumericClosingPrice] [decimal] (19, 8) NOT NULL,
[PrintableClosingPrice] [varchar] (11) NOT NULL,
[PriceDate] [varchar] (9) NOT NULL,
[UnderlyingClosingPrice] [decimal] (19, 8) NOT NULL,
[GrossAmount] [decimal] (19, 2) NOT NULL,
[DayQuantity] [decimal] (19, 4) NOT NULL,
[OvernightQuantity] [decimal] (19, 4) NOT NULL,
[ScratchQuantity] [decimal] (19, 4) NOT NULL,
[SpreadQuantity] [decimal] (19, 4) NOT NULL,
[VariationMarginDueOnTrade] [decimal] (19, 2) NOT NULL,
[LastTradeDate] [varchar] (10) NOT NULL,
[FirstNoticeDate] [varchar] (10) NOT NULL,
[ExpirationDate] [varchar] (10) NOT NULL,
[AsOfDate] [datetime] NULL,
[FileName] [varchar] (512) NOT NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_GMI_EXTF1_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_GMI_EXTF1_CreateDate] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_GMI_EXTF1] on [dbo].[GMI_EXTF1]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[GMI_EXTF1] ADD CONSTRAINT [PK_GMI_EXTF1] PRIMARY KEY CLUSTERED  ([GMI_EXTF1ID])
');

GO
EXECUTE ('PRINT N''Creating [stage].[Europower]''
');

GO
EXECUTE ('CREATE TABLE [stage].[Europower]
(
[EuropowerID] [int] NOT NULL IDENTITY(1, 1),
[membClgIdCod] [varchar] (5) NULL,
[membExchIdCod] [varchar] (5) NULL,
[currTypCod] [varchar] (3) NULL,
[accTypGrp] [varchar] (32) NULL,
[prodTypId] [varchar] (4) NULL,
[prodId] [varchar] (4) NULL,
[secuTrdUntNo] [varchar] (20) NULL,
[ticSiz] [varchar] (20) NULL,
[ticVal] [varchar] (20) NULL,
[cntrClasCod] [varchar] (1) NULL,
[cntrExpMthDat] [int] NULL,
[cntrExpYrDat] [int] NULL,
[cntrExerPrc] [decimal] (19, 6) NULL,
[cntrVersNo] [int] NULL,
[lstSetlmtPrc] [varchar] (20) NULL,
[currSetlmtPrc] [varchar] (20) NULL,
[trnIdNo] [varchar] (6) NULL,
[trnIDSfxNo] [int] NULL,
[trnAdjStsCod] [varchar] (1) NULL,
[trnHistAdjInd] [varchar] (1) NULL,
[ordrTypCod] [varchar] (1) NULL,
[ordrCmbTypCod] [varchar] (1) NULL,
[buyCod] [varchar] (1) NULL,
[opnClsCod] [varchar] (1) NULL,
[trdTyp] [varchar] (1) NULL,
[trnLngQty] [int] NULL,
[trnShtQty] [int] NULL,
[netQty] [int] NULL,
[trdMtchPrc] [varchar] (20) NULL,
[mkToMktTick] [varchar] (20) NULL,
[prmVmarAmnt] [varchar] (20) NULL,
[feeByUnt] [varchar] (20) NULL,
[trnFeeAmnt] [varchar] (20) NULL,
[partIDCod] [varchar] (6) NULL,
[trnTyp] [varchar] (3) NULL,
[trnIDSfxNoPnt] [int] NULL,
[custText] [varchar] (36) NULL,
[userOrdrNum] [varchar] (12) NULL,
[text] [varchar] (36) NULL,
[origExchId] [varchar] (4) NULL,
[origTrnId] [varchar] (9) NULL,
[origTrnDat] [datetime] NULL,
[origOrdrNo] [varchar] (12) NULL,
[origTrnTim] [datetime] NULL,
[origTrnDatTim] [datetime] NULL,
[origTrnDatCet] [datetime] NULL,
[origTrnTimCet] [datetime] NULL,
[origTrnDatTimCet] [datetime] NULL,
[membExchIdCodObo] [varchar] (5) NULL,
[sumTrnLngQty] [int] NULL,
[sumTrnShtQty] [int] NULL,
[sumCntrPrmVmarAmnt] [varchar] (20) NULL,
[sumCntrTrnFeeAmnt] [varchar] (20) NULL,
[sumProdPrmVmarAmnt] [varchar] (20) NULL,
[sumProdTrnFeeAmnt] [varchar] (20) NULL,
[sumAcctPrmVmarAmnt] [varchar] (20) NULL,
[sumAccTrnFeeAmnt] [varchar] (20) NULL,
[exchNam] [varchar] (5) NULL,
[envText] [varchar] (1) NULL,
[rptCod] [varchar] (5) NULL,
[rptNam] [varchar] (30) NULL,
[rptFlexKey] [varchar] (14) NULL,
[membId] [varchar] (5) NULL,
[membLglNam] [varchar] (40) NULL,
[rptPrntEffDat] [datetime] NULL,
[rptPrntEffTim] [datetime] NULL,
[rptPrntRunDat] [datetime] NULL,
[FileName] [varchar] (512) NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_Europower_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_Europower_CreateDate] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_Europower] on [stage].[Europower]''
');

GO
EXECUTE ('ALTER TABLE [stage].[Europower] ADD CONSTRAINT [PK_Europower] PRIMARY KEY CLUSTERED  ([EuropowerID])
');

GO
EXECUTE ('PRINT N''Creating index [IX_Europower_FileName] on [stage].[Europower]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_Europower_FileName] ON [stage].[Europower] ([FileName])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[EU_cb010grp]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[EU_cb010grp]
(
[EU_cb010grpID] [int] NOT NULL IDENTITY(1, 1),
[membClgIdCod] [varchar] (5) NULL,
[membExchIdCod] [varchar] (5) NULL,
[currTypCod] [varchar] (3) NULL,
[accTypGrp] [varchar] (32) NULL,
[prodTypId] [varchar] (4) NULL,
[prodId] [varchar] (4) NULL,
[secuTrdUntNo] [varchar] (20) NULL,
[ticSiz] [varchar] (20) NULL,
[ticVal] [varchar] (20) NULL,
[cntrClasCod] [varchar] (1) NULL,
[cntrExpMthDat] [int] NULL,
[cntrExpYrDat] [int] NULL,
[cntrExerPrc] [decimal] (19, 6) NULL,
[cntrVersNo] [int] NULL,
[lstSetlmtPrc] [varchar] (20) NULL,
[currSetlmtPrc] [varchar] (20) NULL,
[trnIdNo] [varchar] (6) NULL,
[trnIDSfxNo] [int] NULL,
[trnAdjStsCod] [varchar] (1) NULL,
[trnHistAdjInd] [varchar] (1) NULL,
[ordrTypCod] [varchar] (1) NULL,
[ordrCmbTypCod] [varchar] (1) NULL,
[buyCod] [varchar] (1) NULL,
[opnClsCod] [varchar] (1) NULL,
[trdTyp] [varchar] (1) NULL,
[trnLngQty] [int] NULL,
[trnShtQty] [int] NULL,
[netQty] [int] NULL,
[trdMtchPrc] [varchar] (20) NULL,
[mkToMktTick] [varchar] (20) NULL,
[prmVmarAmnt] [varchar] (20) NULL,
[feeByUnt] [varchar] (20) NULL,
[trnFeeAmnt] [varchar] (20) NULL,
[partIDCod] [varchar] (6) NULL,
[trnTyp] [varchar] (3) NULL,
[trnIDSfxNoPnt] [int] NULL,
[custText] [varchar] (36) NULL,
[userOrdrNum] [varchar] (12) NULL,
[text] [varchar] (36) NULL,
[origExchId] [varchar] (4) NULL,
[origTrnId] [varchar] (9) NULL,
[origTrnDat] [datetime] NULL,
[origOrdrNo] [varchar] (12) NULL,
[origTrnTim] [datetime] NULL,
[origTrnDatTim] [datetime] NULL,
[origTrnDatCet] [datetime] NULL,
[origTrnTimCet] [datetime] NULL,
[origTrnDatTimCet] [datetime] NULL,
[membExchIdCodObo] [varchar] (5) NULL,
[sumTrnLngQty] [int] NULL,
[sumTrnShtQty] [int] NULL,
[sumCntrPrmVmarAmnt] [varchar] (20) NULL,
[sumCntrTrnFeeAmnt] [varchar] (20) NULL,
[sumProdPrmVmarAmnt] [varchar] (20) NULL,
[sumProdTrnFeeAmnt] [varchar] (20) NULL,
[sumAcctPrmVmarAmnt] [varchar] (20) NULL,
[sumAccTrnFeeAmnt] [varchar] (20) NULL,
[exchNam] [varchar] (5) NULL,
[envText] [varchar] (1) NULL,
[rptCod] [varchar] (5) NULL,
[rptNam] [varchar] (30) NULL,
[rptFlexKey] [varchar] (14) NULL,
[membId] [varchar] (5) NULL,
[membLglNam] [varchar] (40) NULL,
[rptPrntEffDat] [datetime] NULL,
[rptPrntEffTim] [datetime] NULL,
[rptPrntRunDat] [datetime] NULL,
[FileName] [varchar] (512) NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_EU_cb010grp_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_EU_cb010grp_CreateDate] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_EU_cb010grp] on [dbo].[EU_cb010grp]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[EU_cb010grp] ADD CONSTRAINT [PK_EU_cb010grp] PRIMARY KEY CLUSTERED  ([EU_cb010grpID])
');

GO
EXECUTE ('PRINT N''Creating index [IX_EU_cb010grp_FileName] on [dbo].[EU_cb010grp]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_EU_cb010grp_FileName] ON [dbo].[EU_cb010grp] ([FileName])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[DGCX_Transaction]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[DGCX_Transaction]
(
[DGCX_TransactionID] [int] NOT NULL IDENTITY(1, 1),
[TradeNumber] [varchar] (32) NULL,
[TradeStatus] [varchar] (20) NULL,
[InstrumentId] [varchar] (2) NULL,
[InstrumentName] [varchar] (15) NULL,
[ContractCode] [varchar] (64) NULL,
[ExpiryDate] [varchar] (11) NULL,
[StrikePrice] [varchar] (28) NULL,
[OptionType] [varchar] (2) NULL,
[ContractDesc] [varchar] (255) NULL,
[BookType] [varchar] (2) NULL,
[BookTypeName] [varchar] (3) NULL,
[MarketType] [varchar] (50) NULL,
[TradingMemberId] [varchar] (64) NULL,
[UserId] [varchar] (64) NULL,
[BuySellInd] [varchar] (1) NULL,
[TradeQty] [varchar] (16) NULL,
[Price] [varchar] (28) NULL,
[ProClientInst] [varchar] (1) NULL,
[Account] [varchar] (64) NULL,
[ClearingMemberId] [varchar] (64) NULL,
[OpenCloseFlag] [varchar] (5) NULL,
[SpreadPrice] [varchar] (28) NULL,
[CoverUncoverFlag] [varchar] (7) NULL,
[TradedTime] [varchar] (20) NULL,
[OrderNumber] [varchar] (32) NULL,
[UserRemarks] [varchar] (255) NULL,
[FileName] [varchar] (512) NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_DGCX_Transaction_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_DGCX_Transaction_CreateDate] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating index [IX_DGCX_Transaction_Filename] on [dbo].[DGCX_Transaction]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_DGCX_Transaction_Filename] ON [dbo].[DGCX_Transaction] ([FileName]) INCLUDE ([CreateDate], [DGCX_TransactionID])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[DGCX_Position]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[DGCX_Position]
(
[DGCX_PositionID] [int] NOT NULL IDENTITY(1, 1),
[Date] [varchar] (11) NULL,
[ClearingMemberCode] [varchar] (64) NULL,
[TradingMemberCode] [varchar] (64) NULL,
[AccountType] [varchar] (1) NULL,
[ClientCode] [varchar] (64) NULL,
[InstrumentType] [varchar] (15) NULL,
[ContractCode] [varchar] (255) NULL,
[ExpiryDate] [varchar] (11) NULL,
[StrikePrice] [varchar] (28) NULL,
[OptionType] [varchar] (2) NULL,
[BroughtForwardLongQty] [varchar] (12) NULL,
[BroughtForwardLongValue] [varchar] (25) NULL,
[BroughtForwardShortQty] [varchar] (12) NULL,
[BroughtForwardShortValue] [varchar] (25) NULL,
[DayBuyQty] [varchar] (12) NULL,
[DayBuyValue] [varchar] (25) NULL,
[DaySellQty] [varchar] (12) NULL,
[DaySellValue] [varchar] (25) NULL,
[PreDelExAssignLongQty] [varchar] (12) NULL,
[PreDelExAssignLongValue] [varchar] (25) NULL,
[PreDelExAssignShortQty] [varchar] (12) NULL,
[PreDelExAssignShortValue] [varchar] (25) NULL,
[BuyDelMarkedExerQty] [varchar] (12) NULL,
[SellDelMarkedAssignQty] [varchar] (12) NULL,
[PostDelExerAssignLongQty] [varchar] (12) NULL,
[PostDelExerAssignLongValue] [varchar] (25) NULL,
[PostDelExerAssignShortQty] [varchar] (12) NULL,
[PostDelExerAssignShortValue] [varchar] (25) NULL,
[SettlementPrice] [varchar] (12) NULL,
[NetPremium] [varchar] (25) NULL,
[DailyMTMSettlementValue] [varchar] (25) NULL,
[DelMarkedExAssignValue] [varchar] (25) NULL,
[FileName] [varchar] (512) NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_DGCX_Position_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_DGCX_Position_CreateDate] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating index [IX_DGCX_Position_Filename] on [dbo].[DGCX_Position]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_DGCX_Position_Filename] ON [dbo].[DGCX_Position] ([FileName]) INCLUDE ([CreateDate], [DGCX_PositionID])
');

GO
EXECUTE ('PRINT N''Creating [stage].[CME_TrdCaptRpt]''
');

GO
EXECUTE ('CREATE TABLE [stage].[CME_TrdCaptRpt]
(
[CME_TrdCaptRptID] [int] NOT NULL IDENTITY(1, 1),
[AsOfInd] [nvarchar] (1) NULL,
[AvgPx] [nvarchar] (9) NULL,
[AvgPxInd] [nvarchar] (1) NULL,
[BizDt] [nvarchar] (10) NULL,
[CopyMsgInd] [nvarchar] (1) NULL,
[LastPx] [decimal] (24, 10) NULL,
[LastQty] [int] NULL,
[MtchStat] [nvarchar] (1) NULL,
[ExecType] [nvarchar] (1) NULL,
[TradeDate] [nvarchar] (11) NULL,
[TradeId] [bigint] NULL,
[TradeReportType] [int] NULL,
[VenueType] [nvarchar] (1) NULL,
[TradeSubType] [tinyint] NULL,
[TradeType] [tinyint] NULL,
[TrdTyp2] [tinyint] NULL,
[TrxTime] [nvarchar] (25) NULL,
[ExecId] [nvarchar] (35) NULL,
[TransferReason] [nvarchar] (4) NULL,
[OrigTradeId] [varchar] (50) NULL,
[InstrExchange] [nvarchar] (25) NULL,
[InstrumentType] [nvarchar] (100) NULL,
[CommodityId] [nvarchar] (6) NULL,
[MaturityMonthYear] [nvarchar] (8) NULL,
[PutCall] [bit] NULL,
[StrikePrice] [decimal] (19, 6) NULL,
[SideBuySellFlag] [tinyint] NULL,
[ClearingHouse] [nvarchar] (4) NULL,
[Exchange] [nvarchar] (5) NULL,
[TradingMember] [nvarchar] (3) NULL,
[Trader] [nvarchar] (10) NULL,
[ClearingMember] [nvarchar] (3) NULL,
[OppTradingMember] [nvarchar] (3) NULL,
[OppTrader] [nvarchar] (10) NULL,
[CustomerAccount] [nvarchar] (14) NULL,
[PositionAccount] [nvarchar] (5) NULL,
[MarginingAccount] [int] NULL,
[SettlementAccount] [int] NULL,
[SettlementCurrency] [nvarchar] (3) NULL,
[AllocationQty] [int] NULL,
[AllocationExchange] [nvarchar] (4) NULL,
[AllocationClearingHouse] [nvarchar] (4) NULL,
[AllocTradingMember] [nvarchar] (3) NULL,
[AllocationTrader] [nvarchar] (4) NULL,
[FileName] [nvarchar] (512) NOT NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_CME_TrdCaptRpt_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_CME_TrdCaptRpt_CreateDate] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_CME_TrdCaptRpt] on [stage].[CME_TrdCaptRpt]''
');

GO
EXECUTE ('ALTER TABLE [stage].[CME_TrdCaptRpt] ADD CONSTRAINT [PK_CME_TrdCaptRpt] PRIMARY KEY CLUSTERED  ([CME_TrdCaptRptID])
');

GO
EXECUTE ('PRINT N''Creating index [IX_CME_TrdCaptRpt_LoadState_FileName] on [stage].[CME_TrdCaptRpt]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_CME_TrdCaptRpt_LoadState_FileName] ON [stage].[CME_TrdCaptRpt] ([LoadState], [FileName])
');

GO
EXECUTE ('PRINT N''Creating [stage].[CME_PosRpt]''
');

GO
EXECUTE ('CREATE TABLE [stage].[CME_PosRpt]
(
[CME_PosRptID] [int] NOT NULL IDENTITY(1, 1),
[BizDt] [nvarchar] (10) NULL,
[SettlementPrice] [decimal] (24, 10) NULL,
[SettPriceType] [nvarchar] (1) NULL,
[ContingentPrice] [decimal] (24, 10) NULL,
[SettlementCurrency] [nvarchar] (3) NULL,
[InstrumentType] [nvarchar] (100) NULL,
[PutCall] [bit] NULL,
[InstrExchange] [nvarchar] (25) NULL,
[CommodityId] [nvarchar] (6) NULL,
[MaturityMonthYear] [nvarchar] (8) NULL,
[StrikePrice] [decimal] (19, 6) NULL,
[FactorLotSize] [decimal] (19, 6) NULL,
[PosQtyType] [nvarchar] (3) NULL,
[QtyLong] [int] NULL,
[QtyShort] [int] NULL,
[VolLongNonMargin] [int] NULL,
[VolShortNonMargin] [int] NULL,
[TradedLongLots] [int] NULL,
[TradedShortLots] [int] NULL,
[QtySettlementLong] [int] NULL,
[QtySettlementShort] [int] NULL,
[QtyTransferInLong] [int] NULL,
[QtyTransferInShort] [int] NULL,
[QtyTransferOutLong] [int] NULL,
[QtyTransferOutShort] [int] NULL,
[QtyDeliveryIssuedLong] [int] NULL,
[QtyDeliveryIssuedShort] [int] NULL,
[QtyStoppedLong] [int] NULL,
[QtyStoppedShort] [int] NULL,
[QtyOptionExercLong] [int] NULL,
[QtyOptionExercShort] [int] NULL,
[QtyOptionsAssignLong] [int] NULL,
[QtyOptionsAssignShort] [int] NULL,
[QtyExpOptionLong] [int] NULL,
[QtyExpOptionShort] [int] NULL,
[PayCollectAmt] [decimal] (19, 10) NULL,
[PayCollectCcy] [nvarchar] (3) NULL,
[PremPayCollectAmt] [decimal] (19, 10) NULL,
[PremPayCollectCcy] [nvarchar] (3) NULL,
[FCBAAmt] [decimal] (19, 10) NULL,
[FCBACcy] [nvarchar] (3) NULL,
[ContingentMarginAmt] [decimal] (19, 10) NULL,
[ContingentMarginCcy] [nvarchar] (3) NULL,
[TradingMember] [nvarchar] (3) NULL,
[ClearingFirm] [nvarchar] (3) NULL,
[ClearingMember] [nvarchar] (3) NULL,
[ClearingHouse] [nvarchar] (4) NULL,
[Exchange] [nvarchar] (5) NULL,
[PositionAccount] [nvarchar] (5) NULL,
[MarginingAccount] [int] NULL,
[FileName] [nvarchar] (512) NOT NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_CME_PosRpt_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_CME_PosRpt_CreateDate] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_CME_PosRpt] on [stage].[CME_PosRpt]''
');

GO
EXECUTE ('ALTER TABLE [stage].[CME_PosRpt] ADD CONSTRAINT [PK_CME_PosRpt] PRIMARY KEY CLUSTERED  ([CME_PosRptID])
');

GO
EXECUTE ('PRINT N''Creating index [IX_CME_PosRpt_LoadState_Filename] on [stage].[CME_PosRpt]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_CME_PosRpt_LoadState_Filename] ON [stage].[CME_PosRpt] ([LoadState], [FileName])
');

GO
EXECUTE ('PRINT N''Creating [stage].[CME_AsgnRpt]''
');

GO
EXECUTE ('CREATE TABLE [stage].[CME_AsgnRpt]
(
[CME_AsgnRptID] [int] NOT NULL IDENTITY(1, 1),
[BizDt] [nvarchar] (10) NULL,
[SettlementPrice] [decimal] (24, 10) NULL,
[SettlementCurrency] [nvarchar] (3) NULL,
[InstrumentType] [nvarchar] (100) NULL,
[PutCall] [bit] NULL,
[InstrExchange] [nvarchar] (25) NULL,
[CommodityId] [nvarchar] (6) NULL,
[MaturityMonthYear] [nvarchar] (8) NULL,
[StrikePrice] [decimal] (19, 6) NULL,
[FactorLotSize] [decimal] (19, 6) NULL,
[PosQtyType] [nvarchar] (3) NULL,
[QtyLong] [int] NULL,
[QtyShort] [int] NULL,
[QtyDate] [nvarchar] (10) NULL,
[ClearingHouse] [nvarchar] (4) NULL,
[Exchange] [nvarchar] (5) NULL,
[TradingMember] [nvarchar] (3) NULL,
[Trader] [nvarchar] (4) NULL,
[ClearingMember] [nvarchar] (3) NULL,
[UserAccountInfo] [nvarchar] (14) NULL,
[PositionAccount] [nvarchar] (5) NULL,
[MarginingAccount] [int] NULL,
[FileName] [nvarchar] (512) NOT NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_CME_AsgnRpt_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_CME_AsgnRpt_CreateDate] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_CME_AsgnRpt] on [stage].[CME_AsgnRpt]''
');

GO
EXECUTE ('ALTER TABLE [stage].[CME_AsgnRpt] ADD CONSTRAINT [PK_CME_AsgnRpt] PRIMARY KEY CLUSTERED  ([CME_AsgnRptID])
');

GO
EXECUTE ('PRINT N''Creating index [IX_CME_AsgnRpt_LoadState_Filename_PosQtyType] on [stage].[CME_AsgnRpt]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_CME_AsgnRpt_LoadState_Filename_PosQtyType] ON [stage].[CME_AsgnRpt] ([LoadState], [FileName], [PosQtyType])
');

GO
EXECUTE ('PRINT N''Creating [stage].[BmfTrade]''
');

GO
EXECUTE ('CREATE TABLE [stage].[BmfTrade]
(
[BmfTradeId] [int] NOT NULL IDENTITY(1, 1),
[TradeDate] [date] NOT NULL,
[CustomerCode] [varchar] (100) NOT NULL,
[BuySell] [varchar] (1) NOT NULL,
[Contract] [varchar] (3) NOT NULL,
[Market] [varchar] (3) NOT NULL,
[ContractMonth] [varchar] (4) NOT NULL,
[TradePrice] [decimal] (24, 10) NOT NULL,
[Amount] [int] NOT NULL,
[MaturityDate] [date] NOT NULL,
[StrikePrice] [decimal] (24, 10) NOT NULL,
[Filename] [varchar] (512) NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_BMETrade_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_BMETrade_CreateDate] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_BmfTrade] on [stage].[BmfTrade]''
');

GO
EXECUTE ('ALTER TABLE [stage].[BmfTrade] ADD CONSTRAINT [PK_BmfTrade] PRIMARY KEY CLUSTERED  ([BmfTradeId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_BmfTrade_LoadState_Filename] on [stage].[BmfTrade]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_BmfTrade_LoadState_Filename] ON [stage].[BmfTrade] ([LoadState], [Filename])
');

GO
EXECUTE ('PRINT N''Creating [stage].[BmfPositionsRealisedCash]''
');

GO
EXECUTE ('CREATE TABLE [stage].[BmfPositionsRealisedCash]
(
[BmfPositionsRealisedCashId] [int] NOT NULL IDENTITY(1, 1),
[AData] [date] NOT NULL,
[B] [varchar] (100) NULL,
[C] [varchar] (100) NULL,
[DClientCode] [varchar] (100) NOT NULL,
[E] [varchar] (100) NULL,
[FContract] [varchar] (3) NOT NULL,
[G] [varchar] (100) NULL,
[HMaturityMonth] [varchar] (3) NOT NULL,
[I] [varchar] (100) NULL,
[JType] [varchar] (100) NOT NULL,
[K] [varchar] (100) NULL,
[L] [varchar] (100) NULL,
[MAmount] [decimal] (24, 10) NOT NULL,
[N] [varchar] (100) NULL,
[O] [varchar] (100) NULL,
[P] [varchar] (100) NULL,
[Q] [varchar] (100) NULL,
[R] [varchar] (100) NULL,
[S] [varchar] (100) NULL,
[T] [varchar] (100) NULL,
[U] [varchar] (100) NULL,
[V] [varchar] (100) NULL,
[W] [varchar] (100) NULL,
[X] [varchar] (100) NULL,
[Y] [varchar] (100) NULL,
[Z] [varchar] (100) NULL,
[Filename] [varchar] (512) NOT NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF__BmfPositi__LoadS__55B7F9AC] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF__BmfPositi__Creat__56AC1DE5] DEFAULT (getdate()),
[StrikePrice] [decimal] (24, 10) NULL,
[IsCall] [varchar] (1) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_BmfPositionsRealisedCash] on [stage].[BmfPositionsRealisedCash]''
');

GO
EXECUTE ('ALTER TABLE [stage].[BmfPositionsRealisedCash] ADD CONSTRAINT [PK_BmfPositionsRealisedCash] PRIMARY KEY CLUSTERED  ([BmfPositionsRealisedCashId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_BmfPositionsRealisedCash_Filename_CreateDate] on [stage].[BmfPositionsRealisedCash]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_BmfPositionsRealisedCash_Filename_CreateDate] ON [stage].[BmfPositionsRealisedCash] ([Filename]) INCLUDE ([CreateDate])
');

GO
EXECUTE ('PRINT N''Creating index [IX_BmfPositionsRealisedCash_LoadState_Filename] on [stage].[BmfPositionsRealisedCash]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_BmfPositionsRealisedCash_LoadState_Filename] ON [stage].[BmfPositionsRealisedCash] ([LoadState], [Filename])
');

GO
EXECUTE ('PRINT N''Creating [stage].[BmfPosition]''
');

GO
EXECUTE ('CREATE TABLE [stage].[BmfPosition]
(
[BmfPositionId] [int] NOT NULL IDENTITY(1, 1),
[CodeId] [varchar] (100) NULL,
[Agent] [varchar] (100) NULL,
[CustomerCode] [varchar] (100) NOT NULL,
[Client] [varchar] (100) NULL,
[Contract] [varchar] (3) NOT NULL,
[Market] [varchar] (3) NOT NULL,
[ContractMonth] [varchar] (4) NOT NULL,
[MaturityDate] [date] NOT NULL,
[StrikePrice] [decimal] (24, 10) NOT NULL,
[CurrentSettlementPrice] [decimal] (24, 10) NOT NULL,
[PositionD1] [varchar] (100) NULL,
[CVD1] [varchar] (1) NULL,
[OpenPosition] [int] NOT NULL,
[BuySell] [varchar] (1) NOT NULL,
[PositionAfterMarket] [varchar] (100) NULL,
[CV2] [varchar] (1) NULL,
[Settlement] [decimal] (24, 10) NOT NULL,
[ContractSize] [varchar] (100) NULL,
[Filename] [varchar] (512) NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_BMEPosition_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_BMEPosition_CreateDate] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_BmfPosition] on [stage].[BmfPosition]''
');

GO
EXECUTE ('ALTER TABLE [stage].[BmfPosition] ADD CONSTRAINT [PK_BmfPosition] PRIMARY KEY CLUSTERED  ([BmfPositionId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_BmfPosition_LoadState_Filename] on [stage].[BmfPosition]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_BmfPosition_LoadState_Filename] ON [stage].[BmfPosition] ([LoadState], [Filename])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_DataSource_RollbackFileImportForDataSource]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_DataSource_RollbackFileImportForDataSource]
	@DataSourceId INT
	, @FileName VARCHAR(512)
	, @DeleteAdjustments BIT = 1
AS
--	29 Apr 2010		amk		MBAL-13689: rollback new NT file too
--  07 Jul 2010		ED		MBAL-16079 - fix rollback, to include only for current date
--	09 Jul 2010		ED		MBAL-16096 - rollback processing for adjustment user story
--	12 Jul 2010		ED		MBAL-16131 - fix FK error on rollback
--  14 Jul 2010		ED		MBAL-16131 - add  (NOLOCK) to select from adj table
--  16 Jul 2010		AAJM	MBAL-14903: Add ICE File
--	19 Jul 2010		amk		MBAL-16169 be sure to remove trxs created as byproduct of positions
--  26 Jul 2010		AAJM	MBAL-16292 Delete rows from Price Report Summary rather than updating
--  27 Jul 2010		AAJM	Fix rollback problem caused by hyphens in Transaction Type Code
--	03 Aug 2010		amk		Extract adjustment delete to separate routine to make more maintainable
--	09 Aug 2010		amk		Add DeleteAdjustments parameter so we can run routine and NOT cascade delete to adjustments (since all data sources affected)
--	10 Aug 2010		amk		MBAL-15288: delete c21 header row too
--  12 Aug 2010		AAJM	MBAL-16441: Rollback AsOfDate incorrect, conflicting temp table records
--	21 Dec 2010		amk		MBAL-17193: Support new R&N US data source
--	14 Jan 2011		amk		MBAL-17240: Support new ADM2, RNU2, RNG2 data sources
--	17 Jan 2011		amk		MBAL-17219: only rollback adjustments for selected templates
--  07 Apr 2011		AAJM	MBAL-17385: Rollback for Credit Suisse
--  29 Apr 2011		AAJM	MBAL-20388: Rollback for DGCX
--	16 May 2012		ED		ADD new datasource - RNOT
--	11 Jul 2012		ED		MBAL 21156 - add new datasource, RNIN and RNBB
--	13 Jul 2012		AAJM	MBAL 21156 - Rename datasource RNBB to RNST
--	09 Sept 2012	ED		MBAL 21133 - ADD new datasource - BZ
--  10 Oct 2012		AAJM	MBAL-21845 - Fix BZ for new structure
--  15 Jan 2013		MJP		MBAL-22632 - Add new LIFFE datasource (was LCH) for rollback
--  18 Mar 2013		MJP		MBAL-22980 - Add NLX datasource
--  08 May 2013		MJP		MBAL-23171 - Add Eurex to adapter framework
--  09 Jan 2014		ED		EIB 25004 - remove importLog table and use Log table
--  23 Apr 2014		ED		EIB 25559 - add RBC
--  23 Jun 2014		ED		EIB 25762 - add LME
--  21 Jul 2014		ED		EIB 25826 - logic for UM rollback
--  29 Jul 2014		ED		EIB 25855 - add ICE US and CME US
--  20 Aug 2014		ED		EIB 25894  - add OTCM
--  19 Sep 2014		ED		EIB 26029  - Fix UM rollback
--  21 Jan 2019		KR		IBAL-12  - add Rosenthal Collins Group
BEGIN
--Double Check that we have values in both, if not just return
IF @DataSourceId IS NULL OR @FileName IS NULL
BEGIN
	RETURN
END

DECLARE @DataSourceCode VARCHAR(100)
DECLARE @DataSourceName VARCHAR(100)

SELECT @DataSourceCode = [Code], @DataSourceName = [Name]
FROM ib_DataSource
WHERE DataSourceId = @DataSourceId

DECLARE @AlternateDataSourceId INT
SET @AlternateDataSourceId = @DataSourceId

SET NOCOUNT ON
SET XACT_ABORT ON


BEGIN TRY
BEGIN TRAN


	IF object_id(''tempdb..#tmpPositionIds'') IS NOT NULL
	BEGIN
	   DROP TABLE #tmpPositionIds
	END

	CREATE TABLE #tmpPositionIds
	(
		[PositionId] INT NOT NULL
		,UNIQUE ([PositionId])
	)


	IF object_id(''tempdb..#tmpTransactionIds'') IS NOT NULL
	BEGIN
	   DROP TABLE #tmpTransactionIds
	END

	CREATE TABLE #tmpTransactionIds
	(
		[TransactionId] INT NOT NULL
		,UNIQUE ([TransactionId])
	)

	--Clearing21
	IF @DataSourceCode = ''Clearing21''
	BEGIN
		--Insert the PositionIds
		INSERT INTO #tmpPositionIds(PositionId)
		SELECT pos.PositionId
		FROM [dbo].[C21_ResumeLine] tmpPos
			INNER JOIN [dbo].[ib_Position] pos ON tmpPos.[ResumeLineID] = pos.[TempTableRecordId] 
											AND pos.DataSourceId = @DataSourceId
		WHERE tmpPos.[FileName] = @FileName

		--Insert the TransactionIds
		INSERT INTO #tmpTransactionIds(TransactionId)
		SELECT trx1.TrxId
		FROM [dbo].[C21_DetailLine] tmpTrx1
			INNER JOIN [dbo].[ib_Trx] trx1 ON tmpTrx1.[DetailLineID] = trx1.[TempTableRecordId] 
											AND trx1.DataSourceId = @DataSourceId
		WHERE tmpTrx1.[FileName] = @FileName
		
		--Delete From Temp Tables now... 
		DELETE FROM [dbo].[C21_ResumeLine]
		WHERE [FileName] = @FileName
		
		DELETE FROM [dbo].[C21_DetailLine]
		WHERE [FileName] = @FileName
		
		DELETE FROM [dbo].[C21_PreviousDayLine] -- Even though we dont use this table, I''ll delete its data anyway
		WHERE [FileName] = @FileName
	
		DELETE FROM [dbo].[C21_Header]
		WHERE [FileName] = @FileName
	END

	-- Hong Kong Futures Exchange
	IF @DataSourceCode = ''HKFE''
	BEGIN
		
		--Insert the PositionIds
		INSERT INTO #tmpPositionIds(PositionId)
		SELECT pos.PositionId
		FROM [dbo].[HKFE_TP001_Type01] tmpPos
			INNER JOIN [dbo].[ib_Position] pos ON tmpPos.RecordType01_Id = pos.[TempTableRecordId] 
											AND pos.DataSourceId = @DataSourceId
		WHERE tmpPos.[FileName] = @FileName

		--Insert the TransactionIds
		INSERT INTO #tmpTransactionIds(TransactionId)
		SELECT trx1.TrxId
		FROM [dbo].[HKFE_TP001_Type02] tmpTrx1
			INNER JOIN [dbo].[ib_Trx] trx1 on tmpTrx1.RecordType02_Id = trx1.[TempTableRecordId] 
											AND trx1.DataSourceId = @DataSourceId
		WHERE tmpTrx1.[FileName] = @FileName
		
		--Delete From Temp Tables now... 
		DELETE FROM [dbo].[HKFE_TP001_Type01]
		WHERE [FileName] = @FileName
		
		DELETE FROM [dbo].[HKFE_TP001_Type02]
		WHERE [FileName] = @FileName
	END


	-- LCH aka Liffe
	IF @DataSourceCode = ''LCH''
	BEGIN
		--Insert the PositionIds
		INSERT INTO #tmpPositionIds(PositionId)
		SELECT pos.PositionId
		FROM [dbo].[LCH_TypePS_0101] tmpPos
			INNER JOIN [dbo].[ib_Position] pos ON tmpPos.LCH_TypePS_0101_ID = pos.[TempTableRecordId] 
											AND pos.DataSourceId = @DataSourceId
		WHERE tmpPos.[FileName] = @FileName

		-- IMPORTANT NOTE 
		-- re. Recognition of Temp Records where Transactions are sourced from multiple temp		
		-- tables for a single datasource.
		-- Only way to differential TR trx''s against NT trx''s is to assume TrxTypeCode is 
		-- exactly one character for NT and longer for TR. 
		-- Otherwise might delete other one''s rows since TempTableRecordId''s may overlap
		-- and same target table (ib_Trx)
		
		--Insert the TransactionIds (TypeTR)
		INSERT INTO #tmpTransactionIds(TransactionId)
		SELECT trx1.TrxId		
		FROM [dbo].[LCH_TypeTR] tmpTrx1
			INNER JOIN [dbo].[ib_Trx] trx1 ON tmpTrx1.LIFFE_TRID = trx1.[TempTableRecordId] 
											AND trx1.DataSourceId = @DataSourceId
											AND LEN(trx1.TrxTypeCode) > 1
		WHERE tmpTrx1.[FileName] = @FileName

		
		--Insert the TransactionIds (TypeNT)
		INSERT INTO #tmpTransactionIds(TransactionId)
		SELECT trx1.TrxId		
		FROM [dbo].[LCH_TypeNT] tmpTrx1
			INNER JOIN [dbo].[ib_Trx] trx1 ON tmpTrx1.LCH_TypeNTID = trx1.[TempTableRecordId] 
											AND trx1.DataSourceId = @DataSourceId
											AND LEN(trx1.TrxTypeCode) = 1
		WHERE tmpTrx1.[FileName] = @FileName


		--Delete From Temp Tables now... 
		DELETE FROM [dbo].[LCH_TypePS_0101]
		WHERE [FileName] = @FileName
		
		DELETE FROM [dbo].[LCH_TypeTR]
		WHERE [FileName] = @FileName

		DELETE FROM [dbo].[LCH_TypeNT]
		WHERE [FileName] = @FileName
	END
	
	-- Liffe
	IF @DataSourceCode = ''LIFFE''
	BEGIN
		--Insert the PositionIds
		INSERT INTO #tmpPositionIds(PositionId)
		SELECT pos.PositionId
		FROM [dbo].[Liffe_Position] tmpPos
			INNER JOIN [dbo].[ib_Position] pos ON tmpPos.Liffe_PositionId = pos.[TempTableRecordId] 
											AND pos.DataSourceId = @DataSourceId
		WHERE tmpPos.[FileName] = @FileName

		-- IMPORTANT NOTE 
		-- re. Recognition of Temp Records where Transactions are sourced from multiple temp		
		-- tables for a single datasource.
		-- Only way to differential TR trx''s against NT trx''s is to assume TrxTypeCode is 
		-- exactly one character for NT and longer for TR. 
		-- Otherwise might delete other one''s rows since TempTableRecordId''s may overlap
		-- and same target table (ib_Trx)
		
		--Insert the TransactionIds (TypeTR)
		INSERT INTO #tmpTransactionIds(TransactionId)
		SELECT trx1.TrxId		
		FROM [dbo].[Liffe_TradeReport] tmpTrx1
			INNER JOIN [dbo].[ib_Trx] trx1 ON tmpTrx1.Liffe_TradeReportId = trx1.[TempTableRecordId] 
											AND trx1.DataSourceId = @DataSourceId
											AND LEN(trx1.TrxTypeCode) > 1
		WHERE tmpTrx1.[FileName] = @FileName

		
		--Insert the TransactionIds (TypeNT)
		INSERT INTO #tmpTransactionIds(TransactionId)
		SELECT trx1.TrxId		
		FROM [dbo].[Liffe_Notification] tmpTrx1
			INNER JOIN [dbo].[ib_Trx] trx1 ON tmpTrx1.Liffe_NotificationId = trx1.[TempTableRecordId] 
											AND trx1.DataSourceId = @DataSourceId
											AND LEN(trx1.TrxTypeCode) = 1
		WHERE tmpTrx1.[FileName] = @FileName


		--Delete From Temp Tables now... 
		DELETE FROM [dbo].[Liffe_Position]
		WHERE [FileName] = @FileName
		
		DELETE FROM [dbo].[Liffe_TradeReport]
		WHERE [FileName] = @FileName

		DELETE FROM [dbo].[Liffe_Notification]
		WHERE [FileName] = @FileName
	END

	-- Eurex
	--NB2: Eurex has 1 table for both Transaction and Positions
	IF @DataSourceCode = ''Eurex''
	BEGIN
		--Insert the PositionIds
		INSERT INTO #tmpPositionIds(PositionId)
		SELECT pos.PositionId
		FROM [dbo].[EU_CB010GRP] tmpPos
			INNER JOIN [dbo].[ib_Position] pos ON tmpPos.EU_cb010grpID = pos.[TempTableRecordId] 
											AND pos.DataSourceId = @DataSourceId
		WHERE tmpPos.[FileName] = @FileName
											
		--Insert the TransactionIds
		INSERT INTO #tmpTransactionIds(TransactionId)
		SELECT trx1.TrxId
		FROM [dbo].[EU_CB010GRP] tmpTrx1
			INNER JOIN [dbo].[ib_Trx] trx1 on tmpTrx1.EU_cb010grpID = trx1.[TempTableRecordId] 
											AND trx1.DataSourceId = @DataSourceId
		WHERE tmpTrx1.[FileName] = @FileName

		--Delete From Temp Table now...
		DELETE FROM [dbo].[EU_CB010GRP]
		WHERE [FileName] = @FileName

	END

	-- Broker aka Barclays
	IF @DataSourceCode = ''Barclays''
	BEGIN
		--Insert the PositionIds
		INSERT INTO #tmpPositionIds(PositionId)
		SELECT pos.PositionId
		FROM [dbo].[Broker_Position] tmpPos
			INNER JOIN [dbo].[ib_Position] pos ON tmpPos.Broker_PositionID = pos.[TempTableRecordId] 
											AND pos.DataSourceId = @DataSourceId
		WHERE tmpPos.[FileName] = @FileName


		--Insert the TransactionIds
		INSERT INTO #tmpTransactionIds(TransactionId)
		SELECT trx1.TrxId
		FROM [dbo].[Broker_Transaction] tmpTrx1
			INNER JOIN [dbo].[ib_Trx] trx1 ON tmpTrx1.Broker_TransactionID = trx1.[TempTableRecordId] 
											AND trx1.DataSourceId = @DataSourceId
		WHERE tmpTrx1.[FileName] = @FileName
		
		DELETE FROM [dbo].[Broker_Position]
		WHERE [FileName] = @FileName
		
		DELETE FROM [dbo].[Broker_Transaction]
		WHERE [FileName] = @FileName

	END

	-- CSA aka Credit Suisse
	IF @DataSourceCode = ''CSA'' OR @DataSourceCode = ''CSNA''
	BEGIN
		--Insert the PositionIds
		INSERT INTO #tmpPositionIds(PositionId)
		SELECT pos.PositionId
		FROM [dbo].[CreditSuisse_Position] tmpPos
			INNER JOIN [dbo].[ib_Position] pos ON tmpPos.CreditSuisse_PositionID = pos.[TempTableRecordId] 
											AND pos.DataSourceId = @DataSourceId
		WHERE tmpPos.[FileName] = @FileName


		--Insert the TransactionIds
		INSERT INTO #tmpTransactionIds(TransactionId)
		SELECT trx1.TrxId
		FROM [dbo].[CreditSuisse_Transaction] tmpTrx1
			INNER JOIN [dbo].[ib_Trx] trx1 ON tmpTrx1.CreditSuisse_TransactionID = trx1.[TempTableRecordId] 
											AND trx1.DataSourceId = @DataSourceId
		WHERE tmpTrx1.[FileName] = @FileName
		
		DELETE FROM [dbo].[CreditSuisse_Position]
		WHERE [FileName] = @FileName
		
		DELETE FROM [dbo].[CreditSuisse_Transaction]
		WHERE [FileName] = @FileName

	END
	
	-- dgcx
	IF @DataSourceCode = ''DGCX'' 
	BEGIN
		--Insert the PositionIds
		INSERT INTO #tmpPositionIds(PositionId)
		SELECT pos.PositionId
		FROM [dbo].[DGCX_Position] tmpPos
			INNER JOIN [dbo].[ib_Position] pos ON tmpPos.DGCX_PositionID = pos.[TempTableRecordId] 
											AND pos.DataSourceId = @DataSourceId
		WHERE tmpPos.[FileName] = @FileName


		--Insert the TransactionIds
		INSERT INTO #tmpTransactionIds(TransactionId)
		SELECT trx1.TrxId
		FROM [dbo].[DGCX_Transaction] tmpTrx1
			INNER JOIN [dbo].[ib_Trx] trx1 ON tmpTrx1.DGCX_TransactionID = trx1.[TempTableRecordId] 
											AND trx1.DataSourceId = @DataSourceId
		WHERE tmpTrx1.[FileName] = @FileName
		
		DELETE FROM [dbo].[DGCX_Position]
		WHERE [FileName] = @FileName
		
		DELETE FROM [dbo].[DGCX_Transaction]
		WHERE [FileName] = @FileName

	END

	-- NLX
	IF @DataSourceCode = ''NLX'' OR @DataSourceCode = ''Eurex''
	BEGIN
		INSERT INTO #tmpPositionIds (PositionId)
		SELECT		pos.PositionId
		FROM		[dbo].[eib_StagingFile] sf
		INNER JOIN	[dbo].[ib_Position] pos
		ON			sf.[StagingFileId] = pos.[TempTableRecordId]
		WHERE		sf.[Path] = @FileName AND pos.[DataSourceId] = @DataSourceId

		INSERT INTO #tmpTransactionIds (TransactionId)
		SELECT		trx.TrxId
		FROM		[dbo].[eib_StagingFile] sf
		INNER JOIN	[dbo].[ib_Trx] trx
		ON			sf.[StagingFileId] = trx.[TempTableRecordId]
		WHERE		sf.[Path] = @FileName AND trx.[DataSourceId] = @DataSourceId
		
		DELETE FROM [dbo].[eib_StagingFile]
		WHERE		[Path] = @FileName AND [DataSourceId] = @DataSourceId
	END
	
	-- RolfeNolan
	IF @DataSourceCode = ''RolfeNolan'' OR @DataSourceCode = ''RNUS'' 
		OR @DataSourceCode = ''RNU2'' OR @DataSourceCode = ''RNG2'' OR @DataSourceCode = ''RNOT''
		OR @DataSourceCode = ''RNIN'' OR @DataSourceCode = ''RNST''  OR @DataSourceCode=''OTCM''
	BEGIN
		--Insert the PositionIds
		INSERT INTO #tmpPositionIds(PositionId)
		SELECT pos.PositionId
		FROM [dbo].[RolfeNolan_HOSTOPN] tmpPos
			INNER JOIN [dbo].[ib_Position] pos ON tmpPos.RolfeNolan_HOSTOPNID = pos.[TempTableRecordId] 
											AND pos.DataSourceId = @DataSourceId
		WHERE tmpPos.[FileName] = @FileName

		--Insert the TransactionIds
		INSERT INTO #tmpTransactionIds(TransactionId)
		SELECT trx1.TrxId
		FROM [dbo].[RolfeNolan_HOSTTRN] tmpTrx1
			INNER JOIN [dbo].[ib_Trx] trx1 ON tmpTrx1.RolfeNolan_HOSTTRNID = trx1.[TempTableRecordId] 
											AND trx1.DataSourceId = @DataSourceId
		WHERE tmpTrx1.[FileName] = @FileName
		
		DELETE FROM [dbo].[RolfeNolan_HOSTOPN]
		WHERE [FileName] = @FileName
		
		DELETE FROM [dbo].[RolfeNolan_HOSTTRN]
		WHERE [FileName] = @FileName

	END
	
	
	--Citibank and ADM (They are GMI imports)
	IF @DataSourceCode = ''Citibank'' OR @DataSourceCode = ''ADM'' OR @DataSourceCode = ''ADM2''
	BEGIN
		--Insert the PositionIds
		INSERT INTO #tmpPositionIds(PositionId)
		SELECT pos.PositionId
		FROM [dbo].[GMI_EXTF1] tmpPos
			INNER JOIN [dbo].[ib_Position] pos ON tmpPos.[GMI_EXTF1ID] = pos.[TempTableRecordId] 
											AND pos.DataSourceId = @DataSourceId
		WHERE tmpPos.[FileName] = @FileName

		--Insert the TransactionIds
		INSERT INTO #tmpTransactionIds(TransactionId)
		SELECT trx1.TrxId
		FROM [dbo].[GMI_EXTF1] tmpTrx1
			INNER JOIN [dbo].[ib_Trx] trx1 ON tmpTrx1.[GMI_EXTF1ID] = trx1.[TempTableRecordId] 
											AND trx1.DataSourceId = @DataSourceId
		WHERE tmpTrx1.[FileName] = @FileName
	
		--Delete From Temp Tables now... 
		DELETE FROM [dbo].[GMI_EXTF1]
		WHERE [FileName] = @FileName
	
	END
	
	
		-- Banco Santander
	IF  @DataSourceCode=''BZ''
	BEGIN
		--Insert the PositionIds
		INSERT INTO #tmpPositionIds(PositionId)
		SELECT pos.PositionId
		FROM [dbo].[BancoSantander_HOSTOPN] tmpPos
			INNER JOIN [dbo].[ib_Position] pos ON tmpPos.BancoSantander_HOSTOPNID = pos.[TempTableRecordId] 
											AND pos.DataSourceId = @DataSourceId
		WHERE tmpPos.[FileName] = @FileName

		--Insert the TransactionIds
		INSERT INTO #tmpTransactionIds(TransactionId)
		SELECT trx1.TrxId
		FROM [dbo].[BancoSantander_HOSTTRN] tmpTrx1
			INNER JOIN [dbo].[ib_Trx] trx1 ON tmpTrx1.BancoSantander_HOSTTRNID = trx1.[TempTableRecordId] 
											AND trx1.DataSourceId = @DataSourceId
		WHERE tmpTrx1.[FileName] = @FileName
		
		DELETE FROM [dbo].[BancoSantander_HOSTOPN]
		WHERE [FileName] = @FileName
		
		DELETE FROM [dbo].[BancoSantander_HOSTTRN]
		WHERE [FileName] = @FileName

	END
	
	--ICE Import
	
		-- IMPORTANT NOTE 
		-- re. Recognition of Temp Records where Transactions are sourced from multiple temp		
		-- tables for a single datasource.
		-- only way to differential TrdCaptRpt trx''s against AsgnRpt trx''s is to assume		
		-- TrxTypeCode is numeric, or contains a hyphen, for TrdCaptRpt. 
		-- Or transaction types in AsgnRpt will be letters and won''t contain a hyphen.  
		-- Otherwise might delete other one''s rows since TempTableRecordId''s may overlap
		-- and same target table (ib_Trx)
		
		
	IF @DataSourceCode = ''ICE'' OR @DataSourceCode = ''ICEUS''
	BEGIN
		--Insert the PositionIds
		INSERT INTO #tmpPositionIds(PositionId)
		SELECT pos.PositionId
		FROM [dbo].[ICE_PosRpt] tmpPos
			INNER JOIN [dbo].[ib_Position] pos ON tmpPos.ICE_PosRptID = pos.[TempTableRecordId] 
											AND pos.DataSourceId = @DataSourceId
		WHERE tmpPos.[FileName] = @FileName

		
		--Insert the TransactionIds (TrdCaptRpt)
		INSERT INTO #tmpTransactionIds(TransactionId)
		SELECT trx1.TrxId		
		FROM [dbo].[ICE_TrdCaptRpt] tmpTrx1
			INNER JOIN [dbo].[ib_Trx] trx1 ON tmpTrx1.ICE_TrdCaptRptID = trx1.[TempTableRecordId] 
											AND trx1.DataSourceId = @DataSourceId
											AND (ISNUMERIC(trx1.TrxTypeCode) = 1 OR trx1.TrxTypeCode LIKE ''%-%'')
		WHERE tmpTrx1.[FileName] = @FileName

		
		--Insert the TransactionIds (TypeNT)
		INSERT INTO #tmpTransactionIds(TransactionId)
		SELECT trx1.TrxId		
		FROM [dbo].[ICE_AsgnRpt] tmpTrx1
			INNER JOIN [dbo].[ib_Trx] trx1 ON tmpTrx1.ICE_AsgnRptId = trx1.[TempTableRecordId] 
											AND trx1.DataSourceId = @DataSourceId
											AND (ISNUMERIC(trx1.TrxTypeCode) <> 1 AND trx1.TrxTypeCode NOT LIKE ''%-%'')
		WHERE tmpTrx1.[FileName] = @FileName


		--Delete From Temp Tables now... 
		DELETE FROM [dbo].[ICE_TrdCaptRpt]
		WHERE [FileName] = @FileName
		
		DELETE FROM [dbo].[ICE_PosRpt]
		WHERE [FileName] = @FileName

		DELETE FROM [dbo].[ICE_AsgnRpt]
		WHERE [FileName] = @FileName
	END
	
	--CME Import
	
	-- IMPORTANT NOTE 
	-- re. Recognition of Temp Records where Transactions are sourced from multiple temp		
	-- tables for a single datasource.
	-- only way to differential TrdCaptRpt trx''s against AsgnRpt trx''s is to assume		
	-- TrxTypeCode is numeric, or contains a hyphen, for TrdCaptRpt. 
	-- Or transaction types in AsgnRpt will be letters and won''t contain a hyphen.  
	-- Otherwise might delete other one''s rows since TempTableRecordId''s may overlap
	-- and same target table (ib_Trx)
		
		
	IF @DataSourceCode = ''CMEUS''
	BEGIN
		--Insert the PositionIds
		INSERT INTO #tmpPositionIds(PositionId)
		SELECT pos.PositionId
		FROM [stage].[CME_PosRpt] tmpPos
			INNER JOIN [dbo].[ib_Position] pos ON tmpPos.CME_PosRptID = pos.[TempTableRecordId] 
											AND pos.DataSourceId = @DataSourceId
		WHERE tmpPos.[FileName] = @FileName

		
		--Insert the TransactionIds (TrdCaptRpt)
		INSERT INTO #tmpTransactionIds(TransactionId)
		SELECT trx1.TrxId		
		FROM [stage].[CME_TrdCaptRpt] tmpTrx1
			INNER JOIN [dbo].[ib_Trx] trx1 ON tmpTrx1.CME_TrdCaptRptID = trx1.[TempTableRecordId] 
											AND trx1.DataSourceId = @DataSourceId
											AND (ISNUMERIC(trx1.TrxTypeCode) = 1 OR trx1.TrxTypeCode LIKE ''%-%'')
		WHERE tmpTrx1.[FileName] = @FileName

		
		--Insert the TransactionIds (TypeNT)
		INSERT INTO #tmpTransactionIds(TransactionId)
		SELECT trx1.TrxId		
		FROM [stage].[CME_AsgnRpt] tmpTrx1
			INNER JOIN [dbo].[ib_Trx] trx1 ON tmpTrx1.CME_AsgnRptId = trx1.[TempTableRecordId] 
											AND trx1.DataSourceId = @DataSourceId
											AND (ISNUMERIC(trx1.TrxTypeCode) <> 1 AND trx1.TrxTypeCode NOT LIKE ''%-%'')
		WHERE tmpTrx1.[FileName] = @FileName


		--Delete From Temp Tables now... 
		DELETE FROM [stage].[CME_TrdCaptRpt]
		WHERE [FileName] = @FileName
		
		DELETE FROM [stage].[CME_PosRpt]
		WHERE [FileName] = @FileName

		DELETE FROM [stage].[CME_AsgnRpt]
		WHERE [FileName] = @FileName
	END

	-- RBC
	IF @DataSourceCode = ''RBC''
	BEGIN
		--Insert the PositionIds
		INSERT INTO #tmpPositionIds(PositionId)
		SELECT pos.PositionId
		FROM [dbo].[RBC_Position] tmpPos
			INNER JOIN [dbo].[ib_Position] pos ON tmpPos.RBC_PositionID = pos.[TempTableRecordId] 
											AND pos.DataSourceId = @DataSourceId
		WHERE tmpPos.[FileName] = @FileName

		--Insert the TransactionIds
		INSERT INTO #tmpTransactionIds(TransactionId)
		SELECT trx1.TrxId
		FROM [dbo].[RBC_Transaction] tmpTrx1
			INNER JOIN [dbo].[ib_Trx] trx1 ON tmpTrx1.RBC_TransactionID = trx1.[TempTableRecordId] 
											AND trx1.DataSourceId = @DataSourceId
		WHERE tmpTrx1.[FileName] = @FileName
		
		DELETE FROM [dbo].[RBC_Position]
		WHERE [FileName] = @FileName
		
		DELETE FROM [dbo].[RBC_Transaction]
		WHERE [FileName] = @FileName

	END

	-- LME
	IF @DataSourceCode = ''LME''
	BEGIN
		--Insert the PositionIds
		INSERT INTO #tmpPositionIds(PositionId)
		SELECT pos.PositionId
		FROM stage.LmePosition tmpPos
			INNER JOIN [dbo].[ib_Position] pos ON tmpPos.LmePositionId = pos.[TempTableRecordId] 
											AND pos.DataSourceId = @DataSourceId
		WHERE tmpPos.[FileName] = @FileName

		--Insert the TransactionIds
		INSERT INTO #tmpTransactionIds(TransactionId)
		SELECT trx1.TrxId
		FROM stage.LmeTrade tmpTrx1
			INNER JOIN [dbo].[ib_Trx] trx1 ON tmpTrx1.LmeTradeId = trx1.[TempTableRecordId] 
											AND trx1.DataSourceId = @DataSourceId
		WHERE tmpTrx1.[FileName] = @FileName
		
		DELETE FROM stage.LmePosition
		WHERE [FileName] = @FileName
		
		DELETE FROM stage.LmeTrade
		WHERE [FileName] = @FileName

		UPDATE ib_ImbalanceReportDetail 
			SET PositionsRealisedCashId = NULL 
			WHERE PositionsRealisedCashId 
				IN (SELECT PositionsRealisedCashId FROM PositionsRealisedCash prc 
						INNER JOIN stage.LmePositionsRealisedCash lprc ON lprc.LmePositionsRealisedCashId = prc.TempTableRecordId AND prc.DataSourceId = @DataSourceId
							AND lprc.Filename = @FileName)
		DELETE FROM PositionsRealisedCash 
			WHERE DataSourceId = @DataSourceId 
				AND TempTableRecordId IN (SELECT LmePositionsRealisedCashId FROM stage.LmePositionsRealisedCash WHERE Filename = @FileName)
		DELETE FROM  stage.LmePositionsRealisedCash
		WHERE Filename = @FileName

	END

	-- MAQ
	IF @DataSourceCode = ''MAQ'' 
	BEGIN
		--Insert the PositionIds
		INSERT INTO #tmpPositionIds(PositionId)
		SELECT pos.PositionId
		FROM [stage].[MacquariePosition] tmpPos
			INNER JOIN [dbo].[ib_Position] pos ON tmpPos.MacquariePositionId = pos.[TempTableRecordId] 
											AND pos.DataSourceId = @DataSourceId
		WHERE tmpPos.[FileName] = @FileName


		--Insert the TransactionIds
		INSERT INTO #tmpTransactionIds(TransactionId)
		SELECT trx1.TrxId
		FROM [stage].[MacquarieTrade] tmpTrx1
			INNER JOIN [dbo].[ib_Trx] trx1 ON tmpTrx1.MacquarieTradeId = trx1.[TempTableRecordId] 
											AND trx1.DataSourceId = @DataSourceId
		WHERE tmpTrx1.[FileName] = @FileName
		
		DELETE FROM [stage].[MacquariePosition]
		WHERE [FileName] = @FileName
		
		DELETE FROM [stage].[MacquarieTrade]
		WHERE [FileName] = @FileName

	END

	-- BMF
	IF @DataSourceCode = ''BMF'' 
	BEGIN
		--Insert the PositionIds
		INSERT INTO #tmpPositionIds(PositionId)
		SELECT pos.PositionId
		FROM [stage].[BmfPosition] tmpPos
			INNER JOIN [dbo].[ib_Position] pos ON tmpPos.BmfPositionId = pos.[TempTableRecordId] 
											AND pos.DataSourceId = @DataSourceId
		WHERE tmpPos.[FileName] = @FileName


		--Insert the TransactionIds
		INSERT INTO #tmpTransactionIds(TransactionId)
		SELECT trx1.TrxId
		FROM [stage].[BmfTrade] tmpTrx1
			INNER JOIN [dbo].[ib_Trx] trx1 ON tmpTrx1.BmfTradeId = trx1.[TempTableRecordId] 
											AND trx1.DataSourceId = @DataSourceId
		WHERE tmpTrx1.[FileName] = @FileName
		
		DELETE FROM [stage].[BmfPosition]
		WHERE [FileName] = @FileName
		
		DELETE FROM [stage].[BmfTrade]
		WHERE [FileName] = @FileName
		
		UPDATE ib_ImbalanceReportDetail 
			SET PositionsRealisedCashId = NULL 
			WHERE PositionsRealisedCashId 
				IN (SELECT PositionsRealisedCashId FROM PositionsRealisedCash prc 
						INNER JOIN stage.BmfPositionsRealisedCash lprc ON lprc.BmfPositionsRealisedCashId = prc.TempTableRecordId AND prc.DataSourceId = @DataSourceId
							AND lprc.Filename = @FileName)
		DELETE FROM PositionsRealisedCash 
			WHERE DataSourceId = @DataSourceId 
				AND TempTableRecordId IN (SELECT BmfPositionsRealisedCashId FROM stage.BmfPositionsRealisedCash WHERE Filename = @FileName)
		DELETE FROM  stage.BmfPositionsRealisedCash
		WHERE Filename = @FileName

	END

	IF @DataSourceCode = ''EEX''
	BEGIN
		--Insert the PositionIds
		INSERT INTO #tmpPositionIds(PositionId)
		SELECT pos.PositionId
		FROM stage.Europower tmpPos
			INNER JOIN [dbo].[ib_Position] pos ON tmpPos.EuropowerID = pos.[TempTableRecordId] 
											AND pos.DataSourceId = @DataSourceId
		WHERE tmpPos.[FileName] = @FileName
											
		--Insert the TransactionIds
		INSERT INTO #tmpTransactionIds(TransactionId)
		SELECT trx1.TrxId
		FROM stage.Europower tmpTrx1
			INNER JOIN [dbo].[ib_Trx] trx1 on tmpTrx1.EuropowerID = trx1.[TempTableRecordId] 
											AND trx1.DataSourceId = @DataSourceId
		WHERE tmpTrx1.[FileName] = @FileName

		--Delete From Temp Table now...
		DELETE FROM stage.Europower
		WHERE [FileName] = @FileName

	END
	
	-- RCG aka GMI MNA
	IF @DataSourceCode = ''GMI MNA''
	BEGIN
		--Insert the PositionIds
		INSERT INTO #tmpPositionIds(PositionId)
		SELECT pos.PositionId
		FROM [stage].[RosenthalCollinsPosition] tmpPos
			INNER JOIN [dbo].[ib_Position] pos ON tmpPos.RosenthalCollinsPositionID = pos.[TempTableRecordId] 
											AND pos.DataSourceId = @DataSourceId
		WHERE tmpPos.[FileName] = @FileName


		--Insert the TransactionIds
		INSERT INTO #tmpTransactionIds(TransactionId)
		SELECT trx1.TrxId
		FROM [stage].[RosenthalCollinsTrade] tmpTrx1
			INNER JOIN [dbo].[ib_Trx] trx1 ON tmpTrx1.RosenthalCollinsTradeId = trx1.[TempTableRecordId] 
											AND trx1.DataSourceId = @DataSourceId
		WHERE tmpTrx1.[FileName] = @FileName
		
		DELETE FROM [stage].[RosenthalCollinsPosition]
		WHERE [FileName] = @FileName
		
		DELETE FROM [stage].[RosenthalCollinsTrade]
		WHERE [FileName] = @FileName

	END

	-- Minneapolis Grain Exchange (aka MGEX)
	IF @DataSourceCode = ''MGEX'' 
	BEGIN
		--Insert the PositionIds
		INSERT INTO #tmpPositionIds(PositionId)
		SELECT pos.PositionId
		FROM [stage].[MGEPosition] tmpPos
			INNER JOIN [dbo].[ib_Position] pos ON tmpPos.MGEPositionId = pos.[TempTableRecordId] 
											AND pos.DataSourceId = @DataSourceId
		WHERE tmpPos.[FileName] = @FileName


		--Insert the TransactionIds
		INSERT INTO #tmpTransactionIds(TransactionId)
		SELECT trx1.TrxId
		FROM [stage].[MGETrade] tmpTrx1
			INNER JOIN [dbo].[ib_Trx] trx1 ON tmpTrx1.MGETradeId = trx1.[TempTableRecordId] 
											AND trx1.DataSourceId = @DataSourceId
		WHERE tmpTrx1.[FileName] = @FileName
		
		DELETE FROM [stage].[MGEPosition]
		WHERE [FileName] = @FileName
		
		DELETE FROM [stage].[MGETrade]
		WHERE [FileName] = @FileName

	END

	--Now We delete all the common tables and any linked data we need to delete as well.
	
	--Be sure to include trxs related to positions
	INSERT INTO #tmpTransactionIds (TransactionId)
	SELECT trxid FROM ib_trx
	WHERE relatedposition_id IN (SELECT positionid from #tmpPositionIds)
	
	--Delete the trade reconciliation Detail records so we can delete the record in the in_Trx Table.
	DELETE trxDetail
	FROM [dbo].[ib_TradeReconciliationDetail] trxDetail
		INNER JOIN #tmpTransactionIds tmpTrx ON tmpTrx.TransactionId = trxDetail.TrxId
	
	--before delete transactions, reset status on automatched adjs
	UPDATE ib_Adjustment
	SET AdjustmentStatusId = NULL
	FROM ib_Adjustment a 
		INNER JOIN ib_Trx trx ON trx.MatchingAdjustmentId = a.AdjustmentId
		INNER JOIN #tmpTransactionIds tmpTrx ON trx.TrxId = tmpTrx.TransactionId
		WHERE trx.IsUnmatched = 0
	--delete UM adjs
	DECLARE @Adjustments TABLE(AdjustmentId INT)
	INSERT INTO @Adjustments
		SELECT AdjustmentId FROM ib_Adjustment adj
			INNER JOIN ib_trx trx ON trx.MatchingAdjustmentId = adj.AdjustmentId
			INNER JOIN #tmpTransactionIds tmpTrx ON trx.TrxId = tmpTrx.TransactionId
			WHERE trx.IsUnmatched = 1
	UPDATE ib_trx SET MatchingAdjustmentId = NULL WHERE
		MatchingAdjustmentId IN (SELECT AdjustmentId FROM @Adjustments)

	UPDATE ib_TradeReconciliationDetail SET AdjustmentId = NULL 
		WHERE AdjustmentId IN (SELECT AdjustmentId FROM @Adjustments)

	DELETE FROM ib_Adjustment WHERE AdjustmentId IN (SELECT AdjustmentId FROM @Adjustments)

	--Delete Transactions
	DELETE trx
	FROM [dbo].[ib_Trx] trx
		INNER JOIN #tmpTransactionIds tmpTrx ON trx.TrxId = tmpTrx.TransactionId
	
	--Delete the Positions
	DELETE pos
	FROM [dbo].[ib_Position] pos
		INNER JOIN #tmpPositionIds tmpPos ON pos.PositionId = tmpPos.PositionId

	--Delete Prices

	EXEC ib_Price_Delete_ForFile @DataSourceId, @FileName

	--Delete Adjustments

	IF @DeleteAdjustments = 1
	BEGIN
		DECLARE @AsOfDate DATETIME
		SET @AsOfDate = (SELECT MAX(AsOfDate) 
							FROM ib_ImportFile [if] 
							WHERE [if].[Filename] = @FileName)

		EXEC ib_Adjustment_Delete_AsOf @AsOfDate, @DataSourceId
	END
	
	-- Delete associated ImportFile record
	DELETE [if]
	FROM [dbo].[ib_ImportFile] [if]
	WHERE [if].DataSourceId = @DataSourceId AND [if].[Filename] = @FileName

	-- Finally Add a logger message, indicating that the Delete Was Done.
	IF EXISTS(SELECT 1 FROM dbo.Log l INNER JOIN dbo.ReceiveLocation rl ON rl.ReceiveLocationSysId = l.ReceiveLocationSysId AND l.FileName = @FileName AND rl.DataSourceId = @AlternateDataSourceId)
	BEGIN
		DECLARE @ReceiveLocationSysId INT
		SET @ReceiveLocationSysId = (SELECT TOP 1 l.ReceiveLocationSysId FROM dbo.Log l INNER JOIN dbo.ReceiveLocation rl ON rl.ReceiveLocationSysId = l.ReceiveLocationSysId AND l.FileName = @FileName AND rl.DataSourceId = @AlternateDataSourceId)
		UPDATE Log SET IsComplete = 0 WHERE ReceiveLocationSysId = @ReceiveLocationSysId AND FileName = @FileName AND IsComplete = 1
		EXEC Log_Insert @ReceiveLocationSysId, @Filename, ''Rollback'',''Rollback completed.'', ''Success'', '''',0
	END
	
COMMIT TRAN
END TRY
BEGIN CATCH

IF XACT_STATE() = -1
	ROLLBACK TRAN
	
DECLARE @ErrorMessage NVARCHAR(400);
DECLARE @ErrorNumber INT;
DECLARE @ErrorSeverity INT;
DECLARE @ErrorState INT;
DECLARE @ErrorLine INT;

SELECT @ErrorMessage = N''Error %d, Line %d, Message: '' +
ERROR_MESSAGE();
SELECT @ErrorNumber = ERROR_NUMBER();
SELECT @ErrorSeverity = ERROR_SEVERITY();
SELECT @ErrorState = ERROR_STATE();
SELECT @ErrorLine = ERROR_LINE();
RAISERROR (@ErrorMessage, @ErrorSeverity, @ErrorState, @ErrorNumber,@ErrorLine)

END CATCH

SET XACT_ABORT OFF


END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[Broker_Position_Purge]''
');

GO
EXECUTE ('



-- =============================================
-- Author:		Petru Konrad Bercea
-- Create date: 13.05.2009
-- Description:	Deletes from Broker_Position table all the records where the LoadState is 0
-- =============================================
CREATE PROCEDURE [dbo].[Broker_Position_Purge] 
	(
		@LoadState		TINYINT = 0,
		@FileName       VARCHAR (512)= NULL
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
		DELETE FROM [dbo].[Broker_Position] WHERE LoadState= @LoadState AND [FileName] = Coalesce(@FileName, [FileName])

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[LCH_TypePS_0101_Add]''
');

GO
EXECUTE ('
-- =============================================
-- Author:		Lee Manifold
-- Create date: 21 Jun 2006
-- Description:	Insert into LCH_TypePS_0101 table
--KevinP, 22 Feb 2010 - Added FileName
-- =============================================
CREATE PROCEDURE [dbo].[LCH_TypePS_0101_Add] 
	(
	@FileName							VARCHAR (512) = NULL,
	@Exchange							varchar(3),
	@DownloadNumber						varchar(4),
	@TradingDay							varchar(6),
	@TenderDeletionDay					varchar(6),
	@OriginatingClearerName				varchar(3),
	@OriginatingMemberName				varchar(3),
	@OriginatingTraderName				varchar(3),
	@AccountCode						varchar(1),
	@MarginingAccount					varchar(1),
	@PhysicalCommodity					varchar(3),
	@LogicalCommodity					varchar(3),
	@ContractType						varchar(1),
	@GenericContractType				varchar(1),
	@LongExpiryDate						varchar(8),
	@ExercisePrice						varchar(9),
	@ValuationPrice						varchar(9),
	@LongAccountVolume					varchar(11),
	@ShortAccountVolume					varchar(11),
	@LongAdjustedVolume					varchar(11),
	@ShortAdjustedVolume				varchar(11),
	@LongNonMarginableVolume			varchar(11),
	@ShortNonMarginableVolume			varchar(11),
	@LongAdjustedNonMarginableVolume	varchar(11),
	@ShortAdjustedNonMarginalVolume		varchar(11),
	@PayCollect							varchar(15),
	@LongContractsTraded				varchar(7),
	@ShortContractsTraded				varchar(7),
	@LongLotsTraded						varchar(7),
	@ShortLotsTraded					varchar(7),
	@ContingentMargin					varchar(15),
	@PremiumPayCollect					varchar(15),
	@ContigentPrice						varchar(9),
	@ManuallyExercisedLots				varchar(7),
	@AutoExercisedLots					varchar(7),
	@ManuallyDeliveredLots				varchar(7),
	@AutoDeliveredLots					varchar(7),
	@ManuallySettledLots				varchar(7),
	@AutoSettledLots					varchar(7),
	@LongExpiredLots					varchar(7),
	@ShortExpiredLots					varchar(7),
	@LongTransferredIn					varchar(7),
	@LongTransferredOut					varchar(7),
	@ShortTransferredIn					varchar(7),
	@ShortTransferredOut				varchar(7),
	@AssignedLots						varchar(7),
	@LotsSize							varchar(5),
	@PositionType						varchar(1)
	)
	
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

  INSERT INTO [dbo].[LCH_TypePS_0101]
           (
			[Exchange]           
           ,[DownloadNumber]
           ,[TradingDay]
           ,[TenderDeletionDay]
           ,[OriginatingClearerName]
           ,[OriginatingMemberName]
           ,[OriginatingTraderName]
           ,[AccountCode]
           ,[MarginingAccount]
		   ,[PhysicalCommodity]
           ,[LogicalCommodity]
           ,[ContractType]
           ,[GenericContractType]
           ,[LongExpiryDate]
           ,[ExercisePrice]
           ,[ValuationPrice]
           ,[LongAccountVolume]
           ,[ShortAccountVolume]
           ,[LongAdjustedVolume]
           ,[ShortAdjustedVolume]
           ,[LongNonMarginableVolume]
           ,[ShortNonMarginableVolume]
           ,[LongAdjustedNonMarginableVolume]
           ,[ShortAdjustedNonMarginalVolume]
           ,[PayCollect]
           ,[LongContractsTraded]
           ,[ShortContractsTraded]
           ,[LongLotsTraded]
           ,[ShortLotsTraded]
           ,[ContingentMargin]
           ,[PremiumPayCollect]
           ,[ContigentPrice]
           ,[ManuallyExercisedLots]
           ,[AutoExercisedLots]
           ,[ManuallyDeliveredLots]
           ,[AutoDeliveredLots]
           ,[ManuallySettledLots]
           ,[AutoSettledLots]
           ,[LongExpiredLots]
           ,[ShortExpiredLots]
           ,[LongTransferredIn]
           ,[LongTransferredOut]
           ,[ShortTransferredIn]
           ,[ShortTransferredOut]
           ,[AssignedLots]
           ,[LotsSize]
           ,[PositionType]
           ,[FileName]
			)
     VALUES
           (
			@Exchange							,
			@DownloadNumber						,
			@TradingDay							,
			@TenderDeletionDay					,
			@OriginatingClearerName				,
			@OriginatingMemberName				,
			@OriginatingTraderName				,
			@AccountCode						,
			@MarginingAccount					,
			@PhysicalCommodity					,
			@LogicalCommodity					,
			@ContractType						,
			@GenericContractType				,
			@LongExpiryDate						,
			@ExercisePrice						,
			@ValuationPrice						,
			@LongAccountVolume					,
			@ShortAccountVolume					,
			@LongAdjustedVolume					,
			@ShortAdjustedVolume				,
			@LongNonMarginableVolume			,
			@ShortNonMarginableVolume			,
			@LongAdjustedNonMarginableVolume	,
			@ShortAdjustedNonMarginalVolume		,
			@PayCollect							,
			@LongContractsTraded				,
			@ShortContractsTraded				,
			@LongLotsTraded						,
			@ShortLotsTraded					,
			@ContingentMargin					,
			@PremiumPayCollect					,
			@ContigentPrice						,
			@ManuallyExercisedLots				,
			@AutoExercisedLots					,
			@ManuallyDeliveredLots				,
			@AutoDeliveredLots					,
			@ManuallySettledLots				,
			@AutoSettledLots					,
			@LongExpiredLots					,
			@ShortExpiredLots					,
			@LongTransferredIn					,
			@LongTransferredOut					,
			@ShortTransferredIn					,
			@ShortTransferredOut				,
			@AssignedLots						,
			@LotsSize							,
			@PositionType						,
			@FileName

			)
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Rule_GetTemplatesByRuleType]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Rule_GetTemplatesByRuleType]
	@ruleTypeId int = NULL
AS
SET NOCOUNT ON
	IF @ruleTypeId IS NOT NULL
	BEGIN
		SELECT
			T.TemplateId, T.[Description], T.[TypeCode]
		FROM
			[dbo].[ib_Template] AS T
		INNER JOIN
			[dbo].[ib_TemplateType] TT ON TT.[Code] = T.[TypeCode] AND IsAutomatchEnabled = 1
		--INNER JOIN
			--[dbo].[ib_RuleType] RT ON RT.TemplateTypeId = TT.TemplateTypeId AND RT.RuleTypeId = @ruleTypeId
		ORDER BY
			T.[Description]
	END
	ELSE
	BEGIN
		SELECT 
			T.TemplateId, T.[Description], T.[TypeCode]
		FROM
			[dbo].[ib_Template] AS T
		INNER JOIN
			[dbo].[ib_TemplateType] TT ON TT.[Code] = T.[TypeCode] AND IsAutomatchEnabled = 1
		---INNER JOIN
		--	[dbo].[ib_RuleType] RT ON RT.TemplateTypeId = TT.TemplateTypeId --AND RT.RuleTypeId = @ruleTypeId
		ORDER BY
			T.[Description]
	END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_InstrumentDataSource_GetInstrumentDataSourceById]''
');

GO
EXECUTE ('/*
<details>
 <summary> Selectes an instrument data source from the ib_InstrumentDataSource table by its id</summary>
 <created author="Laurentiu Macovei" Date="Tuesday, 12 September 2006 9:34PM GMT" /> 
</details>
Version		Date		Author			Description
1.1			01 Feb 2007	LM				Changed inner join to Currency to Outer join
			29 Oct 2009	amk				Add in price divisor
			26 Apr 2010	AAJM			MBAL-15413 Add BaseId which will now be stored on InstrumentDataSource
			23 Jun 2010 ED MBAL 15913 - Tidy up Trade/Settlement Price Corrections for Rounded Prices

*/
CREATE PROCEDURE [dbo].[ib_InstrumentDataSource_GetInstrumentDataSourceById]
(
	@InstrumentDataSourceId int
)
AS 
SET NOCOUNT ON


SELECT ids.[InstrumentDataSourceId]
      ,ids.[InstrumentId]
	  ,i.[Name] as InstrumentName
	  ,i.[Code] as InstrumentCode
      ,ids.[DataSourceId]
	  ,ds.[Name] as DataSourceName
      ,ids.[DataSourceInstrumentCode]
      ,ids.[CurrencyId]
	  ,c.[Code] as CurrencyCode
      ,ids.[MarketValueDivisor]
	  ,ids.[StrikePriceDivisor]	
      ,ids.[CreateDate]
      ,ids.[CreateUsername]
      ,ids.[UpdateDate]
      ,ids.[UpdateUsername]
      ,ids.[PriceDivisor]
      , ids.[BaseId]
      ,b.[Name] as BaseName
      ,RunCloseOutReport
FROM [dbo].[ib_InstrumentDataSource] ids
INNER JOIN [dbo].[ib_Instrument] i ON i.[InstrumentId] = ids.[InstrumentId]
INNER JOIN [dbo].[ib_DataSource] ds ON ds.[DataSourceId] = ids.[DataSourceId]
LEFT OUTER JOIN [dbo].[ib_Currency] c ON c.[CurrencyId] = ids.[CurrencyId]
LEFT JOIN [dbo].[ib_Base] b ON b.[BaseId] = ids.[BaseId]
WHERE InstrumentDataSourceId = @InstrumentDataSourceId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_DGCX_Position_Load]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_DGCX_Position_Load] 
	(
		@LocationPath VARCHAR(100)
		,@ReceiveLocationSysId INT
		,@RunId INT
	)
AS
SET NOCOUNT ON

-- Description:	This stored procedure pulls data from the DGCX_Position temp
-- table and inserts it into ib_Position
-- Whilst iterating through the records in DGCX_Position, all 
-- of these inserts are wrapped in a transaction so that any failure causes
-- the changes to not commit.

-- 26 Apr 2012	AAJM	Creation
-- 30 Apr 2012	AAJM	Move addition of FileImport record to earlier to allow for rollback if load issues
-- 03 May 2012	AAJM	Ensure import log messages specify DataSourceId
-- 14 Sep 2012	AAJM	MBAL-21654 Make expiry day the last day in the month
-- 02 Jan 2014  RD		MBAL-24931 Added checking file age
-- 09 Jan 2014	ED		EIB 25004 - remove importLog table and use Log table
-- 25 Apr 2014	ED		EIB 25473 - raise error if file is too old and mark temp records as LoadState=3

BEGIN

	DECLARE @Message			VARCHAR(1024)
	DECLARE @AddCount			INT
	SET @AddCount = 0
					
	DECLARE @DataSourceCode VARCHAR(100)
	DECLARE @DataSourceId INT
	DECLARE @Code VARCHAR(100)
	DECLARE @Code2 VARCHAR(100)
	DECLARE @ReturnValue INT
	DECLARE @Output INT
	DECLARE @Output2 INT
	DECLARE @DefaultCurrencyId INT
			
	-- Get Datasource
	SET @DataSourceCode = ''DGCX''
	IF @LocationPath IS NULL SET @LocationPath = @DataSourceCode

	SET @Code = @DataSourceCode
	EXEC @ReturnValue= [_ib_DataSource_GetByCodeForOutput] @Code,@OutPut output,@Output2 output	
	SET @DataSourceId = @Output
	SET @DefaultCurrencyId = @Output2	

	-- Duplicate file check										
	DECLARE @IsFileAlreadyLoaded INT
	EXEC @IsFileALreadyLoaded = HasFileBeenLoaded @LocationPath, @DataSourceId

	IF @IsFileAlreadyLoaded = 1
	BEGIN
		UPDATE [DGCX_Position]
		SET LoadState = 3
		WHERE LoadState = 1
			AND FileName = @LocationPath		
		RETURN
	END
	
	-- Store ImportFile record for use
	DECLARE @ImportFileId INT
	EXEC ib_ImportFile_Add @DataSourceId, @LocationPath, @ImportFileId output
	
	-- Set AsOfDate from Filename
	DECLARE @AsOfDate DATETIME
	EXEC [dbo].[TryParseYYYYMMDDFromEndOfFilename] @LocationPath, @AsOfDate OUTPUT
	
	DECLARE @WrongDate AS DATETIME
	SET @WrongDate = NULL
	
	SET @WrongDate = ( SELECT TOP(1) [Date] FROM DGCX_Position p
	WHERE CONVERT(DATETIME, p.Date, 6) <> @AsOfDate
		AND [FileName] = @LocationPath AND LoadState = 1 )
	
	IF @WrongDate IS NOT NULL
	BEGIN			
			--check on validation
			RETURN 0
		END	
	
	--rd - make sure the As Of Date is not older than acceptable
	DECLARE @IsAcceptable bit
	EXECUTE [dbo].[Load_IsFileTooOld] @DataSourceId,@LocationPath,@AsOfDate,@IsAcceptable OUTPUT, @ReceiveLocationSysId, @RunId
	IF (@IsAcceptable = 0)
	BEGIN
		UPDATE DGCX_Position SET [LoadState] = 3 WHERE [Filename] = @LocationPath
		RAISERROR (''File is too old.'', 18, 0)
		RETURN 0
	END

	--Gets the defaultStrikePriceDivisor
	DECLARE	@DefaultStrikePriceDivisor	DECIMAL(19,6)
	SET @DefaultStrikePriceDivisor = [dbo].[udf_GetDefaultStrikePriceDivisor](@DataSourceId, NULL)
	
	IF OBJECT_ID(''tempdb..#temp9'') IS NOT NULL 
		DROP TABLE #temp9
		
	CREATE TABLE #temp9
	(
		DGCX_PositionID		INT
		, FirmCode					VARCHAR(64)
		, Account					VARCHAR(64)
		, AsOfDateChr				VARCHAR(11)
		, InstrumentType			VARCHAR(15)
		, ContractCode				VARCHAR(255)
		, QuantityLongChr			VARCHAR(12)
		, QuantityShortChr			VARCHAR(12)
		, FuturesMarketValue		VARCHAR(25)
		, OptionsMarketValue		VARCHAR(25)
		, ExpiryDate				VARCHAR(11)
		, StrikePriceChr			VARCHAR(28)
		, OptionTypeCode			VARCHAR(2)
		, TradedLongQtyChr			VARCHAR(12)
		, TradedShortQtyChr			VARCHAR(12)
		, SettlementPriceChr		VARCHAR(12)		
	)

	INSERT INTO #temp9
	(
		DGCX_PositionID
		, FirmCode
		, Account
		, AsOfDateChr
		, InstrumentType
		, ContractCode
		, QuantityLongChr
		, QuantityShortChr
		, FuturesMarketValue
		, OptionsMarketValue
		, ExpiryDate
		, StrikePriceChr
		, OptionTypeCode
		, TradedLongQtyChr
		, TradedShortQtyChr
		, SettlementPriceChr
	)
	SELECT 	
		[DGCX_PositionID]
		, LTRIM(RTRIM([TradingMemberCode]))
		, LTRIM(RTRIM([ClientCode]))
		, [Date]
		, LTRIM(RTRIM([InstrumentType]))
		, LTRIM(RTRIM([ContractCode]))
		, [PostDelExerAssignLongQty]
		, [PostDelExerAssignShortQty]
		, [DailyMTMSettlementValue]
		, [DelMarkedExAssignValue]	
		, [ExpiryDate]
		, [StrikePrice]
		, LTRIM(RTRIM([OptionType]))
		, [DayBuyQty]
		, [DaySellQty]	
		, [SettlementPrice]	

	FROM [dbo].[DGCX_Position]
	WHERE LoadState = 1
		AND [Filename] = @LocationPath

	SET XACT_ABORT ON 

	BEGIN TRAN T1

		-- BizTalk''s SQL Adapter uses more restrictive read serializable
		-- so this is necessary to relax it to something that is default
		-- and perfectly acceptable!
		SET TRANSACTION ISOLATION LEVEL READ COMMITTED

		BEGIN TRY
		
			DECLARE @DGCX_PositionID			INT
			DECLARE @FirmCode					VARCHAR(64)
			DECLARE @Account					VARCHAR(64)
			DECLARE @Currency					VARCHAR(3)
			DECLARE @AsOfDateChr				VARCHAR(11)
			DECLARE @InstrumentType				VARCHAR(15)
			DECLARE @ContractCode				VARCHAR(255)
			DECLARE @QuantityLongChr			VARCHAR(12)
			DECLARE @QuantityShortChr			VARCHAR(12)
			DECLARE @FuturesMarketValueChr		VARCHAR(25)
			DECLARE @OptionsMarketValueChr		VARCHAR(25)
			DECLARE @ExpiryDateChr				VARCHAR(11)
			DECLARE @StrikePriceChr				VARCHAR(28)
			DECLARE @OptionTypeCode				VARCHAR(2)
			DECLARE @TradedLongQtyChr			VARCHAR(12)
			DECLARE @TradedShortQtyChr			VARCHAR(12)
			DECLARE @SettlementPriceChr			VARCHAR(12)

			DECLARE pos_cursor CURSOR FOR
			SELECT	DGCX_PositionID
				    , FirmCode
				  	, Account
					, AsOfDateChr
					, InstrumentType
					, ContractCode
					, QuantityLongChr
					, QuantityShortChr
					, FuturesMarketValue
					, OptionsMarketValue
					, ExpiryDate
					, StrikePriceChr
					, OptionTypeCode
					, TradedLongQtyChr
					, TradedShortQtyChr
					, SettlementPriceChr					--

			FROM	#temp9

			OPEN pos_cursor

			FETCH NEXT FROM pos_cursor
			INTO 
					@DGCX_PositionID
					, @FirmCode
					, @Account
					, @AsOfDateChr
					, @InstrumentType
					, @ContractCode
					, @QuantityLongChr
					, @QuantityShortChr
					, @FuturesMarketValueChr	
					, @OptionsMarketValueChr
					, @ExpiryDateChr
					, @StrikePriceChr
					, @OptionTypeCode
					, @TradedLongQtyChr
					, @TradedShortQtyChr
					, @SettlementPriceChr

				-- Check @@FETCH_STATUS to see IF there are any more rows to fetch.
				WHILE @@FETCH_STATUS = 0
				BEGIN
					DECLARE		@AccountCd				VARCHAR(100)
					DECLARE		@ExchangeCd				VARCHAR(25)
					DECLARE		@AsOfDateFromRecord		DATETIME
					DECLARE		@InstrumentCd			VARCHAR(100)
					DECLARE		@MarketValueDec			DECIMAL(19,4)
					DECLARE		@ExpiryDate				DATETIME
					DECLARE		@ExpYr					SMALLINT
					DECLARE		@ExpMth					SMALLINT
					DECLARE		@ExpDay					SMALLINT
					DECLARE		@StrikePrice			DECIMAL(19,4)
					DECLARE		@PriceDivisor			DECIMAL(19,4)
					DECLARE		@StrikePriceDivisor		DECIMAL(19,4)
					DECLARE		@MarketValueDivisor		DECIMAL(19,4)
					DECLARE		@SettlementPrice		DECIMAL(24,10)
					DECLARE		@TrxTypeCd				VARCHAR(25)
					DECLARE		@TrxDate				DATETIME
					DECLARE		@InstrumentTypeCd		VARCHAR(100)
					DECLARE     @ErrorMessageForRecord	VARCHAR(1024)
					DECLARE		@ErrorSeverity			INT
					DECLARE		@ErrorState				INT
					DECLARE		@QuantityLong			DECIMAL(19,4)
					DECLARE		@QuantityShort			DECIMAL(19,4)
					DECLARE		@SignedQuantity			DECIMAL(19,4)
					DECLARE		@OptionTypeCodeTranslated		VARCHAR(1)
					DECLARE		@TradedQuantityLong		DECIMAL(19,4)
					DECLARE		@TradedQuantityShort	DECIMAL(19,4)
					-- Temporary variables
                    DECLARE     @TempDate DATETIME
								
			SET	@ExchangeCd = ''DGCX'' -- Hard code as this datasource is for the single exchange
		
			-- Ensure account code is in correct format (strip off account type and hyphen at start)
			SET @AccountCd = @Account
			DECLARE @AccountType CHAR
			SET @AccountType = LEFT(@AccountCd, 1)
			IF (@AccountType = ''H'' OR @AccountType = ''N'' OR @AccountType = ''S'')
			BEGIN
				DECLARE @AccountHyphenIndex int
				SET @AccountHyphenIndex = CHARINDEX(''-'', @AccountCd)
				IF (@AccountHyphenIndex = 2)
					SET @AccountCd = RIGHT(@AccountCd, LEN(@AccountCd) - @AccountHyphenIndex)
			END
			
			-- No currency on file
			-- Use default process to ascertain = use InstrumentDataSource or DataSource default
			SET @Currency = null 
			
			
			-- Set ExpiryDate
			SET @ExpiryDate = CONVERT(DATETIME, @ExpiryDateChr, 6)
			
			SET @ExpYr = YEAR(@ExpiryDate)
			SET @ExpMth = MONTH(@ExpiryDate)
			SET @ExpDay = dbo.udf_GetDaysInMonth(@ExpYr,@ExpMth)
			
			-- Set InstrumentTypeCd
			IF @InstrumentType = ''FUTURE''
				SET @InstrumentTypeCd = ''F''
			ELSE IF @InstrumentType = ''OPTION''
				SET @InstrumentTypeCd = ''O''
				
			-- Ensure contract code is in correct format (exclude everything from first hyphen onwards)
			DECLARE @ContractCodeHyphenIndex int
			DECLARE @FormattedContractCode VARCHAR(64)
			SET @FormattedContractCode = @ContractCode
			SET @ContractCodeHyphenIndex = CHARINDEX(''-'', @FormattedContractCode)
			IF (@ContractCodeHyphenIndex != 0 AND @ContractCodeHyphenIndex IS NOT NULL)
				SET @FormattedContractCode = LEFT(@FormattedContractCode, @ContractCodeHyphenIndex - 1)
			
			-- We prefix the Instruments with the IntrumentTypeCode
			SET @InstrumentCd = @InstrumentTypeCd + ''_'' + @ExchangeCd + ''_'' + @FormattedContractCode


			-- Set Option Type Code for position load
			SET @OptionTypeCodeTranslated = '' ''
						
			IF @OptionTypeCode IN (''CA'',''CE'')
				SET @OptionTypeCodeTranslated = ''C''
			ELSE 
				BEGIN
					IF @OptionTypeCode IN (''PA'',''PE'')
						SET @OptionTypeCodeTranslated = ''P''
				END
	
			-- Get Divisors						
			SET @StrikePriceDivisor = NULL
			SET	@PriceDivisor = NULL
			SET	@MarketValueDivisor = NULL
								
			SELECT @StrikePriceDivisor = ids.StrikePriceDivisor
					, @PriceDivisor = ids.PriceDivisor
					, @MarketValueDivisor = ids.MarketValueDivisor
			FROM [dbo].[ib_InstrumentDataSource] ids
			WHERE ids.DataSourceId = @DataSourceId
				AND ids.DataSourceInstrumentCode = @InstrumentCd
											
			-- Set Settlement Price				
			IF @PriceDivisor IS NULL 
				SET @PriceDivisor = 1				

			SET @SettlementPrice = CONVERT(DECIMAL(24,10), @SettlementPriceChr) / @PriceDivisor
			
			-- Set StrikePrice
			SET @StrikePrice = NULL
			IF @InstrumentTypeCd = ''F''
			BEGIN
			SET @StrikePrice = 0
			END
			ELSE
			BEGIN
			IF @StrikePriceDivisor IS NULL
				BEGIN
					SET @StrikePrice = CAST(@StrikePriceChr AS DECIMAL(19,4)) / ISNULL(@DefaultStrikePriceDivisor, 1)
				END
			ELSE
				BEGIN
					SET @StrikePrice = CAST(@StrikePriceChr AS DECIMAL(19,4)) / @StrikePriceDivisor
				END			
			END
			
			-- Set TrxTypeCd
			SET @TrxTypeCd = ''POSITION''
						
			-- Set Quantity 

			SET @QuantityLong = 0
			SET @QuantityShort = 0
			SET @TradedQuantityLong = 0
			SET @TradedQuantityShort = 0

			-- Set Quantity (on validation check if convertible)
			
			SET @QuantityLong = CONVERT(DECIMAL(19,4), @QuantityLongChr)
			SET @QuantityShort = CONVERT(DECIMAL(19,4), @QuantityShortChr)
			SET @TradedQuantityLong = CONVERT(DECIMAL(19,4), @TradedLongQtyChr)
			SET @TradedQuantityShort = CONVERT(DECIMAL(19,4), @TradedShortQtyChr)
			
			-- Set Quantity
			IF @QuantityLong <> 0
				SET @SignedQuantity = @QuantityLong
			ELSE
				SET @SignedQuantity = @QuantityShort * (-1)
		
			-- Set Market Value
			IF @MarketValueDivisor IS NULL 
				SET @MarketValueDivisor = 1
			
			IF @InstrumentTypeCd = ''F''
				SET @MarketValueDec = CONVERT(DECIMAL(19,4), @FuturesMarketValueChr) / @MarketValueDivisor
			ELSE IF @InstrumentTypeCd = ''O''
				SET @MarketValueDec = CONVERT(DECIMAL(19,4), @OptionsMarketValueChr) / @MarketValueDivisor


			-- TrxDate
			SET @TrxDate = GETDATE()  -- This is not actually used

			DECLARE @PositionId INT
			SET @PositionId = NULL
			
			EXEC [ib_Position_Load]
			@DataSourceCode			
			, @ExchangeCd
			, @FirmCode -- Firm will be added if not present					
			, @AccountCd				
			, @AsOfDate				
			, @InstrumentCd			
			, @SignedQuantity			
			, @MarketValueDec			
			, @ExpYr					
			, @ExpMth					
			, @ExpDay	
			, @StrikePrice			
			, @TrxTypeCd				
			, @OptionTypeCodeTranslated	
			, @TrxDate 			
			, @SettlementPrice -- This value is NOT actually used in the ib_Position_Load Stored Procedure, should be removed ?			
			, @DGCX_PositionID
			, @InstrumentTypeCd		
			, @LocationPath
			, @Currency
			, @LongQuantity = @QuantityLong
			, @ShortQuantity = @QuantityShort
			, @TradedLongQuantity = @TradedQuantityLong
			, @TradedShortQuantity = @TradedQuantityShort
			, @PositionId = @PositionId output
			, @ReceiveLocationSysId = @ReceiveLocationSysId
			, @RunId = @RunId
			-- ClassId will be retrieved based on Account and Firm
			
			-- Add Settlement Price											
			EXEC ib_Price_AddFromPositionLoad
				@PositionId
				, @ImportFileId
				, @SettlementPrice 	
				
			--flip processed flag in source table.
			UPDATE [DGCX_Position] 
			WITH (ROWLOCK)
			SET [LoadState] = 2
			WHERE [DGCX_PositionID] = @DGCX_PositionID 
				AND [LoadState] = 1
				
			SET @AddCount = @AddCount + 1

			FETCH NEXT FROM pos_cursor
			INTO 
					@DGCX_PositionID
					, @FirmCode
					, @Account
					, @AsOfDateChr
					, @InstrumentType
					, @ContractCode
					, @QuantityLongChr
					, @QuantityShortChr
					, @FuturesMarketValueChr	
					, @OptionsMarketValueChr
					, @ExpiryDateChr
					, @StrikePriceChr
					, @OptionTypeCode
					, @TradedLongQtyChr
					, @TradedShortQtyChr
					, @SettlementPriceChr

		END
			
			CLOSE pos_cursor
			DEALLOCATE pos_cursor

			SET @Message = @DataSourceCode + '' position loader ended ('' 
				+ CONVERT(VARCHAR(10), @AddCount) + '' added)'' 
		
			EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @Message, ''Success'', '''', @RunId

			UPDATE ib_ImportFile
			SET AsOfDate = @AsOfDate
			WHERE ImportFileId = @ImportFileId
			
		COMMIT TRAN T1

	DROP TABLE #temp9
	
	END TRY
	BEGIN CATCH 

		IF XACT_STATE() = -1 
			ROLLBACK TRANSACTION
	
		SET @Message = @DataSourceCode + '' position loader failed'' 		
		EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @Message, ''Error'', '''', @RunId
	
		EXEC [dbo].[sp_RethrowError]
		
	END CATCH 

	SET XACT_ABORT OFF
	
END

RETURN 0
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_DataSourceExchange_CheckForDuplicate]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_DataSourceExchange_CheckForDuplicate]
@Code VARCHAR(100)
, @DataSourceId INT
, @DataSourceExchangeId INT
AS
SET NOCOUNT ON
-- 08 Nov 2010	AAJM	Updated to allow DataSourceExchangeCode unique to DataSource but not
--						unique to table.
DECLARE @Count INT

SELECT @Count = 1
	FROM [dbo].[ib_DataSourceExchange] dse
	WHERE dse.DataSourceExchangeCode = @Code
		AND dse.DataSourceId = @DataSourceId
		AND dse.DataSourceExchangeID <> @DataSourceExchangeId

IF @Count > 0
	RAISERROR (N''There is already another DataSourceExchange with same code (%s) for the specified Data Source. Please specify a different code.'', 11, 1, @Code)
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_DataSourceExchange_Add]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_DataSourceExchange_Add]
(
	@DataSourceId					INT
	, @ExchangeId					INT
	, @DataSourceExchangeCode		VARCHAR(100) = NULL
	, @CreateUsername				VARCHAR(255) = ''''
	, @@DataSourceExchangeId		INT OUTPUT
)
AS
SET NOCOUNT ON
/*
Programmer:  Petru Konrad Bercea
Date:        17/02/09
Description: Inserts value into DataSourceExchange if lookup fails
-- 
--	08 Nov 2010	AAJM	Updated to allow DataSourceExchangeCode unique to DataSource but not
--						unique to table.
*/
BEGIN TRY
--check for duplicates 
EXEC [dbo].[ib_DataSourceExchange_CheckForDuplicate] @DataSourceExchangeCode, @DataSourceId, -1

	INSERT INTO ib_DataSourceExchange 
		(
			[DataSourceId],
			[ExchangeId],
			[DataSourceExchangeCode],
			CreateUsername
		)
	VALUES 
		(
			@DataSourceId,
			@ExchangeId,
			@DataSourceExchangeCode,
			@CreateUsername 
		)

SELECT @@DataSourceExchangeId = SCOPE_IDENTITY()
END TRY
BEGIN CATCH
	EXEC [dbo].[sp_RethrowError]
END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[Broker_Transaction_Add]''
');

GO
EXECUTE ('




-- =============================================
-- Author:		Petru Konrad Bercea
-- Create date: 13.05.2009
-- Description:	Insert into Broker_Transaction table
--
-- Revision History
--
-- =============================================
CREATE PROCEDURE [dbo].[Broker_Transaction_Add]
	-- Add the parameters for the stored procedure here
	(
		@FileName varchar(512) = NULL,
		@serial_number varchar(11) = NULL,
		@trade_date varchar(8) = NULL,
		@trade_time varchar(8) = NULL,
		@trade_type varchar(8) = NULL,
		@account varchar(35) = NULL,
		@delivery_month varchar(8) = NULL,
		@host_instrument varchar(35) = NULL,
		@lots varchar(21) = NULL,
		@lot_size varchar(21) = NULL,
		@exchange_code varchar(50) = NULL,
		@call_put varchar(3) = NULL,
		@strike_price varchar(21) = NULL,
		@trade_price varchar(21) = NULL,
		@currency varchar(3) = NULL,
		@amount_paid varchar(21) = NULL,
		@expiration_date varchar(8) = NULL,
		@broker_code varchar(50) = NULL,
		@commission varchar(21) = NULL,
		@post_date varchar(8) = NULL,
		@settlement_date varchar(8) = NULL,
		@nominal_value varchar(35) = NULL,
		@nominal_amount varchar(35) = NULL,
		@exchange_rate varchar(21) = NULL,
		@exchange_rate_ind varchar(21) = NULL,
		@run_date varchar(8) = NULL,
		@record_type varchar(3) = NULL,
		@link_number varchar(8) = NULL,
		@comment varchar(100) = NULL,
		@fas_acn varchar(5) = NULL
    )
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

  INSERT INTO [dbo].[Broker_Transaction]
			( 
				[FileName],
				[serial_number],
				[trade_date],
				[trade_time],
				[trade_type],
				[account],
				[delivery_month],
				[host_instrument],
				[lots],
				[lot_size],
				[exchange_code],
				[call_put],
				[strike_price],
				[trade_price],
				[currency],
				[amount_paid],
				[expiration_date],
				[broker_code],
				[commission],
				[post_date],
				[settlement_date],
				[nominal_value],
				[nominal_amount],
				[exchange_rate],
				[exchange_rate_ind],
				[run_date],
				[record_type],
				[link_number],
				[comment],
				[fas_acn]
			)
    VALUES
			( 
				@FileName,
				@serial_number,
				@trade_date,
				@trade_time,
				@trade_type,
				@account,
				@delivery_month,
				@host_instrument,
				@lots,
				@lot_size,
				@exchange_code,
				@call_put,
				@strike_price,
				@trade_price,
				@currency,
				@amount_paid,
				@expiration_date,
				@broker_code,
				@commission,
				@post_date,
				@settlement_date,
				@nominal_value,
				@nominal_amount,
				@exchange_rate,
				@exchange_rate_ind,
				@run_date,
				@record_type,
				@link_number,
				@comment,
				@fas_acn
			)
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Rule_GetToleranceTypes]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Rule_GetToleranceTypes]
AS
SET NOCOUNT ON
	SELECT
		Code
		,ToleranceTypeId
		,Description
	FROM
		[dbo].[ib_tolerancetype]
	ORDER BY
		Description
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_InstrumentDataSource_GetInstrumentDataSourceIdByCode]''
');

GO
EXECUTE ('-- =============================================
-- Author:		Lee Manifold
-- Create date: 22 December 2006
-- Description:	Retrieve Instrument id

CREATE proc [dbo].[ib_InstrumentDataSource_GetInstrumentDataSourceIdByCode]
	(
	@DataSourceId int,
	@Code varchar(25),
	@InstrumentDataSourceId int output
	)

AS
SET NOCOUNT ON

	SELECT	@InstrumentDataSourceId = [InstrumentDataSourceId]

	FROM	[dbo].[ib_InstrumentDataSource]
	
	WHERE	[DataSourceInstrumentCode] = @Code
	AND		[DataSourceId] = @DataSourceId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_DGCX_Transaction_Load]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_DGCX_Transaction_Load] 
	-- Add the parameters for the stored procedure here
	(
		@LocationPath VARCHAR(100)
		,@ReceiveLocationSysId INT
		,@RunId INT
	)
AS
SET NOCOUNT ON

-- Description:	This stored procedure pulls data from the DGCX_Transaction temp
-- table and inserts it into ib_Trx
-- Whilst iterating through the records in DGCX_Transaction, all 
-- of these inserts are wrapped in a transaction so that any failure causes
-- the changes to not commit.
--
-- 26 Apr 2012	AAJM	Creation
-- 30 Apr 2012	AAJM	Move addition of FileImport record to earlier to allow for rollback if load issues
-- 03 May 2012	AAJM	Ensure import log messages specify DataSourceId
-- 11 May 2012  ED		MBAL 20756 Set StrikePrice to 0 if Future(@InstrumentTypeCd = ''F'')
-- 14 Sep 2012	AAJM	MBAL-21654 Make expiry day the last day in the month
-- 02 Jan 2014  RD		MBAL-24931 Added checking file age
-- 09 Jan 2014	ED		EIB 25004 - remove importLog table and use Log table
-- 25 Apr 2014	ED		EIB 25473 - raise error if file is too old and mark temp records as LoadState=3

BEGIN

	DECLARE @Message			VARCHAR(1024)
	DECLARE @AddCount			INT
	SET @AddCount = 0
					
	DECLARE @DataSourceCode VARCHAR(100)
	DECLARE @DataSourceId INT
	DECLARE @Code VARCHAR(100)
	DECLARE @Code2 VARCHAR(100)
	DECLARE @ReturnValue INT
	DECLARE @Output INT
	DECLARE @Output2 INT
	DECLARE @DefaultCurrencyId INT
			
	-- Get Datasource
	SET @DataSourceCode = ''DGCX''
	IF @LocationPath IS NULL SET @LocationPath = @DataSourceCode

	SET @Code = @DataSourceCode
	EXEC @ReturnValue= [_ib_DataSource_GetByCodeForOutput] @Code,@OutPut output,@Output2 output	
	SET @DataSourceId = @Output
	SET @DefaultCurrencyId = @Output2	

	-- Duplicate file check										
	DECLARE @IsFileAlreadyLoaded INT
	EXEC @IsFileALreadyLoaded = HasFileBeenLoaded @LocationPath, @DataSourceId

	IF @IsFileAlreadyLoaded = 1
	BEGIN
		UPDATE DGCX_Transaction
		SET LoadState = 3
		WHERE LoadState = 1
			AND FileName = @LocationPath		
		RETURN
	END
	
	-- Store ImportFile record for use
	DECLARE @ImportFileId INT
	EXEC ib_ImportFile_Add @DataSourceId, @LocationPath, @ImportFileId output
	
	-- Set AsOfDate from Filename
	DECLARE @AsOfDate DATETIME
	EXEC [dbo].[TryParseYYYYMMDDFromEndOfFilename] @LocationPath, @AsOfDate OUTPUT
	
	--rd - make sure the As Of Date is not older than acceptable
	DECLARE @IsAcceptable bit
	EXECUTE [dbo].[Load_IsFileTooOld] @DataSourceId,@LocationPath,@AsOfDate,@IsAcceptable OUTPUT, @ReceiveLocationSysId, @RunId
	IF (@IsAcceptable = 0)
	BEGIN
		UPDATE DGCX_Transaction SET [LoadState] = 3 WHERE [Filename] = @LocationPath
		RAISERROR (''File is too old.'', 18, 0)
		RETURN 0
	END

	--Gets the defaultStrikePriceDivisor
	DECLARE	@DefaultStrikePriceDivisor	DECIMAL(19,6)
	SET @DefaultStrikePriceDivisor = [dbo].[udf_GetDefaultStrikePriceDivisor](@DataSourceId, NULL)
	
	
	IF OBJECT_ID(''tempdb..#temp8'') IS NOT NULL 
	DROP TABLE #temp8
		
	CREATE TABLE #temp8
	(
		DGCX_TransactionID			INT
		, FirmCode					VARCHAR(64)
		, Account					VARCHAR(64)		
		, TrxDateChr				VARCHAR(8)
		, TradedTime				VARCHAR(20)
		, InstrumentCode			VARCHAR(15)
		, ContractCode				VARCHAR(64)
		, QuantityChr				VARCHAR(16)
		, BuySell					VARCHAR(1)
		, PriceChr					VARCHAR(28)
		, ExpiryDate				VARCHAR(11)
		, StrikePriceChr			VARCHAR(28)
		, TrxTypeCode				VARCHAR(20)
		, OptionTypeCode			VARCHAR(2)

	)

	INSERT INTO #temp8
	(
		DGCX_TransactionID
		, FirmCode
		, Account	
		, TradedTime	
		, InstrumentCode
		, ContractCode
		, QuantityChr			
		, BuySell		
		, PriceChr	
		, ExpiryDate
		, StrikePriceChr
		, TrxTypeCode	
		, OptionTypeCode
	)
	SELECT 	
		[DGCX_TransactionID]
		, [TradingMemberId]	
		, LTRIM(RTRIM([Account]))
		, [TradedTime]
		, LTRIM(RTRIM([InstrumentName]))
		, LTRIM(RTRIM([ContractCode]))
		, LTRIM(RTRIM([TradeQty]))
		, [BuySellInd]
		, LTRIM(RTRIM([Price]))
		, [ExpiryDate]
		, [StrikePrice]
		, LTRIM(RTRIM([TradeStatus]))
		, LTRIM(RTRIM([OptionType]))
		
	FROM [dbo].[DGCX_Transaction]
	WHERE LoadState = 1
		AND [Filename] = @LocationPath

	SET XACT_ABORT ON 

	BEGIN TRAN T1

		-- BizTalk''s SQL Adapter uses more restrictive read serializable
		-- so this is necessary to relax it to something that is default
		-- and perfectly acceptable!
		SET TRANSACTION ISOLATION LEVEL READ COMMITTED

		BEGIN TRY

			DECLARE @DGCX_TransactionID	INT
			DECLARE @FirmCode					VARCHAR(64)
			DECLARE @Account					VARCHAR(64)
			DECLARE @TradedTime					VARCHAR(20)
			DECLARE @InstrumentCode				VARCHAR(15)
			DECLARE @ContractCode				VARCHAR(64)			
			DECLARE @QuantityChr				VARCHAR(16)
			DECLARE @BuySell					VARCHAR(1)
			DECLARE @PriceChr					VARCHAR(28)	
			DECLARE @ExpiryDateChr				VARCHAR(11)
			DECLARE @StrikePriceChr				VARCHAR(28)
			DECLARE @Currency					VARCHAR(3)
			DECLARE @TrxDateChr					VARCHAR(8)
			DECLARE @TrxTypeCode				VARCHAR(20)	
			DECLARE @OptionTypeCode				VARCHAR(2)

			DECLARE trx_cursor CURSOR FOR
			SELECT DGCX_TransactionID
					, FirmCode
					, Account
					, TradedTime
					, InstrumentCode
					, ContractCode
					, QuantityChr			
					, BuySell		
					, PriceChr
					, ExpiryDate
					, StrikePriceChr
					, TrxTypeCode
					, OptionTypeCode
					
			FROM #temp8

			OPEN trx_cursor

			FETCH NEXT FROM trx_cursor
			INTO 
					@DGCX_TransactionID
					, @FirmCode
					, @Account		
					, @TradedTime			
					, @InstrumentCode
					, @ContractCode
					, @QuantityChr
					, @BuySell	
					, @PriceChr
					, @ExpiryDateChr
					, @StrikePriceChr
					, @TrxTypeCode
					, @OptionTypeCode

				-- Check @@FETCH_STATUS to see IF there are any more rows to fetch.
				WHILE @@FETCH_STATUS = 0
				BEGIN
					DECLARE		@AccountCd				VARCHAR(100)
					DECLARE		@ExchangeCd				VARCHAR(25)
					DECLARE		@InstrumentCd			VARCHAR(100)
					DECLARE		@Quantity				DECIMAL(19,4)
					DECLARE		@MarketValueDec			DECIMAL(19,4)
					DECLARE		@ExpiryDate				DATETIME
					DECLARE		@ExpYr					SMALLINT
					DECLARE		@ExpMth					SMALLINT
					DECLARE		@ExpDay					SMALLINT
					DECLARE		@StrikePrice			DECIMAL(19,4)
					DECLARE		@PriceDivisor			DECIMAL(19,4)
					DECLARE		@StrikePriceDivisor		DECIMAL(19,4)
					DECLARE		@MarketValueDivisor		DECIMAL(19,4)
					DECLARE		@Price					DECIMAL(24,10)
					DECLARE		@TrxDate				DATETIME
					DECLARE		@InstrumentTypeCd		VARCHAR(100)
					DECLARE     @ErrorMessageForRecord	VARCHAR(1024)
					DECLARE		@ErrorSeverity			INT
					DECLARE		@ErrorState				INT
					DECLARE		@QuantityLong			DECIMAL(19,4)
					DECLARE		@QuantityShort			DECIMAL(19,4)
					DECLARE		@SignedQuantity			DECIMAL(19,4)
					DECLARE		@OptionTypeCodeTranslated		VARCHAR(1)
					
			-- Temporary variables
            DECLARE     @TempDate DATETIME
					
			SET	@ExchangeCd = ''DGCX'' -- Hard code as this datasource is for the single exchange
								
			-- Ensure account code is in correct format (strip off account type and hyphen at start)
			SET @AccountCd = @Account
			DECLARE @AccountType CHAR
			SET @AccountType = LEFT(@AccountCd, 1)
			IF (@AccountType = ''H'' OR @AccountType = ''N'' OR @AccountType = ''S'')
			BEGIN
				DECLARE @AccountHyphenIndex int
				SET @AccountHyphenIndex = CHARINDEX(''-'', @AccountCd)
				IF (@AccountHyphenIndex = 2)
					SET @AccountCd = RIGHT(@AccountCd, LEN(@AccountCd) - @AccountHyphenIndex)
			END
			
			-- No currency on file
			-- Use default process to ascertain = use InstrumentDataSource or DataSource default
			SET @Currency = null 
			
						
			-- Set ExpiryDate
			SET @ExpiryDate = CONVERT(DATETIME, @ExpiryDateChr, 6)
			
			SET @ExpYr = YEAR(@ExpiryDate)
			SET @ExpMth = MONTH(@ExpiryDate)
			SET @ExpDay = dbo.udf_GetDaysInMonth(@ExpYr,@ExpMth)
			
				
			-- Set InstrumentTypeCd
			IF @InstrumentCode = ''OPTION''
				SET @InstrumentTypeCd = ''O''
				
			IF @InstrumentCode  = ''FUTURES''
				SET @InstrumentTypeCd = ''F''
			
			-- Ensure contract code is in correct format (exclude everything from first hyphen onwards)
			DECLARE @ContractCodeHyphenIndex int
			DECLARE @FormattedContractCode VARCHAR(64)
			SET @FormattedContractCode = @ContractCode
			SET @ContractCodeHyphenIndex = CHARINDEX(''-'', @FormattedContractCode)
			IF (@ContractCodeHyphenIndex != 0 AND @ContractCodeHyphenIndex IS NOT NULL)
				SET @FormattedContractCode = LEFT(@FormattedContractCode, @ContractCodeHyphenIndex - 1)

			-- We prefix the Instruments with the IntrumentTypeCode
			SET @InstrumentCd = @InstrumentTypeCd + ''_'' + @ExchangeCd + ''_'' + @FormattedContractCode

			-- Set Option Type Code for position load
			SET @OptionTypeCodeTranslated = '' ''
 			
			IF @OptionTypeCode IN (''CA'',''CE'')
				SET @OptionTypeCodeTranslated = ''C''
			ELSE 
				BEGIN
					IF @OptionTypeCode IN (''PA'',''PE'')
						SET @OptionTypeCodeTranslated = ''P''
				END
				
			-- Get Divisors						
			SET @StrikePriceDivisor = NULL
			SET	@PriceDivisor = NULL
			SET	@MarketValueDivisor = NULL
								
			SELECT @StrikePriceDivisor = ids.StrikePriceDivisor
					, @PriceDivisor = ids.PriceDivisor
					, @MarketValueDivisor = ids.MarketValueDivisor
			FROM [dbo].[ib_InstrumentDataSource] ids
			WHERE ids.DataSourceId = @DataSourceId
				AND ids.DataSourceInstrumentCode = @InstrumentCd

			-- Set Price				
			IF @PriceDivisor IS NULL 
				SET @PriceDivisor = 1				

			SET @Price = CONVERT(DECIMAL(24,10), @PriceChr) / @PriceDivisor
			
								
			-- Set StrikePrice
			SET @StrikePrice = NULL
			
			IF ISNULL(@StrikePriceChr, '''') <> ''''
			BEGIN
				IF @StrikePriceDivisor IS NULL
					BEGIN
						SET @StrikePrice = CAST(@StrikePriceChr AS DECIMAL(19,4)) / ISNULL(@DefaultStrikePriceDivisor, 1)
					END
				ELSE
					BEGIN
						SET @StrikePrice = CAST(@StrikePriceChr AS DECIMAL(19,4)) / @StrikePriceDivisor
					END		
			END
			--set StrikePrice to 0 if Future(@InstrumentTypeCd = ''F'')
			IF @StrikePrice IS NULL AND @InstrumentTypeCd = ''F''
				SET @StrikePrice = 0
					
			-- Set Quantity 
			SET @Quantity = 0
			SET @QuantityLong = 0
			SET @QuantityShort = 0
			
			-- Set Quantity (throw an error if not convertible)
			SET @Quantity = CONVERT(DECIMAL(19,4), @QuantityChr)
						
			-- Set QuantityLong
			IF (@BuySell = ''1'')
				BEGIN
					SET @QuantityLong = @Quantity
					SET @SignedQuantity = @Quantity 
				END
			ELSE
					SET @QuantityLong = 0
								
			-- Set QuantityShort
			IF (@BuySell = ''2'')
				BEGIN
					SET @QuantityShort = @Quantity
					SET @SignedQuantity = @Quantity * (-1)
				END	
			ELSE
				SET @QuantityShort = 0
				
				
			-- Set Market Value
			IF @MarketValueDivisor IS NULL 
				SET @MarketValueDivisor = 1
			
			-- Market Value Not Applicable
			--SET @MarketValueDec = CONVERT(DECIMAL(19,4), @MarketValueChr) / @MarketValueDivisor
			
			-- TrxDate
			SET @TrxDate = [dbo].[udf_GetDatePart](CONVERT(DATETIME, @TradedTime, 101))
					
			EXEC [ib_Trx_Load]
				@DataSourceCode			
				, @ExchangeCd				
				, @FirmCode -- Firm will be added if not present					
				, @AccountCd	
				, @AccountCd -- DetailAccountCd		
				, @InstrumentCd			
				, @ExpYr					
				, @ExpMth 					
				, @ExpDay 					
				, @StrikePrice			
				, @TrxTypeCode				
				, @OptionTypeCodeTranslated
				, @SignedQuantity			
				, @TrxDate				
				, @Price 
				, @DGCX_TransactionID
				, @InstrumentTypeCd
				, @AsOfDate		
				, @LocationPath
				, @MarketValueDec
				, @Currency
				, @QuantityLong = @QuantityLong 
				, @QuantityShort = @QuantityShort
				, @ReceiveLocationSysId = @ReceiveLocationSysId
				, @RunId = @RunId
				-- ClassId will be retrieved based on Account and Firm
						
			--flip processed flag in source table.
			UPDATE [DGCX_Transaction]
			WITH (ROWLOCK)
			SET [LoadState] = 2
			WHERE [DGCX_TransactionID] = @DGCX_TransactionID
				AND [LoadState] = 1

			SET @AddCount = @AddCount + 1
			
			FETCH NEXT FROM trx_cursor
			INTO 
					@DGCX_TransactionID
					, @FirmCode
					, @Account		
					, @TradedTime			
					, @InstrumentCode
					, @ContractCode
					, @QuantityChr
					, @BuySell	
					, @PriceChr
					, @ExpiryDateChr
					, @StrikePriceChr
					, @TrxTypeCode
					, @OptionTypeCode
		END
			
		CLOSE trx_cursor
		DEALLOCATE trx_cursor

			-- Now update state of any left-over temporary transaction records
			-- so there are no ''left-overs''
			UPDATE [DGCX_Transaction]
			WITH (ROWLOCK)
			SET [LoadState] = 2
			WHERE [LoadState] = 1 AND [FileName] = @LocationPath

			SET @Message = @DataSourceCode + '' transaction loader ended ('' 
			+ CONVERT(VARCHAR(10), @AddCount) + '' added)'' 
		
			EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @Message, ''Success'', '''', @RunId

			UPDATE ib_ImportFile
			SET AsOfDate = @AsOfDate
			WHERE ImportFileId = @ImportFileId
			
		COMMIT TRAN T1

		DROP TABLE #temp8
	
	END TRY
	BEGIN CATCH 

		IF XACT_STATE() = -1 
			ROLLBACK TRANSACTION
	
		SET @Message = @DataSourceCode + '' transaction loader failed'' 		
		EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @Message, ''Error'', '''', @RunId
	
		EXEC [dbo].[sp_RethrowError]
		
	END CATCH 

	SET XACT_ABORT OFF

END

RETURN 0
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_DataSourceExchange_GetById]''
');

GO
EXECUTE ('





CREATE proc [dbo].[ib_DataSourceExchange_GetById]
@DataSourceId int,
@ExchangeId int,
@DataSourceExchangeId int output

as
SET NOCOUNT ON

select @DataSourceExchangeId = DataSourceExchangeId 
from ib_DataSourceExchange
where ExchangeId = @ExchangeId
and DataSourceId = @DataSourceId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_DataSourceExchange_AddAsNeeded]''
');

GO
EXECUTE ('

-- =============================================
-- Author:		Petru Konrad Bercea
-- Create date: 17 02 2009
-- Description:	Retrieve DataSourceExchange id
---=============================================

CREATE proc [dbo].[ib_DataSourceExchange_AddAsNeeded]
	(
		@DataSourceId				int,
		@ExchangeId					int,
		@DataSourceExchangeCode		varchar(25) = NULL,
		@DataSourceExchangeId		int output
	
	)
AS
SET NOCOUNT ON

	DECLARE @ReturnValue int
	DECLARE @Output int
	EXEC @ReturnValue= [ib_DataSourceExchange_GetById] @DataSourceId, @ExchangeId, @DataSourceExchangeId output	


	IF @DataSourceExchangeId IS NULL
	BEGIN
		
		EXEC [dbo].[ib_DataSourceExchange_Add] @DataSourceId, @ExchangeId, @DataSourceExchangeCode
		SELECT @DataSourceExchangeId = DataSourceExchangeId 
		FROM ib_DataSourceExchange
		WHERE DataSourceId = @DataSourceId
		AND ExchangeId = @ExchangeId
	END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[Broker_Transaction_LoadStateChange]''
');

GO
EXECUTE ('



-- =============================================
-- Author:		Petru Konrad Bercea
-- Create date: 13.05.2009
-- Description:	Changes the LoadState of the Broker_Transaction type table
-- =============================================
CREATE PROCEDURE [dbo].[Broker_Transaction_LoadStateChange] 
	-- Add the parameters for the stored procedure here
	(
		@OldLoadState	TINYINT,
		@NewLoadState	TINYINT
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

		UPDATE [dbo].[Broker_Transaction] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[LCH_TypePS_0101_Purge]''
');

GO
EXECUTE ('




-- =============================================
-- Author:		Lee Manifold
-- Create date: 11 Jul 2006
-- Description:	Deletes from all is_G type files where the LoadState is 0
-- =============================================
CREATE PROCEDURE [dbo].[LCH_TypePS_0101_Purge]
	(
	@LoadState		TINYINT = 0,
	@FileName       VARCHAR (512)= NULL
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	
	--raiserror (''Lee doing specific raiserror in stored proc for testing'', 19, 1) with log
	DELETE FROM [dbo].[LCH_TypePS_0101] WHERE LoadState= @LoadState AND [FileName] = Coalesce(@FileName, [FileName])
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Rule_ManageMatchCode]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Rule_ManageMatchCode]
	@ruleId int, 
	@inlclude bit,
	@matchCodeId int
	
AS
SET NOCOUNT ON
	DECLARE @sequenceNumber INT
	
	DELETE FROM ib_RuleMatchCode WHERE RuleId = @ruleId AND MatchCodeId = @matchCodeId
	
	SELECT 
		@sequenceNumber = ISNULL(MAX(SequenceNumber),0) + 1 
	FROM 
		ib_RuleMatchCode 
	WHERE 
		--RuleId = @ruleId AND 
		MatchCodeId = @matchCodeId
	
	IF(@inlclude = 1)
		INSERT INTO ib_RuleMatchCode VALUES (@ruleId, @matchCodeId, @sequenceNumber, getdate(), ''system'', getdate(), ''system'')
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_EU_cb010_Load]''
');

GO
EXECUTE ('CREATE procedure [dbo].[ib_EU_cb010_Load]
	(
		@LocationPath VARCHAR(100)
		,@ReceiveLocationSysId INT
		,@RunId INT
	)
AS
SET NOCOUNT ON

/*
Description:  This stored procedure pulls data from the e80_cb010grp
table and inserts it into the ib_Position ./ ib_trx table.  Also, any
new values encountered for firm, account, instrument, and currency create
new values in the lookups, as well as new values in the data tables for
these values.

Whilst iterating through the records in e80_cb010grp, all 
of these inserts are wrapped in a transaction so that any failure causes
the changes to not commit.

01 Aug 2006		lm		Creation
08 Aug 2006		amk		Bug Fix: Trx''s not loading correctly; 1) Chg to outer join  2) Remove hard-coded trxtype codes!
09 Aug 2006		amk		1) Uncomment out pass of MarketValue into Trx Load
						2) Pass Currency into Trx Load AND Pos Load
						3) Bug Fix: Change right to left for prodtypeid for instrtypecode
10 Aug 2006		amk		1) Bug Fix: Instrument code set to wrong value (ID!)
						2) Divide strike price by 100
26 Sep 2006		LM		Added the @StrikePriceDivisor logic.
25 Oct 2006		LM		Changed QuantityTR to TrnLngQty-TrnShtQty
02 Nov 2006		amk		1) Log start and end ib_ImportLog rows (with filename)
						2) Only run code to get DataSourceId once.
30 Nov 2006		LM		Added code to concatenate @tmpInstrumentCode and @tmpTrxInstrumentCode 
						and @tmpCntrVersNo.
02 Feb 2007		LM		Added value @DefaultStrikePriceDivisor instead of hard coding value 100 both for
						Position and Transaction.
02 Feb 2007		amk		Bug Fix: Fix second fetch for trx so as of date loaded correctly
20 May 2009     Konrad  Exp Day set to the last day of the Exp Month and Exp Year if Exp Month and Exp Year are valid
21 May 2009     Konrad  Added for Transaction Load the Exp Day setting to the last day of the Exp Month and Exp Year if Exp Month and Exp Year are valid
16 June 2009    Konrad  Added for Position Load, the TradedLongQuantity and TradedShortQuantity
23 June 2009    Konrad  Fixed bug when StrikePrice or OptionTypeCode are null and TradedLongQuantity and TradedShortQuantity were not loaded
09 July 2009    Konrad  Fixed bug of wrong Traded Long / Short data for positions with no trades.
10 July 2009    Konrad  Created calculation of TradedShort and TradedLong values for different Account and Firm.
14 July 2009    Konrad  StrikePrice for Transactions computed the same way as for the Positions, 
				StrikePrice = StrikePrice / StrikePriceDivisor or StrikePrice = StrikePrice / DefaultStrikePriceDivisor 
16 Jul 2009		AAJM	Update to account for new DetailAccountId column in ib_Trx table - see MBAL-12454
21 Jul 2009		AAJM	Add MarexFirmId to ensure correct DetailAccountId is obtained
22 Jul 2009		AAJM	MBAL-12377 use common source for default Strike Price Divisor
28 Jul 2009		AAJM	MBAL-12623 Include QuantityLong and QuantityShort
26 Oct 2009		amk		MBAL-13604 Switch negative short/longs to positive on type 000 records
17 Feb 2010		AAJM	MBAL-13937 Stop same file being imported again
03 Mar 2010		KevinP	MBAL-14819 Add ability to filter SELECT records by new [FileName] Column
03 Mar 2010		amk		MBAL-14836 Change transaction isolation level
24 Mar 2010		amk		MBAL-15051 bug fix: when joining to trx type include data source so as not to duplicate source rows
22 Apr 2010		AAJM	MBAL-14741 Save settlement prices from CurrSetlmtPrc
20 May 2010		amk		MBAL-15566 Move import log add to outside transaction to avoid deadlocks
02 Jun 2010		ED      MBAL-15687 populate ib_ImportFile.AsOfDate
16 Aug 2010		amk		MBAL-16455 Include 045 in closeout
17 Aug 2010		amk		MBAL-16455 More types for closeout
31 May 2012		AAJM	MBAL-20956 Bypass changes to long and short quantities for account M1
02 Jan 2014		RD		MBAL-24931 Added checking file age
09 Jan 2014		ED		EIB 25004 - remove importLog table and use Log table
25 Apr 2014		ED		EIB 25473 - raise error if file is too old and mark temp records as LoadState=3
*/

	/*
	Logic:  Get all the Positional data. Update the Production tables
			Get all the Transactional data. Updat the Production tables
	*/
	DECLARE @DataSourceCd VARCHAR(100)
	DECLARE @TrxTypePos VARCHAR(4)
	DECLARE @TrxTypeTrade VARCHAR(3)
	DECLARE @TrxTypeTradeAmended VARCHAR(4)

	SET @DataSourceCd = ''Eurex''
	SET @TrxTypePos = ''END''
	SET @TrxTypeTrade = ''000''
	SET @TrxTypeTradeAmended = ''000a''

	DECLARE @ReturnValue				int
	DECLARE	@Output						int  
	DECLARE	@Output2					int
	DECLARE @DataSourceId				int
	DECLARE @Code						varchar(100)
	DECLARE @DefaultCurrencyId	int

	--Gets the DataSource and DefaultCurrencyId values
	SET @Code = @DataSourceCd
	EXEC @ReturnValue = [dbo].[_ib_DataSource_GetByCodeForOutput] @Code, @OutPut output, @Output2 output
	SET @DataSourceId = @Output
	SET @DefaultCurrencyId = @Output2

	-- Duplicate file check										
	DECLARE @IsFileAlreadyLoaded INT
	EXEC @IsFileALreadyLoaded = HasFileBeenLoaded @LocationPath, @DataSourceId

	IF @IsFileAlreadyLoaded = 1
	BEGIN
		UPDATE [dbo].[EU_cb010grp]
		SET [LoadState] = 3
		WHERE [LoadState] = 1
			AND [FileName] = @LocationPath -- Is there a Filename column?
		
		RETURN
	END
	
	-- Store ImportFile record to be associated with Settlement Price load
	DECLARE @ImportFileId INT
	EXEC ib_ImportFile_Add @DataSourceId, @LocationPath, @ImportFileId output
	DECLARE @SelectedAsOfDate DATETIME
	--Gets the defaultStrikePriceDivisor
	DECLARE	@DefaultStrikePriceDivisor	decimal(19,6)
	SET @DefaultStrikePriceDivisor = [dbo].[udf_GetDefaultStrikePriceDivisor](@DataSourceId, NULL)

	DECLARE @SwapQuantity INT

	CREATE TABLE #TempPos
	(
		[ID]					int,
		[ExchangeCode]			varchar(4), 
		[FirmCode]				varchar(5),
		[AccountID]				varchar(32),
		[InstrumentCode]		varchar(10), 
		[InstrumentTypeCode]	varchar(1),
		[SumtrnLngQty]			int, --Quantity Lng-sht 
		[SumtrnShtQty]			int, 
		[CurrencyCode]			varchar(3), 
		[MarketValue]			varchar(20),			
		[ExpiryYear]			int, 
		[ExpiryMonth]			int, 
		[StrikePrice]			decimal(19,6), 
		[OptionTypeCode]		varchar(1),
		[rptPrntEffDat]			DateTime,
		[CntrVersNo]			int,
		[CurrSetlmtPrc]			varchar(20)
	)
			
	INSERT INTO #TempPos
	(
		[ID],
		[ExchangeCode],
		[FirmCode],			
		[AccountID],
		[InstrumentCode],
		[InstrumentTypeCode],
		[SumtrnLngQty],			
		[SumtrnShtQty],			
		[CurrencyCode],			
		[MarketValue],						
		[ExpiryYear],			
		[ExpiryMonth],			
		[StrikePrice],			
		[OptionTypeCode],
		[rptPrntEffDat],
		[CntrVersNo],
		[CurrSetlmtPrc]
	)
	SELECT [EU_cb010grpID],
				''XEUR'',
				[membexchIDCod], 
				[accTypGrp],
				[ProdID], 
				LEFT([ProdTypId],1),
				[sumtrnLngQty],
				[sumtrnShtQty],
				[currTypCod],
				[sumCntrPrmVmarAmnt],		
				[CntrExpYrDat],
				[CntrExpMthDat],
				[cntrExerPrc],
				[cntrClasCod],
				[rptPrntEffDat],
				[CntrVersNo],
				[currSetlmtPrc]
	FROM [dbo].[eu_cb010grp]
		JOIN [dbo].[ib_TrxType]
			ON [ib_TrxType].[Code] = [eu_cb010grp].[TrnTyp] 
				AND ib_TrxType.DataSourceId = @DataSourceId
	WHERE [LoadState] = 1
		AND [ib_TrxType].[IsPosition] = 1
		AND [ib_TrxType].[code] = @TrxTypePos
		AND [FileName] = @LocationPath

	--rd - make sure the As Of Date is not older than acceptable	
	DECLARE @CheckAsOfDate DATETIME
	SET @CheckAsOfDate = (SELECT MIN(rptPrntEffDat) AS CheckRunDate FROM #TempPos WHERE rptPrntEffDat IS NOT NULL)
	IF (@CheckAsOfDate IS NOT NULL)
	BEGIN		
		DECLARE @IsAcceptable bit
		EXECUTE [dbo].[Load_IsFileTooOld] @DataSourceId,@LocationPath,@CheckAsOfDate,@IsAcceptable OUTPUT, @ReceiveLocationSysId, @RunId
		IF (@IsAcceptable = 0)
		BEGIN
			DROP TABLE #TempPos
			UPDATE EU_cb010grp SET [LoadState] = 3 WHERE [Filename] = @LocationPath
			RAISERROR (''File is too old.'', 18, 0)
			RETURN
		END
	END	

	CREATE TABLE #TempQuantitiesSource
	(
		[ID]					int,
		[InstrumentCode]		varchar(10), 
		[InstrumentTypeCode]	varchar(1),
		[CurrencyCode]			varchar(3), 
		[trnLngQty]				int, --Quantity Lng-sht 
		[trnShtQty]				int, 
		[ExpiryYear]			int, 
		[ExpiryMonth]			int, 
		[StrikePrice]			decimal(19,6), 
		[OptionTypeCode]		varchar(1),
		[FirmCd]				varchar(5),	
		[AccountCd]				varchar(32)
	)

	INSERT INTO #TempQuantitiesSource
	(
		[ID],
		[InstrumentCode], 
		[InstrumentTypeCode],
		[CurrencyCode],
		[trnLngQty],
		[trnShtQty], 
		[ExpiryYear], 
		[ExpiryMonth], 
		[StrikePrice], 
		[OptionTypeCode],
		[FirmCd],	
		[AccountCd]
	)
	SELECT [EU_cb010grpID],
				[ProdID], 
				LEFT([ProdTypId],1),
				[currTypCod],
				[trnLngQty],
				[trnShtQty], 
				[CntrExpYrDat],
				[CntrExpMthDat],
				[cntrExerPrc],
				[cntrClasCod],
				[MembExchIdCod],	
				[accTypGrp]
	FROM eu_cb010grp
		JOIN ib_TrxType
			ON ib_TrxType.Code = eu_cb010grp.TrnTyp
				AND ib_TrxType.DataSourceId = @DataSourceId
	WHERE LoadState = 1
		AND (ib_TrxType.IsTrade = 1 OR ib_TrxType.Code IN (''020'', ''021'', ''030'', ''031'', ''035'', ''040'', ''043'', ''044'', ''045'', ''046''))
		AND FileName = @LocationPath
	
	CREATE TABLE #TempQuantitiesDestination
	(
		[DestID]					int IDENTITY(1,1) NOT NULL,
		[InstrumentCode]		varchar(10), 
		[InstrumentTypeCode]	varchar(1),
		[CurrencyCode]			varchar(3), 
		[ExpiryYear]			int, 
		[ExpiryMonth]			int, 
		[StrikePrice]			decimal(19,6) null, 
		[OptionTypeCode]		varchar(1) null,
		[FirmCd]				varchar(5),	
		[AccountCd]				varchar(32)
		CONSTRAINT [PK_#TempQuantitiesDestination] PRIMARY KEY CLUSTERED 
	(	[DestID] ASC
	)	WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
	) ON [PRIMARY]
	
	CREATE TABLE #TempQuantityValues
	(
		[ID]					int NOT NULL,
		[trnLngQty]				decimal(19,4),  
		[trnShtQty]				decimal(19,4) 
	)

	INSERT INTO #TempQuantitiesDestination
	(
		[InstrumentCode], 
		[InstrumentTypeCode],
		[CurrencyCode],
		[ExpiryYear], 
		[ExpiryMonth], 
		[StrikePrice], 
		[OptionTypeCode],
		[FirmCd],	
		[AccountCd]
	)
	SELECT DISTINCT [InstrumentCode], 
					  [InstrumentTypeCode],
					  [CurrencyCode],
					  [ExpiryYear], 
					  [ExpiryMonth], 
					  [StrikePrice], 
					  [OptionTypeCode],
					  [FirmCd],	
					  [AccountCd]
	FROM #TempQuantitiesSource

	INSERT INTO #TempQuantityValues
	(
		[ID], 
		[trnLngQty],
		[trnShtQty]
	)
	SELECT [DestID], 0, 0
	FROM #TempQuantitiesDestination

	BEGIN TRAN TradedQuantTran

	-- BizTalk''s SQL Adapter uses more restrictive read serializable
	-- so this is necessary to relax it to something that is default
	-- and perfectly acceptable!
	SET TRANSACTION ISOLATION LEVEL READ COMMITTED

	DECLARE @DestId						int
	DECLARE @trdQuantLongSum			int
	DECLARE @trdQuantShortSum			int
	DECLARE	@InstrumentCodeDest			varchar(10)
	DECLARE	@InstrumentTypeCodeDest		varchar(1)
	DECLARE	@CurrencyCodeDest			varchar(3) 
	DECLARE	@trnLngQtyDest				decimal(19,4)
	DECLARE	@trnShtQtyDest				decimal(19,4) 
	DECLARE	@ExpiryYearDest				int 
	DECLARE	@ExpiryMonthDest			int 
	DECLARE	@StrikePriceDest			decimal(19,6) 
	DECLARE	@OptionTypeCodeDest			varchar(1)
	DECLARE @FirmCod						varchar(5)
	DECLARE	@AccountCod					varchar(32)

	DECLARE pos_cursor_dest CURSOR FOR
		SELECT 	[DestID],
				[InstrumentCode], 
				[InstrumentTypeCode],
				[CurrencyCode],
				[ExpiryYear], 
				[ExpiryMonth], 
				[StrikePrice], 
				[OptionTypeCode],
				[FirmCd],	
				[AccountCd]
		FROM #TempQuantitiesDestination
		
		OPEN pos_cursor_dest

		FETCH NEXT FROM pos_cursor_dest
		INTO	
				 @DestId,					
				 @InstrumentCodeDest,
				 @InstrumentTypeCodeDest,
				 @CurrencyCodeDest, 
				 @ExpiryYearDest, 
				 @ExpiryMonthDest,
				 @StrikePriceDest, 
				 @OptionTypeCodeDest,
				 @FirmCod,
				 @AccountCod

		WHILE @@FETCH_STATUS = 0
		BEGIN

				 SELECT @trdQuantLongSum = SUM([trnLngQty]), @trdQuantShortSum = SUM([trnShtQty])
				 FROM #TempQuantitiesSource
				 WHERE [InstrumentCode] = @InstrumentCodeDest AND 
						[InstrumentTypeCode] = @InstrumentTypeCodeDest AND
						[CurrencyCode] = @CurrencyCodeDest AND
						[ExpiryYear] = @ExpiryYearDest AND
						[ExpiryMonth] = @ExpiryMonthDest AND
						[FirmCd] = @FirmCod AND	
						[AccountCd] = @AccountCod AND
						((@StrikePriceDest is not null AND [StrikePrice] = @StrikePriceDest) OR [StrikePrice] is null) AND
						((@OptionTypeCodeDest is not null AND [OptionTypeCode] = @OptionTypeCodeDest) OR [OptionTypeCode] is null)

				 SET @trnLngQtyDest = CAST(@trdQuantLongSum as decimal(19,4))
				 SET @trnShtQtyDest = CAST(@trdQuantShortSum as decimal(19,4))

				 UPDATE #TempQuantityValues
				 SET [trnLngQty] = @trnLngQtyDest,
					 [trnShtQty] = @trnShtQtyDest
				 WHERE [ID] = @DestId 

				 SET @StrikePriceDest = null
				 SET @OptionTypeCodeDest = null	

		FETCH NEXT FROM pos_cursor_dest
		INTO	
				 @DestId,					
				 @InstrumentCodeDest,
				 @InstrumentTypeCodeDest,
				 @CurrencyCodeDest, 
				 @ExpiryYearDest, 
				 @ExpiryMonthDest,
				 @StrikePriceDest, 
				 @OptionTypeCodeDest,
				 @FirmCod,
				 @AccountCod

	END

	CLOSE pos_cursor_dest
	DEALLOCATE pos_cursor_dest

	COMMIT TRAN TradedQuantTran

	DROP TABLE #TempQuantitiesSource
	
	BEGIN TRAN T1

		-- BizTalk''s SQL Adapter uses more restrictive read serializable
		-- so this is necessary to relax it to something that is default
		-- and perfectly acceptable!
		SET TRANSACTION ISOLATION LEVEL READ COMMITTED

		DECLARE @tmpID					int
		DECLARE @tmpExchangeCode		varchar(4) 
		DECLARE @tmpFirmCode			varchar(5)
		DECLARE @tmpAccountID			varchar(32)
		DECLARE @tmpInstrumentCode		varchar(10) 
		DECLARE @tmpInstrumentTypeCode	varchar(1)
		DECLARE @tmpSumtrnLngQty		int --Quantity Lng-sht 
		DECLARE @tmpSumtrnShtQty		int 
		DECLARE @tmpCurrencyCode		varchar(3) 
		DECLARE @tmpMarketValue			varchar(20)			
		DECLARE @tmpExpiryYear			int 
		DECLARE @tmpExpiryMonth			int 
		DECLARE @tmpStrikePrice			decimal(19,6) 
		DECLARE @tmpOptionTypeCode		varchar(1)
		DECLARE	@tmprptPrntEffDat		Datetime
		DECLARE	@tmpCntrVersNo			int
		DECLARE @started				bit
		DECLARE @tmpCurrSetlmtPrc		VARCHAR(20)
		
		SET @started = 0

		DECLARE pos_cursor CURSOR FOR
		SELECT 	[ID],
				[ExchangeCode],
				[FirmCode],			
				[AccountID],
				[InstrumentCode],
				[InstrumentTypeCode],
				[SumtrnLngQty],			
				[SumtrnShtQty],			
				[CurrencyCode],			
				[MarketValue],						
				[ExpiryYear],			
				[ExpiryMonth],			
				[StrikePrice],			
				[OptionTypeCode],
				[rptPrntEffDat],
				[CntrVersNo],
				[CurrSetlmtPrc]
		FROM	#TempPos
		OPEN pos_cursor

		FETCH NEXT FROM pos_cursor
		INTO	
				 @tmpID,					
				 @tmpExchangeCode,		 
				 @tmpFirmCode,			
				 @tmpAccountID,
				 @tmpInstrumentCode,		
				 @tmpInstrumentTypeCode,
				 @tmpSumtrnLngQty,		--Quantity Lng-sht 
				 @tmpSumtrnShtQty,		
				 @tmpCurrencyCode,		 
				 @tmpMarketValue,					
				 @tmpExpiryYear,			
				 @tmpExpiryMonth,			
				 @tmpStrikePrice,			
				 @tmpOptionTypeCode,
				 @tmprptPrntEffDat,
				 @tmpCntrVersNo, 	
				 @tmpCurrSetlmtPrc
		-- Check @@FETCH_STATUS to see if there are any more rows to fetch.
		WHILE @@FETCH_STATUS = 0
		BEGIN

			DECLARE @ExchangeCd			varchar(25)
			DECLARE @FirmCd				varchar(100)
			DECLARE @AccountCd			varchar(100)
			DECLARE @AsOfDate			datetime
			DECLARE @InstrumentCd		varchar(100)
			DECLARE @QuantityPS			decimal(18,10)
			DECLARE @MarketValue		decimal(19,4)
			DECLARE @ExpiryDate			datetime
			DECLARE @StrikePrice		decimal(19,6)
			DECLARE @TrxTypeCd			varchar(25)
			DECLARE @OptionTypeCd		varchar(25)
			DECLARE @QuantityTR			decimal(18,10)
			DECLARE @TrxDate			datetime
			DECLARE @Price				decimal(19,4)
			DECLARE @ExpYr				smallint
			DECLARE @ExpMth				smallint
			DECLARE @ExpDay				smallint
			DECLARE	@InstrumentTypeCd	varchar(100)
			DECLARE	@QuantityLong		int
			DECLARE	@QuantityShort		int

			--specify datasource in proc.
			
			--here I have to do this so that I can grab the ticksize
			--so that I can do the quantity calculation.
			DECLARE @Code2						varchar(100)
			DECLARE @InstrumentTypeId			int
			DECLARE @CurrencyId					int
			DECLARE @InstrumentId				int
			DECLARE @ExchangeId					int
			DECLARE	@LongQuantity				decimal(19,4) 
			DECLARE	@ShortQuantity				decimal(19,4)
			DECLARE	@TradedLongQuantity			decimal(19,4)
			DECLARE	@TradedShortQuantity		decimal(19,4)
			DECLARE @StrikePriceDivisor			decimal(19,4)
			DECLARE	@PriceDivisor				DECIMAL(19,4)

			IF @started = 0
			BEGIN
				SET @Output = null
				SET @Output2 = null

				SET @started = 1
			END

			IF @tmpCntrVersNo IS NOT NULL AND @tmpCntrVersNo <> 0
				BEGIN		
					SET @tmpInstrumentCode = RTRIM(@tmpInstrumentCode) + ''_'' + RTRIM(LTRIM(CAST(@tmpCntrVersNo AS varchar(10))))
					PRINT ''Pos''
					PRINT @tmpInstrumentCode
				END
			--Gets the InstrumentTypeId
			SET	@Code = @tmpInstrumentTypeCode 
			--PRINT ''START - ib_Instrumenttype_AddAsNeeded''
			EXEC @ReturnValue = [dbo].[ib_Instrumenttype_AddAsNeeded] @DataSourceId,@Code,@OutPut output
			SET	@InstrumentTypeId = @Output
			SET @Output2 = null
			SET @Output = null
			
			--PRINT  ''END - ib_Instrumenttype_AddAsNeeded''
			--PRINT  ''START [ib_Instrument_AddAsNeeded]''
			--Sets the InstrumentId and the CurrencyId
			SET @Code = @tmpInstrumentCode
			EXEC @ReturnValue= [ib_Instrument_AddAsNeeded] @DataSourceId,@InstrumentTypeId,@Code,@CurrencyId,@OutPut output,@OutPut2 output	
			SET @InstrumentId = @Output
			SET @CurrencyId = @Output2
			--PRINT ''END [ib_Instrument_AddAsNeeded]''
			IF @CurrencyId is null
			BEGIN
				SET @CurrencyId = @DefaultCurrencyId
			END

			SET @ExchangeCd			= @tmpExchangeCode
			SET @FirmCd				= @tmpFirmCode
			SET @AccountCd			= @tmpAccountID
			SET @AsOfDate			= @tmprptPrntEffDat
			SET @InstrumentCd		= @tmpInstrumentCode
			SET @QuantityPS			= CAST((@tmpSumtrnLngQty -  @tmpSumtrnshtQty) AS decimal(18,10))
			SET @MarketValue		= @tmpMarketValue
			
			SET @StrikePriceDivisor	= null
			SELECT	@StrikePriceDivisor	= StrikePriceDivisor
					, @PriceDivisor = PriceDivisor
			FROM [dbo].[ib_InstrumentDataSource]
			WHERE DataSourceId = @DataSourceId
				AND DataSourceInstrumentCode = @InstrumentCd 

			IF @StrikePriceDivisor IS NULL
				BEGIN
					SET @StrikePrice = CAST(@tmpStrikePrice as decimal(19,4)) / @DefaultStrikePriceDivisor
				END
			ELSE
				BEGIN
					SET @StrikePrice = CAST(@tmpStrikePrice as decimal(19,4)) / @StrikePriceDivisor
				END

			-- Set Settlement Price				
			IF @PriceDivisor IS NULL 
				SET @PriceDivisor = 1
					
			DECLARE @SettlementPrice DECIMAL(24,10)
			SET @SettlementPrice = CONVERT(DECIMAL(24,10), @tmpCurrSetlmtPrc) / @PriceDivisor
			
			SET @TrxTypeCd			= ''POS'' 
			SET @OptionTypeCd		= @tmpOptionTypeCode
			SET @TrxDate			= GETDATE()
			--SET @QuantityTR			= CAST(@tmpQuantity as decimal(18,10))
			SET @ExpYr				= @tmpExpiryYear
			SET @ExpMth				= @tmpExpiryMonth
			SET @ExpDay				= 0
			SET @InstrumentTypeCd	= @tmpInstrumentTypeCode --@InstrumentTypeId
			SET @LongQuantity		= @tmpSumtrnLngQty
			SET @ShortQuantity		= @tmpSumtrnShtQty	

			SET @TradedLongQuantity	 = NULL	 
			SET @TradedShortQuantity = NULL 	 

			SELECT @TradedLongQuantity = trnLngQty, @TradedShortQuantity = trnShtQty
			FROM #TempQuantitiesDestination
				RIGHT JOIN #TempQuantityValues ON ID = DestID
			WHERE [InstrumentCode] = @tmpInstrumentCode AND 
				  [InstrumentTypeCode] = @tmpInstrumentTypeCode AND
				  [CurrencyCode] = @tmpCurrencyCode AND
				  [ExpiryYear] = @tmpExpiryYear AND 
				  [ExpiryMonth] = @tmpExpiryMonth AND 
				  [FirmCd] = @FirmCd AND	
				  [AccountCd] = @AccountCd AND	
				  (([StrikePrice] is not null AND [StrikePrice] = @tmpStrikePrice) OR [StrikePrice] is null) AND
				  (([OptionTypeCode] is not null AND [OptionTypeCode] = @tmpOptionTypeCode) OR [OptionTypeCode] is null)

			SET @ExpDay = dbo.udf_OnLoad_ExpiryDate_Get_Day(@ExpYr,@ExpMth,@ExpDay)
			
			
			
			
			DECLARE @PositionId INT
			SET @PositionId = NULL
			
			EXEC	[dbo].[ib_Position_Load]
					@DataSourceCd,
					@ExchangeCd,
					@FirmCd,
					@AccountCd,	
					@AsOfDate,
					@InstrumentCd,
					@QuantityPS,
					@MarketValue,
					@ExpYr,
					@ExpMth,
					@ExpDay,
					@StrikePrice,
					@TrxTypeCd,
					@OptionTypeCd,
					@TrxDate,
					@Price,
					@tmpID,
					@InstrumentTypeCd,
					@LocationPath,
					@tmpCurrencyCode,
					@LongQuantity,		
					@ShortQuantity,			 
					@TradedLongQuantity,	
					@TradedShortQuantity,	
					@PositionId = @PositionId OUTPUT, 
					@ReceiveLocationSysId = @ReceiveLocationSysId,
					@RunId = @RunId
					
			-- Add Settlement Price											
			EXEC ib_Price_AddFromPositionLoad
				@PositionId
				, @ImportFileId
				, @SettlementPrice 	
				
			--flip processed flag in source table.
			
			UPDATE [dbo].[EU_cb010grp]
			SET [LoadState] = 2
			WHERE [EU_cb010grp].[EU_cb010grpID] = @tmpID
				AND [LoadState] = 1

			SET @tmpStrikePrice = null
			SET @tmpOptionTypeCode = null

			FETCH NEXT FROM pos_cursor
			INTO 
				 @tmpID,					
				 @tmpExchangeCode,		 
				 @tmpFirmCode,			
				 @tmpAccountID,			
				 @tmpInstrumentCode,		
				 @tmpInstrumentTypeCode,
				 @tmpSumtrnLngQty,		--Quantity Lng-sht 
				 @tmpSumtrnShtQty,		
				 @tmpCurrencyCode,		 
				 @tmpMarketValue,					
				 @tmpExpiryYear,			
				 @tmpExpiryMonth,			
				 @tmpStrikePrice,			
				 @tmpOptionTypeCode,
				 @tmprptPrntEffDat,
				 @tmpCntrVersNo,
				 @tmpCurrSetlmtPrc
		END

		CLOSE pos_cursor
		DEALLOCATE pos_cursor

	COMMIT TRAN T1

	DROP TABLE #TempPos
	DROP TABLE #TempQuantityValues
	DROP TABLE #TempQuantitiesDestination
	/****Now do the Transaction Type ****/

	DECLARE @DetailAccountCd	varchar(36) -- AAJM Added for MBAL-12454
	
	SET @DefaultCurrencyId		= NULL
	SET @ExchangeCd				= NULL
	SET @FirmCd					= NULL
	SET @AccountCd				= NULL
	SET @DetailAccountCd		= NULL -- AAJM Added for MBAL-12454
	SET @AsOfDate				= NULL
	SET @InstrumentCd			= NULL
	SET @QuantityPS				= NULL
	SET @MarketValue			= NULL
	SET @ExpiryDate				= NULL
	SET @StrikePrice			= NULL
	SET @TrxTypeCd				= NULL
	SET @OptionTypeCd			= NULL
	SET @QuantityTR				= NULL
	SET @TrxDate				= NULL
	SET @Price					= NULL
	SET @ExpYr					= NULL
	SET @ExpMth					= NULL
	SET @ExpDay					= NULL
	SET	@InstrumentTypeCd		= NULL

	SET @DataSourceCd = ''Eurex''
	
	DECLARE @MarexFirmId INT
	SET @MarexFirmId = [dbo].[udf_GetMarexFirmId]() -- AAJM Added for MBAL-12454

	CREATE TABLE #TempTrx
	(
		[ID]					int,
		[ExchangeCode]			varchar(4), 
		[FirmCode]				varchar(5),
		[AccountID]				varchar(32),
		[DetailAccountCd]		varchar(36), -- AAJM Added for MBAL-12454
		[TrxDate]				datetime,
		[InstrumentCode]		varchar(10), 
		[InstrumentTypeCode]	varchar(1),
		[SumtrnLngQty]			int, --Quantity Lng-sht 
		[SumtrnShtQty]			int, 
		[CurrencyCode]			varchar(3), 
		[MarketValue]			varchar(20),
		[Price]					varchar(20),
		[ExpiryYear]			int, 
		[ExpiryMonth]			int, 
		[StrikePrice]			decimal(19,6), 
		[OptionTypeCode]		varchar(1),
		[TrxTypeCode]			varchar(3),
		[trnLngQty]				int,	
		[trnshtQty]				int,
		[rptPrntEffDat]			datetime,
		[CntrVersNo]			int
	)
			
	INSERT INTO #TempTrx
	(
		[ID],
		[ExchangeCode],
		[FirmCode],			
		[AccountID],
		[DetailAccountCd], -- AAJM Added for MBAL-12454
		[TrxDate],				
		[InstrumentCode],
		[InstrumentTypeCode],
		[SumtrnLngQty],			
		[SumtrnShtQty],			
		[CurrencyCode],			
		[MarketValue],
		[Price],						
		[ExpiryYear],			
		[ExpiryMonth],			
		[StrikePrice],			
		[OptionTypeCode],
		[TrxTypeCode],
		[trnLngQty],	
		[trnshtQty],
		[rptPrntEffDat],
		[CntrVersNo]			
	)
	SELECT [EU_cb010grpID],
				[origExchId],
				[membexchIDCod], 
				[accTypGrp],
				[custText], -- AAJM Added for MBAL-12454
				[OrigTrnDat],
				[ProdID], 
				RIGHT([ProdTypId],1),
				[sumtrnLngQty],
				[sumtrnShtQty],
				[currTypCod],
				[prmVmarAmnt],
				[trdMtchPrc],
				[CntrExpYrDat],
				[CntrExpMthDat],
				[cntrExerPrc],
				[cntrClasCod],
				[trnTyp],
				[trnLngQty],	
				[trnshtQty],
				[rptPrntEffDat],
				[CntrVersNo]			
	FROM [dbo].[eu_cb010grp]
		LEFT OUTER JOIN [dbo].[ib_TrxType]
			ON [ib_TrxType].[Code] = [eu_cb010grp].[TrnTyp] 		
				AND ib_TrxType.DataSourceId = @DataSourceId
	WHERE [LoadState] = 1
		AND ([ib_TrxType].[IsPosition] = 0
			OR [ib_TrxType].[IsPosition] IS NULL)
		AND [FileName] = @LocationPath

	BEGIN TRAN T2

		-- BizTalk''s SQL Adapter uses more restrictive read serializable
		-- so this is necessary to relax it to something that is default
		-- and perfectly acceptable!
		SET TRANSACTION ISOLATION LEVEL READ COMMITTED

		DECLARE @tmpTrxID					int
		DECLARE @tmpTrxExchangeCode			varchar(4) 
		DECLARE @tmpTrxFirmCode				varchar(5)
		DECLARE @tmpTrxAccountID			varchar(32)
		DECLARE @tmpTrxDetailAccountCd		varchar(36) -- AAJM Added for MBAL-12454
		DECLARE @tmpTrxTrxDate				datetime
		DECLARE @tmpTrxInstrumentCode		varchar(10)
		DECLARE @tmpTrxInstrumentTypeCode	varchar(1)
		DECLARE @tmpTrxSumtrnLngQty			int --Quantity Lng-sht 
		DECLARE @tmpTrxSumtrnShtQty			int 
		DECLARE @tmpTrxCurrencyCode			varchar(3) 
		DECLARE @tmpTrxMarketValue			varchar(20)
		DECLARE @tmpTrxPrice				varchar(20)
		DECLARE @tmpTrxExpiryYear			int 
		DECLARE @tmpTrxExpiryMonth			int
		DECLARE @tmpTrxStrikePrice			decimal(19,6) 
		DECLARE @tmpTrxOptionTypeCode		varchar(1)
		DECLARE @tmpTrxTrxTypeCode			varchar(3) 
		DECLARE @tmpTrxtrnLngQty			int	
		DECLARE	@tmpTrxtrnShtQty			int
		DECLARE	@tmpTrxrptPrntEffDat		datetime
		DECLARE @tmpTrxCntrVersNo			int
		DECLARE @ClassID					int

		SET @started = 0

		DECLARE trx_cursor CURSOR FOR
		SELECT 	[ID],
				[ExchangeCode],
				[FirmCode],			
				[AccountID],
				[DetailAccountCd], -- AAJM Added for MBAL-12454
				[TrxDate],				
				[InstrumentCode],
				[InstrumentTypeCode],
				[SumtrnLngQty],			
				[SumtrnShtQty],			
				[CurrencyCode],			
				[MarketValue],
				[Price],						
				[ExpiryYear],			
				[ExpiryMonth],			
				[StrikePrice],			
				[OptionTypeCode],
				[TrxTypeCode],
				[trnLngQty],	
				[trnshtQty],
				[rptPrntEffDat],
				[CntrVersNo]			

		FROM	#TempTrx
		OPEN trx_cursor

		FETCH NEXT FROM trx_cursor
		INTO	
			 @tmpTrxID,					
			 @tmpTrxExchangeCode,		
			 @tmpTrxFirmCode,			
			 @tmpTrxAccountID,
			 @tmpTrxDetailAccountCd,	-- AAJM Added for MBAL-12454		
			 @tmpTrxTrxDate,			
			 @tmpTrxInstrumentCode,		
			 @tmpTrxInstrumentTypeCode,	
			 @tmpTrxSumtrnLngQty,		
			 @tmpTrxSumtrnShtQty,		 
			 @tmpTrxCurrencyCode,		
			 @tmpTrxMarketValue,		
			 @tmpTrxPrice,			
			 @tmpTrxExpiryYear,			
			 @tmpTrxExpiryMonth,		
			 @tmpTrxStrikePrice,		
			 @tmpTrxOptionTypeCode,		
			 @tmpTrxTrxTypeCode,
			 @tmpTrxtrnLngQty,	
			 @tmpTrxtrnShtQty,
			 @tmpTrxrptPrntEffDat,
			 @tmpTrxCntrVersNo	

		-- Check @@FETCH_STATUS to see if there are any more rows to fetch.
		WHILE @@FETCH_STATUS = 0
		BEGIN
			--specify datasource in proc.
			--here I have to do this so that I can grab the ticksize
			--so that I can do the quantity calculation.
			
			IF @started = 0
			BEGIN
				SET @Output = null
				SET @Output2 = null
				SET @ClassID = null

				SET @started = 1
			END

			IF @tmpTrxCntrVersNo IS NOT NULL AND @tmpTrxCntrVersNo <> 0
				BEGIN	
					SET  @tmpTrxInstrumentCode = RTRIM(@tmpTrxInstrumentCode) + ''_'' + RTRIM(LTRIM(CAST(@tmpTrxCntrVersNo AS varchar(10))))
					PRINT ''Trx''
					PRINT @tmpTrxCntrVersNo
				END
			--Gets the InstrumentTypeId
			SET	@Code = @tmpTrxInstrumentTypeCode 
			
			EXEC @ReturnValue = [dbo].[ib_Instrumenttype_AddAsNeeded] @DataSourceId,@Code,@OutPut output
			SET	@InstrumentTypeId = @Output
			SET @Output2 = null
			SET @Output = null
			
			--Sets the InstrumentId and the CurrencyId
			SET @Code = @tmpTrxInstrumentCode
			EXEC @ReturnValue= [ib_Instrument_AddAsNeeded] @DataSourceId,@InstrumentTypeId,@Code,@CurrencyId,@OutPut output,@OutPut2 output	
			SET @InstrumentId = @Output
			SET @CurrencyId = @Output2
			
			IF @CurrencyId is null
			BEGIN
				SET @CurrencyId = @DefaultCurrencyId
			END
				
			SET @ExchangeCd			= @tmpTrxExchangeCode
			SET @FirmCd				= @tmpTrxFirmCode
			SET @AccountCd			= @tmpTrxAccountID
			SET @DetailAccountCd	= @tmpTrxDetailAccountCd  -- AAJM Added for MBAL-12454
			SET @AsOfDate			= @tmpTrxrptPrntEffDat
			SET @SelectedAsOfDate   = @AsOfDate
			SET @InstrumentCd		= @tmpTrxInstrumentCode
			
			
			SET @QuantityTR			= CAST((ISNULL(@tmpTrxTrnLngQty,0) -  ISNULL(@tmpTrxTrnShtQty,0)) AS decimal(18,10))
			
			SET @QuantityLong = ISNULL(@tmpTrxTrnLngQty,0)
			SET @QuantityShort = ISNULL(@tmpTrxTrnShtQty,0)
											
			SET @MarketValue = @tmpTrxMarketValue

			SET @StrikePriceDivisor	= null
			
			SELECT @StrikePriceDivisor	= StrikePriceDivisor
			FROM [dbo].[ib_InstrumentDataSource]
			WHERE DataSourceId = @DataSourceId
				AND DataSourceInstrumentCode = @InstrumentCd 

			IF @StrikePriceDivisor IS NULL
				BEGIN
					SET @StrikePrice = CAST(@tmpTrxStrikePrice as decimal(19,4)) / @DefaultStrikePriceDivisor
				END
			ELSE
				BEGIN
					SET @StrikePrice = CAST(@tmpTrxStrikePrice as decimal(19,4)) / @StrikePriceDivisor
				END	
				
			SET @TrxTypeCd			= @tmpTrxTrxTypeCode 
			SET @OptionTypeCd		= @tmpTrxOptionTypeCode
			SET @TrxDate			= @tmpTrxTrxDate
			SET @Price				= @tmpTrxPrice
			SET @ExpYr				= @tmpTrxExpiryYear
			SET @ExpMth				= @tmpTrxExpiryMonth
			SET @ExpDay				= 0
			SET @InstrumentTypeCd	= @tmpTrxInstrumentTypeCode --@InstrumentTypeId

			SET @ExpDay = dbo.udf_OnLoad_ExpiryDate_Get_Day(@ExpYr,@ExpMth,@ExpDay)
			
			-- Don''t perform this process for account M1
			IF NOT (@tmpTrxAccountID IS NOT NULL AND @tmpTrxAccountID = ''M1'')
			BEGIN
			
				IF @QuantityLong < 0 AND @TrxTypeCd = @TrxTypeTrade 
				BEGIN
					-- swap the long and short quantitites and reverse the	sign
					-- of course short in this case should be zero, but we''ll swap anyway
					SET @SwapQuantity = @QuantityShort
					SET @QuantityShort = @QuantityLong * -1
					SET @QuantityLong = @SwapQuantity
					SET @TrxTypeCd = @TrxTypeTradeAmended
				END
				ELSE 
				BEGIN
					IF @QuantityShort < 0 AND @TrxTypeCd = @TrxTypeTrade
					BEGIN 
						-- swap the long and short quantitites and reverse the sign
						-- of course long in this case should be zero, but we''ll swap anyway
						SET @SwapQuantity = @QuantityLong
						SET @QuantityLong = @QuantityShort * -1
						SET @QuantityShort = @SwapQuantity
						SET @TrxTypeCd = @TrxTypeTradeAmended
					END
				END
			END

			EXEC [dbo].[ib_Trx_Load]
					@DataSourceCd,
					@ExchangeCd,
					@FirmCd,
					@AccountCd,	
					@DetailAccountCd,
					@InstrumentCd,
					@ExpYr,
					@ExpMth,
					@ExpDay,
					@StrikePrice,
					@TrxTypeCd,
					@OptionTypeCd,
					@QuantityTR,
					@TrxDate,
					@Price,
					@tmpTrxID,
					@InstrumentTypeCd,
					@AsOfDate,
					@LocationPath,
					@MarketValue,
					@tmpTrxCurrencyCode,
					@ClassID,
					@MarexFirmId, -- AAJM Added for MBAL-12454
					@QuantityLong = @QuantityLong,
					@QuantityShort = @QuantityShort,
					@ReceiveLocationSysId = @ReceiveLocationSysId,
					@RunId = @RunId

			--flip processed flag in source table.
			--PRINT ''END3''
			UPDATE [dbo].[EU_cb010grp]
			SET [LoadState] = 2
			WHERE [EU_cb010grp].[EU_cb010grpID] = @tmpTrxID
				AND [LoadState] = 1

			FETCH NEXT FROM trx_cursor
			INTO 
			 @tmpTrxID,					
			 @tmpTrxExchangeCode,		
			 @tmpTrxFirmCode,			
			 @tmpTrxAccountID,	
			 @tmpTrxDetailAccountCd, -- AAJM Added for MBAL-12454		
			 @tmpTrxTrxDate,			
			 @tmpTrxInstrumentCode,		
			 @tmpTrxInstrumentTypeCode,	
			 @tmpTrxSumtrnLngQty,		
			 @tmpTrxSumtrnShtQty,		 
			 @tmpTrxCurrencyCode,		
			 @tmpTrxMarketValue,		
			 @tmpTrxPrice,			
			 @tmpTrxExpiryYear,			
			 @tmpTrxExpiryMonth,		
			 @tmpTrxStrikePrice,		
			 @tmpTrxOptionTypeCode,		
			 @tmpTrxTrxTypeCode,
			 @tmpTrxtrnLngQty,	
			 @tmpTrxtrnShtQty,
			 @tmpTrxrptPrntEffDat,
			 @tmpTrxCntrVersNo	
		END

		CLOSE trx_cursor
		DEALLOCATE trx_cursor

		UPDATE ib_ImportFile 
		SET AsOfDate = @SelectedAsOfDate 
		WHERE ImportFileId = @ImportFileId
	COMMIT TRAN T2

	DROP TABLE #TempTrx
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_ComparePassword]''
');

GO
EXECUTE ('/* =============================================
Author				Create date				Description
Lee Manifold		23 Oct 2006				Compares password for the last x Months
KevinP				05 Oct 2009				Changed to be last x days, AND for it not to just return 1

=============================================
*/
CREATE PROCEDURE [dbo].[ib_ComparePassword]
(
	@UserId uniqueIdentifier,
	@NewPassword	varchar(100),
	@PasswordHistoryDepth			int = 30 -- For now, it will be in days.
)
AS
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	IF EXISTS (SELECT * FROM [dbo].[ib_PasswordHistory] WHERE UserId = @UserId 
													   AND [Password] = @NewPassword 
													   AND DATEDIFF(dd, ISNULL(UpdateDate, CreateDate), GETDATE()) <= @PasswordHistoryDepth)
		SELECT 0
	ELSE
		SELECT 1
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_DataSourceExchange_Delete]''
');

GO
EXECUTE ('/*
--Description: delete exchange
--17 May 2010 ED create
*/
CREATE PROCEDURE [dbo].[ib_DataSourceExchange_Delete]
(
	@DataSourceExchangeId INT 
)
AS
SET NOCOUNT ON
BEGIN TRY
DELETE FROM [dbo].[ib_DataSourceExchange]
      WHERE DataSourceExchangeId = @DataSourceExchangeId
END TRY
BEGIN CATCH
	EXEC [dbo].[sp_RethrowError] ''DataSourceExchange is currently in use!''	
END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[Broker_Transaction_Purge]''
');

GO
EXECUTE ('



-- =============================================
-- Author:		Petru Konrad Bercea
-- Create date: 13.05.2009
-- Description:	Deletes from Broker_Transaction table all the records where the LoadState is 0
-- =============================================
CREATE PROCEDURE [dbo].[Broker_Transaction_Purge] 
	(
		@LoadState		TINYINT = 0,
		@FileName       VARCHAR (512)= NULL
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
		DELETE FROM [dbo].[Broker_Transaction] WHERE LoadState= @LoadState AND [FileName] = Coalesce(@FileName, [FileName])

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Rule_ManageMultipleMatchCodes]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Rule_ManageMultipleMatchCodes]
	@ruleId int,  
	@inlclude bit,
	@firmId int = NULL,
	@currencyId int = NULL
	
AS
SET NOCOUNT ON
	SELECT @firmId = COALESCE(@firmId, -1)
	SELECT @currencyId = COALESCE(@currencyId, -1)
	
	DECLARE @matchCodeId INT 
	DECLARE MatchCodesCursor CURSOR
	FOR
		SELECT 
			MatchCodeId
		FROM 
			ib_MatchCode MC
		INNER JOIN
			ib_TemplateGroup TG 
			ON 
			(TG.Description = MC.MatchCode)
			AND 
			((@currencyId > -1 AND TG.CurrencyId = @currencyId) OR (@currencyId < 0))
			AND
			((@firmId > -1 AND TG.FirmId = @firmId) OR (@firmId < 0))
		INNER JOIN
			ib_Rule R ON TG.TemplateId = R.TemplateId AND R.RuleId = @ruleId
			
	OPEN MatchCodesCursor
	
	FETCH NEXT FROM MatchCodesCursor
		INTO @matchCodeId
		 		
	WHILE @@FETCH_STATUS = 0
	BEGIN
		EXEC [ib_Rule_ManageMatchCode] @ruleId, @inlclude, @matchCodeId
		
		FETCH NEXT FROM MatchCodesCursor
		INTO @matchCodeId
	END
	CLOSE  MatchCodesCursor
	DEALLOCATE  MatchCodesCursor
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_GMI_EXTF1_Position_Load]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_GMI_EXTF1_Position_Load]
(
	@LocationPath		VARCHAR(100)
	, @DataSourceId		INT
	, @DataSourceCode	VARCHAR(100)
	, @ReceiveLocationSysId INT
	, @RunId INT
)
AS
SET NOCOUNT ON

-- Description: Load Positions for GMIEXTF1

-- History:
-- 11 Mar 2010	AAJM	MBAL-14813 Creation
-- 26 Mar 2010	AAJM	MBAL-15070 Include Exchange in Instrument Data Source Code
-- 06 Apr 2010	AAJM	MBAL-15070 Fix truncation of Instrument Data Source Code
-- 12 Apr 2010	AAJM	MBAL-15187 Fix Expiry Day loaded incorrectly
-- 12 Apr 2010	AAJM	MBAL-15195 Fix sold positions appearing as positive
-- 12 Apr 2010	AAJM	Update to use MarketValueDivisor
-- 13 Apr 2010	AAJM	Use concatenated instrument code to look up divisors
-- 22 Apr 2010	AAJM	MBAL-14741 Save settlement prices
-- 02 Jun 2010  ED      MBAL-15687 populate ib_ImportFile.AsOfDate
-- 17 Jun 2010  ED		MBAL 15621 - add logic for converting from 5 to 6 decimals
-- 23 Jun 2010 ED MBAL 15913 - Tidy up Trade/Settlement Price Corrections for Rounded Prices
-- 02 Jan 2014  RD		MBAL-24931 Added checking file age
-- 09 Jan 2014	ED		EIB 25004 - remove importLog table and use Log table
-- 25 Apr 2014	ED		EIB 25473 - raise error if file is too old and mark temp records as LoadState=3

		DECLARE @Message			VARCHAR(1024)
		DECLARE @AddCount			INT
			SET @AddCount = 0

		DECLARE @Code				VARCHAR(100)
		DECLARE @ReturnValue		INT
		DECLARE @Output				INT
		DECLARE @Output2			INT
		DECLARE @DefaultCurrencyId	INT

		-- Variables for values from Temp rows selected:
		DECLARE @GMI_EXTF1ID		INT
		DECLARE @ExchangeCode		VARCHAR(2)
		DECLARE @FirmCode			VARCHAR(100)
		DECLARE @AccountCode		VARCHAR(5)
		DECLARE @InstrumentCode		VARCHAR(100)
		DECLARE @CurrencyCode		VARCHAR(3)
		DECLARE @ContractYearMonth	VARCHAR(6)
		DECLARE @ContractDay		VARCHAR(2)
		DECLARE @Strike				VARCHAR(17)
		DECLARE @RecordType			VARCHAR(1)
		DECLARE @TransactionType	VARCHAR(1)
		DECLARE @PutCallCode		VARCHAR(1)
		DECLARE @Quantity			DECIMAL(19,4)		
		DECLARE @TradeDate			VARCHAR(8)
		DECLARE @TradePrice			DECIMAL(19,8)
		DECLARE @AsOfDate			DATETIME
		DECLARE @MarketValue		DECIMAL(19,2)
		DECLARE @BuySell			VARCHAR(1)
		DECLARE @NumericClosingPrice DECIMAL(19,8)
	
	-- Store ImportFile record to be associated with Settlement Price load
	DECLARE @ImportFileId INT
	EXEC ib_ImportFile_Add @DataSourceId, @LocationPath, @ImportFileId output
	DECLARE @SelectedAsOfDate DATETIME
	--Gets the defaultStrikePriceDivisor
	DECLARE	@DefaultStrikePriceDivisor	decimal(19,6)
	SET @DefaultStrikePriceDivisor = [dbo].[udf_GetDefaultStrikePriceDivisor](@DataSourceId, NULL)
		
	IF OBJECT_ID(''tempdb..#temp1'') IS NOT NULL 
		DROP TABLE #temp1

	CREATE TABLE #temp1
	(
		GMI_EXTF1ID			INT
		, ExchangeCode		VARCHAR(2)
		, FirmCode			VARCHAR(100)
		, AccountCode		VARCHAR(5)
		, InstrumentCode	VARCHAR(6)
		, CurrencyCode		VARCHAR(3)
		, ContractYearMonth	VARCHAR(6)
		, ContractDay		VARCHAR(2)
		, Strike			VARCHAR(17)
		, RecordType		VARCHAR(1)
		, TransactionType	VARCHAR(1)
		, PutCallCode		VARCHAR(1)
		, Quantity			DECIMAL(19,4)
		, TradeDate			VARCHAR(8)
		, TradePrice		DECIMAL(19,8)
		, AsOfDate			DATETIME
		, MarketValue		DECIMAL(19,2)
		, BuySell			VARCHAR(1)
		, NumericClosingPrice	DECIMAL(19,8)

	)

	INSERT INTO #temp1
	(	
		GMI_EXTF1ID
		, ExchangeCode
		, FirmCode
		, AccountCode
		, InstrumentCode
		, CurrencyCode
		, ContractYearMonth
		, ContractDay
		, Strike
		, RecordType
		, TransactionType
		, PutCallCode
		, Quantity
		, TradeDate
		, TradePrice
		, AsOfDate
		, MarketValue
		, BuySell
		, NumericClosingPrice
	)
	SELECT GMI_EXTF1ID
		, LTRIM(RTRIM(Exchange))
		, LTRIM(RTRIM(GmiFirmIdent))
		, LTRIM(RTRIM(AccountIdent))
		, LTRIM(RTRIM(FuturesCodeSymbolCusip))
		, LTRIM(RTRIM(CurrencySymbol))
		, ContractYearMonth
		, LTRIM(RTRIM(ContractDay))
		, StrikeOrCusip
		, RecordType
		, TransactionType
		, PutCallCode
		, Quantity
		, TradeDate
		, InputTradePrice
		, AsOfDate
		, MarketValueOrOpenTradeEquity
		, BuySell
		, NumericClosingPrice
	
	FROM GMI_EXTF1 g
	WHERE g.LoadState = 1
		AND g.Filename = @LocationPath
		AND TransactionType IN (''P'')

	--rd - make sure the As Of Date is not older than acceptable	
	DECLARE @CheckAsOfDate DATETIME
	SET @CheckAsOfDate = (SELECT MIN(AsOfDate) AS CheckRunDate FROM #temp1 WHERE AsOfDate IS NOT NULL)
	IF (@CheckAsOfDate IS NOT NULL)
	BEGIN		
		DECLARE @IsAcceptable bit
		EXECUTE [dbo].[Load_IsFileTooOld] @DataSourceId,@LocationPath,@CheckAsOfDate,@IsAcceptable OUTPUT, @ReceiveLocationSysId, @RunId
		IF (@IsAcceptable = 0)
		BEGIN
			DROP TABLE #temp1
			UPDATE GMI_EXTF1 SET [LoadState] = 3 WHERE [Filename] = @LocationPath
			RAISERROR (''File is too old.'', 18, 0)
			RETURN 0
		END
	END	

	
SET XACT_ABORT ON 
			
BEGIN TRANSACTION T1
	
-- BizTalk''s SQL Adapter uses more restrictive read serializable
-- so this is necessary to relax it to something that is default
-- and perfectly acceptable!

SET TRANSACTION ISOLATION LEVEL READ COMMITTED

BEGIN TRY
	
	DECLARE pos_cursor CURSOR FOR
	SELECT GMI_EXTF1ID
		, ExchangeCode
		, FirmCode
		, AccountCode
		, InstrumentCode
		, CurrencyCode
		, ContractYearMonth
		, ContractDay
		, Strike
		, RecordType
		, TransactionType
		, PutCallCode
		, Quantity
		, TradeDate
		, TradePrice
		, AsOfDate
		, MarketValue
		, BuySell
		, NumericClosingPrice
	FROM #temp1

	OPEN pos_cursor

	FETCH NEXT FROM pos_cursor
	INTO @GMI_EXTF1ID
		, @ExchangeCode
		, @FirmCode
		, @AccountCode
		, @InstrumentCode
		, @CurrencyCode
		, @ContractYearMonth
		, @ContractDay
		, @Strike
		, @RecordType
		, @TransactionType
		, @PutCallCode
		, @Quantity
		, @TradeDate
		, @TradePrice
		, @AsOfDate
		, @MarketValue
		, @BuySell
		, @NumericClosingPrice
		
	-- Check @@FETCH_STATUS to see IF there are any more rows to fetch.
	WHILE @@FETCH_STATUS = 0
	BEGIN
				-- Set the FirmId (add if doesn''t exist)
				DECLARE @FirmId INT
				EXEC [dbo].[ib_Firm_AddAsNeeded] @DataSourceId, @FirmCode , @FirmId OUTPUT
								
				DECLARE @ExpYr SMALLINT
				SET @ExpYr = LEFT(@ContractYearMonth, 4)
				
				DECLARE @ExpMth SMALLINT
				SET @ExpMth = RIGHT(@ContractYearMonth, 2)
				
				DECLARE @ExpDay SMALLINT
								
				IF @ContractDay IS NULL OR @ContractDay = ''''
					BEGIN
						-- Get the last day of the month
						SET @ExpDay = dbo.udf_OnLoad_ExpiryDate_Get_Day(@ExpYr,@ExpMth,@ContractDay)
					END
				ELSE	SET @ExpDay = CAST(@ContractDay AS INT)
											
				DECLARE @TrxTypeCode VARCHAR(25)
				SET @TrxTypeCode = ISNULL(@RecordType, '''') + ISNULL(@TransactionType, '''')
				
				DECLARE @OptionTypeCode VARCHAR(25)
				SET @OptionTypeCode = ISNULL(@PutCallCode, '' '')	
	
				-- Set the InstrumentTypeCode from OptionTypeCode
				DECLARE @InstrumentTypeCode VARCHAR(25)
				IF @OptionTypeCode IN (''P'',''C'')
						SET @InstrumentTypeCode = ''O''			
				ELSE
						SET @InstrumentTypeCode = ''F''
				
				-- MBAL-15070 Update the Instrument code
				SET @InstrumentCode = @InstrumentTypeCode + ''_'' + @ExchangeCode + ''_'' + @InstrumentCode
				
				-- TradeDate is in yyyymmdd ISO 112 format
				DECLARE @TrxDate DATETIME
				SET @TrxDate = CONVERT(DATETIME, @TradeDate, 112)
	
				-- Set StrikePrice				
				DECLARE @StrikePrice				DECIMAL(19,4)
				DECLARE @StrikePriceDivisor			DECIMAL(19,4)
				DECLARE @PriceDivisor				DECIMAL(19,4)
				DECLARE @MarketValueDivisor			DECIMAL(19,4)
				DECLARE @Base						INT
				DECLARE @BaseId						INT
				
				SET @StrikePriceDivisor = NULL
				SET	@PriceDivisor = NULL
				SET	@MarketValueDivisor = NULL
				SET @Base = NULL
				SET @BaseId = NULL
				
				SELECT @StrikePriceDivisor = ids.StrikePriceDivisor
						, @PriceDivisor = ids.PriceDivisor
						, @MarketValueDivisor = ids.MarketValueDivisor
						, @Base = b.Base
						, @BaseId = b.BaseId
				FROM [dbo].[ib_InstrumentDataSource] ids
					LEFT OUTER JOIN ib_Base b ON b.BaseId = ids.BaseId
				WHERE ids.DataSourceId = @DataSourceId
					AND ids.DataSourceInstrumentCode = @InstrumentCode
								
				IF @StrikePriceDivisor IS NULL
					BEGIN
						SET @StrikePrice = CAST(@Strike AS DECIMAL(19,4)) / @DefaultStrikePriceDivisor
					END
				ELSE
					BEGIN
						SET @StrikePrice = CAST(@Strike AS DECIMAL(19,4)) / @StrikePriceDivisor
					END
				
				-- Set Price				
				IF @PriceDivisor IS NULL 
					SET @PriceDivisor = 1
					
				DECLARE @PriceDec DECIMAL(24,10)
				SET @PriceDec = CONVERT(DECIMAL(24, 10), @TradePrice)
				--fix the 5-6 dp
				SET @PriceDec = dbo.PerformCorrections(@PriceDec, @BaseId)
				SET @PriceDec = @PriceDec / @PriceDivisor -- Watch out, the precision is less than the input type
						
				-- Set SettlementPrice
				DECLARE @SettlementPrice DECIMAL(24,10)
				SET @SettlementPrice = CONVERT(DECIMAL(24,10), @NumericClosingPrice)
				--fix the 5-6 dp
				SET @SettlementPrice = dbo.PerformCorrections(@SettlementPrice, @BaseId)			
				--divide it
				SET @SettlementPrice = @SettlementPrice / @PriceDivisor
				
				-- Set Market Value
				IF @MarketValueDivisor IS NULL SET @MarketValueDivisor = 1
				
				DECLARE @MarketValueDec DECIMAL(19,4)
				SET @MarketValueDec = CONVERT(DECIMAL(19,4), @MarketValue) / @MarketValueDivisor
				
				DECLARE @SignedQuantity DECIMAL(19,4)
				SET @SignedQuantity = @Quantity
				
				-- Set QuantityLong
				DECLARE @QuantityLong INT
				IF (@BuySell = ''1'')
					BEGIN
						SET @QuantityLong = CONVERT(INT, @Quantity)
					END
				ELSE
					SET @QuantityLong = 0
								
				-- Set QuantityShort
				DECLARE @QuantityShort INT
				IF (@BuySell = ''2'')
					BEGIN
						SET @QuantityShort = CONVERT(INT, @Quantity)
						SET @SignedQuantity = @Quantity * (-1)
					END
				ELSE
					SET @QuantityShort = 0
				
				DECLARE @PositionId INT
				SET @PositionId = NULL
				
				-- TODO: Check on Class logic
				EXEC	[dbo].[ib_Position_Load]
					@DataSourceCode	
					, @ExchangeCode	
					, @FirmCode	
					, @AccountCode		
					, @AsOfDate	
					, @InstrumentCode	
					, @SignedQuantity
					, @MarketValueDec 
					, @ExpYr		
					, @ExpMth					
					, @ExpDay
					, @StrikePrice 
					, @TrxTypeCode	
					, @OptionTypeCode	
					, @TrxDate	
					, @PriceDec 
					, @GMI_EXTF1ID --@TempTableRecordId	
					, @InstrumentTypeCode 
					, @LocationPath		
					, @CurrencyCode 
					, @QuantityLong 
					, @QuantityShort		 
					, NULL -- @TradedLongQuantity
					, NULL -- @TradedShortQuantity					
					, @PositionId = @PositionId OUTPUT
					, @ReceiveLocationSysId = @ReceiveLocationSysId
					, @RunId = @RunId

					SET @SelectedAsOfDate = @AsOfDate											
			-- Add Settlement Price											
			EXEC ib_Price_AddFromPositionLoad
				@PositionId
				, @ImportFileId
				, @SettlementPrice 	
				
 		-- Flip processed flag in source table
		UPDATE GMI_EXTF1
		WITH (ROWLOCK)
		SET LoadState = 2
		WHERE GMI_EXTF1ID = @GMI_EXTF1ID
			AND LoadState = 1

		SET @AddCount = @AddCount + 1
		
		FETCH NEXT FROM pos_cursor
		INTO @GMI_EXTF1ID
			, @ExchangeCode
			, @FirmCode
			, @AccountCode
			, @InstrumentCode
			, @CurrencyCode
			, @ContractYearMonth
			, @ContractDay
			, @Strike
			, @RecordType
			, @TransactionType
			, @PutCallCode
			, @Quantity
			, @TradeDate
			, @TradePrice
			, @AsOfDate
			, @MarketValue
			, @BuySell
			, @NumericClosingPrice
	END
						
	CLOSE pos_cursor
	DEALLOCATE pos_cursor
	
			
	SET @Message = @DataSourceCode + '' GMIEXTF1 position loader ended ('' 
		+ CONVERT(VARCHAR(10), @AddCount) + '' added)'' 
		
	EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @Message, ''Success'', '''', @RunId
	UPDATE ib_ImportFile SET AsOfDate= @SelectedAsOfDate WHERE ImportFileId=@ImportFileId
	COMMIT TRANSACTION
		
	DROP TABLE #temp1
	
END TRY
BEGIN CATCH 

	IF XACT_STATE() = -1 
		ROLLBACK TRANSACTION
	
	SET @Message = @DataSourceCode + '' GMIEXTF1 position loader failed'' 		
	EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @Message, ''Error'', '''', @RunId
	
	EXEC [dbo].[sp_RethrowError]
		
END CATCH 

SET XACT_ABORT OFF
	
RETURN 0
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_DataSourceExchange_Update]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_DataSourceExchange_Update]
(
	@DataSourceExchangeId INT
	, @DataSourceId INT
	, @DataSourceExchangeCode VARCHAR(100)
    , @UpdateUsername VARCHAR(50)
)
AS
SET NOCOUNT ON
 /*
-- Updates a exchange from the ib_DataSourceExchange table by its id
-- 17 May 2010 ED created 
-- 08 Nov 2010	AAJM	Updated to allow DataSourceExchangeCode unique to DataSource but not
--						unique to table.
*/
BEGIN TRY
--check for duplicates 
EXEC [dbo].[ib_DataSourceExchange_CheckForDuplicate] @DataSourceExchangeCode, @DataSourceId, @DataSourceExchangeId

UPDATE ib_DataSourceExchange
   SET DataSourceExchangeCode = @DataSourceExchangeCode,
	    DataSourceId = @DataSourceId,
	    UpdateUsername=@UpdateUsername
 WHERE DataSourceExchangeId = @DataSourceExchangeId
END TRY
BEGIN CATCH
	EXEC [dbo].[sp_RethrowError]
END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[C21_Footer]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[C21_Footer]
(
[FooterID] [int] NOT NULL IDENTITY(1, 1),
[RecordType] [varchar] (5) NULL,
[FileType] [varchar] (50) NULL,
[LineCounter] [int] NULL,
[OrgID] [varchar] (5) NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_C21_Footer_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_C21_Footer_CreateDate] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_C21_Footer] on [dbo].[C21_Footer]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[C21_Footer] ADD CONSTRAINT [PK_C21_Footer] PRIMARY KEY CLUSTERED  ([FooterID])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[C21_Delete]''
');

GO
EXECUTE ('


-- =============================================
-- Author:		Lee Manifold
-- Create date: 15 Jun 2006
-- Description:	Deletes records from the C21 tables
-- =============================================
CREATE PROCEDURE [dbo].[C21_Delete]
	(
	@OrgID		varchar(5)
	)
	
AS
BEGIN

	SET NOCOUNT ON

	DELETE 
	FROM	[dbo].[C21_Header]
	WHERE	[ClearingOrganisationID] = @OrgID 

	DELETE 
	FROM	[dbo].[C21_Footer]
	WHERE	[OrgID] = @OrgID 

	DELETE 
	FROM	[dbo].[C21_DetailLine]
	WHERE	[OrgID] = @OrgID 
	
	DELETE 
	FROM	[dbo].[C21_PreviousDayLine]
	WHERE	[OrgID] = @OrgID 

	DELETE 
	FROM	[dbo].[C21_ResumeLine]
	WHERE	[OrgID] = @OrgID 

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[vw_aspnet_Roles]''
');

GO
SET QUOTED_IDENTIFIER OFF

GO
EXECUTE ('
  CREATE VIEW [dbo].[vw_aspnet_Roles]
  AS SELECT [dbo].[aspnet_Roles].[ApplicationId], [dbo].[aspnet_Roles].[RoleId], [dbo].[aspnet_Roles].[RoleName], [dbo].[aspnet_Roles].[LoweredRoleName], [dbo].[aspnet_Roles].[Description]
  FROM [dbo].[aspnet_Roles]
  
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Rule_Update]''
');

GO
SET QUOTED_IDENTIFIER ON

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Rule_Update]
	@RuleId int, 
	@Name nvarchar(150) = null,
	@Description nvarchar(450) = null,
	@IsEnabled bit = null,
	@MatchCountTypeId int = null,
	@Tolerance decimal(18,4) = null,
	@UpdateUsername nvarchar(100) = null,
	@TemplateId int = null,
	@ToleranceTypeId int = null
AS
SET NOCOUNT ON
	SELECT
		@Name = CASE WHEN @Name IS NULL THEN [Name] ELSE @Name END,
		@Description = CASE WHEN @Description IS NULL THEN [Description] ELSE @Description END,
		@IsEnabled = CASE WHEN @IsEnabled IS NULL THEN [IsEnabled] ELSE @IsEnabled END,
		@MatchCountTypeId = CASE WHEN @MatchCountTypeId  IS NULL THEN [MatchCountTypeId] ELSE @MatchCountTypeId  END,
		@Tolerance = CASE WHEN @Tolerance IS NULL THEN Tolerance ELSE @Tolerance  END,
		@TemplateId = CASE WHEN @TemplateId IS NULL THEN TemplateId ELSE @TemplateId END,
		@ToleranceTypeId = CASE WHEN @ToleranceTypeId IS NULL THEN ToleranceTypeId ELSE @ToleranceTypeId END
	FROM 
		[dbo].[ib_Rule]
	WHERE
		RuleId = @RuleId
	
	UPDATE
		[dbo].[ib_Rule]
	SET	
		[Name] = @Name,
		[Description] = @Description,
		[IsEnabled] = @IsEnabled,
		[UpdateUsername] = @UpdateUsername,
		[UpdateDate] = getdate(),
		[MatchCountTypeId] = @MatchCountTypeId,
		Tolerance = @Tolerance,
		TemplateId = @TemplateId,
		ToleranceTypeId = @ToleranceTypeId
	WHERE
		RuleId = @RuleId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_GMI_EXTF1_Trx_Load]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_GMI_EXTF1_Trx_Load]
(
	@LocationPath		VARCHAR(100)
	, @DataSourceId		INT
	, @DataSourceCode	VARCHAR(100)
	, @ReceiveLocationSysId INT
	, @RunId INT	
)
AS
SET NOCOUNT ON

-- Description: Load Transactions for GMIEXTF1

-- History:
-- 11 Mar 2010	AAJM	MBAL-14813 Creation
-- 26 Mar 2010	AAJM	MBAL-15070 Include Exchange in Instrument Data Source Code
-- 06 Apr 2010	AAJM	MBAL-15070 Fix truncation of Instrument Data Source Code
-- 12 Apr 2010	AAJM	MBAL-15187 Fix Expiry Day loaded incorrectly
-- 12 Apr 2010	AAJM	MBAL-15195 Fix sold positions appearing as positive
-- 12 Apr 2010	AAJM	Update to use MarketValueDivisor
-- 13 Apr 2010	AAJM	Use concatenated instrument code to look up divisors
-- 23 Apr 2010	AAJM	MBAL-15411 Change Market Value source
-- 05 May 2010	amk		MBAL-15481 trade price still 19,4 - should be longer
-- 06 May 2010  ED      MBAL-15459 Change Market Value source
-- 17 May 2010  ED		MBAL-15550 Giveup Trades
-- 02 Jun 2010	amk		MBAL-15696 bug fix: reset divisors so they don''t carry from previous run
-- 17 Jun 2010  ED		MBAL 15621 - add logic for converting from 5 to 6 decimals
-- 23 Jun 2010	ED		MBAL 15913 - Tidy up Trade/Settlement Price Corrections for Rounded Prices
-- 01 Jul 2010	AAJM	MBAL-15637 - Add trx types TC TE and TX
-- 26 Jul 2010	AAJM	MBAL-16289 - Add TV Transaction Type
-- 02 Jan 2014  RD		MBAL-24931 Added checking file age
-- 09 Jan 2014	ED		EIB 25004 - remove importLog table and use Log table
-- 25 Apr 2014	ED		EIB 25473 - raise error if file is too old and mark temp records as LoadState=3

		DECLARE @Message			VARCHAR(1024)
		DECLARE @AddCount			INT
			SET @AddCount = 0

		DECLARE @Code				VARCHAR(100)
		DECLARE @ReturnValue		INT
		DECLARE @Output				INT
		DECLARE @Output2			INT
		DECLARE @DefaultCurrencyId	INT

		-- Variables for values from Temp rows selected:
		DECLARE @GMI_EXTF1ID		INT
		DECLARE @ExchangeCode		VARCHAR(2)
		DECLARE @FirmCode			VARCHAR(100)
		DECLARE @AccountCode		VARCHAR(5)
		DECLARE @InstrumentCode		VARCHAR(100)
		DECLARE @CurrencyCode		VARCHAR(3)
		DECLARE @ContractYearMonth	VARCHAR(6)
		DECLARE @ContractDay		VARCHAR(2)
		DECLARE @Strike				VARCHAR(17)
		DECLARE @RecordType			VARCHAR(1)
		DECLARE @TransactionType	VARCHAR(1)
		DECLARE @PutCallCode		VARCHAR(1)
		DECLARE @Quantity			DECIMAL(19,4)		
		DECLARE @TradeDate			VARCHAR(8)
		DECLARE @TradePrice			DECIMAL(19,8)
		DECLARE @AsOfDate			DATETIME
		DECLARE @MarketValue		DECIMAL(19,2)
		DECLARE @BuySell			VARCHAR(1)
		DECLARE @GrossAmount		DECIMAL(19,2)
	
	--Gets the defaultStrikePriceDivisor
	DECLARE	@DefaultStrikePriceDivisor	decimal(19,6)
	SET @DefaultStrikePriceDivisor = [dbo].[udf_GetDefaultStrikePriceDivisor](@DataSourceId, NULL)
	
	
	IF OBJECT_ID(''tempdb..#temp1'') IS NOT NULL 
		DROP TABLE #temp1

	CREATE TABLE #temp1
	(
		GMI_EXTF1ID			INT
		, ExchangeCode		VARCHAR(2)
		, FirmCode			VARCHAR(100)
		, AccountCode		VARCHAR(5)
		, InstrumentCode	VARCHAR(6)
		, CurrencyCode		VARCHAR(3)
		, ContractYearMonth	VARCHAR(6)
		, ContractDay		VARCHAR(2)
		, Strike			VARCHAR(17)
		, RecordType		VARCHAR(1)
		, TransactionType	VARCHAR(1)
		, PutCallCode		VARCHAR(1)
		, Quantity			DECIMAL(19,4)
		, TradeDate			VARCHAR(8)
		, TradePrice		DECIMAL(19,8)
		, AsOfDate			DATETIME
		, MarketValue		DECIMAL(19,2)
		, BuySell			VARCHAR(1)
		, GrossAmount		DECIMAL(19,2)

	)

	INSERT INTO #temp1
	(	
		GMI_EXTF1ID
		, ExchangeCode
		, FirmCode
		, AccountCode
		, InstrumentCode
		, CurrencyCode
		, ContractYearMonth
		, ContractDay
		, Strike
		, RecordType
		, TransactionType
		, PutCallCode
		, Quantity
		, TradeDate
		, TradePrice
		, AsOfDate
		, MarketValue
		, BuySell
		, GrossAmount
	)
	SELECT GMI_EXTF1ID
		, LTRIM(RTRIM(Exchange))
		, LTRIM(RTRIM(GmiFirmIdent))
		, LTRIM(RTRIM(AccountIdent))
		, LTRIM(RTRIM(FuturesCodeSymbolCusip))
		, LTRIM(RTRIM(CurrencySymbol))
		, ContractYearMonth
		, LTRIM(RTRIM(ContractDay))
		, StrikeOrCusip
		, RecordType
		, TransactionType
		, PutCallCode
		, Quantity
		, TradeDate
		, InputTradePrice
		, AsOfDate
		, MarketValueOrOpenTradeEquity
		, BuySell
		, GrossAmount
	
	FROM GMI_EXTF1 g
	WHERE g.LoadState = 1
		AND g.Filename = @LocationPath
		AND TransactionType IN (''T'',''L'',''Q'', ''C'',''E'',''X'',''V'')
		AND GiveInGiveOutCode!=''GO''

	--rd - make sure the As Of Date is not older than acceptable	
	DECLARE @CheckAsOfDate DATETIME
	SET @CheckAsOfDate = (SELECT MIN(AsOfDate) AS CheckRunDate FROM #temp1 WHERE AsOfDate IS NOT NULL)
	IF (@CheckAsOfDate IS NOT NULL)
	BEGIN		
		DECLARE @IsAcceptable bit
		EXECUTE [dbo].[Load_IsFileTooOld] @DataSourceId,@LocationPath,@CheckAsOfDate,@IsAcceptable OUTPUT, @ReceiveLocationSysId, @RunId
		IF (@IsAcceptable = 0)
		BEGIN
			DROP TABLE #temp1
			UPDATE GMI_EXTF1 SET [LoadState] = 3 WHERE [Filename] = @LocationPath
			RAISERROR (''File is too old.'', 18, 0)
			RETURN 0
		END
	END	
	
SET XACT_ABORT ON 
			
BEGIN TRANSACTION T1
	
-- BizTalk''s SQL Adapter uses more restrictive read serializable
-- so this is necessary to relax it to something that is default
-- and perfectly acceptable!

SET TRANSACTION ISOLATION LEVEL READ COMMITTED

BEGIN TRY
	
	DECLARE pos_cursor CURSOR FOR
	SELECT GMI_EXTF1ID
		, ExchangeCode
		, FirmCode
		, AccountCode
		, InstrumentCode
		, CurrencyCode
		, ContractYearMonth
		, ContractDay
		, Strike
		, RecordType
		, TransactionType
		, PutCallCode
		, Quantity
		, TradeDate
		, TradePrice
		, AsOfDate
		, MarketValue
		, BuySell
		, GrossAmount
	FROM #temp1

	OPEN pos_cursor

	FETCH NEXT FROM pos_cursor
	INTO @GMI_EXTF1ID
		, @ExchangeCode
		, @FirmCode
		, @AccountCode
		, @InstrumentCode
		, @CurrencyCode
		, @ContractYearMonth
		, @ContractDay
		, @Strike
		, @RecordType
		, @TransactionType
		, @PutCallCode
		, @Quantity
		, @TradeDate
		, @TradePrice
		, @AsOfDate
		, @MarketValue
		, @BuySell
		, @GrossAmount
		
	-- Check @@FETCH_STATUS to see IF there are any more rows to fetch.
	WHILE @@FETCH_STATUS = 0
	BEGIN

						-- Set the FirmId (add if doesn''t exist)
				DECLARE @FirmId INT
				EXEC [dbo].[ib_Firm_AddAsNeeded] @DataSourceId, @FirmCode , @FirmId OUTPUT
								
				DECLARE @ExpYr SMALLINT
				SET @ExpYr = LEFT(@ContractYearMonth, 4)
				
				DECLARE @ExpMth SMALLINT
				SET @ExpMth = RIGHT(@ContractYearMonth, 2)
				
				DECLARE @ExpDay SMALLINT
								
				IF @ContractDay IS NULL OR @ContractDay = ''''
					BEGIN
						-- Get the last day of the month
						SET @ExpDay = dbo.udf_OnLoad_ExpiryDate_Get_Day(@ExpYr,@ExpMth,@ContractDay)
					END
				ELSE	SET @ExpDay = CAST(@ContractDay AS INT)
				
											
				DECLARE @TrxTypeCode VARCHAR(25)
				SET @TrxTypeCode = ISNULL(@RecordType, '''') + ISNULL(@TransactionType, '''')
				
				DECLARE @OptionTypeCode VARCHAR(25)
				SET @OptionTypeCode = ISNULL(@PutCallCode, '' '')
				
				-- Set the InstrumentTypeCode from OptionTypeCode
				DECLARE @InstrumentTypeCode VARCHAR(25)
				IF @OptionTypeCode IN (''P'',''C'')
						SET @InstrumentTypeCode = ''O''			
				ELSE
						SET @InstrumentTypeCode = ''F''
				
				-- MBAL-15070 Update the Instrument code
				SET @InstrumentCode = @InstrumentTypeCode + ''_'' + @ExchangeCode + ''_'' + @InstrumentCode
				
				-- TradeDate is in yyyymmdd ISO 112 format
				DECLARE @TrxDate DATETIME
				SET @TrxDate = CONVERT(DATETIME, @TradeDate, 112)	
	
				-- Set StrikePrice				
				DECLARE @StrikePrice				DECIMAL(19,4)
				DECLARE @StrikePriceDivisor			DECIMAL(19,4)
				DECLARE @PriceDivisor				DECIMAL(19,4)
				DECLARE @MarketValueDivisor			DECIMAL(19,4)
				DECLARE @Base						INT
				DECLARE @BaseId						INT

				SET @StrikePriceDivisor = NULL
				SET @PriceDivisor = NULL
				SET @MarketValueDivisor = NULL
				SET @Base = NULL
				SET @BaseId = NULL
				
				SELECT @StrikePriceDivisor = ids.StrikePriceDivisor
						, @PriceDivisor = ids.PriceDivisor
						, @MarketValueDivisor = ids.MarketValueDivisor
						, @Base = b.Base
						, @BaseId = b.BaseId
				FROM [dbo].[ib_InstrumentDataSource] ids
					LEFT OUTER JOIN ib_Base b ON b.BaseId = ids.BaseId
				WHERE ids.DataSourceId = @DataSourceId
					AND ids.DataSourceInstrumentCode = @InstrumentCode
				
				IF @StrikePriceDivisor IS NULL
					BEGIN
						SET @StrikePrice = CAST(@Strike AS DECIMAL(19,4)) / @DefaultStrikePriceDivisor
					END
				ELSE
					BEGIN
						SET @StrikePrice = CAST(@Strike AS DECIMAL(19,4)) / @StrikePriceDivisor
					END
				
				-- Set Price				
				IF @PriceDivisor IS NULL 
					SET @PriceDivisor = 1
					
				DECLARE @PriceDec DECIMAL(24, 10)
				SET @PriceDec = CONVERT(DECIMAL(24, 10), @TradePrice)
				--fix the 5-6 dp
				SET @PriceDec = dbo.PerformCorrections(@PriceDec, @BaseId)	
				SET @PriceDec = @PriceDec / @PriceDivisor -- Watch out, the precision is less than the input type					
					
				-- Set Price to Zero for certain transaction types (to match R&N feed)					
				IF (UPPER(@TransactionType) IN (''E'',''X''))
					SET @PriceDec = 0
					
				-- Set Market Value
				IF @MarketValueDivisor IS NULL SET @MarketValueDivisor = 1
					
				DECLARE @MarketValueSource DECIMAL(19,2)
				
				-- All should currently == @GrossAmount
				--IF (UPPER(@TransactionType) IN (''L'',''Q'',''T'',''C'',''E'',''X'', ''V''))
					SET @MarketValueSource = @GrossAmount
					
				DECLARE @MarketValueDec DECIMAL(19,4)
				SET @MarketValueDec = CONVERT(DECIMAL(19,4), @MarketValueSource) / @MarketValueDivisor
											
				DECLARE @SignedQuantity DECIMAL(19,4)
				SET @SignedQuantity = @Quantity
								
				-- Set QuantityLong
				DECLARE @QuantityLong INT
				IF (@BuySell = ''1'')
					BEGIN
						SET @QuantityLong = CONVERT(INT, @Quantity)
					END
				ELSE
					SET @QuantityLong = 0
								
				-- Set QuantityShort
				DECLARE @QuantityShort INT
				IF (@BuySell = ''2'')
					BEGIN
						SET @QuantityShort = CONVERT(INT, @Quantity)
						SET @SignedQuantity = @Quantity * (-1)
					END	
				ELSE
					SET @QuantityShort = 0
				
				-- TX and TE Transactions should have a negative quantity
				IF (UPPER(@TransactionType) = ''X'' OR UPPER(@TransactionType) = ''E'')
				BEGIN
					SET @SignedQuantity = @SignedQuantity * (-1)					
					SET @QuantityLong = @QuantityLong * (-1)
					SET @QuantityShort = @QuantityShort * (-1)
				END
					
				EXEC [ib_Trx_Load]
				@DataSourceCode												
				, @ExchangeCode												
				, @FirmCode													
				, @AccountCode												
				, NULL -- DetailAccountCd
				, @InstrumentCode		
				, @ExpYr		
				, @ExpMth					
				, @ExpDay
				, @StrikePrice 
				, @TrxTypeCode						
				, @OptionTypeCode								
				, @SignedQuantity				
				, @TrxDate	
				, @PriceDec 
				, @GMI_EXTF1ID --@TempTableRecordId	
				, @InstrumentTypeCode 
				, @AsOfDate	
				, @LocationPath		
				, @MarketValueDec 
				, @CurrencyCode 
				, @QuantityLong = @QuantityLong 
				, @QuantityShort = @QuantityShort
				, @ReceiveLocationSysId = @ReceiveLocationSysId
				, @RunId = @RunId
		
 		-- Flip processed flag in source table
		UPDATE GMI_EXTF1
		WITH (ROWLOCK)
		SET LoadState = 2
		WHERE GMI_EXTF1ID = @GMI_EXTF1ID
			AND LoadState = 1

		SET @AddCount = @AddCount + 1
		
		FETCH NEXT FROM pos_cursor
		INTO @GMI_EXTF1ID
			, @ExchangeCode
			, @FirmCode
			, @AccountCode
			, @InstrumentCode
			, @CurrencyCode
			, @ContractYearMonth
			, @ContractDay
			, @Strike
			, @RecordType
			, @TransactionType
			, @PutCallCode
			, @Quantity
			, @TradeDate
			, @TradePrice
			, @AsOfDate
			, @MarketValue
			, @BuySell
			, @GrossAmount
	END
						
	CLOSE pos_cursor
	DEALLOCATE pos_cursor
	
			
	SET @Message = @DataSourceCode + '' GMIEXTF1 transaction loader ended ('' 
		+ CONVERT(VARCHAR(10), @AddCount) + '' added)'' 
		
	EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @Message, ''Success'', '''', @RunId
		
	COMMIT TRANSACTION
		
	DROP TABLE #temp1
	
END TRY
BEGIN CATCH 

	IF XACT_STATE() = -1 
		ROLLBACK TRANSACTION
	
	SET @Message = @DataSourceCode + '' GMIEXTF1 transaction loader failed'' 		
	EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @Message, ''Error'', '''', @RunId
	
	EXEC [dbo].[sp_RethrowError]
		
END CATCH 

SET XACT_ABORT OFF
	
RETURN 0
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Currency_GetCodeAndIdForAllCurrencys]''
');

GO
EXECUTE ('
   /*
<details>
 <summary>Returns code and id columns for all the Currencys</summary>
 <created author="laurentiu.macovei" date="Fri, 15 Sep 2006 01:07:52 GMT"/>
<updated author="Emilian Damian" Date="9 Feb 2007" /> 
<order by code>
</details>
--	16 Apr 2014		ED			EIB 25500 - deactivate currencies
*/
CREATE PROCEDURE [dbo].[ib_Currency_GetCodeAndIdForAllCurrencys]
AS
SET NOCOUNT ON
SELECT Code, CurrencyId 
	FROM ib_Currency WHERE IsActive = 1
    ORDER BY Code
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Department_CheckForDuplicate]''
');

GO
EXECUTE ('/*
<details>
 <summary>
	Checks for the duplicate departments with same code. 
</summary>
 <created author="konrad" date="24 Mar 2009 16:33:45 GMT"/>  
</details>
*/
CREATE PROCEDURE [dbo].[ib_Department_CheckForDuplicate]
	(
		@Code			varchar(100),
		@DepartmentId	int
	)
AS
SET NOCOUNT ON

	DECLARE @Count int

	SELECT	TOP 1 @Count = 1
	FROM	[dbo].[ib_Department] c
	WHERE	[Code] = @Code
	AND		[DepartmentId] <> @DepartmentId

	IF @Count > 0
		RAISERROR (N''There is already another department with same code (%s). Please specify other code!'', 11, 1, @Code)
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Department_Add]''
');

GO
EXECUTE ('/*
<details>
 <summary>Adds an department into the ib_Department table</summary>
 <created author="konrad" date="24 Mar 2009 16:33:45 GMT"/> 
</details>
*/
CREATE PROCEDURE [dbo].[ib_Department_Add]
	(
	@Code				varchar(100),
	@Description		varchar(100),
	@CreateUsername		varchar(50)= NULL,
	@@DepartmentId		int OUTPUT,
	@PriceTypeCode		varchar(50) = NULL	
	)
AS
SET NOCOUNT ON

	BEGIN TRY
	--check for duplicates 

		IF @CreateUsername IS NULL 
			SET @CreateUsername = (suser_sname())


		EXEC [dbo].[ib_Department_CheckForDuplicate] @Code, -1

		INSERT INTO [dbo].[ib_Department]
				   (
					[Code],
					[Description],
					[CreateUsername] 
					)
			 VALUES
				   (
					@Code, 
					@Description, 
					@CreateUsername
				    )

		SELECT @@DepartmentId = Scope_Identity()

	END TRY
	BEGIN CATCH
		EXEC [dbo].[sp_RethrowError]
	END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[C21_DetailLine_Add]''
');

GO
EXECUTE ('-- =============================================
-- Author:		Lee Manifold
-- Create date: 09 May 2006
-- Description: Biztalk: Clearing 21 insert into table 10000

-- 19 Feb 2010 - Added FileName to Add SP
-- =============================================
CREATE PROCEDURE [dbo].[C21_DetailLine_Add]
	(
	@FileName           VARCHAR (512)= NULL,
	@SettlementDate		varchar(8),
	@TMF				varchar(10),
	@PA15				varchar(15),
	@OrgID				varchar(5),
	@Busdate			varchar(8),
	@Wording			varchar(15),
	@TradingEngine		varchar(5),
	@c21TradeLegID		varchar(50),
	@ExtTradeLegID		varchar(50),
	@SendingMbr			varchar(50),
	@BuyQtyIFT			varchar(1),
	@BuyQtyQMT			decimal(14,4),
	@SellQtyIFT			varchar(1),
	@SellQtyQMT			varchar(18),
	@IFTPrice			varchar(1),
	@QMTPrice			varchar(18),
	@C21ID				varchar(50),
	@CorrectionType		varchar(1),
	@InstructionType	varchar(1),
	@Instruction		varchar(2),
	@OCind				varchar(1),
	@BuyQtyUpdateIFT	varchar(1),
	@BuyQtyUpdateQMT	varchar(18),
	@SellQtyUpdateIFT	varchar(1),
	@SellQtyUpdateQMT	varchar(18),
	@IFTDebit			varchar(1),
	@QMTDebit			varchar(18),
	@IFTCredit			varchar(1),
	@QMTCredit			varchar(18),
    @ContractAliasName		varchar(3),
    @ContractAliasExp1		varchar(1),
    @ContractAliasExp2		varchar(1),
    @ContractAliasExp3		varchar(1),
    @ContractAliasExp4		varchar(1),
    @ContractAliasStrike	 varchar(8),
    @ContractAliasCPF		varchar(1),
    @ContractAliasFull		varchar(40)
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

--raiserror (''krip doing specific error in stored proc for testing'', 19, 1) with log

DECLARE @ResumeLine	INT


INSERT INTO [dbo].[C21_DetailLine]
           (
		    [SettlementDate]	
		   ,[PA15]
		   ,[TMF]
		   ,[OrgID]
		   ,[Busdate]
           ,[Wording]
           ,[TradingEngine]
           ,[c21TradeLegID]
           ,[ExtTradeLegID]
           ,[SendingMbr]
           ,[BuyQtyIFT]
           ,[BuyQtyQMT]
           ,[SellQtyIFT]
           ,[SellQtyQMT]
           ,[IFTPrice]
           ,[QMTPrice]
           ,[C21ID]
           ,[CorrectionType]
           ,[InstructionType]
           ,[Instruction]
           ,[OCind]
           ,[BuyQtyUpdateIFT]
           ,[BuyQtyUpdateQMT]
           ,[SellQtyUpdateIFT]
           ,[SellQtyUpdateQMT]
           ,[IFTDebit]
           ,[QMTDebit]
           ,[IFTCredit]
           ,[QMTCredit]
		   ,[ContractAliasName]
		   ,[ContractAliasExp1]
		   ,[ContractAliasExp2]
		   ,[ContractAliasExp3]
		   ,[ContractAliasExp4]
		   ,[ContractAliasStrike]
		   ,[ContractAliasCPF]
		   ,[ContractAliasFull]
		   ,[FileName]	
			)
     VALUES
			(
			@SettlementDate		,
			@PA15				,
			@TMF				,
			@OrgID				,
			@Busdate			,
			@Wording			,
			@TradingEngine		,
			@c21TradeLegID		,
			@ExtTradeLegID		,
			@SendingMbr			,
			@BuyQtyIFT			,
			@BuyQtyQMT			,
			@SellQtyIFT			,
			@SellQtyQMT			,
			@IFTPrice			,
			@QMTPrice			,
			@C21ID				,
			@CorrectionType		,
			@InstructionType	,
			@Instruction		,
			@OCind				,
			@BuyQtyUpdateIFT	,
			@BuyQtyUpdateQMT	,
			@SellQtyUpdateIFT	,
			@SellQtyUpdateQMT	,
			@IFTDebit			,
			@QMTDebit			,
			@IFTCredit			,
			@QMTCredit			,
			@ContractAliasName	,
			@ContractAliasExp1	,
			@ContractAliasExp2	,
			@ContractAliasExp3	,
			@ContractAliasExp4	,
			@ContractAliasStrike,
			@ContractAliasCPF,
			@ContractAliasFull,
			@FileName
			)
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[LCH_TypeTR_Add]''
');

GO
EXECUTE ('

-- =============================================
-- Author:		Lee Manifold	
-- Create date: 19 Jun 2006
-- Description:	Insert into LIFFE_TypeTR table 
-- =============================================
CREATE PROCEDURE [dbo].[LCH_TypeTR_Add]
	(
	@FileName				VARCHAR (512) = NULL,
	@Exchange				varchar(3),
	@SequenceNumber			varchar(5), -- int,
	@DownloadNumber			varchar(4), --int,
	@RecordType				varchar(4), --int,
	@ClearingSlipID			varchar(10), --int,
	@SubTradeSequenceNumber	varchar(3), --int,
	@ClearingSlipType		varchar(1),
	@TradeType				varchar(1),
	@CrossType				varchar(1),
	@HalfTradeStatus		varchar(2),
	@TraderCardReference	varchar(16),
	@OriginatingTraderName	varchar(3),
	@OriginatingMemberName	varchar(3),
	@OriginatingClearerName	varchar(3),
	@CounterPartyTraderName	varchar(3),
	@CounterpartyMemberName	varchar(3),
	@BuyorSell				varchar(1),
	@ContractType			varchar(1),
	@GenericContractType	varchar(1),
	@PhysicalCommodity		varchar(3),
	@LogicalCommodity		varchar(3),
	@DeliveryMonth			varchar(1),
	@LongExpiryDate			varchar(8),
	@ExercisePrice			varchar(9), --int,
	@Price					varchar(9), --int,
	@Volume					varchar(6), --int,
	@TradeChargeIndicator	varchar(1),
	@AccountCode			varchar(1),
	@AllocationTraderName	varchar(3),
	@AllocationMemberName	varchar(3),
	@OpenorClose			varchar(1),
	@DateEntered			varchar(8),
	@TimeEntered			varchar(6),
	@TimeTraded				varchar(6),
	@TimeLastModified		varchar(6),
	@TimeAssignment			varchar(6),
	@TimeMatched			varchar(6),
	@OperatorReference		varchar(12),
	@UserSpecifiedData		varchar(14),
	@MarginingAccount		varchar(1),
	@TradingDay				varchar(6), --int,
	@OrderSlipID			varchar(8), --int,
	@CustomerTypeIndicator	varchar(1),
	@TimeBracket			varchar(2),
	@TradingEnvironment		varchar(1),
	@CountertradeSlipNumber	varchar(10), --int,
	@CountertradeSubNumber	varchar(3), --int,
	@CounterclaimSlipNumber	varchar(10), --int,
	@SubAccount				varchar(4),
	@TransferIndicator		varchar(1),
	@CalandarDayOffset		varchar(2), --int,
	@OtisFba				varchar(3),
	@ConnectStrategyCode	varchar(1),
	@DesignatedAccount		varchar(1),
	@PostingCode			int,
	@SessionId				int,
	@TradeClipId			varchar(10), --int,
	@CustomerReference		varchar(14),
	@ConnectOrderId			varchar(20), --int,
	@Aggresor				varchar(1),
	@ActionFlag				varchar(1)
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON

 INSERT INTO [dbo].[LCH_TypeTR]
           (
			[Exchange]
           ,[SequenceNumber]
           ,[DownloadNumber]
           ,[RecordType]
           ,[ClearingSlipID]
           ,[SubTradeSequenceNumber]
           ,[ClearingSlipType]
           ,[TradeType]
           ,[CrossType]
           ,[HalfTradeStatus]
           ,[TraderCardReference]
           ,[OriginatingTraderName]
           ,[OriginatingMemberName]
           ,[OriginatingClearerName]
           ,[CounterPartyTraderName]
           ,[CounterpartyMemberName]
           ,[BuyorSell]
           ,[ContractType]
           ,[GenericContractType]
           ,[PhysicalCommodity]
           ,[LogicalCommodity]
           ,[DeliveryMonth]
           ,[LongExpiryDate]
           ,[ExercisePrice]
           ,[Price]
           ,[Volume]
           ,[TradeChargeIndicator]
           ,[AccountCode]
           ,[AllocationTraderName]
           ,[AllocationMemberName]
           ,[OpenorClose]
           ,[DateEntered]
           ,[TimeEntered]
           ,[TimeTraded]
           ,[TimeLastModified]
           ,[TimeAssignment]
           ,[TimeMatched]
           ,[OperatorReference]
           ,[UserSpecifiedData]
           ,[MarginingAccount]
           ,[TradingDay]
           ,[OrderSlipID]
           ,[CustomerTypeIndicator]
           ,[TimeBracket]
           ,[TradingEnvironment]
           ,[CountertradeSlipNumber]
           ,[CountertradeSubNumber]
           ,[CounterclaimSlipNumber]
           ,[SubAccount]
           ,[TransferIndicator]
           ,[CalandarDayOffset]
           ,[OtisFba]
           ,[ConnectStrategyCode]
           ,[DesignatedAccount]
           ,[PostingCode]
           ,[SessionId]
           ,[TradeClipId]
           ,[CustomerReference]
           ,[ConnectOrderId]
           ,[Aggresor]
           ,[ActionFlag]
           ,[FileName]
           )	
     VALUES
           (
			@Exchange				,
			@SequenceNumber			, 
			@DownloadNumber			,
			@RecordType				,
			@ClearingSlipID			,
			@SubTradeSequenceNumber	,
			@ClearingSlipType		,
			@TradeType				,
			@CrossType				,
			@HalfTradeStatus		,
			@TraderCardReference	,
			@OriginatingTraderName	,
			@OriginatingMemberName	,
			@OriginatingClearerName	,
			@CounterPartyTraderName	,
			@CounterpartyMemberName ,
			@BuyorSell				,
			@ContractType			,
			@GenericContractType	,
			@PhysicalCommodity		,
			@LogicalCommodity		,
			@DeliveryMonth			,
			@LongExpiryDate			,
			@ExercisePrice			,
			@Price					,
			@Volume					,
			@TradeChargeIndicator	,
			@AccountCode			,
			@AllocationTraderName	,
			@AllocationMemberName	,
			@OpenorClose			,
			@DateEntered			,
			@TimeEntered			,
			@TimeTraded				,
			@TimeLastModified		,
			@TimeAssignment			,
			@TimeMatched			,
			@OperatorReference		,
			@UserSpecifiedData		,
			@MarginingAccount		,
			@TradingDay				,
			@OrderSlipID			,
			@CustomerTypeIndicator	,
			@TimeBracket			,
			@TradingEnvironment		,
			@CountertradeSlipNumber	,
			@CountertradeSubNumber	,
			@CounterclaimSlipNumber	,
			@SubAccount				,
			@TransferIndicator		,
			@CalandarDayOffset		,
			@OtisFba				,
			@ConnectStrategyCode	,
			@DesignatedAccount		,
			@PostingCode			,
			@SessionId				,
			@TradeClipId			,
			@CustomerReference		,
			@ConnectOrderId			,
			@Aggresor				,
			@ActionFlag				,
			@FileName
			)

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[vw_aspnet_UsersInRoles]''
');

GO
SET QUOTED_IDENTIFIER OFF

GO
EXECUTE ('
  CREATE VIEW [dbo].[vw_aspnet_UsersInRoles]
  AS SELECT [dbo].[aspnet_UsersInRoles].[UserId], [dbo].[aspnet_UsersInRoles].[RoleId]
  FROM [dbo].[aspnet_UsersInRoles]
  
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_RuleCondition_Add]''
');

GO
SET QUOTED_IDENTIFIER ON

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_RuleCondition_Add]
	@RuleId int,
	 @InternalExternalCode CHAR(1) = null,
     @FieldId int,
     @IsEnabled bit = null,
     @OperatorId int,
     @Value NVARCHAR(255) = null,
     @SecondFieldId int = null,
     @Description NVARCHAR(255) = null,
     @CreateUsername NVARCHAR(50) = null
     ,@@ConditionId INT OUTPUT 
AS
SET NOCOUNT ON
	SELECT @SecondFieldId = CASE WHEN @SecondFieldId = -1 THEN NULL ELSE @SecondFieldId END
	SELECT @IsEnabled = CASE WHEN @IsEnabled IS NULL THEN 0 ELSE @IsEnabled END
	
	INSERT INTO [dbo].[ib_RuleCondition]
           ([RuleId]
           ,[Description]
           ,[InternalExternalCode]
           ,[Field1Id]
           ,[OperatorId]
           ,[Field2Id]
           ,[Value]
           ,[IsEnabled]
           ,[CreateDate]
           ,[CreateUsername]
           ,[UpdateDate]
           ,[UpdateUsername])
     VALUES
           (@RuleId
           ,@Description
           ,@InternalExternalCode
           ,@FieldId
           ,@OperatorId
           ,@SecondFieldId
           ,@Value
           ,@IsEnabled
           ,getdate()
           ,@CreateUsername
           ,getdate()
           ,@CreateUsername)
	SELECT 
		@@ConditionId = SCOPE_IDENTITY()
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_InstrumentDetail_CheckforDuplicate]''
');

GO
EXECUTE ('
/*	=============================================
	Author:			Lee Manifold
	Create date:	17 Oct 2006
	Description:	Tests to see if the record already exists. Sets output
					value to true or false
	History
	Date		Author	Desc
	
	=============================================
*/
Create proc [dbo].[ib_InstrumentDetail_CheckforDuplicate]
	(
	@InstrumentId		int,
	@ExpiryYear			smallint,
	@ExpiryMonth		smallint,
	@ExpiryDay			smallint,
	@StrikePrice		decimal(19,4),
	@OptionTypeCode		varchar(25),
	@AsOfDate			datetime,
	@Exists				bit Output
	)
AS
SET NOCOUNT ON
	SET @Exists = 0

	SELECT	TOP 1 @Exists = COUNT(*)
	FROM	[dbo].[ib_InstrumentDetail]
	WHERE	[InstrumentId]	=	@InstrumentId
	AND		[ExpiryYear]	=	@ExpiryYear	
	AND		[ExpiryMonth]	=	@ExpiryMonth
	AND		[ExpiryDay]		=	@ExpiryDay
	AND		[StrikePrice]	=	@StrikePrice
	AND		[OptionTypeCode]=	@OptionTypeCode
	AND		[AsOfDate]		=	@AsOfDate
');

GO
EXECUTE ('PRINT N''Creating [dbo].[HKFE_TPOO1_Format]''
');

GO
EXECUTE ('
-- =============================================
-- Author:		Lee Manifold
-- Create date: 13 Oct 2006
-- Description:	Extracts and interprets a field from HKFE datasource to return
--				InstrumentCode
--				ExpiryMonth
--				ExpiryYear
--				StrikePrice	 This is only set when type is an option.
--				InstrumentType		
--				
-- Note:		
-- 09 Jan 2014	ED		EIB 25004 - remove importLog table and use Log table
-- =============================================
CREATE proc [dbo].[HKFE_TPOO1_Format]
	(
	@InputString		varchar(15),
	@DataSourceId		int,
	@InstrumentCode		varchar(4)		output,
	@ExpiryMonth		tinyint			output,
	@ExpiryYear			smallint		output,
	@StrikePrice		int=NULL		output,
	@OptionTypeCode		varchar(1)=NULL output
	)
AS
SET NOCOUNT ON

	DECLARE @ExpiryMonthCode	varchar(1)
	DECLARE @StrikePriceLen		tinyint
	DECLARE @ReturnValue		int


	--Future
	IF (LEN(@InputString) = 5)  
		BEGIN
			SET @InstrumentCode		= ''F'' + LEFT(@InputString,3)
			SET @ExpiryMonthCode	= UPPER(SUBSTRING(@InputString, 4, 1))
			SET @ExpiryYear			= 2000 + CAST(SUBSTRING(@InputString, 5, 1) AS int)
			SET @StrikePrice		= 0
		END

	--Option
	IF LEN(@InputString) > 5  
		BEGIN
			SET @InstrumentCode		= ''O'' + LEFT(@InputString,3)
			SET @StrikePriceLen		= LEN(@InputString) - 5
			SET @StrikePrice		= SUBSTRING(@InputString, 4, @StrikePriceLen)
			SET @ExpiryMonthCode	= UPPER(SUBSTRING(@InputString, 4 + @StrikePriceLen, 1))
			SET @ExpiryYear			= 2000 + CAST(SUBSTRING(@InputString, 5 + @StrikePriceLen, 1) AS int)
			SET @OptionTypeCode =			
				CASE 		
					WHEN @ExpiryMonthCode IN (''F'',''G'',''H'',''J'',''K'',''M'',''N'',''Q'',''U'',''V'',''X'',''Z'') THEN		
						''C''
					WHEN @ExpiryMonthCode IN (''A'',''B'',''C'',''D'',''E'',''I'',''J'',''O'',''P'',''R'',''S'',''T'') THEN
						''P''
				END
		END

		SET @ExpiryMonth	= 
			CASE  
				WHEN @ExpiryMonthCode IN (''F'',''A'') THEN 1 --''JAN''
				WHEN @ExpiryMonthCode IN (''G'',''B'') THEN 2--''FEB''
				WHEN @ExpiryMonthCode IN (''H'',''C'') THEN 3--''MAR''
				WHEN @ExpiryMonthCode IN (''J'',''D'') THEN 4--''APR''
				WHEN @ExpiryMonthCode IN (''K'',''E'') THEN 5--''MAY''
				WHEN @ExpiryMonthCode IN (''M'',''I'') THEN 6--''JUN''
				WHEN @ExpiryMonthCode IN (''N'',''J'') THEN 7--''JUL''
				WHEN @ExpiryMonthCode IN (''Q'',''O'') THEN 8--''AUG''
				WHEN @ExpiryMonthCode IN (''U'',''P'') THEN 9--''SEP''
				WHEN @ExpiryMonthCode IN (''V'',''R'') THEN 10--''OCT''
				WHEN @ExpiryMonthCode IN (''X'',''S'') THEN 11--''NOV''
				WHEN @ExpiryMonthCode IN (''Z'',''T'') THEN 12--''DEC''
			END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_HKFE_TP001_Type01_Load]''
');

GO
EXECUTE ('
/*
Developer:  Lee Manifold
Date:		11 Oct 2006

Description:  This stored procedure pulls data from the C21 data table
table and inserts it into the ib_Position ./ ib_trx table.  Also, any
new values encountered for firm, account, instrument, and currency create
new values in the lookups, as well as new values in the data tables for
these values.

Whilst iterating through the records in C21 data tables, all 
of these inserts are wrapped in a transaction so that any failure causes
the changes to not commit.

NOTE: @tmpParticipantCode: Is this the OrgID?
	: Assume the following are correct;
			SET @InstrumentTypeCd = ''S''
			SET @ClassID = NULL
			SET @TradedLongQuantity = NULL
			SET @TradedShortQuantity = NULL
			SET @TrxTypeCd = ''POSITION''  
			SET @ExchangeCd	 = @Market
			SET @Price	 =	Not Set
			SET @TrxDate =	Not Set

History:
22 Jul 2009		AAJM	MBAL-12377 use common source for default Strike Price Divisor		
03 Mar 2010		KevinP	MBAL-14819 Add ability to filter SELECT records by new [FileName] Column	
03 Mar 2010		KevinP	MBAL-14819 Moved selecting the DataSourceId out of the loop an into a place where it only retrieves it once.
04 Mar 2010		KevinP	MBAL-14836 adjust transaction isolation level
22 Apr 2010		AAJM	MBAL-14741 Add PositionId as output parameter
*/
CREATE procedure [dbo].[ib_HKFE_TP001_Type01_Load]
	(
	@LocationPath		VARCHAR(100)
	)
AS
SET NOCOUNT ON

	--Set the Datasource
	DECLARE @DataSourceCd		varchar(20)
	DECLARE @DataSourceId				int
	DECLARE @DefaultCurrencyId			int
	DECLARE @ExchangeCd					varchar(25)

	SET @DataSourceCd = ''HKFE''
	--Gets the DataSource and DefaultCurrencyId values
	EXEC [dbo].[_ib_DataSource_GetByCodeForOutput] @DataSourceCd, @DataSourceId output, @DefaultCurrencyId output	


	BEGIN TRAN T1
	
		-- BizTalk''s SQL Adapter uses more restrictive read serializable
		-- so this is necessary to relax it to something that is default
		-- and perfectly acceptable!
		SET TRANSACTION ISOLATION LEVEL READ COMMITTED

		DECLARE @FirmCd						varchar(100)
		DECLARE @AccountCd					varchar(100)
		DECLARE @AsOfDate					datetime
		DECLARE @InstrumentCd				varchar(100)
		DECLARE @QuantityPS					decimal(19,4)
		DECLARE @MarketValue				decimal(19,4)
		DECLARE @ExpiryDate					datetime
		DECLARE @StrikePrice				decimal(19,4)
		DECLARE @TrxTypeCd					varchar(25)
		DECLARE @OptionTypeCd				varchar(25)
		DECLARE @TrxDate					datetime
		DECLARE @Price						decimal(19,4)
		DECLARE @ExpYr						smallint
		DECLARE @ExpMth						smallint
		DECLARE @ExpDay						smallint
		DECLARE	@InstrumentTypeCd			varchar(100)
		DECLARE @ClassId					int
		DECLARE @LongQuantity				decimal(19,4) 
		DECLARE @ShortQuantity				decimal(19,4)
		DECLARE @TradedLongQuantity			decimal(19,4)
		DECLARE	@TradedShortQuantity		decimal(19,4)
		DECLARE @ReturnValue				int
		DECLARE	@Outputvarchar				varchar(50)				
		DECLARE @InstrumentTypeId			int
		DECLARE @CurrencyCd					varchar(25)
		DECLARE @InstrumentId				int
		DECLARE @ExchangeId					int
		DECLARE	@StrikePriceDivisor			Decimal(19,4)
		

		DECLARE @tmpID						int
		DECLARE @tmpParticipantCode			varchar(5)				
		DECLARE @tmpAccountID				varchar(50)
		DECLARE @tmpBusinessDate			datetime
		DECLARE @tmpCurrentPositionLong		varchar(8)
		DECLARE @tmpCurrentPositionShort	varchar(8)
		DECLARE @tmpCurrency				varchar(3)
		DECLARE @tmpPreVariationAdjustment	varchar(19)
		DECLARE @tmpMarket					varchar(5)
		DECLARE @tmpSeriesName				varchar(15)				

		DECLARE pos_cursor CURSOR FOR
		SELECT 	[RecordType01_ID],
				[ParticipantCode],
				[AccountID],
				[BusinessDate],
				[CurrentPositionLong],
				[CurrentPositionShort],
				[Currency],
				[PrevVariationAdjustment],
				[Market],
				[SeriesName]
	
		FROM	[dbo].[HKFE_TP001_Type01]
		WHERE	[LoadState] = 1
		  AND	[FileName] = @LocationPath

		OPEN pos_cursor

		FETCH NEXT FROM pos_cursor
		INTO	
				@tmpID,
				@tmpParticipantCode,				
				@tmpAccountID,
				@tmpBusinessDate,
				@tmpCurrentPositionLong,
				@tmpCurrentPositionShort,
				@tmpCurrency,
				@tmpPreVariationAdjustment,
				@tmpMarket,
				@tmpSeriesName

		-- Check @@FETCH_STATUS to see if there are any more rows to fetch.
		WHILE @@FETCH_STATUS = 0
		BEGIN

			SET @FirmCd		= @tmpParticipantCode
			SET @AccountCd	= @tmpAccountID 
			SET @AsofDate	= @tmpBusinessDate
			SET @QuantityPS = (CAST(@tmpCurrentPositionLong AS Decimal(19,4)) - CAST(@tmpCurrentPositionShort AS Decimal(19,4)))
			SET @LongQuantity = CAST(@tmpCurrentPositionLong AS Decimal(19,4))
			SET @ShortQuantity = CAST(@tmpCurrentPositionShort AS Decimal(19,4))
			SET @ExpiryDate = 0
			SET @MarketValue = @tmpPreVariationAdjustment
			SET @ExchangeCd	 = @tmpMarket	
			SET @InstrumentTypeCd = ''S''
			SET @ClassID = NULL
			SET @TradedLongQuantity = NULL
			SET @TradedShortQuantity = NULL
			SET @TrxTypeCd = ''POSITION''  
			SET @CurrencyCd = @tmpCurrency
			
			--Gets the ExchangeID from the DataSourceExchangeCode from the OrgID
			EXEC [dbo].[ib_DataSourceExchange_GetByCode] @DataSourceId, @tmpParticipantCode, @ExchangeID output
			
			--Gets the InstrumentTypeID from the InstrumentTypeCode to then get the currency
			--EXEC @ReturnValue = [dbo].[ib_InstrumentType_AddAsNeeded] @DataSourceId, @InstrumentTypeCd, @InstrumentTypeID output

			--Gets the InstrumentID
			--EXEC @ReturnValue	= [dbo].[ib_Instrument_AddAsNeeded] @DataSourceId, @InstrumentTypeID, @InstrumentCd, @CurrencyId, @InstrumentID output, @CurrencyId output

			--IF @CurrencyId IS NULL SET @CurrencyId = @DefaultCurrencyId

			--Use the Seriesname to ge the Instrumentcd,ExpiryMonth, ExpiryYr and InstrumentType
			EXEC @ReturnValue = [HKFE_TPOO1_Format] @tmpSeriesName,
													@DataSourceId,
													@InstrumentCd Output,			
													@ExpMth Output,
													@ExpYr Output,
													@StrikePrice Output,
													@OptionTypeCd Output	

			--Get the StrikePrice Divisor and divide strikeprice by it if not null
			SELECT	@StrikePriceDivisor	= StrikePriceDivisor
			FROM	[dbo].[ib_InstrumentDataSource]
			WHERE	DataSourceId = @DataSourceId
			AND		DataSourceInstrumentCode = @InstrumentCd 			

			IF @StrikePriceDivisor IS NULL
				BEGIN
					SET @StrikePriceDivisor = [dbo].[udf_GetDefaultStrikePriceDivisor](@DataSourceId, NULL)
				END
				
			SET @StrikePrice = (CAST(@StrikePrice as decimal(19,4))/@StrikePriceDivisor)	
			
			DECLARE @PositionId INT
			SET @PositionId = NULL
			
			EXEC	[dbo].[ib_Position_Load]
					@DataSourceCd,
					@ExchangeCd,
					@FirmCd,
					@AccountCd,	
					@AsOfDate,
					@InstrumentCd,
					@QuantityPS,
					@MarketValue,
					@ExpYr,
					@ExpMth,
					@ExpDay,
					@StrikePrice,
					@TrxTypeCd,
					@OptionTypeCd,
					@TrxDate,
					@Price,
					@tmpID,
					@InstrumentTypeCd,
					@LocationPath,
					@CurrencyCd,
					@LongQuantity, 
					@ShortQuantity, 
					@TradedLongQuantity, 
					@TradedShortQuantity,
					@ClassId,
					@PositionId = @PositionId OUTPUT
			
			--flip processed flag in source table.
			UPDATE	[dbo].[HKFE_TP001_Type01]
			SET		[LoadState] = 2
			WHERE	[RecordType01_Id] = @tmpID
			AND		[LoadState] = 1

			FETCH NEXT FROM pos_cursor
			INTO 
					@tmpID,
					@tmpParticipantCode,				
					@tmpAccountID,
					@tmpBusinessDate,
					@tmpCurrentPositionLong,
					@tmpCurrentPositionShort,
					@tmpCurrency,
					@tmpPreVariationAdjustment,
					@tmpMarket,
					@tmpSeriesName
		END

		CLOSE pos_cursor
		DEALLOCATE pos_cursor

	COMMIT TRAN T1
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Department_Update]''
');

GO
EXECUTE ('
/*
<details>
 <summary>Updates an department from the ib_Department table by its id</summary>
 <created author="konrad" date="24 Mar 2009 16:33:45 GMT"/> 
</details>
*/
--
-- Revision History
--
-- 01.05.09 Konrad Setting UpdateDate field value when updating.
--
CREATE PROCEDURE [dbo].[ib_Department_Update]
	(
	@DepartmentId		int,
	@Code				varchar(100) = NULL,
	@Description		varchar(100) = NULL,
	@UpdateUsername		varchar(50) = NULL
	)
AS
SET NOCOUNT ON

	BEGIN TRY
		--check for duplicates 
		EXEC [dbo].[ib_Department_CheckForDuplicate] @Code, @DepartmentId

		UPDATE [dbo].[ib_Department]
			SET		[Code]				= ISNULL(@Code,[Code]), 
					[Description]		= ISNULL(@Description,[Description]), 
					[UpdateUsername]	= ISNULL(@UpdateUsername,[UpdateUsername]),
					[UpdateDate]		= getdate()

			WHERE	[DepartmentId]	= @DepartmentId
	END TRY
	BEGIN CATCH
		EXEC [dbo].[sp_RethrowError]
	END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[C21_Footer_Add]''
');

GO
EXECUTE ('

-- =============================================
-- Author:		Lee Manifold
-- Create date: 14 Jun 2006
-- Description:	Insert into C21_Footer table

-- =============================================
CREATE PROCEDURE [dbo].[C21_Footer_Add] 
	(
		@RecordType		varchar(5),
		@FileType		varchar(50),
		@LineCounter	int,
		@OrgID			varchar(5)
	)
	
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

  INSERT INTO [dbo].[C21_Footer]
           (
			[RecordType]
           ,[FileType]
           ,[LineCounter]
		   ,[OrgID]
			)
     VALUES
           (
			@RecordType,
			@FileType,	
			@LineCounter,
			@OrgID 
			)
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[LCH_TypeTR_Delete]''
');

GO
EXECUTE ('

-- =============================================
-- Author:		Lee Manifold
-- Create date: 20 Jun 2006
-- Description:	Deletes the records in the LIFFE_TypeTR table
-- =============================================
CREATE PROCEDURE [dbo].[LCH_TypeTR_Delete] 
	(
	@Exchange		Varchar(3)
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	DELETE
	FROM [dbo].[LCH_TypeTR]
	WHERE Exchange = @Exchange  

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_RuleCondition_Delete]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_RuleCondition_Delete]
(
	@ConditionId int 
)
AS
SET NOCOUNT ON

DELETE FROM [dbo].[ib_RuleCondition]
      WHERE RuleConditionId = @ConditionId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_InstrumentDetail_GetSettlementPriceAndCurrencyByMatchCodeForInstrumentDetail]''
');

GO
EXECUTE ('  /*
<details>
 <summary>Returns the settlement price, the currency code and the currency id for a specific set of values</summary>
 <created author="laurentiu.macovei" date="Wed, 25 Oct 2006 19:07:55 GMT"/>
 <updated author="anil.kripalani" date="14 Dec 2006">
	BUG FIX: Strike Price passed in but not used in query!  Include in where clause.
 </updated>
</details>
*/
CREATE PROCEDURE [dbo].[ib_InstrumentDetail_GetSettlementPriceAndCurrencyByMatchCodeForInstrumentDetail]
@InstrumentId int,
@ExpiryYear DateTime,
@ExpiryMonth DateTime,
@ExpiryDay DateTime,
@StrikePrice decimal(19,4),
@OptionTypeCode char(1),
@AsOfDate DateTime
AS
SET NOCOUNT ON
IF @InstrumentId IS NULL
	SET @InstrumentID = 0
IF @ExpiryYear IS NULL
	SET @ExpiryYear = 0
IF @ExpiryMonth IS NULL
	SET @ExpiryMonth = 0
IF @ExpiryDay IS NULL
	SET @ExpiryDay = 0
IF @StrikePrice IS NULL
	SET @StrikePrice = 0
SELECT id.SettlementPrice, c.CurrencyId, c.Code as CurrencyCode
	FROM ib_InstrumentDetail id
	INNER JOIN ib_Currency c ON c.CurrencyId = id.CurrencyId
	WHERE [InstrumentId] = @InstrumentId
		AND [ExpiryYear] = @ExpiryYear
		AND [ExpiryMonth] = @ExpiryMonth
		AND [ExpiryDay] = @ExpiryDay
		AND [OptionTypeCode] = @OptionTypeCode
		AND [AsOfDate] = @AsOfDate
		AND id.[StrikePrice] = @StrikePrice
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_HKFE_TP001_Type02_Load]''
');

GO
EXECUTE ('
/*
Developer	:	Lee Manifold
Date		:	21 Sept 2006
Description	:	This stored procedure pulls data from the HKFE_TP001_Type01
				table and inserts it into the ib_Position.  Also, any
				new values encountered for firm, account, instrument, and currency create
				new values in the lookups, as well as new values in the data tables for
				these values.

				Whilst iterating through the records in HKFE_TP001_Type01, all 
				of these inserts are wrapped in a transaction so that any failure causes
				the changes fail.

Notes:			@InstrumentTypeCd = ''S'' ???

Revision History:
16 Jul 2009		AAJM	Update to account for new DetailAccountId column in ib_Trx table - see MBAL-12454
22 Jul 2009		AAJM	MBAL-12377 use common source for default Strike Price Divisor		
04 Mar 2010		KevinP	MBAL-14836 adjust transaction isolation level

*/
CREATE PROCEDURE [dbo].[ib_HKFE_TP001_Type02_Load]
	(
	@LocationPath		varchar(100)=NULL
	)
AS
SET NOCOUNT ON

	--Set the Datasource
	DECLARE @DataSourceCd		varchar(20)
	DECLARE @DefaultCurrencyId			int
	DECLARE @DataSourceId				int

	SET @DataSourceCd = ''HKFE''
	--Gets the DataSource and DefaultCurrencyId values
	EXEC [dbo].[_ib_DataSource_GetByCodeForOutput] @DataSourceCd,@DataSourceId output, @DefaultCurrencyId output	


	BEGIN TRAN T1
		-- BizTalk''s SQL Adapter uses more restrictive read serializable
		-- so this is necessary to relax it to something that is default
		-- and perfectly acceptable!
		SET TRANSACTION ISOLATION LEVEL READ COMMITTED

		DECLARE @ExchangeCd					varchar(25)
		DECLARE @FirmCd						varchar(100)
		DECLARE @AccountCd					varchar(100)
		DECLARE @AsOfDate					datetime
		DECLARE @InstrumentCd				varchar(100)
		DECLARE @QuantityTR					decimal(19,4)
		DECLARE @MarketValue				decimal(19,4)
		DECLARE @ExpiryDate					datetime
		DECLARE @StrikePrice				decimal(19,4)
		DECLARE @TrxTypeCd					varchar(25)
		DECLARE @OptionTypeCd				varchar(25)
		DECLARE @TrxDate					datetime
		DECLARE @Price						decimal(19,4)
		DECLARE @ExpYr						smallint
		DECLARE @ExpMth						smallint
		DECLARE @ExpDay						smallint
		DECLARE	@InstrumentTypeCd			varchar(100)
		DECLARE @ClassId					int
		DECLARE @LongQuantity				decimal(19,4) 
		DECLARE @ShortQuantity				decimal(19,4)
		DECLARE @TradedLongQuantity			decimal(19,4)
		DECLARE	@TradedShortQuantity		decimal(19,4)
		DECLARE @ReturnValue				int
		DECLARE	@Outputvarchar				varchar(50)				
		DECLARE @InstrumentTypeId			int
		DECLARE @CurrencyCd					varchar(25)
		DECLARE @InstrumentId				int
		DECLARE @ExchangeId					int
		DECLARE	@StrikePriceDivisor			Decimal(19,4)
		

		DECLARE @tmpID						int
		DECLARE @tmpParticipantCode			varchar(5)				
		DECLARE @tmpAccountID				varchar(50)
		DECLARE @tmpBusinessDate			datetime
		DECLARE @tmpLong					varchar(8)
		DECLARE @tmpShort					varchar(8)
		DECLARE @tmpCurrency				varchar(3)
		DECLARE @tmpVariationAdjustment		varchar(19)
		DECLARE @tmpMarket					varchar(5)
		DECLARE @tmpSeriesName				varchar(15)				
		DECLARE @tmpMovement					varchar(15)
		DECLARE @tmpTradePrice				varchar(12)

		DECLARE pos_cursor CURSOR FOR
		SELECT 	[RecordType02_ID],
				[ParticipantCode],
				[AccountID],
				[BusinessDate],
				[Long],
				[Short],
				[Movement],
				[Currency],
				[Market],
				[SeriesName],
				[VariationAdjustment],
				[TradePrice]
	
		FROM	[dbo].[HKFE_TP001_Type02]
		WHERE	[LoadState] = 1
		  AND	[FileName] = @LocationPath

		OPEN pos_cursor

		FETCH NEXT FROM pos_cursor
		INTO	
				@tmpID,
				@tmpParticipantCode,				
				@tmpAccountID,
				@tmpBusinessDate,
				@tmpLong,
				@tmpShort,
				@tmpMovement,
				@tmpCurrency,
				@tmpMarket,
				@tmpSeriesName,
				@tmpVariationAdjustment,
				@tmpTradePrice

		-- Check @@FETCH_STATUS to see if there are any more rows to fetch.
		WHILE @@FETCH_STATUS = 0
		BEGIN

			--Gets the ExchangeID from the DataSourceExchangeCode from the OrgID
			EXEC @ReturnValue = [dbo].[ib_DataSourceExchange_GetByCode] @DataSourceId, @tmpParticipantCode, @ExchangeID output

			SET @Price		= @tmpTradePrice
			SET @FirmCd		= @tmpParticipantCode
			SET @AccountCd	= @tmpAccountID 
			SET @AsofDate	= @tmpBusinessDate
			SET @TrxDate	= @tmpBusinessDate
			SET @MarketValue = @tmpVariationAdjustment
			SET @QuantityTR = (CAST(@tmpLong AS Decimal(19,4)) - CAST(@tmpShort AS Decimal(19,4)))
			SET @ExpiryDate = 0
			SET @CurrencyCd = @tmpCurrency
			
			SET @ExchangeCd	 = @tmpMarket	
			SET @InstrumentTypeCd = ''S''
			SET @ClassID = NULL
			SET @TradedLongQuantity = NULL
			SET @TradedShortQuantity = NULL
			SET @TrxTypeCd = @tmpMovement 

			--Use the Seriesname to ge the Instrumentcd,ExpiryMonth, ExpiryYr and InstrumentType
			EXEC @ReturnValue = [HKFE_TPOO1_Format] @tmpSeriesName,
													@DataSourceId,
													@InstrumentCd Output,			
													@ExpMth Output,
													@ExpYr Output,
													@StrikePrice Output,
													@OptionTypeCd Output	

			--Get the StrikePrice Divisor and divide strikeprice by it if not null
			SELECT	@StrikePriceDivisor	= StrikePriceDivisor
			FROM	[dbo].[ib_InstrumentDataSource]
			WHERE	DataSourceId = @DataSourceId
			AND		DataSourceInstrumentCode = @InstrumentCd 			

			IF @StrikePriceDivisor IS NULL
				BEGIN
					SET @StrikePriceDivisor = [dbo].[udf_GetDefaultStrikePriceDivisor](@DataSourceId, NULL)
				END
				
			SET @StrikePrice = (CAST(@StrikePrice as decimal(19,4))/@StrikePriceDivisor)	
			
			EXEC [dbo].[ib_Trx_Load]
						@DataSourceCd,
						@ExchangeCd,
						@FirmCd,
						@AccountCd,
						NULL, -- DetailAccountCd -- AAJM Added for MBAL-12454
						@InstrumentCd,
						@ExpYr,
						@ExpMth,
						@ExpDay,
						@StrikePrice,
						@TrxTypeCd,
						@OptionTypeCd,
						@QuantityTR,
						@TrxDate,
						@Price,
						@tmpID,
						@InstrumentTypeCd,
						@AsOfDate,
						@LocationPath,
						@MarketValue,
						@CurrencyCd,
						@ClassId
			
			--flip processed flag in source table.
			UPDATE	[dbo].[HKFE_TP001_Type02]
			SET		[LoadState] = 2
			WHERE	[RecordType02_Id] = @tmpID
			AND		[LoadState] = 1

			FETCH NEXT FROM pos_cursor
			INTO 
					@tmpID,
					@tmpParticipantCode,				
					@tmpAccountID,
					@tmpBusinessDate,
					@tmpLong,
					@tmpShort,
					@tmpMovement,
					@tmpCurrency,
					@tmpMarket,
					@tmpSeriesName,
					@tmpVariationAdjustment,
					@tmpTradePrice
		END

		CLOSE pos_cursor
		DEALLOCATE pos_cursor

	COMMIT TRAN T1
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Currency_GetCurrencyById]''
');

GO
EXECUTE (' /*
<details>
 <summary> Selectes a currency from the ib_Currency table by its id</summary>
 <created author="Laurentiu Macovei" Date="Wednesday, 6 September 2006 3:11AM GMT" /> 
</details>
*/
create PROCEDURE [dbo].[ib_Currency_GetCurrencyById]
	@CurrencyId int
AS
SET NOCOUNT ON
SELECT * FROM [dbo].[ib_Currency]
	WHERE CurrencyID = @CurrencyID
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Exchange_CheckForDuplicate]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Exchange_CheckForDuplicate]
@Code VARCHAR(100),
@Name VARCHAR(100),
@ExchangeId INT
AS
SET NOCOUNT ON

DECLARE @Count INT

SELECT TOP 1 @Count = 1
	FROM [dbo].[ib_Exchange] c
	WHERE Code = @Code
		AND ExchangeID <> @ExchangeId

IF @Count > 0
	RAISERROR (N''There is already another Exchange with same code (%s). Please specify other code!'', 11, 1, @Code)

SET @Count = 0

SELECT TOP 1 @Count = 1
	FROM [dbo].[ib_Exchange] c
	WHERE Name = @Name
		AND ExchangeID <> @ExchangeId

IF @Count > 0
	RAISERROR (N''There is already another Exchange with same name (%s). Please specify other name!'', 11, 1, @Name)
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Exchange_Add]''
');

GO
EXECUTE ('/*
Programmer:  Petru konrad Bercea
Date:        17/02/09
Description: Inserts value into Exchange if lookup fails
--17 May 2010 ED add RunTradeLevelReconciliation parameter
*/
CREATE PROC [dbo].[ib_Exchange_Add]
(
	@Code VARCHAR(25),
	@Name VARCHAR(50),
	@RunBalanceReport BIT,
	@RunCloseOutReport BIT,
	@RunTradeLevelReconciliation BIT=1,
	@CreateUsername VARCHAR(255) = '''',
	@@ExchangeId INT OUTPUT
)
AS
SET NOCOUNT ON
BEGIN TRY
--check for duplicates 
EXEC [dbo].[ib_Exchange_CheckForDuplicate] @Code, @Name, -1

	INSERT INTO ib_Exchange 
		(
			[Code],
			[Name],
			[RunBalanceReport],
			[RunCloseOutReport],
			RunTradeLevelReconciliation,
			CreateUserName
		)
	VALUES 
		(
			@Code,
			@Name,
			@RunBalanceReport,
			@RunCloseOutReport,
			@RunTradeLevelReconciliation,
			@CreateUserName
		)

SELECT @@ExchangeId = SCOPE_IDENTITY()
END TRY
BEGIN CATCH
	EXEC [dbo].[sp_RethrowError]
END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_RuleCondition_GetConditionById]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_RuleCondition_GetConditionById]
	@conditionId int
AS
SET NOCOUNT ON
	SELECT
		RC.RuleConditionId,
		RC.RuleConditionId AS ConditionId,
		RC.InternalExternalCode,
		RC.Field1Id,
		F.Description AS Field1IdDescription,
		SF.Description AS Field2IdDescription,
		O.Description AS OperatorIdDescription,
		O.ShortDescription AS OperatorIdShortDescription,
		RC.OperatorId,
		RC.Field2Id,
		RC.Value,
		RC.Description,
		RC.IsEnabled,
		RC.CreateDate,
		RC.CreateUsername,
		RC.UpdateDate,
		RC.UpdateUsername
	FROM
		ib_RuleCondition RC
	INNER JOIN
		ib_Field F ON F.FieldId = RC.Field1Id
	INNER JOIN
		ib_Operator O ON RC.OperatorId = O.OperatorId
	LEFT OUTER JOIN
		ib_Field SF ON SF.FieldId = RC.Field2Id AND RC.Field2Id IS NOT NULL
	WHERE
		RuleConditionId = @conditionId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[GetDateFromIceBizDt]''
');

GO
EXECUTE ('CREATE FUNCTION [dbo].[GetDateFromIceBizDt]
(
	@BizDate VARCHAR(10)
)
RETURNS DATETIME
AS
	-- Description: Returns a business date from a string date in format CCYY-MM-DD
	--	15 Jul 2010		AAJM		Creation
BEGIN

	DECLARE @ReturnDate DATETIME
	DECLARE @BizDateYear VARCHAR(4)
	DECLARE @BizDateMonth VARCHAR(2)
	DECLARE @BizDateDay VARCHAR(2)
	
	SET @BizDateYear = LEFT(@BizDate, 4)
	SET @BizDateMonth = SUBSTRING(@BizDate, 6, 2)
	SET @BizDateDay = RIGHT (@BizDate, 2)
	
	SET @ReturnDate = CONVERT(DATETIME, @BizDateMonth + ''/'' + @BizDateDay + ''/'' + CONVERT(VARCHAR(4), @BizDateYear), 101)
	
	RETURN @ReturnDate

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_ICE_AsgnRpt_Load]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_ICE_AsgnRpt_Load]
(
	@LocationPath		VARCHAR(100)
	,@ReceiveLocationSysId INT
	,@RunId INT
)
AS

-- Description: Load Transactions for ICE Assignment Report

-- History:
-- 16 Jul 2010	AAJM	MBAL-14903 Creation
-- 26 Jul 2010	AAJM	MBAL-16294 Deletion and Assignment Transactions to Neg
-- 26 Jul 2010	AAJM	MBAL-16294 Ensure QtyLong and QtyShort are inverse signed for TrxTypes
-- 01 Mar 2012	AAJM	MBAL-20193 Update StrikePrice to Decimal
-- 01 Mar 2012	AAJM	Ensure no AsgnRpt records are left in State 1 erroneously
-- 02 Jan 2014  RD		MBAL-24931 Added checking file age
-- 09 Jan 2014	ED		EIB 25004 - remove importLog table and use Log table
-- 21 Mar 2014  ED		EIB 25410 - add ''OPT'' instrument type
-- 25 Apr 2014	ED		EIB 25473 - raise error if file is too old and mark temp records as LoadState=3
-- 14 May 2014	ED		EIB 25636 - pass LocationPath to ib_trx_load
-- 28 Jul 2014	ED		EIB 25628 - get DataSource from ReceiveLocation
-- 19 Sep 2014	ED		EIB 26023 - Fix Add Count
-- 29 Oct 2014	ED		EIB 26160 - Use Currency

SET NOCOUNT ON

DECLARE @DataSourceCode		VARCHAR(100)
DECLARE @DataSourceId		INT
DECLARE @Code				VARCHAR(100)
DECLARE @ReturnValue		INT
DECLARE @Output				INT
DECLARE @Output2			INT
DECLARE @DefaultCurrencyId	INT
DECLARE @Message			VARCHAR(1024)

DECLARE @AddCount			INT
SET @AddCount = 0

DECLARE @ProcessedCount		INT
SET @ProcessedCount = 0

--specify datasource in proc.
SET @DataSourceCode = (SELECT d.Code FROM ib_DataSource d INNER JOIN ReceiveLocation rl ON rl.DataSourceId = d.DataSourceId WHERE ReceiveLocationSysId = @ReceiveLocationSysId)
IF @LocationPath IS NULL SET @LocationPath = @DataSourceCode

SET @Code = @DataSourceCode
EXEC @ReturnValue= [_ib_DataSource_GetByCodeForOutput] @Code,@OutPut output,@Output2 output	
SET @DataSourceId = @Output
SET @DefaultCurrencyId = @Output2	
			
SET @Message = @DataSourceCode + '' Assignment Report loader started'' 		
EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @Message, ''Success'', '''', @RunId

--Gets the defaultStrikePriceDivisor
DECLARE	@DefaultStrikePriceDivisor	DECIMAL(19,6)
SET @DefaultStrikePriceDivisor = [dbo].[udf_GetDefaultStrikePriceDivisor](@DataSourceId, NULL)

-- There really isn''t any need for orchestration to call a LoadStateChange anymore
-- since we only process rows for single file now
-- but to keep consistent with other loaders - we''ll update to LoadState 1 at 
-- start of this Load stored procedure
UPDATE [dbo].[ICE_AsgnRpt]
SET LoadState = 1
WHERE LoadState = 0
	AND Filename = @LocationPath

-- Creating Temp Table just for use in this process
-- for iterating through the records.
CREATE TABLE #temp1
	(
	ICE_AsgnRptID		INT				NOT NULL
	, Exchange				VARCHAR(4)		NOT NULL
	, OriginatingMemberName VARCHAR(3)		NOT NULL
	, AccountCode			VARCHAR(1)		NOT NULL
	, PhysicalCommodity		VARCHAR(3)		NOT NULL
	, ContractType			VARCHAR(3)		NOT NULL
	, PutCall				BIT				NULL
	, LongExpiryDate		VARCHAR(8)		NOT NULL
	, ExercisePrice			DECIMAL(19,4)	NULL
	, QtyLong				INT				NOT NULL
	, QtyShort				INT				NOT NULL
	, Price					DECIMAL(24,10)	NOT NULL
	, DateOfTradeChr		NVARCHAR(10)    NULL
	, PositionType			NVARCHAR(3)		NOT NULL
	, BizDate				NVARCHAR(10)	NOT NULL
	, SettlementCurrency    VARCHAR(3)      NULL
	)

INSERT INTO #temp1
	(
	ICE_AsgnRptID
	, Exchange	
	, OriginatingMemberName
	, AccountCode
	, PhysicalCommodity
	, ContractType
	, PutCall
	, LongExpiryDate
	, ExercisePrice	
	, QtyLong
	, QtyShort
	, Price	
	, DateOfTradeChr
	, PositionType
	, BizDate
	, SettlementCurrency
	)
	
	SELECT 
		ICE_AsgnRptID
		, Exchange
		, TradingMember	
		, PositionAccount
		, CommodityId
		, InstrumentType		-- ContractType
								-- If ContractType was F or M or D then "FUT"
								-- If ContractType was P or C then "OOF"
		, PutCall				-- 0 = Put,  1 = Call
		, MaturityMonthYear
		, StrikePrice
		, QtyLong				
		, QtyShort		
		, SettlementPrice
		, QtyDate
		, PosQtyType
		, BizDt
		, SettlementCurrency
	FROM [dbo].[ICE_AsgnRpt]
	WHERE LoadState = 1
	  AND [FileName] = @LocationPath
			AND (
			PosQtyType IN (''AS'',''DC'', ''EX'', ''FXP'')
			OR (PosQtyType IN (''OXP'') AND (QtyLong > 0 OR QtyShort > 0))		
			)
	-- If you add to the WHERE clause, make sure you update the 
	-- code at the end of the proc which updates non-processed records.

	--rd - make sure the As Of Date is not older than acceptable	
	DECLARE @CheckAsOfDate DATETIME

	SET @CheckAsOfDate = (SELECT MIN([dbo].[GetDateFromIceBizDt](BizDate)) AS CheckRunDate FROM #temp1)
	IF (@CheckAsOfDate IS NOT NULL)
	BEGIN		
		DECLARE @IsAcceptable bit
		EXECUTE [dbo].[Load_IsFileTooOld] @DataSourceId,@LocationPath,@CheckAsOfDate,@IsAcceptable OUTPUT, @ReceiveLocationSysId, @RunId
		IF (@IsAcceptable = 0)
		BEGIN
			DROP TABLE #temp1
			UPDATE ICE_AsgnRpt SET [LoadState] = 3 WHERE [Filename] = @LocationPath
			RAISERROR (''File is too old.'', 18, 0)
			RETURN 0
		END
	END	
		
SET XACT_ABORT ON 
			
BEGIN TRANSACTION T1
	
-- BizTalk''s SQL Adapter uses more restrictive read serializable
-- so this is necessary to relax it to something that is default
-- and perfectly acceptable!

SET TRANSACTION ISOLATION LEVEL READ COMMITTED

BEGIN TRY

	DECLARE
		@ICE_AsgnRptID				INT
		, @Exchange					VARCHAR(4)
		, @OriginatingMemberName	VARCHAR(3)
		, @AccountCode				VARCHAR(1)
		, @PhysicalCommodity		VARCHAR(3)
		, @ContractType				VARCHAR(3)
		, @PutCall					BIT	
		, @LongExpiryDate			VARCHAR(8)
		, @ExercisePrice			BIGINT
		, @QtyLong					INT
		, @QtyShort					INT	
		, @Price					DECIMAL(24,10)
		, @DateOfTradeChr			NVARCHAR(10)
		, @PositionType				NVARCHAR(3)
		, @BizDate					NVARCHAR(10)
		, @SettlementCurrency		VARCHAR(3)
	
	DECLARE @MarexFirmId INT
	SET @MarexFirmId = [dbo].[udf_GetMarexFirmId]() 

	DECLARE trx_cursor CURSOR FOR
	SELECT	ICE_AsgnRptID
		, Exchange	
		, OriginatingMemberName 
		, AccountCode
		, PhysicalCommodity
		, ContractType
		, PutCall
		, LongExpiryDate
		, ExercisePrice
		, QtyLong
		, QtyShort
		, Price
		, DateOfTradeChr
		, PositionType
		, BizDate
		, SettlementCurrency
	FROM #temp1

	OPEN trx_cursor

	-- Perform the first fetch and store the values in variables.
	-- Note: The variables are in the same order as the columns
	-- in the SELECT statement. 
	
	FETCH NEXT FROM trx_cursor
	INTO @ICE_AsgnRptID
		, @Exchange	
		, @OriginatingMemberName
		, @AccountCode
		, @PhysicalCommodity
		, @ContractType
		, @PutCall
		, @LongExpiryDate
		, @ExercisePrice
		, @QtyLong
		, @QtyShort
		, @Price
		, @DateOfTradeChr
		, @PositionType
		, @BizDate
		, @SettlementCurrency

		-- Check @@FETCH_STATUS to see if there are any more rows to fetch.
		WHILE @@FETCH_STATUS = 0
		BEGIN

	
		DECLARE @ExchangeCd			VARCHAR(25)
		DECLARE @FirmCd				VARCHAR(100)
		DECLARE @AccountCd			VARCHAR(100)
		DECLARE @InstrumentCd		VARCHAR(100)
		DECLARE @InstrumentTypeCd	VARCHAR(100)
		DECLARE @ExpYr				SMALLINT
		DECLARE @ExpMth				SMALLINT
		DECLARE @ExpDay				SMALLINT
		DECLARE @StrikePrice		DECIMAL(19,4)
		DECLARE @TrxTypeCd			VARCHAR(25)
		DECLARE @OptionTypeCd		VARCHAR(25)
		DECLARE @Quantity			DECIMAL(18,10)
		DECLARE	@QuantityLong		INT
		DECLARE @QuantityShort		INT
		DECLARE @AsOfDate			DATETIME
		DECLARE @DateOfTrade		DATETIME
		DECLARE @TrxDate			DATETIME
		DECLARE @PriceDec			DECIMAL(19,4)
		DECLARE @Volume				DECIMAL(18,10)
		DECLARE @CurrencyId			INT		
		DECLARE @InstrumentId		INT		
		DECLARE @TickSize			INT		
		DECLARE @GenericContractType VARCHAR(1)
		DECLARE @StrikePriceDivisor DECIMAL(19,4)
		DECLARE @PriceDivisor		DECIMAL(19,4)
		
		SET @ExchangeCd = @Exchange
	
		SET @Output = NULL
		DECLARE @InstrumentTypeId INT

		SET @InstrumentTypeCd = 
			CASE @ContractType
				WHEN ''FUT'' THEN ''F''
				WHEN ''OOF'' THEN ''O''
				WHEN ''OPT'' THEN ''O''
				WHEN ''OOC'' THEN ''O''
			END

		EXEC @ReturnValue = ib_Instrumenttype_AddAsNeeded @DataSourceId,@InstrumentTypeCd,@OutPut output
		SET @InstrumentTypeId = @Output

		SET @CurrencyId = NULL
		IF @SettlementCurrency IS NOT NULL
			BEGIN
				EXEC @ReturnValue = [ib_Currency_AddAsNeeded] @DataSourceId, @SettlementCurrency, @Output output
				SET @CurrencyId = @Output
			END	

		SET @Output = NULL
		SET @Output2 = NULL
		
		SET @InstrumentCd = @InstrumentTypeCd + ''_'' + @ExchangeCd + ''_'' + @PhysicalCommodity
		
		EXEC @ReturnValue= [ib_Instrument_AddAsNeeded] @DataSourceId,@InstrumentTypeId,@InstrumentCd,@CurrencyId,@OutPut output,@Output2 output	
		SET @InstrumentId = @Output
		SET @CurrencyId = @Output2
		IF @Output2 = NULL
			BEGIN
				SET @CurrencyId = @DefaultCurrencyId
			END
		
		SET @TickSize = NULL
		SELECT @TickSize = TickSize FROM ib_Instrument WHERE InstrumentId = @InstrumentId

		SET @FirmCd = @OriginatingMemberName
		SET @AccountCd = @AccountCode
			
		SET @StrikePriceDivisor = NULL
		SET @PriceDivisor = NULL

		SELECT @StrikePriceDivisor = StrikePriceDivisor
			, @PriceDivisor = PriceDivisor
		FROM [dbo].[ib_InstrumentDataSource]
		WHERE DataSourceId = @DataSourceId
			AND DataSourceInstrumentCode = @InstrumentCd 

		IF @PriceDivisor IS NULL 
			SET @PriceDivisor = 1
			
		IF @StrikePriceDivisor IS NULL -- then get the default
			BEGIN
				DECLARE @ExchangeId INT
				SELECT @ExchangeId = ExchangeId FROM ib_Exchange WHERE [Code] = @ExchangeCd
				
				SET @StrikePriceDivisor = [dbo].[udf_GetDefaultStrikePriceDivisor](@DataSourceId, @ExchangeId)
			END

		SET @StrikePrice = (@ExercisePrice/@StrikePriceDivisor)
		
		SET @TrxTypeCd = @PositionType
		
		-- Set Option Type Code
		SET @OptionTypeCd = 
			CASE @PutCall
				WHEN 0 THEN ''P''
				WHEN 1 THEN ''C''
			END 
		
		SET @Volume = 0
		
		SET @Volume = 
			CASE 
				WHEN @QtyLong > 0 THEN @QtyLong
				WHEN @QtyShort > 0 THEN @QtyShort		
			END

		
		SET @ExpYr = LEFT(@LongExpiryDate,4)
		SET @ExpMth = SUBSTRING(@LongExpiryDate,5,2)
		SET @ExpDay = RIGHT(@LongExpiryDate,2)
		SET @ExpDay = dbo.udf_OnLoad_ExpiryDate_Get_Day(@ExpYr,@ExpMth,@ExpDay)

		-- Set AsOfDate	
		SET @AsOfDate = [dbo].[GetDateFromIceBizDt] (@BizDate)
		SET @DateOfTrade = [dbo].[GetDateFromIceBizDt] (@DateOfTradeChr)
		
		SET @TrxDate = DATEADD(d
			, (CONVERT(INT, @AsOfDate) - CONVERT(INT, @DateOfTrade)) * -1
			, @AsOfDate
			)

		IF @PositionType IN (''OXP'', ''AS'', ''FXP'', ''EX'', ''DC'')-- Was(''T'', ''J'', ''H'', ''R'', ''A'', ''E'', ''B'')
		BEGIN
			SET @Volume = @Volume * (-1)
			SET @QtyLong = @QtyLong * (-1)
			SET @QtyShort = @QtyShort * (-1)
		END
		
		IF @PositionType IN (''OXP'', ''AS'', ''EX'', ''FXP'') -- Was ''J'', ''A'', ''E''
			SET @PriceDec = 0
		ELSE
			SET @PriceDec = CONVERT(DECIMAL(24,10), @Price) / @PriceDivisor
			
		-- Set Generic Contract Type
		IF (@ContractType IS NOT NULL AND @ContractType = ''FUT'')
			SET @GenericContractType = ''F''
		ELSE
			SET @GenericContractType = ''O''
						
		SET @Quantity = @Volume
		SET @QuantityLong = @QtyLong
		SET @QuantityShort = @QtyShort
				
		DECLARE @TrxId INT
		SET @TrxId = NULL

		EXEC [ib_Trx_Load]
		@DataSourceCode
		, @ExchangeCd
		, @FirmCd
		, @AccountCd
		, NULL
		, @InstrumentCd
		, @ExpYr
		, @ExpMth
		, @ExpDay
		, @StrikePrice
		, @TrxTypeCd
		, @OptionTypeCd
		, @Quantity
		, @TrxDate
		, @PriceDec
		, @ICE_AsgnRptID
		, @GenericContractType
		, @AsOfDate
		, @LocationPath = @LocationPath
		, @CurrencyCd = @SettlementCurrency
		, @MarexFirmId = @MarexFirmId
		, @TrxId = @TrxId OUTPUT
		, @QuantityLong = @QuantityLong 
		, @QuantityShort = @QuantityShort
		, @ReceiveLocationSysId = @ReceiveLocationSysId
		, @RunId = @RunId

		-- Flip processed flag in source table.
		UPDATE ICE_AsgnRpt
		SET LoadState = 2
		WHERE ICE_AsgnRptID = @ICE_AsgnRptID
		AND LoadState = 1
		
		IF @TrxId IS NOT NULL AND @TrxId > 0
			SET @AddCount = @AddCount + 1
		
		SET @ProcessedCount = @ProcessedCount + 1

		FETCH NEXT FROM trx_cursor
		INTO @ICE_AsgnRptID
		, @Exchange	
		, @OriginatingMemberName
		, @AccountCode
		, @PhysicalCommodity
		, @ContractType
		, @PutCall
		, @LongExpiryDate
		, @ExercisePrice
		, @QtyLong
		, @QtyShort
		, @Price
		, @DateOfTradeChr
		, @PositionType
		, @BizDate
		, @SettlementCurrency
		END

	CLOSE trx_cursor
	DEALLOCATE trx_cursor


		-- Now update Assignment Report Items not processed
		UPDATE ICE_AsgnRpt
		SET LoadState = 2
		WHERE LoadState = 1 AND [FileName] = @LocationPath
		AND NOT (
			PosQtyType IN (''AS'',''DC'', ''EX'', ''FXP'')
			OR (PosQtyType IN (''OXP'') AND (QtyLong > 0 OR QtyShort > 0))		
			)
		
		
	SET @Message = @DataSourceCode + '' Assignment Report loader ended ('' + CONVERT(VARCHAR(10), @ProcessedCount) + '' processed, '' 
		+ CONVERT(VARCHAR(10), @AddCount) + '' added)'' 
		
	EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @Message, ''Success'', '''', @RunId
		
	COMMIT TRANSACTION
		
	IF OBJECT_ID(''tempdb..#temp1'') IS NOT NULL 
	DROP TABLE #temp1
		
END TRY

BEGIN CATCH 

	IF XACT_STATE() = -1 
		ROLLBACK TRANSACTION
	
	SET @Message = @DataSourceCode + '' Assignment Report loader failed'' 		
	EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @Message, ''Error'', '''', @RunId
	
	EXEC [dbo].[sp_RethrowError]
		
END CATCH 

SET XACT_ABORT OFF
	
RETURN 0
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Exchange_GetByCode]''
');

GO
EXECUTE ('





-- =============================================
-- Author:		Petru Konrad Bercea
-- Create date: 17 Feb 2009
-- Description:	Retrieve Exchange id

CREATE proc [dbo].[ib_Exchange_GetByCode]
@Code varchar(25),
@ExchangeId int = NULL output
as
SET NOCOUNT ON

select @ExchangeId = ExchangeId 
from ib_Exchange
where Code = @Code
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Exchange_AddAsNeeded]''
');

GO
EXECUTE ('

-- =============================================
-- Author:		Petru Konrad Bercea
-- Create date: 17 02 2009
-- Description:	Retrieve Exchange id
---=============================================

CREATE proc [dbo].[ib_Exchange_AddAsNeeded]
	(
	@Code		varchar(25),
	@Name		varchar(50),
	@RunBalanceReport bit,
	@RunCloseOutReport bit,
	@ExchangeId	int output
	
	)
AS
SET NOCOUNT ON

	DECLARE @ReturnValue int
	EXEC @ReturnValue= [ib_Exchange_GetByCode] @Code,@ExchangeId output	


	IF @ExchangeId IS NULL
	BEGIN
		
		EXEC [dbo].[ib_Exchange_Add] @Code,@Name,@RunBalanceReport,@RunCloseOutReport 
		SELECT @ExchangeId = ExchangeId 
		FROM ib_Exchange
		WHERE Code = @Code
	END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[C21_Header_Add]''
');

GO
EXECUTE ('

-- =============================================
-- Author:		Lee Manifold
-- Create date: 15 Jun 2006
-- Description:	Inserts into C21_Header table
-- Revision History:
-- 15 Apr 2010	MBAL-15151: store filename
-- =============================================
CREATE PROCEDURE [dbo].[C21_Header_Add]
		(
		@RecordType				varchar(5),
        @FileType				varchar(50),
		@DatetimeCreation		varchar(14),
        @BusinessDate			datetime,
        @ClearingOrganisationID varchar(5),
        @ClearingMemberFirm		varchar(10),
		@FileName				VARCHAR (512)=NULL
		)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	INSERT INTO [dbo].[C21_Header]
           (
			[RecordType]
           ,[FileType]
           ,[DatetimeCreation]
           ,[BusinessDate]
           ,[ClearingOrganisationID]
           ,[ClearingMemberFirm]
           ,[FileName]
			)
     VALUES
           (
			@RecordType,			
			@FileType,				
			@DatetimeCreation,		
			@BusinessDate,			
			@ClearingOrganisationID, 
			@ClearingMemberFirm,	
			@FileName	
			)
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[LCH_TypeTR_Purge]''
');

GO
EXECUTE ('





-- =============================================
-- Author:		Lee Manifold
-- Create date: 11 Jul 2006
-- Description:	Deletes from all is_G type files where the LoadState is 0
-- =============================================
CREATE PROCEDURE [dbo].[LCH_TypeTR_Purge]
	(
	@LoadState		TINYINT = 0,
	@FileName       VARCHAR (512)= NULL
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	
	--raiserror (''Lee doing specific raiserror in stored proc for testing'', 19, 1) with log
	DELETE FROM [dbo].[LCH_TypeTR] WHERE LoadState= @LoadState AND [FileName] = Coalesce(@FileName, [FileName])
	
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_InstrumentType_Delete]''
');

GO
EXECUTE ('/*
<details>
 <summary>Deletes an instrument type by its id from the ib_InstrumentType table</summary>
 <created author="Laurentiu Macovei" Date=" Sunday, 10 September 2006 2:26PM GMT" /> 
</details>
*/
create PROCEDURE [dbo].[ib_InstrumentType_Delete]
(
	@InstrumentTypeId int
)
AS
SET NOCOUNT ON

DELETE FROM [dbo].[ib_InstrumentType]
      WHERE InstrumentTypeId = @InstrumentTypeId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Position_W_Trans_Load]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Position_W_Trans_Load]

@DataSourceCd			varchar(100),
@ExchangeCd				varchar(25),
@FirmCd					varchar(100),
@AccountCd				varchar(100),
@AsOfDate				datetime,
@InstrumentCd			varchar(100),
@QuantityPS				decimal(18,10),
@MarketValuePS			decimal(19,4),
@MarketValueTR			decimal(19,4),
@ExpYr					smallint,
@ExpMth					smallint,
@ExpDay					smallint,
@StrikePrice			decimal(19,6),
@TrxTypeCdPS			varchar(25),
@TrxTypeCdTR			varchar(25),
@OptionTypeCd			varchar(25),
@QuantityTR				decimal(18,10),
@TrxDate				datetime,
@Price					decimal(24,10),
@TempTableRecordId		int,
@InstrumentTypeCd		varchar(100),
@CurrencyCd				varchar(100) = NULL,
@LongQuantity			decimal(19,4) = NULL, 
@ShortQuantity			decimal(19,4) = NULL, 
@TradedLongQuantity		decimal(19,4) = NULL, 
@TradedShortQuantity	decimal(19,4) = NULL,
@PositionId				INT OUTPUT,
@ReceiveLocationSysId INT,
@RunId INT,
@LocationPath VARCHAR(100)

as
SET NOCOUNT ON

/*
Programmer:  Bruce McQuien
Date: 07/07/2006

Purpose:  This stored proc will accept the parameters passed to it from any 
datasource, perform the necessary lookups, and then insert a record in the #
ib_position table, and a record in the ib_trx table.

Revision History

09 Aug 2006		amk		1) Use MarketValue (Also they are different for PS and TR)
						2) Take in currency code too and process it
15 Aug 2006		amk		BUG FIX: Instrument Code should be bigger than 3!
						Bumped up Firm Code, Account Code, and Exchange Code too
11 Sep 2006		LM		Added 4 new fields LongQuantity, ShortQuantity, TradedLongQuantity and TradedShortQuantity

09 June 2009    Konrad  Added ClassId

16 Jul 2009		AAJM	Added DetailAccountId which is will be a duplicate of the AccountId - see MBAL-12454
22 Apr 2010		AAJM	MBAL-14741 Add PositionId as output parameter
23 Apr 2010		AAJM	MBAL-15416 Increase size of Price field
28 Apr 2010		AAJM	MBAL-15315 Ensure load only if Account.IsImported = true
14 Jul 2010		ED		MBAL 15856 don''t load trx with market value = 0
09 Jan 2014		ED		EIB 25004 - remove importLog table and use Log table
17 Apr 2014		ED      EIB 25498 - log exchange not found as warning
08 Dec 2014		ED      EIB 26286 - Change StrikePrice decimals from 4 to 6
*/
	
	declare @ReturnValue int,@OutPut int,@OutPut2 int
	declare @DataSourceId int
	declare @DefaultCurrencyId int
	declare @Code varchar(100)
	set @Code = @DataSourceCd
	exec @ReturnValue= [_ib_DataSource_GetByCodeForOutput] @Code,@OutPut output,@Output2 output
	set @DataSourceId = @OutPut
	set @DefaultCurrencyId = @Output2

	set @OutPut = null
	declare @ExchangeId int
	set @Code = @ExchangeCd
	exec @ReturnValue = ib_DataSourceExchange_GetByCode @DataSourceId,@Code,@Output output
	set @ExchangeId = @OutPut

	--if no exchange found quit here
	if @ExchangeId is null 
		begin
		declare @now datetime
		declare @logmsg varchar(100)
		declare @user varchar(100)
		set @user = suser_sname()
		set @now = getdate()
		set @logmsg = ''Exchange Code Not Found for ib_Position_W_Trans_Load run for code: '' + @ExchangeCd
		EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @logmsg, ''Warning'', @TempTableRecordId, @RunId
		end
	else	
		begin

		set @Output = null
		declare @InstrumentTypeId int
		set @Code = @InstrumentTypeCd
		exec @ReturnValue = ib_Instrumenttype_AddAsNeeded @DataSourceId,@Code,@OutPut output
		set @InstrumentTypeId = @OutPut

		set @Output = null
		declare @FirmId int
		set @Code = @FirmCd
		exec @ReturnValue= [ib_Firm_AddAsNeeded] @DataSourceId,@Code,@OutPut output	
		
		set @FirmId = @OutPut
	
		set @Output = null
		set @Output2 = null
		declare @AccountId int
		declare @ClassId int
    	declare @DetailAccountId int
		set @Code = @AccountCd
		
		DECLARE @IsImported BIT
		SET @IsImported = NULL
		
		exec @ReturnValue= [ib_Account_AddAsNeeded] @Code,@FirmId,@OutPut output,@Output2 output, @IsImported = @IsImported OUTPUT	
		set @AccountId = @OutPut
		set @DetailAccountId = @AccountId
		set @ClassId   = @Output2
	
		IF (@IsImported = 1) 
		BEGIN
		
			set @Output = null
			declare @CurrencyId int
		
			if @CurrencyCd is not Null
			begin
				exec @ReturnValue = [ib_Currency_AddAsNeeded] @DataSourceId, @CurrencyCd, @Output output
				set @CurrencyId = @Output
			end
		
			set @Output2 = null
			set @Output = null
			declare @InstrumentId int
			set @Code = @InstrumentCd
			exec @ReturnValue= [ib_Instrument_AddAsNeeded] @DataSourceId,@InstrumentTypeId,@Code,@CurrencyId,@OutPut output,@OutPut2 output	
			set @InstrumentId = @OutPut
			if @CurrencyId is null
			begin
				if @Output2 is null
					set @CurrencyId = @DefaultCurrencyId	
				else
					set @CurrencyId = @Output2
			end
			
			--now inserting into the ib_Position table.			

			set @Output = null		

			exec @ReturnValue=ib_Position_Add @DataSourceId,@ExchangeId,@FirmId,@AccountId,@AsOfDate,@InstrumentId,@QuantityPS,@CurrencyId,@MarketValuePS,@ExpYr,@ExpMth,@ExpDay,@StrikePrice,@TrxTypeCdPS,@OptionTypeCd,@TempTableRecordId,@OutPut output, @LongQuantity, @ShortQuantity, @TradedLongQuantity, @TradedShortQuantity, @ClassId
			set @PositionId=@OutPut		

			--MBAL 15856 don''t load trx with market value = 0
			IF @MarketValueTR != 0
				exec ib_Trx_Add @DataSourceId,@ExchangeId,@FirmId,@AccountId,@DetailAccountId,@TrxDate,@AsOfDate,@InstrumentId,@QuantityTR,@CurrencyId,@Price,@ExpYr,@ExpMth,@ExpDay,@StrikePrice,@TrxTypeCdTR,@OptionTypeCd,@TempTableRecordId,@PositionId,@ClassId,@MarketValueTR
			
		END -- IF @IsImported = 1
	end
');

GO
EXECUTE ('PRINT N''Creating [dbo].[GetConfigValueByDataSourceAndConfigurationType]''
');

GO
EXECUTE ('CREATE FUNCTION [dbo].[GetConfigValueByDataSourceAndConfigurationType]
(
	@DataSourceCode VARCHAR(100),
	@ConfigurationTypeCode VARCHAR(100)
)
RETURNS VARCHAR(100)
AS

BEGIN
	DECLARE @ConfigValue VARCHAR(100)
	
	SET @ConfigValue = (SELECT ConfigValue 
						FROM ib_DataSourceConfiguration dsc 
							JOIN ib_ConfigurationType ct ON dsc.ConfigurationTypeId = ct.ConfigurationTypeId
							JOIN ib_DataSource ds ON dsc.DataSourceId = ds.DataSourceId 
						WHERE ds.Code = @DataSourceCode AND ct.ConfigurationTypeCode = @ConfigurationTypeCode)
	RETURN @ConfigValue
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_ICE_PosRpt_Load]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_ICE_PosRpt_Load]
(
	@LocationPath		VARCHAR(100)
	,@ReceiveLocationSysId INT
	,@RunId INT
)
AS

-- Description: Load Transactions for ICE PosRpt

-- 14 Jul 2010		AAJM	MBAL-14903 Creation
-- 09 Aug 2010		amk		1) MBAL-16422: market value on premium transactions incorrectly signed
--					amk		2) MBAL-16408: bug fix, set asofdate on importfile record
-- 01 Mar 2012		AAJM	MBAL-20193 Update StrikePrice to Decimal
-- 02 Jan 2014		RD		MBAL-24931 Added checking file age
-- 09 Jan 2014		ED		EIB 25004 - remove importLog table and use Log table
-- 21 Mar 2014  ED		EIB 25410 - add ''OPT'' instrument type
-- 25 Apr 2014	ED		EIB 25473 - raise error if file is too old and mark temp records as LoadState=3
-- 28 Jul 2014	ED		EIB 25628 - get DataSource from ReceiveLocation
-- 19 Sep 2014	ED		EIB 26023 - set PayCollectAmt to 0 in case of NULL
-- 29 Oct 2014	ED		EIB 26160 - Use Currency

SET NOCOUNT ON

DECLARE @DataSourceCode		 VARCHAR(100)
DECLARE @DataSourceId		 INT
DECLARE @Code				 VARCHAR(100)
DECLARE @ReturnValue		 INT
DECLARE @Output				 INT
DECLARE @Output2			 INT
DECLARE @DefaultCurrencyId	 INT
DECLARE @Message			 VARCHAR(1024)
DECLARE @AccountFormatConfig VARCHAR(100)

DECLARE @ProcessedCount INT
SET @ProcessedCount = 0

DECLARE @AddCount INT
SET @AddCount = 0

--specify datasource in proc.
SET @DataSourceCode = (SELECT d.Code FROM ib_DataSource d INNER JOIN ReceiveLocation rl ON rl.DataSourceId = d.DataSourceId WHERE ReceiveLocationSysId = @ReceiveLocationSysId)
IF @LocationPath IS NULL SET @LocationPath = @DataSourceCode

SET @Code = @DataSourceCode
EXEC @ReturnValue= [_ib_DataSource_GetByCodeForOutput] @Code, @OutPut output, @Output2 output	
SET @DataSourceId = @Output
SET @DefaultCurrencyId = @Output2	
			
SET @Message = @DataSourceCode + '' Position Report loader started'' 		
EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @Message, ''Success'', '''', @RunId

-- Store ImportFile record to be associated with Settlement Price load
DECLARE @ImportFileId INT
EXEC ib_ImportFile_Add @DataSourceId, @LocationPath, @ImportFileId output
DECLARE @SelectedAsOfDate DATETIME

--Gets the defaultStrikePriceDivisor
DECLARE	@DefaultStrikePriceDivisor	DECIMAL(19,6)
SET @DefaultStrikePriceDivisor = [dbo].[udf_GetDefaultStrikePriceDivisor](@DataSourceId, NULL)

-- Get the Config Value based on Data Source Code and Configuration Type
SET @AccountFormatConfig = [dbo].[GetConfigValueByDataSourceAndConfigurationType](@DataSourceCode, ''IceAccountFormat'')

-- There really isn''t any need for orchestration to call a LoadStateChange anymore
-- since we only process rows for single file now
-- but to keep consistent with other loaders - we''ll update to LoadState 1 at 
-- start of this Load stored procedure
UPDATE [dbo].[ICE_PosRpt]
SET LoadState = 1
WHERE LoadState = 0
	AND Filename = @LocationPath

-- Creating Temp Table just for use in this process
-- for iterating through the records.
CREATE TABLE #temp1
	(
	ICE_PosRptID			INT				NOT NULL
	, Exchange				VARCHAR(4)		NOT NULL
	, OriginatingMemberName VARCHAR(3)		NOT NULL
	, AccountCode			VARCHAR(4)		NOT NULL
	, PhysicalCommodity		VARCHAR(3)		NOT NULL
	, ContractType			VARCHAR(3)		NOT NULL
	, PutCall				BIT				NULL
	, LongExpiryDate		VARCHAR(8)		NOT NULL
	, ExercisePrice			DECIMAL(19,4)	NULL
	, LongAccountVolme		INT				NOT NULL
	, ShortAccountVolume	INT				NOT NULL	
	, PayCollect			DECIMAL(19,10)	NOT NULL
	, PremiumPayCollect		DECIMAL(19,10)	NULL
	, LongLotsTraded		INT				NULL	
	, ShortLotsTraded		INT				NULL
	, ValuationPrice		DECIMAL(24,10)	NOT NULL
	, BizDate				VARCHAR(10)
	, SettlementCurrency    VARCHAR (3)     NULL
	)

INSERT INTO #temp1
	(
	ICE_PosRptID	
	, Exchange	
	, OriginatingMemberName
	, AccountCode	
	, PhysicalCommodity	
	, ContractType	
	, PutCall	
	, LongExpiryDate
	, ExercisePrice	
	, LongAccountVolme	
	, ShortAccountVolume
	, PayCollect
	, PremiumPayCollect	
	, LongLotsTraded		
	, ShortLotsTraded
	, ValuationPrice
	, BizDate	
	, SettlementCurrency
	)
	
	SELECT 
		ICE_PosRptID
		, Exchange
		, TradingMember
		, CASE WHEN @AccountFormatConfig = ''PositionAccount'' THEN PositionAccount ELSE ClearingMember + PositionAccount END
		, CommodityId	
		, InstrumentType		-- ContractType
								-- If ContractType was F or M or D then "FUT"
								-- If ContractType was P or C then "OOF"
		, PutCall				-- PutCall: 0 = Put, 1 = Call
		, MaturityMonthYear	
		, StrikePrice
		, QtyLong	
		, QtyShort			
		, ISNULL(PayCollectAmt, 0)
		, PremPayCollectAmt	
		, TradedLongLots	
		, TradedShortLots
		, SettlementPrice
		, BizDt
		, SettlementCurrency
	FROM [dbo].[ICE_PosRpt]
	WHERE LoadState = 1
	  AND [FileName] = @LocationPath
	
	--rd - make sure the As Of Date is not older than acceptable	
	DECLARE @CheckAsOfDate DATETIME

	SET @CheckAsOfDate = (SELECT MIN([dbo].[GetDateFromIceBizDt](BizDate)) AS CheckRunDate FROM #temp1)
	IF (@CheckAsOfDate IS NOT NULL)
	BEGIN		
		DECLARE @IsAcceptable bit
		EXECUTE [dbo].[Load_IsFileTooOld] @DataSourceId,@LocationPath,@CheckAsOfDate,@IsAcceptable OUTPUT, @ReceiveLocationSysId, @RunId
		IF (@IsAcceptable = 0)
		BEGIN
			DROP TABLE #temp1
			UPDATE ICE_PosRpt SET [LoadState] = 3 WHERE [Filename] = @LocationPath
			RAISERROR (''File is too old.'', 18, 0)
			RETURN 0
		END
	END
	  
		
SET XACT_ABORT ON 
			
BEGIN TRANSACTION T1
	
-- BizTalk''s SQL Adapter uses more restrictive read serializable
-- so this is necessary to relax it to something that is default
-- and perfectly acceptable!

SET TRANSACTION ISOLATION LEVEL READ COMMITTED

BEGIN TRY

	DECLARE 
		@ICE_PosRptID				INT				
		, @Exchange					VARCHAR(4)		
		, @OriginatingMemberName	VARCHAR(3)		
		, @AccountCode				VARCHAR(4)		
		, @PhysicalCommodity		VARCHAR(3)		
		, @ContractType				VARCHAR(3)		
		, @PutCall					BIT				
		, @LongExpiryDate			VARCHAR(8)		
		, @ExercisePrice			DECIMAL(19,4)		
		, @LongAccountVolume		INT				
		, @ShortAccountVolume		INT					
		, @PayCollect				DECIMAL(19,10)	
		, @PremiumPayCollect		DECIMAL(19,10)	
		, @LongLotsTraded			INT					
		, @ShortLotsTraded			INT				
		, @ValuationPrice			DECIMAL(24,10)	
		, @BizDate					VARCHAR(10)
		, @SettlementCurrency		VARCHAR(3)

	DECLARE pos_cursor CURSOR FOR
	SELECT ICE_PosRptID	
		, Exchange	
		, OriginatingMemberName
		, AccountCode	
		, PhysicalCommodity	
		, ContractType	
		, PutCall	
		, LongExpiryDate
		, ExercisePrice	
		, LongAccountVolme	
		, ShortAccountVolume
		, PayCollect
		, PremiumPayCollect	
		, LongLotsTraded		
		, ShortLotsTraded
		, ValuationPrice
		, BizDate	
		, SettlementCurrency
	FROM #temp1

	OPEN pos_cursor

	-- Perform the first fetch and store the values in variables.
	-- Note: The variables are in the same order as the columns
	-- in the SELECT statement. 
	
	FETCH NEXT FROM pos_cursor
	INTO 
		@ICE_PosRptID
		, @Exchange		
		, @OriginatingMemberName
		, @AccountCode	
		, @PhysicalCommodity	
		, @ContractType	
		, @PutCall	
		, @LongExpiryDate	
		, @ExercisePrice	
		, @LongAccountVolume	
		, @ShortAccountVolume	
		, @PayCollect
		, @PremiumPayCollect
		, @LongLotsTraded		
		, @ShortLotsTraded	
		, @ValuationPrice	
		, @BizDate	
		, @SettlementCurrency

		-- Check @@FETCH_STATUS to see if there are any more rows to fetch.
		WHILE @@FETCH_STATUS = 0
		BEGIN

	
		DECLARE @ExchangeCode			VARCHAR(25)
		DECLARE @FirmCd					VARCHAR(100)
		DECLARE @AccountCd				VARCHAR(100)
		DECLARE @InstrumentCd			VARCHAR(100)
		DECLARE @InstrumentTypeCd		VARCHAR(100)
		DECLARE @QuantityPS				DECIMAL(18,10)
		DECLARE @MarketValuePS			DECIMAL(19,4)
		DECLARE @MarketValueTR			DECIMAL(19,4)
		DECLARE @ExpiryDate				DATETIME
		DECLARE @StrikePrice			DECIMAL(19,4)
		DECLARE @TrxTypeCdPS			VARCHAR(25)
		DECLARE @TrxTypeCdTR			VARCHAR(25)
		DECLARE @OptionTypeCd			VARCHAR(25)
		DECLARE @QuantityTR				DECIMAL(18,10)
		DECLARE @TrxDate				DATETIME
		DECLARE @ExpYr					SMALLINT
		DECLARE @ExpMth					SMALLINT
		DECLARE @ExpDay					SMALLINT
		DECLARE	@LongQuantity			DECIMAL(19,4)
		DECLARE @ShortQuantity			DECIMAL(19,4)
		DECLARE @TradedLongQuantity		DECIMAL(19,4)
		DECLARE @TradedShortQuantity	DECIMAL(19,4)
		DECLARE @AsOfDate				DATETIME
		DECLARE @InstrumentId			INT
		DECLARE @TickSize				INT
		DECLARE @MarketValueDivisor		DECIMAL(19,4)
		DECLARE	@StrikePriceDivisor		DECIMAL(19,4)
		DECLARE @PriceDivisor			DECIMAL(19,4)
		
		SET @ExchangeCode = @Exchange
	
		SET @Output = NULL
		DECLARE @InstrumentTypeId INT

		SET @InstrumentTypeCd = 
			CASE @ContractType
				WHEN ''FUT'' THEN ''F''
				WHEN ''OOF'' THEN ''O''
				WHEN ''OPT'' THEN ''O''
				WHEN ''OOC'' THEN ''O''
			END

		EXEC @ReturnValue = ib_Instrumenttype_AddAsNeeded @DataSourceId,@InstrumentTypeCd,@OutPut output
		SET @InstrumentTypeId = @Output

		DECLARE @CurrencyId INT
		SET @CurrencyId = NULL
		IF @SettlementCurrency IS NOT NULL
			BEGIN
				EXEC @ReturnValue = [ib_Currency_AddAsNeeded] @DataSourceId, @SettlementCurrency, @Output output
				SET @CurrencyId = @Output
			END

		SET @Output = NULL
		SET @Output2 = NULL
		
		SET @InstrumentCd = @InstrumentTypeCd + ''_'' + @ExchangeCode + ''_'' + @PhysicalCommodity
				
		EXEC @ReturnValue= [ib_Instrument_AddAsNeeded] @DataSourceId,@InstrumentTypeId,@InstrumentCd,@CurrencyId,@OutPut output,@Output2 output	
		SET @InstrumentId = @Output
		SET @CurrencyId = @Output2
		IF @Output2 = NULL
			BEGIN
				SET @CurrencyId = @DefaultCurrencyId
			END

		SET @TickSize = NULL
		SELECT @TickSize = TickSize FROM ib_Instrument WHERE InstrumentId = @InstrumentId

		SET @MarketValueDivisor = NULL
		SET @StrikePriceDivisor = NULL
		SET @PriceDivisor = NULL

		SELECT @MarketValueDivisor = MarketValueDivisor
				, @StrikePriceDivisor	= StrikePriceDivisor
				, @PriceDivisor = PriceDivisor
		FROM [dbo].[ib_InstrumentDataSource]
		WHERE DataSourceId = @DataSourceId
			AND DataSourceInstrumentCode = @InstrumentCd 
			
		IF @MarketValueDivisor IS NULL SET @MarketValueDivisor = 1

		SET @FirmCd = @OriginatingMemberName
		SET @AccountCd = @AccountCode
		
		SET @QuantityPS = CAST(@LongAccountVolume AS DECIMAL(18,10)) - CAST(@ShortAccountVolume AS DECIMAL(18,10))
		SET @MarketValuePS = CASE WHEN @TickSize > 0 THEN (@PayCollect * @TickSize / @MarketValueDivisor) ELSE @PayCollect END
		SET @MarketValueTR = CASE WHEN @TickSize > 0 THEN @PremiumPayCollect * @TickSize / @MarketValueDivisor ELSE @PremiumPayCollect END
			
		IF @StrikePriceDivisor IS NULL -- Then get the default
			BEGIN
				DECLARE @ExchangeId INT
				SELECT @ExchangeId = ExchangeId FROM ib_Exchange WHERE [Code] = @ExchangeCode
				
				SET @StrikePriceDivisor = [dbo].[udf_GetDefaultStrikePriceDivisor](@DataSourceId, @ExchangeId)
			END

		SET @StrikePrice = (@ExercisePrice/@StrikePriceDivisor)
	
		-- Set Settlement Price
		IF @PriceDivisor IS NULL 
			SET @PriceDivisor = 1
					
		DECLARE @SettlementPrice DECIMAL(24,10)
		SET @SettlementPrice = CONVERT(DECIMAL(24,10), @ValuationPrice) / @PriceDivisor
			
		SET @TrxTypeCdPS = ''Position''
		SET @TrxTypeCdTR = ''Premium''

		-- Set Option Type Code
		SET @OptionTypeCd = 
			CASE @PutCall
				WHEN 0 THEN ''P''
				WHEN 1 THEN ''C''
			END 

		-- Set AsOfDate	
		SET @AsofDate = [dbo].[GetDateFromIceBizDt] (@BizDate)
					
		SET @TrxDate = @AsOfDate
		SET @SelectedAsOfDate = @AsOfDate

		-- MBAL 15856 - Set Quantity = 0 to Premium trx
		-- SET @QuantityTR = case when @TickSize > 0 then @premiumpaycollect/@TickSize else @premiumpaycollect END
		SET @QuantityTR = 0

		SET @ExpYr = LEFT(@LongExpiryDate,4)
		SET @ExpMth = SUBSTRING(@LongExpiryDate,5,2)
		SET @ExpDay = RIGHT(@LongExpiryDate,2)
		SET @ExpDay = dbo.udf_OnLoad_ExpiryDate_Get_Day(@ExpYr,@ExpMth,@ExpDay)
		
		SET @LongQuantity = @LongAccountVolume
		SET @ShortQuantity = @ShortAccountVolume
		SET @TradedLongQuantity = @LongLotsTraded 
		SET @TradedShortQuantity = @ShortLotsTraded
		
		DECLARE @PositionId INT
		SET @PositionId = NULL		
		
		EXEC [ib_Position_W_Trans_Load]
			@DataSourceCode
			, @ExchangeCode
			, @FirmCd
			, @AccountCd	
			, @AsOfDate
			, @InstrumentCd
			, @QuantityPS
			, @MarketValuePS
			, @MarketValueTR
			, @ExpYr
			, @ExpMth
			, @ExpDay
			, @StrikePrice
			, @TrxTypeCdPS
			, @TrxTypeCdTR
			, @OptionTypeCd
			, @QuantityTR
			, @TrxDate
			, NULL -- @Price is not used in LCH_TypePS_Load
			, @ICE_PosRptID
			, @InstrumentTypeCd
			, @SettlementCurrency
			, @LongQuantity 
			, @ShortQuantity 
			, @TradedLongQuantity 
			, @TradedShortQuantity
			, @PositionId = @PositionId OUTPUT
			, @ReceiveLocationSysId = @ReceiveLocationSysId
			, @RunId = @RunId
			, @LocationPath = @LocationPath
						
			-- Add Settlement Price											
			EXEC ib_Price_AddFromPositionLoad
				@PositionId
				, @ImportFileId
				, @SettlementPrice 			
		
		
		--flip processed flag in source table.
		UPDATE ICE_PosRpt
		SET LoadState = 2
		WHERE ICE_PosRptID = @ICE_PosRptID
			AND LoadState = 1
		
		IF @PositionId IS NOT NULL AND @PositionId > 0
			SET @AddCount = @AddCount + 1

		SET @ProcessedCount	= @ProcessedCount + 1
		
		FETCH NEXT FROM pos_cursor
		INTO 		
			@ICE_PosRptID
			, @Exchange		
			, @OriginatingMemberName
			, @AccountCode	
			, @PhysicalCommodity	
			, @ContractType	
			, @PutCall	
			, @LongExpiryDate	
			, @ExercisePrice	
			, @LongAccountVolume	
			, @ShortAccountVolume	
			, @PayCollect
			, @PremiumPayCollect
			, @LongLotsTraded		
			, @ShortLotsTraded	
			, @ValuationPrice	
			, @BizDate	
			, @SettlementCurrency
		END

	CLOSE pos_cursor
	DEALLOCATE pos_cursor

	SET @Message = @DataSourceCode + '' Position Report loader ended ('' + CONVERT(VARCHAR(10), @ProcessedCount) + '' processed, '' 
		+ CONVERT(VARCHAR(10), @AddCount) + '' added)'' 
		
	EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @Message, ''Success'', '''', @RunId
		
	UPDATE ib_ImportFile 
	SET AsOfDate = @SelectedAsOfDate 
	WHERE ImportFileId = @ImportFileId

	COMMIT TRANSACTION
		
	IF OBJECT_ID(''tempdb..#temp1'') IS NOT NULL 
		DROP TABLE #temp1
		
END TRY


BEGIN CATCH 

	IF XACT_STATE() = -1 
		ROLLBACK TRANSACTION
	
	SET @Message = @DataSourceCode + '' Position Report Report loader failed'' 		
	EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @Message, ''Error'', '''', @RunId
	
	EXEC [dbo].[sp_RethrowError]
		
END CATCH 

SET XACT_ABORT OFF
	
RETURN 0
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Exchange_Delete]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Exchange_Delete]
(
	@ExchangeId INT 
)
AS
SET NOCOUNT ON

--Description: delete exchange

--	17 May 2010		ED		create
--	15 Jul 2010		amk		MBAL-16177: Cascade delete to child tables
--	20 Jul 2010		amk		MBAL-16177: Cascade delete to price report summary, template group, and price

	BEGIN TRANSACTION

	BEGIN TRY
		DELETE FROM [dbo].[ib_DataSourceExchange]
			WHERE ExchangeId = @ExchangeId

		DELETE FROM [dbo].[ib_CashGroupExchange]
			WHERE ExchangeId = @ExchangeId

		DELETE FROM [dbo].[ib_PriceReportSummary]
			WHERE ExchangeId = @ExchangeId

		DELETE FROM [dbo].[ib_TemplateGroup]
			WHERE ExchangeId = @ExchangeId

		DELETE FROM [dbo].[ib_Price]
			WHERE ExchangeId = @ExchangeId

		DELETE FROM [dbo].[ib_Exchange]
			WHERE ExchangeId = @ExchangeId

		COMMIT TRANSACTION
	END TRY
	BEGIN CATCH
		ROLLBACK TRANSACTION
		EXEC [dbo].[sp_RethrowError] ''Exchange is currently in use.''	
	END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[Liffe_Notification_Add]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[Liffe_Notification_Add]
	(
    @RowId					VARCHAR(19) = NULL
    , @System					VARCHAR(7) = NULL
    , @Version					VARCHAR(3) = NULL
    , @RecType					VARCHAR(3) = NULL
    , @Exchange				VARCHAR(1) = NULL
    , @ExchangeMnemonic		VARCHAR(5) = NULL    
    , @TradingDate				VARCHAR(10) = NULL -- Date YYYY-MM-DD
    , @TDD						VARCHAR(19) = NULL
    , @NewTDD					VARCHAR(19) = NULL   
    , @TradingDayTrade			VARCHAR(19) = NULL
    , @OrgClearer				VARCHAR(3) = NULL
    , @OrgMember				VARCHAR(3) = NULL -- Mnemonic
    , @OrgTrader				VARCHAR(3) = NULL -- Mnemonic
    , @Account					VARCHAR(25) = NULL -- Seg Characters 8
    , @PMA						VARCHAR(25) = NULL
    , @MarginAccount			VARCHAR(1) = NULL
    , @ChargeInd				VARCHAR(1) = NULL
    , @LongShort				VARCHAR(1) = NULL
    , @Commodity				VARCHAR(3) = NULL
    , @LogCommodity			VARCHAR(3) = NULL
    , @ContractType			VARCHAR(1) = NULL
    , @GenContractType			VARCHAR(1) = NULL
    , @ExpiryMonth				VARCHAR(5) = NULL
    , @LongExpiryDate			VARCHAR(10) = NULL -- YYYY-MM-00
    , @Strike					VARCHAR(24) = NULL     
    , @NotificationSlipType	VARCHAR(1) = NULL
    , @ClearingSlipId			VARCHAR(19) = NULL -- Integer            
    , @VolumeToAdjust			VARCHAR(100) = NULL
    , @ValPrice				VARCHAR(24) = NULL
    , @CptyMember				VARCHAR(3) = NULL -- Mnemonic
    , @CptyTrader				VARCHAR(3) = NULL -- Mnemonic
    , @MatchedTime				VARCHAR(19) = NULL -- YYYY-MM-DD HH:MM:SS 
    , @TRSOperator				VARCHAR(50) = NULL
    , @UserSpecifiedData		VARCHAR(100) = NULL
    , @CounternoteSlipNumber	VARCHAR(19) = NULL -- Integer
    , @ClosingTradeSlipNumber	VARCHAR(19) = NULL -- Integer
    , @ClosingTradeSubNumber	VARCHAR(19) = NULL -- Integer
    , @ClosingTradeVolume		VARCHAR(100) = NULL -- Text
    , @AllLotsIndicator		VARCHAR(1) = NULL -- Y or N
    , @NotificationSource		VARCHAR(1) = NULL 
    , @NotificationStatus		VARCHAR(2) = NULL
    , @LotSize					VARCHAR(19) = NULL --DEFAULT 1
    , @PositionType			VARCHAR(1) = NULL
    , @TradingDayNotificationProcessing	VARCHAR(19) = NULL -- Integer
    , @EnteredDate				VARCHAR(10) = NULL
    , @ModifiedTime			VARCHAR(8) = NULL
    , @PositionMaintenanceId	VARCHAR(100) = NULL
    , @ReportTime				VARCHAR(19) = NULL -- YYYY-MM-DD HH:MM:SS            
    , @FileName	   		   VARCHAR (512) = NULL
)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON

	INSERT INTO [dbo].[Liffe_Notification] 
	(
	 [RowId]					
    , [System]					
    , [Version]					
    , [RecType]					
    , [Exchange]				
    , [ExchangeMnemonic]		
    , [TradingDate]				
    , [TDD]						
    , [NewTDD]					
    , [TradingDayTrade]			
    , [OrgClearer]				
    , [OrgMember]				
    , [OrgTrader]				
    , [Account]					
    , [PMA]						
    , [MarginAccount]			
    , [ChargeInd]				
    , [LongShort]				
    , [Commodity]				
    , [LogCommodity]			
    , [ContractType]			
    , [GenContractType]			
    , [ExpiryMonth]				
    , [LongExpiryDate]			
    , [Strike]					
    , [NotificationSlipType]	
    , [ClearingSlipId]			
    , [VolumeToAdjust]			
    , [ValPrice]				
    , [CptyMember]				
    , [CptyTrader]				
    , [MatchedTime]				
    , [TRSOperator]				
    , [UserSpecifiedData]		
    , [CounternoteSlipNumber]	
    , [ClosingTradeSlipNumber]	
    , [ClosingTradeSubNumber]	
    , [ClosingTradeVolume]		
    , [AllLotsIndicator]		
    , [NotificationSource]		
    , [NotificationStatus]		
    , [LotSize]					
    , [PositionType]			
    , [TradingDayNotificationProcessing]	
    , [EnteredDate]				
    , [ModifiedTime]			
    , [PositionMaintenanceId]	
    , [ReportTime]				
    , [FileName]	  		   
		
	)
	VALUES
	(
   @RowId					
    , @System				
    , @Version				
    , @RecType				
    , @Exchange				
    , @ExchangeMnemonic		
    , @TradingDate			
    , @TDD					
    , @NewTDD				
    , @TradingDayTrade		
    , @OrgClearer			
    , @OrgMember			
    , @OrgTrader			
    , @Account				
    , @PMA					
    , @MarginAccount		
    , @ChargeInd			
    , @LongShort			
    , @Commodity			
    , @LogCommodity			
    , @ContractType			
    , @GenContractType		
    , @ExpiryMonth			
    , @LongExpiryDate		
    , @Strike				
    , @NotificationSlipType	
    , @ClearingSlipId		
    , @VolumeToAdjust		
    , @ValPrice				
    , @CptyMember			
    , @CptyTrader			
    , @MatchedTime			
    , @TRSOperator			
    , @UserSpecifiedData	
    , @CounternoteSlipNumber
    , @ClosingTradeSlipNumber	
    , @ClosingTradeSubNumber	
    , @ClosingTradeVolume		
    , @AllLotsIndicator		
    , @NotificationSource		
    , @NotificationStatus		
    , @LotSize					
    , @PositionType			
    , @TradingDayNotificationProcessing	
    , @EnteredDate				
    , @ModifiedTime			
    , @PositionMaintenanceId	
    , @ReportTime				
    , @FileName	   		   
	)
	
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_InstrumentType_GetByCode]''
');

GO
EXECUTE ('
CREATE proc [dbo].[ib_InstrumentType_GetByCode]
@Code varchar(100),
@InstrumentTypeId int output

as
SET NOCOUNT ON

SELECT	@InstrumentTypeId = InstrumentTypeId
FROM	[dbo].[ib_InstrumentType]
WHERE	[Code] = @Code
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_ICE_TrdCaptRpt_Load]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_ICE_TrdCaptRpt_Load]
(
	@LocationPath		VARCHAR(100)
	,@ReceiveLocationSysId INT
	,@RunId INT
)
AS

-- Description: Load Transactions for ICE TrdCaptRpt

-- History:
-- 12 Jul 2010	AAJM	MBAL-14903 Creation
-- 03 Aug 2010	amk		MBAL-16367: special trade types for adj/pos/gu per Jeff
-- 06 Aug 2010	amk		MBAL-16417: reverse long and short quantity for 3-5adj and 3-5pos
-- 09 Aug 2010	amk		MBAL-16417: Re-do this change; reverse buyer/seller indicator for 3-5adj and 3-5pos
-- 08 Sep 2010	amk		MBAL-16602: Undo the above change for 3-5adj and 3-5pos
-- 09 Sep 2010	amk		MBAL-16602: OK, put above change back in per Marc! ad other related tweaks
-- 04 Oct 2010  AAJM	MBAL-16775: Allow nulls for TradeDate and set TradeDate to AsOfDate if it doesn''t exist
-- 23 Feb 2011	amk		MBAL-17645: changes for new fixml schema as spelled out on "ICE Transaction Mapping v3.xls"
-- 24 Feb 2011	amk		MBAL-17645: don''t require customer account
-- 03 Mar 2011	amk		MBAL-17722: BUG FIX, make sure trx type has dash before suffixing transfer reason
--						file rollback demands this
-- 01 Mar 2012		AAJM	MBAL-20193 Update StrikePrice to Decimal
-- 02 Jan 2014	RD		MBAL-24931 Added checking file age
-- 09 Jan 2014	ED		EIB 25004 - remove importLog table and use Log table
-- 21 Mar 2014  ED		EIB 25410 - add ''OPT'' instrument type
-- 25 Apr 2014	ED		EIB 25473 - raise error if file is too old and mark temp records as LoadState=3
-- 14 May 2014	ED		EIB 25636 - pass LocationPath to ib_trx_load
-- 28 Jul 2014	ED		EIB 25628 - get DataSource from ReceiveLocation
-- 29 Oct 2014	ED		EIB 26160 - Use Currency

SET NOCOUNT ON

DECLARE @DataSourceCode		 VARCHAR(100)
DECLARE @DataSourceId		 INT
DECLARE @Code				 VARCHAR(100)
DECLARE @ReturnValue		 INT
DECLARE @Output				 INT
DECLARE @Output2			 INT
DECLARE @DefaultCurrencyId	 INT
DECLARE @Message			 VARCHAR(1024)
DECLARE @AccountFormatConfig VARCHAR(100)

DECLARE @AddCount			INT
SET @AddCount = 0

DECLARE @ProcessedCount		INT
SET @ProcessedCount = 0

--specify datasource in proc.
SET @DataSourceCode = (SELECT d.Code FROM ib_DataSource d INNER JOIN ReceiveLocation rl ON rl.DataSourceId = d.DataSourceId WHERE ReceiveLocationSysId = @ReceiveLocationSysId)
IF @LocationPath IS NULL SET @LocationPath = @DataSourceCode

SET @Code = @DataSourceCode
EXEC @ReturnValue= [_ib_DataSource_GetByCodeForOutput] @Code,@OutPut output,@Output2 output	
SET @DataSourceId = @Output
SET @DefaultCurrencyId = @Output2	
			
SET @Message = @DataSourceCode + '' Trade Capture Report loader started'' 		
EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @Message, ''Success'', '''', @RunId

--Gets the defaultStrikePriceDivisor
DECLARE	@DefaultStrikePriceDivisor	DECIMAL(19,6)
SET @DefaultStrikePriceDivisor = [dbo].[udf_GetDefaultStrikePriceDivisor](@DataSourceId, NULL)

-- Get the Config Value based on Data Source Code and Configuration Type
SET @AccountFormatConfig = [dbo].[GetConfigValueByDataSourceAndConfigurationType](@DataSourceCode, ''IceAccountFormat'')

-- There really isn''t any need for orchestration to call a LoadStateChange anymore
-- since we only process rows for single file now
-- but to keep consistent with other loaders - we''ll update to LoadState 1 at 
-- start of this Load stored procedure
UPDATE [dbo].[ICE_TrdCaptRpt]
SET LoadState = 1
WHERE LoadState = 0
	AND Filename = @LocationPath

	-- Creating Temp Table just for use in this process
	-- for iterating through the records.
	CREATE TABLE #temp1
		(
		ICE_TrdCaptRptID		INT				NOT NULL
		, Exchange				VARCHAR(4)		NOT NULL
		, OriginatingMemberName VARCHAR(3)		NOT NULL
		, AccountCode			VARCHAR(4)		NOT NULL
		, DetailAccountCode		VARCHAR(14)		NULL
		, PhysicalCommodity		VARCHAR(3)		NOT NULL
		, ContractType			VARCHAR(3)		NOT NULL
		, PutCall				BIT				NULL
		, LongExpiryDate		VARCHAR(8)		NOT NULL
		, ExercisePrice			DECIMAL(19,4)	NULL
		, Volume				INT				NOT NULL
		, BuyOrSell				TINYINT			NOT NULL
		, TradeType				TINYINT			NOT NULL
		, TradeSubType			TINYINT			NULL
		, TradeDate				NVARCHAR(10)	NULL -- MBAL-16775 Missing TrdDt Causing File Failure
		, Price					DECIMAL(24,10)	NOT NULL
		, BizDate				NVARCHAR(10)	NOT NULL
		, TransferReason		NVARCHAR(4)		NULL
		, Currency    VARCHAR(3)		NULL
		)
	
	INSERT INTO #temp1
		(
		ICE_TrdCaptRptID
		, Exchange
		, OriginatingMemberName
		, AccountCode
		, DetailAccountCode
		, PhysicalCommodity
		, ContractType
		, PutCall
		, LongExpiryDate
		, ExercisePrice
		, Volume
		, BuyOrSell
		, TradeType
		, TradeSubType
		, TradeDate
		, Price
		, BizDate
		, TransferReason
		, Currency
		)
	SELECT 
		ICE_TrdCaptRptID
		, Exchange
		, TradingMember	
		, CASE WHEN @AccountFormatConfig = ''PositionAccount'' THEN PositionAccount ELSE ClearingMember + PositionAccount END
		, CustomerAccount	
		, CommodityId
		, InstrumentType		-- ContractType
								-- If ContractType was F or M or D then "FUT"
								-- If ContractType was P or C then "OOF"
		, PutCall				-- 0 = Put,  1 = Call
		, MaturityMonthYear	
		, StrikePrice
		, LastQty	
		, SideBuySellFlag		-- 1 = Buy (was ''B''), 2 = Sell (was ''S'')
		, TradeType		
		, TradeSubType
		, TradeDate
		, LastPx
		, BizDt
		, TransferReason
		, Currency
	FROM [dbo].[ICE_TrdCaptRpt]
	WHERE LoadState = 1
	  AND [FileName] = @LocationPath

	--rd - make sure the As Of Date is not older than acceptable	
	DECLARE @CheckAsOfDate DATETIME

	SET @CheckAsOfDate = (SELECT MIN([dbo].[GetDateFromIceBizDt](BizDate)) AS CheckRunDate FROM #temp1)
	IF (@CheckAsOfDate IS NOT NULL)
	BEGIN		
		DECLARE @IsAcceptable bit
		EXECUTE [dbo].[Load_IsFileTooOld] @DataSourceId,@LocationPath,@CheckAsOfDate,@IsAcceptable OUTPUT, @ReceiveLocationSysId, @RunId
		IF (@IsAcceptable = 0)
		BEGIN
			DROP TABLE #temp1
			UPDATE ICE_TrdCaptRpt SET [LoadState] = 3 WHERE [Filename] = @LocationPath
			RAISERROR (''File is too old.'', 18, 0)
			RETURN 0
		END
	END
SET XACT_ABORT ON 
			
BEGIN TRANSACTION T1
	
-- BizTalk''s SQL Adapter uses more restrictive read serializable
-- so this is necessary to relax it to something that is default
-- and perfectly acceptable!

SET TRANSACTION ISOLATION LEVEL READ COMMITTED

BEGIN TRY
  
	DECLARE 
		@ICE_TrdCaptRptID			INT
		, @Exchange					VARCHAR(4)
		, @OriginatingMemberName	VARCHAR(3)
		, @AccountCode				VARCHAR(4) 
		, @DetailAccountCode		VARCHAR(14) 
		, @PhysicalCommodity		VARCHAR(3)
		, @ContractType				VARCHAR(3)
		, @PutCall					BIT
		, @LongExpiryDate			VARCHAR(8)
		, @ExercisePrice			DECIMAL(19,4)
		, @Volume					INT 
		, @BuyOrSell				TINYINT
		, @TradeType				TINYINT 
		, @TradeSubType				TINYINT
		, @TradeDate				NVARCHAR(10)
		, @Price					DECIMAL(24,10) 
		, @BizDate					NVARCHAR(10)
		, @TransferReason			NVARCHAR(4)
		, @Currency       VARCHAR(3)

	DECLARE @MarexFirmId INT
	SET @MarexFirmId = [dbo].[udf_GetMarexFirmId]()	

	DECLARE trx_cursor CURSOR FOR
	SELECT ICE_TrdCaptRptID
		, Exchange	
		, OriginatingMemberName
		, AccountCode
		, DetailAccountCode
		, PhysicalCommodity
		, ContractType
		, PutCall	
		, LongExpiryDate
		, ExercisePrice
		, Volume
		, BuyOrSell
		, TradeType
		, TradeSubType
		, TradeDate
		, Price
		, BizDate
		, TransferReason
		, Currency
	FROM #temp1

	OPEN trx_cursor

	-- Perform the first fetch and store the values in variables.
	-- Note: The variables are in the same order as the columns
	-- in the SELECT statement. 
	
	FETCH NEXT FROM trx_cursor
	INTO @ICE_TrdCaptRptID 
		, @Exchange 
		, @OriginatingMemberName
		, @AccountCode 
		, @DetailAccountCode 
		, @PhysicalCommodity 
		, @ContractType 
		, @PutCall 
		, @LongExpiryDate 
		, @ExercisePrice 
		, @Volume 
		, @BuyOrSell 
		, @TradeType 
		, @TradeSubType
		, @TradeDate
		, @Price
		, @BizDate
		, @TransferReason
		, @Currency

		-- Check @@FETCH_STATUS to see if there are any more rows to fetch.
		WHILE @@FETCH_STATUS = 0
		BEGIN
	
		DECLARE @ExchangeCd			VARCHAR(25)
		DECLARE @FirmCd				VARCHAR(100)
		DECLARE @AccountCd			VARCHAR(100)
		DECLARE @DetailAccountCd	VARCHAR(14)
		DECLARE @InstrumentCd		VARCHAR(100)
		DECLARE @InstrumentTypeCd	VARCHAR(100)
		DECLARE @ExpYr				SMALLINT
		DECLARE @ExpMth				SMALLINT
		DECLARE @ExpDay				SMALLINT
		DECLARE @StrikePrice		DECIMAL(19,4)
		DECLARE @TrxTypeCd			VARCHAR(25)
		DECLARE @OptionTypeCd		VARCHAR(25)
		DECLARE @Quantity			DECIMAL(18,10)
		DECLARE	@QuantityLong		INT
		DECLARE @QuantityShort		INT
		DECLARE @TrxDate			DATETIME
		DECLARE @PriceDec			DECIMAL(24,10)
		DECLARE @AsOfDate			DATETIME
		DECLARE @CurrencyId			INT
		DECLARE @InstrumentId		INT
		DECLARE @TickSize			INT		
		DECLARE @StrikePriceDivisor DECIMAL(19,4)	
		DECLARE @PriceDivisor		DECIMAL(19,4)
		DECLARE @GenericContractType VARCHAR(1)
		
		SET @ExchangeCd = @Exchange
	
		SET @Output = NULL
		DECLARE @InstrumentTypeId INT
		
		SET @InstrumentTypeCd = 
			CASE @ContractType
				WHEN ''FUT'' THEN ''F''
				WHEN ''OOF'' THEN ''O''
				WHEN ''OPT'' THEN ''O''
				WHEN ''OOC'' THEN ''O''
			END
		
		EXEC @ReturnValue = ib_Instrumenttype_AddAsNeeded @DataSourceId, @InstrumentTypeCd, @OutPut OUTPUT
		SET @InstrumentTypeId = @Output
		
		IF @Currency IS NOT NULL
			BEGIN
				EXEC @ReturnValue = [ib_Currency_AddAsNeeded] @DataSourceId, @Currency, @Output output
				SET @CurrencyId = @Output
			END
		
		SET @Output = NULL
		SET @Output2 = NULL
		
		SET @InstrumentCd = @InstrumentTypeCd + ''_'' + @ExchangeCd + ''_'' + @PhysicalCommodity
				
		EXEC @ReturnValue= [ib_Instrument_AddAsNeeded] @DataSourceId,@InstrumentTypeId,@InstrumentCd,@CurrencyId,@OutPut output,@Output2 output	
		SET @InstrumentId = @Output
		SET @CurrencyId = @Output2
		IF @Output2 = NULL
			BEGIN
				SET @CurrencyId = @DefaultCurrencyId
			END

		SET @TickSize = NULL
		SELECT @TickSize = TickSize 
		FROM ib_Instrument 
		WHERE InstrumentId = @InstrumentId

		SET @FirmCd = @OriginatingMemberName
		SET @AccountCd = @AccountCode
		SET @DetailAccountCd = @DetailAccountCode
		
		SET @StrikePriceDivisor = NULL
		SET @PriceDivisor = NULL

		SELECT @StrikePriceDivisor = StrikePriceDivisor
			, @PriceDivisor = PriceDivisor
		FROM [dbo].[ib_InstrumentDataSource]
		WHERE DataSourceId = @DataSourceId
			AND DataSourceInstrumentCode = @InstrumentCd 

		IF @PriceDivisor IS NULL 
			SET @PriceDivisor = 1
		SET @PriceDec = CONVERT(DECIMAL(24,10), @Price) / @PriceDivisor

		IF @StrikePriceDivisor IS NULL -- Then get the default
			BEGIN
				DECLARE @ExchangeId INT
				SELECT @ExchangeId = ExchangeId FROM ib_Exchange WHERE [Code] = @ExchangeCd
				
				SET @StrikePriceDivisor = [dbo].[udf_GetDefaultStrikePriceDivisor](@DataSourceId, @ExchangeId)
			END

		SET @StrikePrice = (@ExercisePrice/@StrikePriceDivisor)
		 
		SET @TrxTypeCd =
			CASE
				WHEN @TradeType = 0 AND @TradeSubType IS NULL
					THEN ''0''
				WHEN @TradeType = 0 AND @TradeSubType = 10
					THEN ''0-10''
				WHEN @TradeType = 0 AND @TradeSubType = 9
					THEN ''0-9''
				WHEN @TradeType = 3 AND @TradeSubType = 5
					THEN ''3-5''
				WHEN @TradeType = 3 AND @TradeSubType = 6
					THEN ''3-6''
				ELSE 
					ISNULL(CONVERT(VARCHAR(3), @TradeType), '''') + ISNULL(''-'' + CONVERT (VARCHAR(3), @TradeSubType), '''')
			END

		IF UPPER(@TransferReason) IN (''ADJ'', ''POS'', ''GU'', ''APT'', ''REV'')
		BEGIN
			-- file rollback requires non-numeric trx type to have a dash so add one if necessary
			IF CHARINDEX(''-'', @TrxTypeCd) = 0
				SET @TrxTypeCd = @TrxTypeCd + ''-''
			SET @TrxTypeCd = @TrxTypeCd + UPPER(@TransferReason)
		END
				
		-- Set Option Type Code
		SET @OptionTypeCd = 
			CASE @PutCall
				WHEN 0 THEN ''P''
				WHEN 1 THEN ''C''
			END 
			
		IF @TrxTypeCd IN (''3-5ADJ'', ''3-5POS'', ''3-5REV'')	-- MBAL-16417
			IF (@BuyOrSell = 1)		-- Buy
				SET @BuyOrSell = 0
			ELSE
				SET @BuyOrSell = 1

		IF (@BuyOrSell = 1) -- = B = Buy
			BEGIN
				SET @Quantity = @volume
				SET @QuantityLong = @volume
				SET @QuantityShort = 0
			END
		ELSE
			BEGIN
				SET @Quantity = @volume * -1
				SET @QuantityLong = 0
				SET @QuantityShort = @volume
			END

		IF @TrxTypeCd IN (''3-5ADJ'', ''3-5POS'', ''3-5REV'')
			BEGIN
				IF @Quantity > 0
					SET @Quantity = @Quantity * -1
				IF @QuantityLong > 0
					SET @QuantityLong = @QuantityLong * -1
				IF @QuantityShort > 0
					SET @QuantityShort = @QuantityShort * -1
			END
		
		SET @ExpYr = LEFT(@LongExpiryDate, 4)
		SET @ExpMth = SUBSTRING(@LongExpiryDate, 5, 2)
		SET @ExpDay = RIGHT(@LongExpiryDate, 2)
		SET @ExpDay = dbo.udf_OnLoad_ExpiryDate_Get_Day(@ExpYr, @ExpMth, @ExpDay)

		-- Set AsOfDate	and TrxDate
		SET @AsofDate = [dbo].[GetDateFromIceBizDt] (@BizDate)	
		
		IF @TradeDate IS NULL
			SET @TrxDate = @AsOfDate
		ELSE
			SET @TrxDate = [dbo].[GetDateFromIceBizDt] (@TradeDate)
	
		-- Set Generic Contract Type
		IF (@ContractType IS NOT NULL AND @ContractType = ''FUT'')
			SET @GenericContractType = ''F''
		ELSE
			SET @GenericContractType = ''O''
		
		DECLARE @TrxId INT
		SET @TrxId = NULL

		EXEC [ib_Trx_Load]
			@DataSourceCode
			, @ExchangeCd
			, @FirmCd
			, @AccountCd
			, @DetailAccountCd
			, @InstrumentCd
			, @ExpYr
			, @ExpMth
			, @ExpDay
			, @StrikePrice
			, @TrxTypeCd
			, @OptionTypeCd
			, @Quantity
			, @TrxDate
			, @PriceDec
			, @ICE_TrdCaptRptID
			, @GenericContractType
			, @AsOfDate
			, @LocationPath = @LocationPath
			, @CurrencyCd = @Currency
			, @MarexFirmId = @MarexFirmId
			, @TrxId = @TrxId OUTPUT
			, @QuantityLong = @QuantityLong 
			, @QuantityShort = @QuantityShort
			, @ReceiveLocationSysId = @ReceiveLocationSysId
			, @RunId = @RunId
			
			
		--flip processed flag in source table.
		UPDATE ICE_TrdCaptRpt
		SET LoadState = 2
		WHERE ICE_TrdCaptRptID = @ICE_TrdCaptRptID
			AND LoadState = 1
		
		IF @TrxId IS NOT NULL AND @TrxId > 0
			SET @AddCount = @AddCount + 1
		
		SET @ProcessedCount = @ProcessedCount + 1

		FETCH NEXT FROM trx_cursor
		INTO @ICE_TrdCaptRptID 
			, @Exchange 
			, @OriginatingMemberName
			, @AccountCode 
			, @DetailAccountCode 
			, @PhysicalCommodity 
			, @ContractType 
			, @PutCall 
			, @LongExpiryDate 
			, @ExercisePrice 
			, @Volume 
			, @BuyOrSell 
			, @TradeType 
			, @TradeSubType
			, @TradeDate
			, @Price
			, @BizDate
			, @TransferReason
			, @Currency
		END

	CLOSE trx_cursor
	DEALLOCATE trx_cursor

	SET @Message = @DataSourceCode + '' Trade Capture Report loader ended ('' + CONVERT(VARCHAR(10), @ProcessedCount) + '' processed, '' 
		+ CONVERT(VARCHAR(10), @AddCount) + '' added)'' 
		
	EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @Message, ''Success'', '''', @RunId
		
	COMMIT TRANSACTION
		
	IF OBJECT_ID(''tempdb..#temp1'') IS NOT NULL 
		DROP TABLE #temp1
		
END TRY

BEGIN CATCH 

	IF XACT_STATE() = -1 
		ROLLBACK TRANSACTION
	
	SET @Message = @DataSourceCode + '' Trade Capture Report loader failed'' 		
	EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @Message, ''Error'', '''', @RunId
	
	EXEC [dbo].[sp_RethrowError]
		
END CATCH 

SET XACT_ABORT OFF
	
RETURN 0
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_CurrencyDataSource_Delete]''
');

GO
EXECUTE ('/*
<details>
 <summary>Deletes a currency data source by its id from the ib_CurrencyDataSource table</summary>
 <created author="Laurentiu Macovei" Date="Friday 8 September 2006 10:20PM GMT" /> 
</details>
*/
create PROCEDURE [dbo].[ib_CurrencyDataSource_Delete]
(
	@CurrencyDataSourceId int
)
AS 
SET NOCOUNT ON

DELETE FROM [dbo].[ib_CurrencyDataSource]
WHERE CurrencyDataSourceId = @CurrencyDataSourceId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Exchange_Update]''
');

GO
EXECUTE (' /*
-- Updates a exchange from the ib_Exchange table by its id
-- 17 May 2010 ED created 

*/
CREATE PROCEDURE [dbo].[ib_Exchange_Update]
(
	@ExchangeId INT ,
	@Code VARCHAR(100),
    @Name VARCHAR(100),
    @RunBalanceReport BIT,
	@RunCloseOutReport BIT,
	@RunTradeLevelReconciliation BIT,
    @UpdateUsername VARCHAR(50)
)
AS
SET NOCOUNT ON
BEGIN TRY
--check for duplicates 
EXEC [dbo].[ib_Exchange_CheckForDuplicate] @Code, @Name, @ExchangeId

UPDATE ib_Exchange
   SET Code = @Code,
      [Name] = @Name, 
      RunBalanceReport = @RunBalanceReport,
      RunCloseOutReport = @RunCloseOutReport,
      RunTradeLevelReconciliation = @RunTradeLevelReconciliation,
      UpdateUsername = @UpdateUsername
 WHERE ExchangeId = @ExchangeId
END TRY
BEGIN CATCH
	EXEC [dbo].[sp_RethrowError]
END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[C21_PreviousDayLine_Add]''
');

GO
EXECUTE ('




-- =============================================
-- Author:		Lee Manifold
-- Create date: 09 May 2006
-- Description: Biztalk: Clearing 21 insert into table C21_PreviousDayLine

-- 19 Feb 2010 - Added FileName to Add SP
-- =============================================
CREATE PROCEDURE [dbo].[C21_PreviousDayLine_Add]
	-- Add the parameters for the stored procedure here
	(
	@FileName            VARCHAR (512) = NULL,
	@OrgID					varchar(5),
	@TMF					[varchar](10),
	@PA						[varchar](15), 
	@Guarantee				[varchar](1),
	@SettlementDate			[varchar](8),
	@ContractAliasName		[varchar](3),
	@ContractAliasExp1		[varchar](1),
	@ContractAliasExp2		[varchar](1),
	@ContractAliasExp3		[varchar](1),
	@ContractAliasExp4		[varchar](1),
	@ContractAliasStrike	[varchar](8),
	@ContractAliasCPF		[varchar](1),
	@IFTPrice				[varchar](1),
	@QMTPrice				[varchar](18),
	@BuyQty					[int],
	@SellQty				[int],
	@IFTDebit				[varchar](1),
	@QMTDebit				[varchar](18),
	@IFTCredit				[varchar](1),
	@QMTCredit				[varchar](18),
	@ISINCode				[varchar](12),
	@TradeCode				[varchar](40)
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for procedure here
INSERT INTO [dbo].[C21_PreviousDayLine]
			(
				[OrgID]
			   ,[TMF]
			   ,[PA]
			   ,[Guarantee]
			   ,[SettlementDate]
			   ,[ContractAliasName]
			   ,[ContractAliasExp1]
			   ,[ContractAliasExp2]
			   ,[ContractAliasExp3]
			   ,[ContractAliasExp4]
			   ,[ContractAliasStrike]
			   ,[ContractAliasCPF]
			   ,[IFTPrice]
			   ,[QMTPrice]
			   ,[BuyQty]
			   ,[SellQty]
			   ,[IFTDebit]
			   ,[QMTDebit]
			   ,[IFTCredit]
			   ,[QMTCredit]
			   ,[ISINCode]
			   ,[TradeCode]
			   ,[FileName]
			)
     VALUES
           (
			@OrgID					,
			@TMF					,
			@PA						, 
			@Guarantee				,
			@SettlementDate			,
			@ContractAliasName		,
			@ContractAliasExp1		,
			@ContractAliasExp2		,
			@ContractAliasExp3		,
			@ContractAliasExp4		,
			@ContractAliasStrike	,
			@ContractAliasCPF		,
			@IFTPrice				,
			@QMTPrice				,
			@BuyQty					,
			@SellQty				,
			@IFTDebit				,
			@QMTDebit				,
			@IFTCredit				,
			@QMTCredit				,
			@ISINCode				,
			@TradeCode				,
			@FileName
		)
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[Liffe_Position_Add]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[Liffe_Position_Add]
(
	 @RowId					VARCHAR(19) = NULL
    , @System					VARCHAR(7) = NULL
    , @Version					VARCHAR(3) = NULL
    , @RecType					VARCHAR(3) = NULL
    , @Exchange				VARCHAR(1) = NULL
    , @ExchangeMnemonic		VARCHAR(5) = NULL
    , @MarginTime				VARCHAR(8) = NULL -- HH:MM:SS
    , @MarginRunSeqNo			VARCHAR(19) = NULL -- Integer
    , @MarginType				VARCHAR(1) = NULL 
    , @TradingDayTrade			VARCHAR(19) = NULL
    , @TradingDate				VARCHAR(10) = NULL -- Date YYYY-MM-DD
    , @TDD						VARCHAR(19) = NULL
    , @OrgClearer				VARCHAR(3) = NULL
    , @OrgMember				VARCHAR(3) = NULL -- Mnemonic
    , @OrgTrader				VARCHAR(3) = NULL -- Mnemonic
    , @Account					VARCHAR(25) = NULL -- Seg Characters 8
    , @PMA						VARCHAR(25) = NULL
    , @MarginAccount			VARCHAR(1) = NULL
    , @Commodity				VARCHAR(3) = NULL
    , @LogCommodity			VARCHAR(3) = NULL
    , @ContractType			VARCHAR(1) = NULL
    , @GenContractType			VARCHAR(1) = NULL
    , @ContractTypeAll			VARCHAR(1) = NULL
    , @MonthCode				VARCHAR(1) = NULL
    , @ExpiryMonth				VARCHAR(5) = NULL
    , @ExpiryDate				VARCHAR(10) = NULL
    , @LongExpiryDate			VARCHAR(10) = NULL -- YYYY-MM-00
    , @Strike					VARCHAR(24) = NULL
    , @ValPrice				VARCHAR(24) = NULL
    , @LongPositionVol			VARCHAR(19) = NULL
    , @ShortPositionVol		VARCHAR(19) = NULL
    , @LongAdjustedVolume		VARCHAR(19) = NULL
    , @ShortAdjustedVolume		VARCHAR(19) = NULL
    , @LongNonMargVol			VARCHAR(19) = NULL
    , @ShortNonMargVol			VARCHAR(19) = NULL
    , @LongAdjustedNonMarginableVolume	VARCHAR(19) = NULL
    , @ShortAdjustedNonMarginableVolume	VARCHAR(19) = NULL
    , @ProfitLoss				VARCHAR(24) = NULL
    , @LongContractsTraded		VARCHAR(19) = NULL
    , @ShortContractsTraded	VARCHAR(19) = NULL
    , @LongTradedVol			VARCHAR(19) = NULL
    , @ShortTradedVol			VARCHAR(19) = NULL
    , @LongResultAssignment    VARCHAR(19) = NULL
    , @ShortResultAssignment   VARCHAR(19) = NULL
    , @LongResultExercise		VARCHAR(19) = NULL
    , @ShortResultExercise		VARCHAR(19) = NULL
    , @ContingentPrice			VARCHAR(24) = NULL
    , @ContingentMargin		VARCHAR(24) = NULL
    , @Premium					VARCHAR(24) = NULL
    , @ManExeVolume			VARCHAR(19) = NULL
    , @AutoExeVolume			VARCHAR(19) = NULL
    , @ManDelVolume			VARCHAR(19) = NULL
    , @AutoDelVolume			VARCHAR(19) = NULL
    , @ManualStl				VARCHAR(19) = NULL
    , @AutoSettleOpen			VARCHAR(100) = NULL
    , @ExpLongVolume			VARCHAR(19) = NULL
    , @ExpShortVolume			VARCHAR(19) = NULL
    , @LongTransIn				VARCHAR(19) = NULL
    , @LongTransOut			VARCHAR(19) = NULL
    , @ShortTransIn			VARCHAR(19) = NULL
    , @ShortTransOut			VARCHAR(19) = NULL
    , @AssignedVol				VARCHAR(19) = NULL
    , @LotSize					VARCHAR(19) = NULL --DEFAULT 1
    , @RemClearer				VARCHAR(4) = NULL
    , @PositionType			VARCHAR(1) = NULL
    , @OptionAbandon			VARCHAR(100) = NULL
    , @Currency				VARCHAR(3) = NULL
    , @NetLiquidating			VARCHAR(24) = NULL
    , @CabinetTradeValue		VARCHAR(24) = NULL
    , @ReportTime				VARCHAR(19) = NULL -- YYYY-MM-DD HH:MM:SS   
    , @FileName				VARCHAR (512) = NULL
)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON

	INSERT INTO [dbo].[Liffe_Position]
           ([RowId]
           ,[System]
           ,[Version]
           ,[RecType]
           ,[Exchange]
           ,[ExchangeMnemonic]
           ,[MarginTime]
           ,[MarginRunSeqNo]
           ,[MarginType]
           ,[TradingDayTrade]
           ,[TradingDate]
           ,[TDD]
           ,[OrgClearer]
           ,[OrgMember]
           ,[OrgTrader]
           ,[Account]
           ,[PMA]
           ,[MarginAccount]
           ,[Commodity]
           ,[LogCommodity]
           ,[ContractType]
           ,[GenContractType]
           ,[ContractTypeAll]
           ,[MonthCode]
           ,[ExpiryMonth]
           ,[ExpiryDate]
           ,[LongExpiryDate]
           ,[Strike]
           ,[ValPrice]
           ,[LongPositionVol]
           ,[ShortPositionVol]
           ,[LongAdjustedVolume]
           ,[ShortAdjustedVolume]
           ,[LongNonMargVol]
           ,[ShortNonMargVol]
           ,[LongAdjustedNonMarginableVolume]
           ,[ShortAdjustedNonMarginableVolume]
           ,[ProfitLoss]
           ,[LongContractsTraded]
           ,[ShortContractsTraded]
           ,[LongTradedVol]
           ,[ShortTradedVol]
           ,[LongResultAssignment]
           ,[ShortResultAssignment]
           ,[LongResultExercise]
           ,[ShortResultExercise]
           ,[ContingentPrice]
           ,[ContingentMargin]
           ,[Premium]
           ,[ManExeVolume]
           ,[AutoExeVolume]
           ,[ManDelVolume]
           ,[AutoDelVolume]
           ,[ManualStl]
           ,[AutoSettleOpen]
           ,[ExpLongVolume]
           ,[ExpShortVolume]
           ,[LongTransIn]
           ,[LongTransOut]
           ,[ShortTransIn]
           ,[ShortTransOut]
           ,[AssignedVol]
           ,[LotSize]
           ,[RemClearer]
           ,[PositionType]
           ,[OptionAbandon]
           ,[Currency]
           ,[NetLiquidating]
           ,[CabinetTradeValue]
           ,[ReportTime]
           ,[FileName]
)
		   
	VALUES
	(
	@RowId					
    , @System				
    , @Version				
    , @RecType				
    , @Exchange				
    , @ExchangeMnemonic		
    , @MarginTime			
    , @MarginRunSeqNo		
    , @MarginType			
    , @TradingDayTrade		
    , @TradingDate			
    , @TDD					
    , @OrgClearer			
    , @OrgMember			
    , @OrgTrader			
    , @Account				
    , @PMA					
    , @MarginAccount		
    , @Commodity			
    , @LogCommodity			
    , @ContractType			
    , @GenContractType		
    , @ContractTypeAll		
    , @MonthCode			
    , @ExpiryMonth			
    , @ExpiryDate			
    , @LongExpiryDate		
    , @Strike				
    , @ValPrice				
    , @LongPositionVol		
    , @ShortPositionVol		
    , @LongAdjustedVolume	
    , @ShortAdjustedVolume	
    , @LongNonMargVol		
    , @ShortNonMargVol		
    , @LongAdjustedNonMarginableVolume	
    , @ShortAdjustedNonMarginableVolume	
    , @ProfitLoss				
    , @LongContractsTraded		
    , @ShortContractsTraded	
    , @LongTradedVol			
    , @ShortTradedVol			
    , @LongResultAssignment    
    , @ShortResultAssignment   
    , @LongResultExercise		
    , @ShortResultExercise		
    , @ContingentPrice			
    , @ContingentMargin		
    , @Premium					
    , @ManExeVolume			
    , @AutoExeVolume			
    , @ManDelVolume			
    , @AutoDelVolume			
    , @ManualStl				
    , @AutoSettleOpen			
    , @ExpLongVolume			
    , @ExpShortVolume			
    , @LongTransIn				
    , @LongTransOut			
    , @ShortTransIn			
    , @ShortTransOut			
    , @AssignedVol				
    , @LotSize					
    , @RemClearer				
    , @PositionType			
    , @OptionAbandon			
    , @Currency				
    , @NetLiquidating			
    , @CabinetTradeValue		
    , @ReportTime				
    , @FileName				
	)
	
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_RuleCondition_GetOperators]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_RuleCondition_GetOperators]
AS
SET NOCOUNT ON
	SELECT 
		OperatorId, Code, Description
	FROM
		ib_Operator
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_InstrumentType_GetCodeAndIdForAllInstrumentTypes]''
');

GO
EXECUTE ('  /*
<details>
 <summary>Returns code and id columns for all the instrument types</summary>
 <created author="Laurentiu Macovei" Date="Monday, 18 September 2006 08:30AM GMT" /> 
</details>
*/
create PROCEDURE [dbo].[ib_InstrumentType_GetCodeAndIdForAllInstrumentTypes]
AS
SET NOCOUNT ON
SELECT Code, InstrumentTypeId
	FROM ib_InstrumentType
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_ImbalanceReport_SelectBuiltReport]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_ImbalanceReport_SelectBuiltReport]
	@ImbalanceReportId INT = NULL,
	@OrderBy VARCHAR(300) = NULL,
	@MaximumRows INT = NULL,
	@StartRowIndex INT = NULL,
	@FilterExchangeId INT = NULL,
	@FilterDescription VARCHAR(100) = NULL,
	@FilterCurrencyId INT = NULL,
	@IncludeRowsInBalance BIT = 0,
	@OnlyImbalanceRowsFor INT = 0 -- 0 = Either Lots OR Variation don''t equal Zero. 1 = Only Lots not equal to zero. 2 = Only Variation not equal to zero.
AS
SET NOCOUNT ON
BEGIN 

/*
Author		Date			Description
Kevinp		23 Mar 2010		Added SP. Created by extracting the SELECT portion out of [ib_ImbalanceReport_BuildReport]
-- 21 May 2014  ED  EIB 25497 - Added notes

*/


--fix orderby
IF (ISNULL(@OrderBy, '''')='''')
	SET @OrderBy = ''Exchange, Description, Currency ASC'' 
--fix the top
IF ISNULL(@MaximumRows, 0) <= 0
	SET @MaximumRows = 0
IF ISNULL(@StartRowIndex, -1) <= -1 OR @MaximumRows = 0 
	SET @StartRowIndex = 0

DECLARE @SQL NVARCHAR(4000)
DECLARE @WHERE NVARCHAR(1000)

SET @WHERE = ''ImbalanceReportId = ''+CAST(@ImbalanceReportId as VARCHAR(10))
IF @FilterExchangeID IS NOT NULL
	SET @WHERE = @WHERE + '' AND ExchangeID = '' + CAST(@FilterExchangeId as VARCHAR(10))

IF @FilterCurrencyID IS NOT NULL
	SET @WHERE = @WHERE + '' AND CurrencyID = '' + CAST(@FilterCurrencyId as VARCHAR(10))

IF @FilterDescription IS NOT NULL
	SET @WHERE = @WHERE + '' AND Description = '''''' + REPLACE(@FilterDescription, '''''''', '''''''''''') + ''''''''

IF @IncludeRowsInBalance = 0
	BEGIN
		IF @OnlyImbalanceRowsFor = 0 
			SET @WHERE = @WHERE + '' AND (LOTS <> 0 OR Variation <> 0) ''
		IF @OnlyImbalanceRowsFor = 1 
			SET @WHERE = @WHERE + '' AND (LOTS <> 0) ''
		IF @OnlyImbalanceRowsFor = 2
			SET @WHERE = @WHERE + '' AND (Variation <> 0) ''
	END
	
IF @MaximumRows >0
	SET @sql = ''
SELECT [ExchangeId], [InstrumentId], [ExpiryYear],
	[ExpiryMonth], [ExpiryDay], [OptionTypeCode],
	[CurrencyId], [StrikePrice], 
	SUM([Internal_YAdjOTE]) AS [Internal_YAdjOTE],
	SUM([Internal_YOTE]) AS [Internal_YOTE], 
	SUM([Internal_PandS]) AS [Internal_PandS],
	SUM([Internal_TAdjOTE]) AS [Internal_TAdjOTE],
	SUM([Internal_TOTE]) AS [Internal_TOTE], 
	SUM([Internal_Position]) AS [Internal_Position], 
	SUM([External_YAdjOTE]) AS [External_YAdjOTE],
	SUM([External_YOTE]) AS [External_YOTE], 
	SUM([External_PandS]) AS [External_PandS], 
	SUM([External_TAdjOTE]) AS [External_TAdjOTE],
	SUM([External_TOTE]) AS [External_TOTE], 
	SUM([External_Position]) AS [External_Position],
	SUM([Lots]) AS [Lots], 
	SUM([Variation]) AS [Variation], 
	[Description], [Exchange], [Currency], [Instrument], ImbalanceReportSummaryId, Notes
FROM
	(SELECT TOP('' + CONVERT(NVARCHAR(10), @StartRowIndex + @MaximumRows) + '')''
ELSE SET @sql = ''SELECT''

--build the query
SET @sql = @sql + '' [ExchangeId], [InstrumentId], [ExpiryYear],
	[ExpiryMonth], [ExpiryDay], [OptionTypeCode],
	[CurrencyId], [StrikePrice], 
	SUM([Internal_YAdjOTE]) AS [Internal_YAdjOTE],
	SUM([Internal_YOTE]) AS [Internal_YOTE], 
	SUM([Internal_PandS]) AS [Internal_PandS],
	SUM([Internal_TAdjOTE]) AS [Internal_TAdjOTE],
	SUM([Internal_TOTE]) AS [Internal_TOTE], 
	SUM([Internal_Position]) AS [Internal_Position], 
	SUM([External_YAdjOTE]) AS [External_YAdjOTE],
	SUM([External_YOTE]) AS [External_YOTE], 
	SUM([External_PandS]) AS [External_PandS], 
	SUM([External_TAdjOTE]) AS [External_TAdjOTE],
	SUM([External_TOTE]) AS [External_TOTE], 
	SUM([External_Position]) AS [External_Position],
	SUM([Lots]) AS [Lots], 
	SUM([Variation]) AS [Variation], 
	[Description], [Exchange], [Currency], [Instrument], ImbalanceReportSummaryId, Notes
''

IF @MaximumRows >0
	SET @sql = @sql+'', ROW_NUMBER() OVER(ORDER BY '' + @OrderBy + '') as RowNum''

SET @sql = @sql + ''
 FROM [dbo].[ib_ImbalanceReportSummary] irs
 WHERE '' + @WHERE


SET @sql = @sql + ''
 GROUP BY [ExchangeId], [InstrumentId], [ExpiryYear], [ExpiryMonth], [ExpiryDay], [OptionTypeCode], [CurrencyId], [StrikePrice], [Description], [Exchange], [Currency], [Instrument], ImbalanceReportSummaryId, Notes
 ''


IF @MaximumRows = 0
	SET @sql = @sql+''
 ORDER BY '' + @OrderBy 

IF @MaximumRows >0
	SET @sql = @sql +  '') x
WHERE RowNum > '' + CONVERT(NVARCHAR(10), @StartRowIndex) + '' ORDER BY RowNum''

EXEC sp_executesql @sql

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_ImbalanceReport_MarkVisited]''
');

GO
EXECUTE ('/*
<details>
	<summary> 
		Moves the data from #visitingReportDetails to #visitedItems and deletes all the record from #visitingReportDetails
	</summary>
	<created author="Laurentiu Macovei" Date="Monday, 14 August 2006 16:25 GMT" />
</details>
*/

CREATE PROCEDURE [dbo].[ib_ImbalanceReport_MarkVisited]
AS
SET NOCOUNT ON
--mark visited rows
INSERT INTO #visitedItems([ImbalanceReportDetailId])--, [Description])
	SELECT [ImbalanceReportDetailId]--, [Description] 
		FROM #visitingReportDetails
--clean visiting rows
DELETE FROM #visitingReportDetails
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_ImbalanceReport_GroupByRule]''
');

GO
EXECUTE ('


/*
<details>
	<summary> Filling the #results for a generic Rule </summary>
	<created author="Laurentiu Macovei(softer)" Date="Tuesday, 22 august 2006" />		
	<updated author="Anil Kripalani" Date="1 Dec 2006">
		Store info in a trace table for debugging
	</updated>
</details>
*/

CREATE PROCEDURE [dbo].[ib_ImbalanceReport_GroupByRule]
	@RuleType	VARCHAR(50) = ''Unknown''
AS
SET NOCOUNT ON

	INSERT INTO #results([ExpiryMonth], [ExpiryYear], [ExpiryDay], 
			[OptionTypeCode], [StrikePrice] , [CurrencyId],
			[ExchangeId], [InstrumentId], [Description],
			Internal_YAdjOTE, Internal_YOTE, Internal_PandS,
			Internal_TAdjOTE, Internal_TOTE, Internal_Position, 
			External_YAdjOTE, External_YOTE, External_PandS, 
			External_TAdjOTE, External_TOTE, External_Position)
		SELECT	[ird].[ExpiryMonth], [ird].[ExpiryYear], [ird].[ExpiryDay], 
				[ird].[OptionTypeCode], [ird].[StrikePrice], [ird].[CurrencyId],
				[ird].[ExchangeId], [ird].[InstrumentId], 
				[vrd].[Description],
				SUM([ird].[Internal_YAdjOTE])  Internal_YAdjOTE, SUM([ird].[Internal_YOTE])  Internal_YOTE, SUM([ird].[Internal_PandS])  Internal_PandS,
				SUM([ird].[Internal_TAdjOTE])  Internal_TAdjOTE, SUM([ird].[Internal_TOTE])  Internal_TOTE, SUM([ird].[Internal_Position])  Internal_Position, 
				SUM([ird].[External_YAdjOTE])  External_YAdjOTE, SUM([ird].[External_YOTE])  External_YOTE, SUM([ird].[External_PandS])  External_PandS, 
				SUM([ird].[External_TAdjOTE])  External_TAdjOTE, SUM([ird].[External_TOTE])  External_TOTE, SUM([ird].[External_Position])  External_Position
			FROM [dbo].[ib_ImbalanceReportDetail] ird
				INNER JOIN #visitingReportDetails vrd ON [ird].[ImbalanceReportDetailId] = [vrd].[ImbalanceReportDetailId]		
			GROUP BY [ird].[ExpiryMonth], [ird].[ExpiryYear], [ird].[ExpiryDay], [ird].[ClassId],
				 [ird].[OptionTypeCode], [ird].[StrikePrice], [ird].[CurrencyId],
				 [ird].[ExchangeId], [ird].[InstrumentId],
				 [vrd].[Description]

	INSERT INTO ib_ImbalanceReportPhase2Trace(RuleType, [ImbalanceReportDetailId], [Description])
		SELECT @RuleType, [ImbalanceReportDetailId], [Description] 
			FROM #visitingReportDetails

	--mark&move visited rows
	EXEC ib_ImbalanceReport_MarkVisited
');

GO
EXECUTE ('PRINT N''Creating [dbo].[GetMatchCodeByAccountExchangeFirmTemplate]''
');

GO
EXECUTE ('CREATE FUNCTION [dbo].[GetMatchCodeByAccountExchangeFirmTemplate]
(
	@AccountId INT,
	@ExchangeId INT,
	@FirmId INT,
	@TemplateId INT
)
RETURNS INT
AS
--	Description: GetMatchCodeByAccountExchangeFirmTemplate
--	25 Jun 2014		ED		EIB 25768 - Created
BEGIN
	DECLARE @MatchCode VARCHAR(100), @MatchCodeId INT, @AccountCode VARCHAR(100)
	
	SET @AccountCode = (SELECT Code FROM ib_Account WHERE AccountId = @AccountId)
	SET @AccountId = (SELECT AccountId FROM ib_Account WHERE Code = @AccountCode AND FirmId = @FirmId)
	
	SET @MatchCodeId= (SELECT TOP 1 MatchCodeId FROM ib_MatchCode mc INNER JOIN ib_TemplateGroup tg ON tg.TemplateId = mc.TemplateId AND tg.Description = mc.MatchCode
				 WHERE tg.TemplateId = @TemplateId 
				 AND ExchangeId = @ExchangeId AND FirmId = @FirmId AND AccountId = @AccountId)
	RETURN @MatchCodeId
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_ImbalanceReport_AddPositionsRealisedCashData]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_ImbalanceReport_AddPositionsRealisedCashData]
	@ReportId int,
	@ImbalanceReportId int
AS
BEGIN
--	Description: Add Positions Realised Cash Data to imbalance report
--	21 Jul 2014		ED		EIB 25791 - Created
--	09 Sep 2014		ED		EIB 25981 - add logic for F records
--	12 Sep 2014		ED		EIB 25981 - redesign the entire logic
	SET NOCOUNT ON
	DECLARE @FutureProducts TABLE(Product VARCHAR(5))
	INSERT INTO @FutureProducts(Product) VALUES(''SR''), (''SC''), (''AU''), (''AG'')
	INSERT INTO @FutureProducts(Product)
	SELECT Product FROM PositionsRealisedCash WHERE DatasourceId = (SELECT DatasourceId FROM ib_DataSource WHERE Code = ''BMF'')

	DECLARE @AsOfDate DATE, @TemplateId INT
	SELECT @AsOfDate = Today, @TemplateId = TemplateId FROM ib_ImbalanceReport WHERE ImbalanceReportId = @ImbalanceReportId
	
	DECLARE @PositionRealisedCash TABLE(
	InstrumentTypeCode CHAR(1)
	 ,AccountId INT
	 ,CurrencyId INT
	 ,PromptDate DATE
	 ,IsCall BIT
	 ,TransactionValue MONEY
	 ,DataSourceId INT
	 ,ExchangeId INT 
	 ,FirmId INT
	 ,InstrumentId INT
	 ,Strike MONEY
	 ,MatchCodeId INT
	 ,Product VARCHAR(5))

	 INSERT INTO @PositionRealisedCash(InstrumentTypeCode, AccountId, CurrencyId, PromptDate, IsCall, TransactionValue, DataSourceId, ExchangeId, FirmId, InstrumentId, Strike, Product)
		SELECT 
			InstrumentTypeCode
			  ,AccountId
			  ,CurrencyId
			  ,PromptDate
			  ,IsCall
			  ,SUM(TransactionValue)
			  ,prc.DataSourceId
			  ,ExchangeId
			  ,FirmId
			  ,InstrumentId
			  ,Strike
			  ,Product
		FROM PositionsRealisedCash prc
			INNER JOIN ib_DataSource ds ON ds.DataSourceId = prc.DataSourceId AND ds.DoPositionsRealiseCash = 1
		WHERE prc.AsOfDate = @AsOfDate
	GROUP BY InstrumentTypeCode,AccountId,CurrencyId,PromptDate,IsCall,prc.DataSourceId,ExchangeId,FirmId,InstrumentId,Strike, InstrumentCode, Product
	UPDATE @PositionRealisedCash SET MatchCodeId = dbo.GetMatchCodeByAccountExchangeFirmTemplate(AccountId, ExchangeId, FirmId, @TemplateId)
		WHERE MatchCodeId IS NULL
	
	DECLARE @PandSImbalanceSummary TABLE(ImbalanceReportSummaryId INT, External_PandS MONEY)
	
	INSERT INTO @PandSImbalanceSummary(ImbalanceReportSummaryId, External_PandS)
	SELECT ImbalanceReportSummaryId, prc.TransactionValue
		FROM ib_ImbalanceReportSummary irs
		INNER JOIN @PositionRealisedCash prc 
			ON 
				(
				     (InstrumentTypeCode = ''P'' AND (OptionTypeCode = ''C'' AND prc.IsCall = 1) OR (OptionTypeCode = ''P'' AND prc.IsCall = 0))
				  OR (InstrumentTypeCode = ''F'' AND ISNULL(OptionTypeCode,'''') = '''' 
				  AND NOT EXISTS(SELECT 1 FROM @FutureProducts fp WHERE prc.Product = fp.Product)
				  )
				)
				AND irs.ExpiryYear = YEAR(prc.PromptDate) 
				AND irs.ExpiryMonth = MONTH(prc.PromptDate) 
				AND irs.ExpiryDay = DAY(prc.PromptDate) 
				AND irs.ExchangeId = prc.ExchangeId 
				AND irs.CurrencyId = prc.CurrencyId
				AND ISNULL(irs.StrikePrice, 0) = ISNULL(prc.Strike, 0)
				AND irs.InstrumentId = prc.InstrumentId
		INNER JOIN  ib_MatchCode mc ON mc.MatchCodeId = prc.MatchCodeId AND mc.MatchCode = irs.Description
	WHERE irs.ImbalanceReportId = @ImbalanceReportId AND ISNULL(External_PandS, 0) = 0
			
	UPDATE irs
		SET irs.External_PandS = tirs.External_PandS
	FROM ib_ImbalanceReportSummary irs	
		INNER JOIN @PandSImbalanceSummary tirs ON tirs.ImbalanceReportSummaryId = irs.ImbalanceReportSummaryId
	
	DECLARE @PandSImbalanceDetail TABLE(ImbalanceReportDetailId INT, External_PandS MONEY)
	
	INSERT INTO @PandSImbalanceDetail(ImbalanceReportDetailId, External_PandS)
	SELECT 
		(SELECT TOP 1 ird.ImbalanceReportDetailId FROM [dbo].[ib_ImbalanceReportSummary] irs
			INNER JOIN ib_ImbalanceReportDetail ird ON ird.ImbalanceReportId=irs.ImbalanceReportId
				AND ird.[ExchangeId]=irs.[ExchangeId]
				AND ird.[InstrumentId]=irs.[InstrumentId]
				AND ird.[CurrencyId]=irs.[CurrencyId]
				AND ird.[ExpiryMonth]=irs.[ExpiryMonth]
				AND ird.[ExpiryYear]=irs.[ExpiryYear]
				AND ird.[ExpiryDay]=irs.[ExpiryDay]
				AND ISNULL(ird.[OptionTypeCode],'''')=ISNULL(irs.[OptionTypeCode],'''')
				AND ISNULL(ird.[StrikePrice],0)=ISNULL(irs.[StrikePrice],0)
				INNER JOIN ib_ImbalanceReportPhase2Trace IRP2T ON irs.Description=irp2t.Description 
				AND ird.ImbalanceReportDetailId=irp2t.ImbalanceReportDetailId
					and irs.ImbalanceReportSummaryId=tirs.ImbalanceReportSummaryId
					AND ISNULL(ird.External_PandS, 0) = 0
					) AS ImbalanceReportDetailId
		, External_PandS 
		FROM @PandSImbalanceSummary tirs

	UPDATE ird
		SET ird.External_PandS = tird.External_PandS
	FROM ib_ImbalanceReportDetail ird
		INNER JOIN @PandSImbalanceDetail tird ON tird.ImbalanceReportDetailId = ird.ImbalanceReportDetailId


DECLARE @TOTEImbalanceSummary TABLE(ImbalanceReportSummaryId INT, External_TOTE MONEY)
	
	INSERT INTO @TOTEImbalanceSummary(ImbalanceReportSummaryId, External_TOTE)
	SELECT ImbalanceReportSummaryId, prc.TransactionValue
		FROM ib_ImbalanceReportSummary irs
		INNER JOIN @PositionRealisedCash prc 
			ON EXISTS(SELECT 1 FROM @FutureProducts fp WHERE prc.Product = fp.Product)
				AND irs.ExpiryYear = YEAR(prc.PromptDate) 
				AND irs.ExpiryMonth = MONTH(prc.PromptDate) 
				AND irs.ExpiryDay = DAY(prc.PromptDate) 
				AND irs.ExchangeId = prc.ExchangeId 
				AND irs.CurrencyId = prc.CurrencyId
				AND ISNULL(irs.StrikePrice, 0) = ISNULL(prc.Strike, 0)
				AND irs.InstrumentId = prc.InstrumentId
		INNER JOIN  ib_MatchCode mc ON mc.MatchCodeId = prc.MatchCodeId AND mc.MatchCode = irs.Description
	WHERE irs.ImbalanceReportId = @ImbalanceReportId AND ISNULL(External_TOTE, 0) = 0
			
	UPDATE irs
		SET irs.External_TOTE = tirs.External_TOTE
	FROM ib_ImbalanceReportSummary irs	
		INNER JOIN @TOTEImbalanceSummary tirs ON tirs.ImbalanceReportSummaryId = irs.ImbalanceReportSummaryId
	
	DECLARE @TOTEImbalanceDetail TABLE(ImbalanceReportDetailId INT, External_TOTE MONEY)
	
	INSERT INTO @TOTEImbalanceDetail(ImbalanceReportDetailId, External_TOTE)
	SELECT 
		(SELECT TOP 1 ird.ImbalanceReportDetailId FROM [dbo].[ib_ImbalanceReportSummary] irs
			INNER JOIN ib_ImbalanceReportDetail ird ON ird.ImbalanceReportId=irs.ImbalanceReportId
				AND ird.[ExchangeId]=irs.[ExchangeId]
				AND ird.[InstrumentId]=irs.[InstrumentId]
				AND ird.[CurrencyId]=irs.[CurrencyId]
				AND ird.[ExpiryMonth]=irs.[ExpiryMonth]
				AND ird.[ExpiryYear]=irs.[ExpiryYear]
				AND ird.[ExpiryDay]=irs.[ExpiryDay]
				AND ISNULL(ird.[OptionTypeCode],'''')=ISNULL(irs.[OptionTypeCode],'''')
				AND ISNULL(ird.[StrikePrice],0)=ISNULL(irs.[StrikePrice],0)
				INNER JOIN ib_ImbalanceReportPhase2Trace IRP2T ON irs.Description=irp2t.Description 
				AND ird.ImbalanceReportDetailId=irp2t.ImbalanceReportDetailId
					and irs.ImbalanceReportSummaryId=tirs.ImbalanceReportSummaryId
					AND ISNULL(ird.External_PandS, 0) = 0
					) AS ImbalanceReportDetailId
		, External_TOTE 
		FROM @TOTEImbalanceSummary tirs

	UPDATE ird
		SET ird.External_TOTE = tird.External_TOTE
	FROM ib_ImbalanceReportDetail ird
		INNER JOIN @TOTEImbalanceDetail tird ON tird.ImbalanceReportDetailId = ird.ImbalanceReportDetailId

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_ImbalanceReport_BuildReportPhase2]''
');

GO
EXECUTE ('/*
<details>
	<summary> We have data populated in the ib_ImbalanceReportDetail table from [ib_ImbalanceReport_BuildReportPhase1],
	 we need to take that and group it (I.e., Consolidate it) suitable for output on a report. /summary>
	<created author="Laurentiu Macovei" Date="Tuesday, 26 July 2006" />	
	<updated author="Laurentiu Macovei" Date="Friday, 4 August 2006">
		Added Exchange(name), currency(code) and instrument(code) to the output
	</updated>
	<updated author="Laurentiu Macovei" Date="Monday, 7 August 2006 1:10 PM GMT">
		Added @ReportId parameter to update more detailed progress details
	</updated>
	<updated author="Laurentiu Macovei" Date="Friday, 11 August 2006">
		Temporary table''s decimal columns length was changed to 19,4
		Unknown items are collapsed excluding AccountId and FirmId
	</updated>
	<updated author="Laurentiu Macovei" Date="Monday, 15 August 2006, 2:00am GMT">
		Rewritten using ibReportDetailId visiting system
	</updated>
	<updated author="Laurentiu Macovei" Date="Tuesday, 15 August 2006, 11:27am GMT" taskId="IBAL-2077">
		Removed accountID and FirmID form the output & Gropuping.
		Added a one more final grouping - by description.
	</updated>
	<updated author="Laurentiu Macovei(softer)" Date="Tuesday, 22 August 2006, 18:47pm GMT" taskId="IBAL-2109">
		Added a new stored procedure to shrink the code ([ib_ImbalanceReport_GroupByRule]), that will be called for each
		rule twice, one time for ClassId NOT NULL and second for ClassId NULL	
	</updated>
	<updated author="Anil Kripalani" Date="1 Dec 2006">
		1) BUG FIX: Populate ClassId in #tg temp table
		2) Collapse 0/null''s/emtry strings in OptionTypeCode and StrikePrice
	</updated>
	<updated author="Anil Kripalani" Date="6 Dec 2006">
		Per Martin, DO NOT DO the Unknown group
	</updated>
	<updated author="Anil Kripalani" Date="8 Dec 2006">
		Move adjustment gathering to here (from phase 1)
	</updated>
	<updated author="Anil Kripalani" Date="1 Oct 2009">
		Re-enable the ''unknown'' bucket at end (MBAL-12855)
	</updated>
	<updated author="Anil Kripalani" Date="6 Aug 2010">
		Externalize calculate imbalance logic so it can be re-used
	</updated>
</details>
-- 21 May 2014  ED  EIB 25497 - added Notes
-- 12 Sep 2014	ED	EIB 25981 - call the AddPositionRealisedCash just before the end
-- 18 Dec 2014	ED	EIB 26327 - improve report performance
*/

CREATE PROCEDURE [dbo].[ib_ImbalanceReport_BuildReportPhase2]
@ReportId int,
@ImbalanceReportId int
AS
SET NOCOUNT ON

	--update the report status
	UPDATE [dbo].[ib_Report]
		SET [Stage] = ''Phase 2: Preparing temporary tables''
		WHERE ReportId = @ReportId


--Create the TemplateGroup #tg Temporary table with only needed records
CREATE TABLE #tg
(	
	[ExchangeId] int, 
	[FirmId] int, 
	[AccountId] int, 
	[InstrumentID] int, 
	[ClassId] int,
	[Description] varchar(100),
	TemplateGroupId int
)
--Create the table for storing visited items
CREATE TABLE #visitedItems
(	
	[ImbalanceReportDetailId] int
)
CREATE UNIQUE NONCLUSTERED INDEX [AK_visitedItems] ON #visitedItems ([ImbalanceReportDetailId]) WITH (PAD_INDEX  = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, IGNORE_DUP_KEY = OFF, ONLINE = OFF) ON [PRIMARY]
--Create the table for storing visiting items
CREATE TABLE #visitingReportDetails
(	
	[ImbalanceReportDetailId] int NOT NULL,
	[Description] varchar(100) NOT NULL
)

----Indexing the #tg table
--CREATE UNIQUE NONCLUSTERED INDEX [AK_TG] ON #TG 
--(
--	[ExchangeId] ASC, 
--	[FirmId] ASC, 
--	[AccountId] ASC, 
--	[InstrumentID] ASC,
--	[ClassId] ASC,
--	[Description] ASC
--)WITH (PAD_INDEX  = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, IGNORE_DUP_KEY = OFF, ONLINE = OFF) ON [PRIMARY]


--Create a temporary table to store & compare results
CREATE TABLE #results 
(
	[ExpiryYear] [smallint] NOT NULL,
	[ExpiryMonth] [smallint] NOT NULL,
	[ExpiryDay] [smallint] NULL,
	[OptionTypeCode] [varchar](25) COLLATE Latin1_General_CI_AS NULL,
	[StrikePrice] [decimal](19, 4) NULL,
	[CurrencyId] [int] NOT NULL,
	[ExchangeId] [int] NOT NULL,
	[InstrumentId] [int] NOT NULL,
	[Description] varchar(100),
	[Internal_YAdjOTE] [decimal](19, 4) NOT NULL,
	[Internal_YOTE] [decimal](19, 4) NOT NULL,
	[Internal_PandS] [decimal](19, 4) NOT NULL,
	[Internal_TAdjOTE] [decimal](19, 4) NOT NULL,
	[Internal_TOTE] [decimal](19, 4) NOT NULL,
	[Internal_Position] [decimal](19, 4) NOT NULL,
	[External_YAdjOTE] [decimal](19, 4) NOT NULL,
	[External_YOTE] [decimal](19, 4) NOT NULL,
	[External_PandS] [decimal](19, 4) NOT NULL,
	[External_TAdjOTE] [decimal](19, 4) NOT NULL,
	[External_TOTE] [decimal](19, 4) NOT NULL,
	[External_Position] [decimal](19, 4) NOT NULL,
	[Exchange] varchar(50) NULL,
	[Currency] varchar(100) NULL,
	[Instrument] varchar(100) NULL
)



----Indexing the #results table for fast searching when excluding
--CREATE NONCLUSTERED INDEX [AK_RESULTS] ON #results 
--(
--	[ExchangeId] ASC, 
--	[InstrumentID] ASC
--) WITH (PAD_INDEX  = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, IGNORE_DUP_KEY = OFF, ONLINE = OFF) ON [PRIMARY]
--
--update the report status
UPDATE [dbo].[ib_Report]
	SET [Stage] = ''Phase 2: Gathering Template Groups''
	WHERE ReportId = @ReportId


--INSERT Template Group elements for the specified TemplateID of the provided ImbalanceReportId
INSERT INTO #tg(ExchangeId, FirmId, AccountId, InstrumentID, Description, TemplateGroupId, ClassId)
	SELECT tg.ExchangeId, tg.FirmId, tg.AccountId, tg.InstrumentID, tg.Description, tg.TemplateGroupId, tg.ClassId
		FROM ib_TemplateGroup tg
		INNER JOIN ib_ImbalanceReport ir ON ir.ImbalanceReportId = @ImbalanceReportId AND tg.TemplateId = ir.TemplateId

--update the report status
UPDATE [dbo].[ib_Report]
	SET [Stage] = ''Phase 2: Gathering records matching rule 1 of 5''
	WHERE ReportId = @ReportId


--MARTIN''s MATRIX RULE #1 (Firm Exchange Account Instrument)
--INSERT records that mach Martin''s rule #1 (Firm Exchange Account Instrument)
	INSERT INTO #visitingReportDetails([ImbalanceReportDetailId], [Description])
		SELECT	[ird].[ImbalanceReportDetailId], [tg].[Description]
			FROM [dbo].[ib_ImbalanceReportDetail] ird 
					INNER JOIN [ib_ImbalanceReport] ir ON 
						ir.ImbalanceReportId = @ImbalanceReportId 
					AND ir.ImbalanceReportId = ird.ImbalanceReportId
					INNER JOIN #tg tg ON
						[tg].[ClassId] = [ird].[ClassId] --IBAL-2109
					AND	[tg].[FirmId] = [ird].[FirmId]
					AND [tg].[ExchangeId] = [ird].[ExchangeId]
					AND [tg].[AccountId] = [ird].[AccountId]
					AND [tg].[InstrumentId] = [ird].[InstrumentId]
			WHERE NOT EXISTS (SELECT 1 FROM #visitedItems v WHERE v.ImbalanceReportDetailId=[ird].[ImbalanceReportDetailId]) --exclude previous items

	EXEC ib_ImbalanceReport_GroupByRule ''1a''

	INSERT INTO #visitingReportDetails([ImbalanceReportDetailId], [Description])
			SELECT	[ird].[ImbalanceReportDetailId], [tg].[Description]
				FROM [dbo].[ib_ImbalanceReportDetail] ird 
						INNER JOIN [ib_ImbalanceReport] ir ON 
							ir.ImbalanceReportId = @ImbalanceReportId 
						AND ir.ImbalanceReportId = ird.ImbalanceReportId
						INNER JOIN #tg tg ON
							[tg].[ClassId] IS NULL --IBAL-2109
						AND	[tg].[FirmId] = [ird].[FirmId]
						AND [tg].[ExchangeId] = [ird].[ExchangeId] 
						AND [tg].[AccountId] = [ird].[AccountId]
						AND [tg].[InstrumentId] = [ird].[InstrumentId]
			WHERE NOT EXISTS (SELECT 1 FROM #visitedItems v WHERE v.ImbalanceReportDetailId=[ird].[ImbalanceReportDetailId]) --exclude previous items

	EXEC [dbo].[ib_ImbalanceReport_GroupByRule] ''1b''

--update the report status
UPDATE [dbo].[ib_Report]
	SET [Stage] = ''Phase 2: Gathering records matching rule 2 of 5''
	WHERE ReportId = @ReportId

--MARTIN''s MATRIX RULE #2 (Firm Exchange Account)
--Select records that mach Martin''s rule #2 (Firm Exchange Account), BUT excluding duplicates from already existing record (rule #1)
--These will be appended to the previous records (rule #1)
	INSERT INTO #visitingReportDetails([ImbalanceReportDetailId], [Description])
		SELECT	[ird].[ImbalanceReportDetailId], [tg].[Description]
			FROM [dbo].[ib_ImbalanceReportDetail] ird
					INNER JOIN [ib_ImbalanceReport] ir ON
						ir.ImbalanceReportId = @ImbalanceReportId
					AND ir.ImbalanceReportId = ird.ImbalanceReportId
					INNER JOIN #tg tg ON
						[tg].[ClassId] = [ird].[ClassId] --IBAL-2109
					AND	[tg].[FirmId] = [ird].[FirmId]
					AND [tg].[ExchangeId] = [ird].[ExchangeId]
					AND [tg].[AccountId] = [ird].[AccountId]
					AND [tg].[InstrumentId] IS NULL
			WHERE NOT EXISTS (SELECT 1 FROM #visitedItems v WHERE v.ImbalanceReportDetailId=[ird].[ImbalanceReportDetailId]) --exclude previous items

	EXEC [dbo].[ib_ImbalanceReport_GroupByRule] ''2a''

	INSERT INTO #visitingReportDetails([ImbalanceReportDetailId], [Description])
			SELECT	[ird].[ImbalanceReportDetailId], [tg].[Description]
				FROM [dbo].[ib_ImbalanceReportDetail] ird 
						INNER JOIN [ib_ImbalanceReport] ir ON 
							ir.ImbalanceReportId = @ImbalanceReportId 
						AND ir.ImbalanceReportId = ird.ImbalanceReportId
						INNER JOIN #tg tg ON
							[tg].[ClassId] IS NULL --IBAL-2109
						AND	[tg].[FirmId] = [ird].[FirmId]
						AND [tg].[ExchangeId] = [ird].[ExchangeId]
						AND [tg].[AccountId] = [ird].[AccountId]
						AND [tg].[InstrumentId] IS NULL
			WHERE NOT EXISTS (SELECT 1 FROM #visitedItems v WHERE v.ImbalanceReportDetailId=[ird].[ImbalanceReportDetailId]) --exclude previous items

	EXEC [dbo].[ib_ImbalanceReport_GroupByRule] ''2b''

--update the report status
UPDATE [dbo].[ib_Report]
	SET [Stage] = ''Phase 2: Gathering records matching rule 3 of 5''
	WHERE ReportId = @ReportId

--MARTIN''s MATRIX RULE #3 (Firm Account)
--Select records that mach Martin''s rule #3 (Firm Account), BUT excluding duplicates from already existing record (rule #1 and rule #2)
--These will be appended to the previous records ((rule #1 UNION rule #2)''s records)
	INSERT INTO #visitingReportDetails([ImbalanceReportDetailId], [Description])
		SELECT	[ird].[ImbalanceReportDetailId], [tg].[Description]
			FROM [dbo].[ib_ImbalanceReportDetail] ird
					INNER JOIN [ib_ImbalanceReport] ir ON
						ir.ImbalanceReportId = @ImbalanceReportId
					AND ir.ImbalanceReportId = ird.ImbalanceReportId
					INNER JOIN #tg tg ON
						[tg].[ClassId] = [ird].[ClassId] --IBAL-2109
					AND	[tg].[FirmId] = [ird].[FirmId]
					AND [tg].[ExchangeId] IS NULL
					AND [tg].[AccountId] = [ird].[AccountId]
					AND [tg].[InstrumentId] IS NULL
			WHERE NOT EXISTS (SELECT 1 FROM #visitedItems v WHERE v.ImbalanceReportDetailId=[ird].[ImbalanceReportDetailId]) --exclude previous items

	EXEC [dbo].[ib_ImbalanceReport_GroupByRule] ''3a''

	INSERT INTO #visitingReportDetails([ImbalanceReportDetailId], [Description])
			SELECT	[ird].[ImbalanceReportDetailId], [tg].[Description]
				FROM [dbo].[ib_ImbalanceReportDetail] ird 
						INNER JOIN [ib_ImbalanceReport] ir ON 
							ir.ImbalanceReportId = @ImbalanceReportId 
						AND ir.ImbalanceReportId = ird.ImbalanceReportId
						INNER JOIN #tg tg ON
							[tg].[ClassId] IS NULL --IBAL-2109
						AND	[tg].[FirmId] = [ird].[FirmId]
						AND [tg].[ExchangeId] IS NULL
						AND [tg].[AccountId] = [ird].[AccountId]
						AND [tg].[InstrumentId] IS NULL
			WHERE NOT EXISTS (SELECT 1 FROM #visitedItems v WHERE v.ImbalanceReportDetailId=[ird].[ImbalanceReportDetailId]) --exclude previous items

	EXEC [dbo].[ib_ImbalanceReport_GroupByRule] ''3b''



--update the report status
UPDATE [dbo].[ib_Report]
	SET [Stage] = ''Phase 2: Gathering records matching rule 4 of 5''
	WHERE ReportId = @ReportId


--MARTIN''s MATRIX RULE #4 (Firm Exchange)
--Select records that mach Martin''s rule #4 (Firm Exchange), BUT excluding duplicates from already existing record (rule #1, rule #2 and rule #3)
--These will be appended to the previous records ((rule #1 UNION #2 UNION r3)''s records)
	INSERT INTO #visitingReportDetails([ImbalanceReportDetailId], [Description])
		SELECT	[ird].[ImbalanceReportDetailId], [tg].[Description]
			FROM [dbo].[ib_ImbalanceReportDetail] ird
					INNER JOIN [ib_ImbalanceReport] ir ON
						ir.ImbalanceReportId = @ImbalanceReportId
					AND ir.ImbalanceReportId = ird.ImbalanceReportId
					INNER JOIN #tg tg ON
						[tg].[ClassId] = [ird].[ClassId] --IBAL-2109
					AND	[tg].[FirmId] = [ird].[FirmId]
					AND [tg].[ExchangeId] = [ird].[ExchangeId]
					AND [tg].[AccountId] IS NULL
					AND [tg].[InstrumentId] IS NULL
			WHERE NOT EXISTS (SELECT 1 FROM #visitedItems v WHERE v.ImbalanceReportDetailId=[ird].[ImbalanceReportDetailId]) --exclude previous items

	EXEC [dbo].[ib_ImbalanceReport_GroupByRule] ''4a''

	INSERT INTO #visitingReportDetails([ImbalanceReportDetailId], [Description])
			SELECT	[ird].[ImbalanceReportDetailId], [tg].[Description]
				FROM [dbo].[ib_ImbalanceReportDetail] ird 
						INNER JOIN [ib_ImbalanceReport] ir ON 
							ir.ImbalanceReportId = @ImbalanceReportId 
						AND ir.ImbalanceReportId = ird.ImbalanceReportId
						INNER JOIN #tg tg ON
							[tg].[ClassId] IS NULL --IBAL-2109
						AND	[tg].[FirmId] = [ird].[FirmId]
						AND [tg].[ExchangeId] = [ird].[ExchangeId]
						AND [tg].[AccountId] IS NULL
						AND [tg].[InstrumentId] IS NULL
			WHERE NOT EXISTS (SELECT 1 FROM #visitedItems v WHERE v.ImbalanceReportDetailId=[ird].[ImbalanceReportDetailId]) --exclude previous items

	EXEC [dbo].[ib_ImbalanceReport_GroupByRule] ''4b''

--update the report status
UPDATE [dbo].[ib_Report]
	SET [Stage] = ''Phase 2: Gathering records matching rule 5 of 5''
	WHERE ReportId = @ReportId


--MARTIN''s MATRIX RULE #5 (Firm)
--Select records that mach Martin''s rule #5 (Firm), BUT excluding duplicates from already existing record (rule #1, rule #2 and rule #3 and rule #4)
--These will be appended to the previous records ((rule #1 UNION #2 UNION r3 UNION r4)''s records)
	INSERT INTO #visitingReportDetails([ImbalanceReportDetailId], [Description])
		SELECT	[ird].[ImbalanceReportDetailId], [tg].[Description]
			FROM [dbo].[ib_ImbalanceReportDetail] ird
					INNER JOIN [ib_ImbalanceReport] ir ON
						ir.ImbalanceReportId = @ImbalanceReportId
					AND ir.ImbalanceReportId = ird.ImbalanceReportId
					INNER JOIN #tg tg ON
						[tg].[ClassId] = [ird].[ClassId] --IBAL-2109
					AND	[tg].[FirmId] = [ird].[FirmId]
					AND [tg].[ExchangeId] IS NULL
					AND [tg].[AccountId] IS NULL
					AND [tg].[InstrumentId] IS NULL
			WHERE NOT EXISTS (SELECT 1 FROM #visitedItems v WHERE v.ImbalanceReportDetailId=[ird].[ImbalanceReportDetailId]) --exclude previous items

	EXEC [dbo].[ib_ImbalanceReport_GroupByRule] ''5a''

	INSERT INTO #visitingReportDetails([ImbalanceReportDetailId], [Description])
			SELECT	[ird].[ImbalanceReportDetailId], [tg].[Description]
				FROM [dbo].[ib_ImbalanceReportDetail] ird 
						INNER JOIN [ib_ImbalanceReport] ir ON 
							ir.ImbalanceReportId = @ImbalanceReportId 
						AND ir.ImbalanceReportId = ird.ImbalanceReportId
						INNER JOIN #tg tg ON
							[tg].[FirmId] = [ird].[FirmId]
				WHERE NOT EXISTS (SELECT 1 FROM #visitedItems v WHERE v.ImbalanceReportDetailId=[ird].[ImbalanceReportDetailId]) --exclude previous items
					AND [tg].[ClassId] IS NULL --IBAL-2109
					AND [tg].[ExchangeId] IS NULL
					AND [tg].[AccountId] IS NULL
					AND [tg].[InstrumentId] IS NULL

	EXEC [dbo].[ib_ImbalanceReport_GroupByRule] ''5b''

--update the report status
UPDATE [dbo].[ib_Report]
	SET [Stage] = ''Phase 2: Gathering the remaining ungrouped through a template items''
	WHERE ReportId = @ReportId

--APPEND those rows wich doesn''t map to any of the MARTIN''s MATRIX RULES, BUT excluding duplicates from already existing record (all Martin''s matrix rules)
--These will be appended to the previous records (all of the MARTIN''s MATRIX RULES)


	INSERT INTO #visitingReportDetails([ImbalanceReportDetailId], [Description])
		SELECT	[ird].[ImbalanceReportDetailId], ''Unknown''
			FROM [dbo].[ib_ImbalanceReportDetail] ird 
				INNER JOIN [ib_ImbalanceReport] ir ON 
					ir.ImbalanceReportId = @ImbalanceReportId 
				AND ir.ImbalanceReportId = ird.ImbalanceReportId
				AND [ird].[ClassId] IS NOT NULL --IBAL-2109
			WHERE NOT EXISTS (SELECT 1 FROM #visitedItems v WHERE v.ImbalanceReportDetailId=[ird].[ImbalanceReportDetailId]) --exclude previous items

	EXEC [dbo].[ib_ImbalanceReport_GroupByRule]

	INSERT INTO #visitingReportDetails([ImbalanceReportDetailId], [Description])
		SELECT [ird].[ImbalanceReportDetailId], ''Unknown''
			FROM [dbo].[ib_ImbalanceReportDetail] ird 
				INNER JOIN [ib_ImbalanceReport] ir ON 
					ir.ImbalanceReportId = @ImbalanceReportId 
				AND ir.ImbalanceReportId = ird.ImbalanceReportId
				AND [ird].[ClassId] IS NULL --IBAL-2109
			WHERE NOT EXISTS (SELECT 1 FROM #visitedItems v WHERE v.ImbalanceReportDetailId=[ird].[ImbalanceReportDetailId]) --exclude previous items

	EXEC [dbo].[ib_ImbalanceReport_GroupByRule]


--update the report status
UPDATE [dbo].[ib_Report]
	SET [Stage] = ''Phase 2: Updating exchange, currency and instrument information''
	WHERE ReportId = @ReportId

--UPDATE the Exchange and currency
UPDATE #results 
	SET [Exchange] = 
	(SELECT [e].[Name] 
		FROM [dbo].[ib_Exchange] e
		WHERE [e].[ExchangeId] = [r].[ExchangeID]),
	[Currency] = 
	(SELECT [c].[Code] 
		FROM [dbo].[ib_Currency] c
		WHERE [c].[CurrencyId] = [r].[CurrencyID]),
	[Instrument] =
	(SELECT [i].[Code] 
		FROM [dbo].[ib_Instrument] i
		WHERE [i].[InstrumentId] = [r].[InstrumentID])
	FROM #results r

-- fix null vs. empty string in option type code
UPDATE #results
	SET OptionTypeCode = ''''
	WHERE OptionTypeCode IS NULL

-- fix null vs. 0 in strike price
UPDATE #results
	SET StrikePrice = 0
	WHERE StrikePrice IS NULL

--update the report status
UPDATE [dbo].[ib_Report]
	SET [Stage] = ''Phase 2: Final grouping...''
	WHERE ReportId = @ReportId

--save data and do one more grouping: see task IBAL-2077
INSERT INTO [dbo].[ib_ImbalanceReportSummary]
	([ImbalanceReportId], [ExchangeId], [InstrumentId],
	[ExpiryYear], [ExpiryMonth], [ExpiryDay], 
	[OptionTypeCode], [CurrencyId], [StrikePrice], 
	[Internal_YAdjOTE], [Internal_YOTE], [Internal_PandS],
	[Internal_TAdjOTE], [Internal_TOTE], [Internal_Position], 
	[External_YAdjOTE], [External_YOTE], [External_PandS], 
	[External_TAdjOTE], [External_TOTE], [External_Position],
	[Lots], [Variation],
	[Description], [Exchange], [Currency], [Instrument], [Notes])
SELECT  @ImbalanceReportId, [ExchangeId], [InstrumentId], 
		[ExpiryYear], [ExpiryMonth], [ExpiryDay], 
		[OptionTypeCode], [CurrencyId], [StrikePrice], 
		SUM([Internal_YAdjOTE]) Internal_YAdjOTE, SUM([Internal_YOTE]) Internal_YOTE, SUM([Internal_PandS]) Internal_PandS,
		SUM([Internal_TAdjOTE]) Internal_TAdjOTE, SUM([Internal_TOTE]) Internal_TOTE, SUM([Internal_Position]) Internal_Position, 
		SUM([External_YAdjOTE]) External_YAdjOTE, SUM([External_YOTE]) External_YOTE, SUM([External_PandS]) External_PandS, 
		SUM([External_TAdjOTE]) External_TAdjOTE, SUM([External_TOTE]) External_TOTE, SUM([External_Position]) External_Position,
		0, 0, [Description], [Exchange], [Currency], [Instrument], NULL
	FROM #results
	GROUP BY [ExchangeId], [InstrumentId], [CurrencyId],
			 [ExpiryMonth], [ExpiryYear], [ExpiryDay], 
			 [OptionTypeCode], [StrikePrice], [Description], 
			 [Exchange], [Currency], [Instrument]
	ORDER BY Exchange, Description, Currency

--calculate adjustments
UPDATE [dbo].[ib_Report]
	SET [Stage] = ''Phase 2: Calculate Adjustments...''
	WHERE ReportId = @ReportId

EXEC [dbo].[ib_ImbalanceReport_GatherAdjustments] @ImbalanceReportId

UPDATE [dbo].[ib_Report]
		SET [Stage] = ''Add Positions Realised Cash Data''
		WHERE ReportId = @ReportId

	EXEC ib_ImbalanceReport_AddPositionsRealisedCashData @ReportId, @ImbalanceReportId


--update the report status
UPDATE [dbo].[ib_Report]
	SET [Stage] = ''Phase 2: Calculate Lots and Variation...''
	WHERE ReportId = @ReportId

--calculate Lots and variation
EXEC ib_ImbalanceReport_CalculateImbalance @ImbalanceReportId

--drop temporary tables
DROP TABLE #tg
DROP TABLE #results
DROP TABLE #visitedItems
DROP TABLE #visitingReportDetails

--update the report status
UPDATE [dbo].[ib_Report]
	SET [Stage] = ''Phase 2: Completed''
	WHERE ReportId = @ReportId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_ImbalanceReport_BuildReportPhase1]''
');

GO
EXECUTE ('/*
<details>
	<summary> Generates the ib_ImbalanceReportDetail records for the report Phase 1</summary>
	<created author="Laurentiu Macovei" Date="Monday, 17 July 2006" />
	<updated author="Laurentiu Macovei" Date="Friday, 21 July 2006 13:45 GMT" taskId="1">
		Tweaking performance with good indexes. Good performance resulted. 
		On a 115K records on each Position, Trx and Adjustment, time for the SP decreased from 1:10 sec to 2 sec. (on my notebook)
	</updated>
	<updated author="Laurentiu Macovei" Date="Tuesday, 25 July 2006" taskId="1990_1">
		The calculation of P and S changed from sum(ib_Trx.Quantity) to (ib_Trx.MarketValue).
		Removed the deletes from SP.
	</updated>
	<updated author="Laurentiu Macovei" Date="Tuesday, 28 July 2006">
		Add @@ib_ImbalanceReportId to the output
	</updated>
	<updated author="Laurentiu Macovei" Date="Wednesday, 2 August 2006">
		Adding more validation rules
	</updated>
	<updated author="Laurentiu Macovei" Date="Friday, 4 August 2006" taskId="2020_1" />
	<updated author="Laurentiu Macovei" Date="Monday, 7 August 2006 1:08 PM GMT">
		Added @@ReportId parameter to update more detailed progress details
	</updated>
	<updated author="Laurentiu Macovei" Date="Monday, 14 August 2006 16:08 GMT" taskId="IBAL-2076" />
	<updated author="Laurentiu.Macovei" Date="Sunday, 20 August 2006 18:15 PM GMT" taskId="IBAL-2034"/>
	<updated author="Laurentiu.Macovei" Date="Sunday, 20 August 2006 19:15 PM GMT" taskId="IBAL-2035"/>
	<updated author="Laurentiu.Macovei(softer)" Date="Tuesday, 22 August 2006 18:08 PM GMT" taskId="IBAL-2109"/>
	<updated author="Laurentiu.Macovei" Date="Thursday 31 August 2006 02:02AM GMT" taskId="IBAL-2058"/>
	<updated author="Anil.Kripalani" Date="29 Nov 2006" taskId="IBAL-2541"/>
	<updated author="Anil.Kripalani" Date="6 Dec 2006">
		BUG FIX 1: When going back and updating numbers in IRD, note that OptionTypeCode can be Null
					AND StrikePrice can be Null
		BUG FIX 2: Need to check PandS and IsPremium for External PandS, not just Internal
		BUG FIX 3: Use MarketValue for PandS, not Quantity
	</updated>
	<updated author="Anil.Kripalani" Date="7 Dec 2006">
		BUG FIX: For PandS, don''t check IsPremium if PriceTypeCode = F
	</updated>
	<updated author="Anil.Kripalani" Date="8 Dec 2006">
		BUG FIX: Move adjustment gathering to phase 2
	</updated>
	<updated author="Anil Kripalani" Date="06 Feb 2007">
		More specific stage updates
	</updated>
	<updated author="Alister McLeod" Date="08 Feb 2010">
		Use TradeDate for looking at Adjustments table for ''today'' not AdjustmentDate
	</updated>
	<updated author="Anil Kripalani" Date="15 Apr 2010">
		MBAL-15275: Forget pricetypecode which isn''t set anyway - use instrument type
	</updated>
	<updated author="Anil Kripalani" Date="16 Apr 2010">
		MBAL-15289: Show OTE for options too (don''t blank out at end of this stored proc)
		MBAL-15300: collect marketvalue on trx for P type instr (not ''not F'')
	</updated>
	<updated author="Anil Kripalani" Date="21 Apr 2010">
		MBAL-15332: collect marketvalue on trx for O type instr where new IsOptionMarketValue is turned on
	</updated>
</details>
*/

CREATE PROCEDURE [dbo].[ib_ImbalanceReport_BuildReportPhase1]
(
	@CreateUsername varchar(50) = NULL,
	@TemplateId int,
	@TodayDate datetime,
	@YesterdayDate datetime,
	@UserId uniqueidentifier,
	@@ReportId int OUTPUT,
	@@ib_ImbalanceReportId int OUTPUT
)
AS
SET NOCOUNT ON

	--	21 Sep 2010		amk		MBAL-16672: bug fix: adjustments not appear when no positions or trxs
	--	06 Jan 2011		amk		MBAL-17237: ensure calls to add new report record carry template so site can be saved correctly
	--	18 Dec 2014		ED		EIB 26327 - improve report performance

	IF @@ReportId IS NULL
		EXEC [dbo].[ib_Report_CreateReport] ''Imbalance'', @CreateUserName, @UserId, @@ReportId OUTPUT
			, NULL, @TemplateId

	--update the report status
	UPDATE [dbo].[ib_Report]
		SET [Stage] = ''Phase 1: Validating''
		WHERE ReportId = @@ReportId

	--validate
	IF @TodayDate IS NULL
		RAISERROR (N''First Date cannot be NULL!'', 11, 1)
	IF @YesterdayDate IS NULL
		RAISERROR (N''Second Date cannot be NULL!'', 11, 2)
	IF @TemplateId IS NULL
		RAISERROR (N''TemplateID cannot be NULL!'', 11, 3)

	--update the report status
	UPDATE [dbo].[ib_Report]
		SET [Stage] = ''Phase 1: Checking for matching data''
		WHERE ReportId = @@ReportId

	--try to validate the input dates, so find if there is any records matching them
	DECLARE @ExistRows BIT
	SET @ExistRows = 0
	IF EXISTS(SELECT TOP 1 TrxId FROM  [dbo].[ib_trx]
		WHERE AsOfDate = @YesterdayDate OR AsOfDate = @TodayDate)
		SET @ExistRows = 1
	--if no record yet
	IF @ExistRows = 0 
	BEGIN
		IF EXISTS(SELECT TOP 1 PositionId FROM [dbo].[ib_Position]
			WHERE AsOfDate = @YesterdayDate OR AsOfDate = @TodayDate)
			SET @ExistRows = 1
		--if still no luck
		IF @ExistRows = 0 
		BEGIN
			IF EXISTS(SELECT TOP 1 AdjustmentId FROM [dbo].[ib_Adjustment]
				WHERE TradeDate = @TodayDate)
				SET @ExistRows = 1
			--if no rows at all
			IF @ExistRows = 0 
			BEGIN
				DECLARE @@TodayDate varchar(30)
				DECLARE @@YesterdayDate varchar(30)
				SET @@TodayDate = Cast(@TodayDate as varchar(30))
				SET @@YesterdayDate = Cast(@YesterdayDate as varchar(30))
				RAISERROR (N''Warning! There is not data (Position, Transaction or Adjusment) matching these dates ''''%s'''' or ''''%s''''!'', 11, 4, @@TodayDate, @@YesterdayDate)
			END
		END
	END

	--fix the username
	IF (@CreateUsername IS NULL)
		SET @CreateUsername = SUSER_NAME()
	
	--update the report status
	UPDATE [dbo].[ib_Report]
		SET [Stage] = ''Phase 1: Create the report header''
		WHERE ReportId = @@ReportId

	--create the ReportHeader
	INSERT INTO [dbo].[ib_ImbalanceReport](TemplateId, Yesterday, Today, CreateUsername)
		SELECT @TemplateId, @YesterdayDate, @TodayDate, @CreateUsername
		FROM [dbo].ib_Template
		WHERE TemplateId = @TemplateId

	--check the creation
	IF @@RowCount = 0 
		RAISERROR (N''Specified Template with TemplateID ''''%d'''' does not exist!'', 11, 1, @TemplateId)

	--take the newly created ReportId
	SELECT @@ib_ImbalanceReportId = SCOPE_IDENTITY()

	--update the report status
	UPDATE [dbo].[ib_Report]
		SET [Stage] = ''Phase 1: Load recs from pos and trx for firms''
		WHERE ReportId = @@ReportId

	DECLARE @DataSources TABLE(DataSourceId INT)
	INSERT INTO @DataSources(DataSourceId)
	SELECT DISTINCT DataSourceId FROM ib_TemplateCompare tc WHERE  TemplateId=@templateid

	DECLARE @tempPosition TABLE(
	DataSourceId           INT NULL
	, ExchangeId           INT NULL
	, FirmId               INT NULL
	, AccountId            INT NULL
	, InstrumentId         INT NULL
	, ClassId              INT NULL
	, ExpiryYear           INT NULL
	, ExpiryMonth          INT NULL
	, ExpiryDay            INT NULL
	, OptionTypeCode       VARCHAR(1) NULL
	, CurrencyId           INT NULL
	, StrikePrice          MONEY NULL)

	INSERT INTO @tempPosition(
	DataSourceId      
	, ExchangeId      
	, FirmId          
	, AccountId       
	, InstrumentId    
	, ClassId         
	, ExpiryYear      
	, ExpiryMonth     
	, ExpiryDay       
	, OptionTypeCode  
	, CurrencyId      
	, StrikePrice     
	)
	SELECT DISTINCT p.DataSourceId, p.ExchangeId, p.FirmId, p.AccountId, p.InstrumentId, p.ClassId,
			p.ExpiryYear, p.ExpiryMonth, p.ExpiryDay, p.OptionTypeCode, p.CurrencyId, p.StrikePrice
			FROM dbo.ib_Position p
			INNER JOIN ib_Exchange ex ON p.ExchangeId = ex.ExchangeId 
						 AND ex.RunBalanceReport != 0
						 INNER JOIN @DataSources ds on ds.DataSourceId = p.DataSourceId
						WHERE  (p.AsOfDate = @TodayDate OR p.AsOfDate = @YesterdayDate) 

	DECLARE @tempTrade TABLE(
	DataSourceId           INT NULL
	, ExchangeId           INT NULL
	, FirmId               INT NULL
	, AccountId            INT NULL
	, InstrumentId         INT NULL
	, ClassId              INT NULL
	, ExpiryYear           INT NULL
	, ExpiryMonth          INT NULL
	, ExpiryDay            INT NULL
	, OptionTypeCode       VARCHAR(1) NULL
	, CurrencyId           INT NULL
	, StrikePrice          MONEY NULL)

	INSERT INTO @tempTrade(
	DataSourceId      
	, ExchangeId      
	, FirmId          
	, AccountId       
	, InstrumentId    
	, ClassId         
	, ExpiryYear      
	, ExpiryMonth     
	, ExpiryDay       
	, OptionTypeCode  
	, CurrencyId      
	, StrikePrice     
	)
	SELECT DISTINCT trx.DataSourceId, trx.ExchangeId, trx.FirmId, trx.AccountId, trx.InstrumentId, trx.ClassId,
			trx.ExpiryYear, trx.ExpiryMonth, trx.ExpiryDay, trx.OptionTypeCode, trx.CurrencyId, trx.StrikePrice
			FROM dbo.ib_Trx trx
					INNER JOIN [dbo].ib_TrxType tt ON  
						tt.Code = trx.TrxTypeCode 
						AND tt.DataSourceId = trx.DataSourceId 
						AND (tt.IsPandS = 1  OR tt.IsPremium = 1)
					INNER JOIN ib_Exchange ex ON 
						trx.ExchangeId = ex.ExchangeId 
						AND ex.RunBalanceReport != 0 
						 WHERE trx.AsOfDate=@TodayDate

	INSERT INTO [dbo].[ib_ImbalanceReportDetail]
			   ([ImbalanceReportId]
			   ,[DataSourceId]
			   ,[ExchangeId]
			   ,[FirmId]
			   ,[AccountId]
			   ,[InstrumentId]
			   ,[ClassId] -- see task IBAL-2109
			   ,[ExpiryYear]
			   ,[ExpiryMonth]
			   ,[ExpiryDay]
			   ,[OptionTypeCode]
			   ,[CurrencyId]
			   ,[StrikePrice]
			   ,[Internal_YAdjOTE]
			   ,[Internal_YOTE]
			   ,[Internal_PandS]
			   ,[Internal_TAdjOTE]
			   ,[Internal_TOTE]
			   ,[Internal_Position]
			   ,[External_YAdjOTE]
			   ,[External_YOTE]
			   ,[External_PandS]
			   ,[External_TAdjOTE]
			   ,[External_TOTE]
			   ,[External_Position]
			   ,[CreateUsername])
	SELECT -- the rows (dates) from Position
		@@ib_ImbalanceReportId, p.DataSourceId, p.ExchangeId, p.FirmId, p.AccountId, p.InstrumentId, p.ClassId,
		p.ExpiryYear, p.ExpiryMonth, p.ExpiryDay, p.OptionTypeCode, p.CurrencyId, p.StrikePrice,
		Internal_YAdjOTE=0, Internal_YOTE=0, Internal_PandS=0, Internal_TAdjOTE=0,
		Internal_TOTE=0, Internal_Position=0, External_YAdjOTE=0, External_YOTE=0,
		External_PandS=0, External_TAdjOTE=0, External_TOTE=0, External_Position=0,
		CreateUsername = @CreateUsername
		FROM dbo.ib_TemplateCompare tc 
		INNER JOIN @tempPosition p ON
						tc.FirmID = p.FirmID AND
						tc.DataSourceId = p.DataSourceId 
					AND tc.TemplateID = @TemplateId
	UNION -- append the different rows (dates) from Trx
	SELECT @@ib_ImbalanceReportId, [trx].[DataSourceId], [trx].[ExchangeId], [trx].[FirmId], [trx].[AccountId], [trx].[InstrumentId], [trx].[ClassId],
		[trx].[ExpiryYear], [trx].[ExpiryMonth], [trx].[ExpiryDay], [trx].[OptionTypeCode], [trx].[CurrencyId], [trx].[StrikePrice], 
		[Internal_YAdjOTE]=0, [Internal_YOTE]=0, [Internal_PandS]=0, [Internal_TAdjOTE]=0,
		[Internal_TOTE]=0, [Internal_Position]=0, [External_YAdjOTE]=0, [External_YOTE]=0,
		[External_PandS]=0, [External_TAdjOTE]=0, [External_TOTE]=0, [External_Position]=0,
		[CreateUsername] = @CreateUsername
		FROM dbo.ib_TemplateCompare tc 
				INNER JOIN @tempTrade trx ON		
					tc.TemplateID = @TemplateId		
					AND trx.FirmID = tc.FirmID 
					AND trx.DataSourceId = tc.DataSourceId 
	UNION -- append the different rows from adjustments
	SELECT @@ib_ImbalanceReportId, a.DataSourceId, a.ExchangeId, a.FirmId, a.AccountId, a.InstrumentId, a.ClassId,
		a.ExpiryYear, a.ExpiryMonth, a.ExpiryDay, a.OptionTypeCode, a.CurrencyId, a.StrikePrice, 
		[Internal_YAdjOTE] = 0, [Internal_YOTE] = 0, [Internal_PandS] = 0, [Internal_TAdjOTE] = 0,
		[Internal_TOTE] = 0, [Internal_Position] = 0, [External_YAdjOTE] = 0, [External_YOTE] = 0,
		[External_PandS] = 0, [External_TAdjOTE] = 0, [External_TOTE] = 0, [External_Position] = 0,
		[CreateUsername] = @CreateUsername
	FROM ib_adjustment a
		INNER JOIN ib_TemplateCompare tc ON tc.TemplateId = a.TemplateId
			AND tc.DataSourceId = a.DataSourceId
			AND tc.FirmId = a.FirmId
		INNER JOIN ib_Exchange ex ON a.ExchangeId = ex.ExchangeId 
			AND ex.RunBalanceReport != 0 -- excluding data that has RunBalanceReport = 0 (IBAL-2034)
	WHERE a.TemplateId = @TemplateId
		AND (a.AdjustmentDate = @TodayDate OR a.AdjustmentDate = @YesterdayDate)	
							
	--update the report status
	UPDATE [dbo].[ib_Report]
	SET [Stage] = ''Phase 1: Performing Position and Transaction data''
		, TargetReportId = @@ib_ImbalanceReportId
	WHERE ReportId = @@ReportId

	UPDATE [dbo].[ib_ImbalanceReportDetail]
	SET 
		[Internal_TOTE] = 
			CASE WHEN [tc].[InternalExternalCode] = ''I'' THEN -- perform only on internal values
				ISNULL((SELECT SUM([p].[MarketValue])
					FROM [dbo].[ib_Position] [p]
					WHERE 
						[p].[DataSourceId] = [ird].[DataSourceId]
						AND [p].[ExchangeId] = [ird].[ExchangeId]
						AND [p].[FirmId] = [ird].[FirmId]
						AND ([p].[AccountId] = [ird].[AccountId] OR [p].[AccountId] IS NULL AND [ird].[AccountId] IS NULL) -- see task IBAL 2109
						AND [p].[AsOfDate] = @TodayDate
						AND [p].[InstrumentId] = [ird].[InstrumentId]
						AND [p].[ExpiryYear] = [ird].[ExpiryYear]
						AND [p].[ExpiryMonth] = [ird].[ExpiryMonth]
						AND [p].[ExpiryDay] = [ird].[ExpiryDay]
						AND [p].[CurrencyId] = [ird].[CurrencyId]
						AND (([p].[StrikePrice] = [ird].[StrikePrice]) OR ([p].[StrikePrice] IS NULL AND [ird].[StrikePrice] IS NULL))
						AND (([p].[OptionTypeCode] = [ird].[OptionTypeCode]) OR ([p].[OptionTypeCode] IS NULL AND [ird].[OptionTypeCode] IS NULL))
						AND ([p].[ClassId] = [ird].[ClassId] OR [p].[ClassId] IS NULL AND [ird].[ClassId] IS NULL) -- see task IBAL 2109
				),0) -- no columns matches the @TodayDate?
			ELSE 0 -- not internal?
			END
			,[External_TOTE] = 
			CASE WHEN [tc].[InternalExternalCode] = ''E'' THEN -- perform only on external values
				ISNULL((SELECT SUM([p].[MarketValue])
					FROM [dbo].[ib_Position] [p]
					WHERE 
						[p].[DataSourceId] = [ird].[DataSourceId]
						AND [p].[ExchangeId] = [ird].[ExchangeId]
						AND [p].[FirmId] = [ird].[FirmId]
						AND ([p].[AccountId] = [ird].[AccountId] OR [p].[AccountId] IS NULL AND [ird].[AccountId] IS NULL) -- see task IBAL 2109
						AND [p].[AsOfDate] = @TodayDate
						AND [p].[InstrumentId] = [ird].[InstrumentId]
						AND [p].[ExpiryYear] = [ird].[ExpiryYear]
						AND [p].[ExpiryMonth] = [ird].[ExpiryMonth]
						AND [p].[ExpiryDay] = [ird].[ExpiryDay]
						AND [p].[CurrencyId] = [ird].[CurrencyId]
						AND (([p].[StrikePrice] = [ird].[StrikePrice]) OR ([p].[StrikePrice] IS NULL AND [ird].[StrikePrice] IS NULL))
						AND (([p].[OptionTypeCode] = [ird].[OptionTypeCode]) OR ([p].[OptionTypeCode] IS NULL AND [ird].[OptionTypeCode] IS NULL))
						AND ([p].[ClassId] = [ird].[ClassId] OR [p].[ClassId] IS NULL AND [ird].[ClassId] IS NULL) -- see task IBAL 2109
				),0) -- no columns matches the @TodayDate?
			ELSE 0 -- not external?
			END
			,[Internal_YOTE] = 
			CASE WHEN [tc].[InternalExternalCode] = ''I'' THEN -- perform only on internal values
				ISNULL((SELECT SUM([p].[MarketValue])
					FROM [dbo].[ib_Position] [p]
					WHERE 
						[p].[DataSourceId] = [ird].[DataSourceId]
						AND [p].[ExchangeId] = [ird].[ExchangeId]
						AND [p].[FirmId] = [ird].[FirmId]
						AND ([p].[AccountId] = [ird].[AccountId] OR [p].[AccountId] IS NULL AND [ird].[AccountId] IS NULL) -- see task IBAL 2109
						AND [p].[AsOfDate] = @YesterdayDate
						AND [p].[InstrumentId] = [ird].[InstrumentId]
						AND [p].[ExpiryYear] = [ird].[ExpiryYear]
						AND [p].[ExpiryMonth] = [ird].[ExpiryMonth]
						AND [p].[ExpiryDay] = [ird].[ExpiryDay]
						AND [p].[CurrencyId] = [ird].[CurrencyId]
						AND (([p].[StrikePrice] = [ird].[StrikePrice]) OR ([p].[StrikePrice] IS NULL AND [ird].[StrikePrice] IS NULL))
						AND (([p].[OptionTypeCode] = [ird].[OptionTypeCode]) OR ([p].[OptionTypeCode] IS NULL AND [ird].[OptionTypeCode] IS NULL))
						AND [ds].[ProvidesVariation] = 0 --see task IBAL-2076 (Allow for Some Sources Sending Variation Instead of OTE)
						AND ([p].[ClassId] = [ird].[ClassId] OR [p].[ClassId] IS NULL AND [ird].[ClassId] IS NULL) -- see task IBAL 2109
				),0) -- no columns matches the @YesterdayDate?
			ELSE 0 -- not internal?
			END
			,[External_YOTE] = 
			CASE WHEN [tc].[InternalExternalCode] = ''E'' THEN -- perform only on external values
				ISNULL((SELECT SUM([p].[MarketValue])
					FROM [dbo].[ib_Position] [p]
					WHERE 
						[p].[DataSourceId] = [ird].[DataSourceId]
						AND [p].[ExchangeId] = [ird].[ExchangeId]
						AND [p].[FirmId] = [ird].[FirmId]
						AND ([p].[AccountId] = [ird].[AccountId] OR [p].[AccountId] IS NULL AND [ird].[AccountId] IS NULL) -- see task IBAL 2109
						AND [p].[AsOfDate] = @YesterdayDate
						AND [p].[InstrumentId] = [ird].[InstrumentId]
						AND [p].[ExpiryYear] = [ird].[ExpiryYear]
						AND [p].[ExpiryMonth] = [ird].[ExpiryMonth]
						AND [p].[ExpiryDay] = [ird].[ExpiryDay]
						AND [p].[CurrencyId] = [ird].[CurrencyId]
						AND (([p].[StrikePrice] = [ird].[StrikePrice]) OR ([p].[StrikePrice] IS NULL AND [ird].[StrikePrice] IS NULL))
						AND (([p].[OptionTypeCode] = [ird].[OptionTypeCode]) OR ([p].[OptionTypeCode] IS NULL AND [ird].[OptionTypeCode] IS NULL))
						AND [ds].[ProvidesVariation] = 0 --see task IBAL-2076 (Allow for Some Sources Sending Variation Instead of OTE)
						AND ([p].[ClassId] = [ird].[ClassId] OR [p].[ClassId] IS NULL AND [ird].[ClassId] IS NULL) -- see task IBAL 2109
				),0) -- no columns matches the @YesterdayDate?
			ELSE 0 -- not external?
			END
			,[Internal_Position] = 
			CASE WHEN [tc].[InternalExternalCode] = ''I'' THEN -- perform only on internal values
				ISNULL((SELECT SUM([p].[Quantity])
					FROM [dbo].[ib_Position] [p]
					WHERE 
						[p].[DataSourceId] = [ird].[DataSourceId]
						AND [p].[ExchangeId] = [ird].[ExchangeId]
						AND [p].[FirmId] = [ird].[FirmId]
						AND [p].[AccountId] = [ird].[AccountId]
						AND [p].[AsOfDate] = @TodayDate
						AND [p].[InstrumentId] = [ird].[InstrumentId]
						AND [p].[ExpiryYear] = [ird].[ExpiryYear]
						AND [p].[ExpiryMonth] = [ird].[ExpiryMonth]
						AND [p].[ExpiryDay] = [ird].[ExpiryDay]
						AND [p].[CurrencyId] = [ird].[CurrencyId]
						AND (([p].[StrikePrice] = [ird].[StrikePrice]) OR ([p].[StrikePrice] IS NULL AND [ird].[StrikePrice] IS NULL))
						AND (([p].[OptionTypeCode] = [ird].[OptionTypeCode]) OR ([p].[OptionTypeCode] IS NULL AND [ird].[OptionTypeCode] IS NULL))
						AND ([p].[ClassId] = [ird].[ClassId] OR [p].[ClassId] IS NULL AND [ird].[ClassId] IS NULL) -- see task IBAL 2109
				),0) -- no columns matches the @TodayDate?
			ELSE 0 -- not internal?
			END
			,[External_Position] = 
			CASE WHEN [tc].[InternalExternalCode] = ''E'' THEN -- perform only on external values
				ISNULL((SELECT SUM([p].[Quantity])
					FROM [dbo].[ib_Position] [p]
					WHERE 
						[p].[DataSourceId] = [ird].[DataSourceId]
						AND [p].[ExchangeId] = [ird].[ExchangeId]
						AND [p].[FirmId] = [ird].[FirmId]
						AND ([p].[AccountId] = [ird].[AccountId] OR [p].[AccountId] IS NULL AND [ird].[AccountId] IS NULL) -- see task IBAL 2109
						AND [p].[AsOfDate] = @TodayDate
						AND [p].[InstrumentId] = [ird].[InstrumentId]
						AND [p].[ExpiryYear] = [ird].[ExpiryYear]
						AND [p].[ExpiryMonth] = [ird].[ExpiryMonth]
						AND [p].[ExpiryDay] = [ird].[ExpiryDay]
						AND [p].[CurrencyId] = [ird].[CurrencyId]
						AND (([p].[StrikePrice] = [ird].[StrikePrice]) OR ([p].[StrikePrice] IS NULL AND [ird].[StrikePrice] IS NULL))
						AND (([p].[OptionTypeCode] = [ird].[OptionTypeCode]) OR ([p].[OptionTypeCode] IS NULL AND [ird].[OptionTypeCode] IS NULL))
						AND ([p].[ClassId] = [ird].[ClassId] OR [p].[ClassId] IS NULL AND [ird].[ClassId] IS NULL) -- see task IBAL 2109
				),0) -- no columns matches the @TodayDate?
			ELSE 0 -- not external?
			END
			,[Internal_PandS] = 
			CASE WHEN [tc].[InternalExternalCode] = ''I'' THEN -- perform only on internal values
				ISNULL((SELECT SUM([trx].[MarketValue])
					FROM [dbo].[ib_Trx] [trx]
						INNER JOIN [dbo].ib_Instrument i ON i.InstrumentId = trx.InstrumentId
						INNER JOIN ib_InstrumentType it ON it.InstrumentTypeId = i.InstrumentTypeId
						INNER JOIN [dbo].ib_TrxType tt ON  tt.Code = trx.TrxTypeCode 
							AND tt.DataSourceId = trx.DataSourceId 
							AND (tt.IsPandS = 1 
								OR (it.Code = ''P'' AND tt.IsPremium = 1)
								OR (it.Code = ''O'' AND tt.IsOptionMarketValue = 1)
								)
					WHERE 							
						[trx].[DataSourceId] = [ird].[DataSourceId]
						AND [trx].[ExchangeId] = [ird].[ExchangeId]
						AND [trx].[FirmId] = [ird].[FirmId]
						AND ([trx].[AccountId] = [ird].[AccountId] OR [trx].[AccountId] IS NULL AND [ird].[AccountId] IS NULL) -- see task IBAL 2109
						AND [trx].[AsOfDate] = @TodayDate
						AND [trx].[InstrumentId] = [ird].[InstrumentId]
						AND [trx].[ExpiryYear] = [ird].[ExpiryYear]
						AND [trx].[ExpiryMonth] = [ird].[ExpiryMonth]
						AND [trx].[ExpiryDay] = [ird].[ExpiryDay]
						AND [trx].[CurrencyId] = [ird].[CurrencyId]
						AND (([trx].[StrikePrice] = [ird].[StrikePrice]) OR ([trx].[StrikePrice] IS NULL AND [ird].[StrikePrice] IS NULL))
						AND (([trx].[OptionTypeCode] = [ird].[OptionTypeCode]) OR ([trx].[OptionTypeCode] IS NULL AND [ird].[OptionTypeCode] IS NULL))
						AND ([trx].[ClassId] = [ird].[ClassId] OR [trx].[ClassId] IS NULL AND [ird].[ClassId] IS NULL) -- see task IBAL 2109											
				),0) -- no columns matches the @TodayDate?
			ELSE 0 -- not internal?
			END
			,[External_PandS] = 
			CASE WHEN [tc].[InternalExternalCode] = ''E'' THEN -- perform only on external values
				ISNULL((SELECT SUM([trx].[MarketValue])
					FROM [dbo].[ib_Trx] [trx]
						INNER JOIN [dbo].ib_Instrument i ON i.InstrumentId = trx.InstrumentId
						INNER JOIN ib_InstrumentType it ON it.InstrumentTypeId = i.InstrumentTypeId
						INNER JOIN [dbo].ib_TrxType tt ON  tt.Code = trx.TrxTypeCode 
							AND tt.DataSourceId = trx.DataSourceId 
							AND (tt.IsPandS = 1 
								OR (it.Code = ''P'' AND tt.IsPremium = 1)
								OR (it.Code = ''O'' AND tt.IsOptionMarketValue = 1)
								)
					WHERE 
						[trx].[DataSourceId] = [ird].[DataSourceId]
						AND [trx].[ExchangeId] = [ird].[ExchangeId]
						AND [trx].[FirmId] = [ird].[FirmId]
						AND ([trx].[AccountId] = [ird].[AccountId] OR [trx].[AccountId] IS NULL AND [ird].[AccountId] IS NULL) -- see task IBAL 2109
						AND [trx].[AsOfDate] = @TodayDate
						AND [trx].[InstrumentId] = [ird].[InstrumentId]
						AND [trx].[ExpiryYear] = [ird].[ExpiryYear]
						AND [trx].[ExpiryMonth] = [ird].[ExpiryMonth]
						AND [trx].[ExpiryDay] = [ird].[ExpiryDay]
						AND [trx].[CurrencyId] = [ird].[CurrencyId]
						AND (([trx].[StrikePrice] = [ird].[StrikePrice]) OR ([trx].[StrikePrice] IS NULL AND [ird].[StrikePrice] IS NULL))
						AND (([trx].[OptionTypeCode] = [ird].[OptionTypeCode]) OR ([trx].[OptionTypeCode] IS NULL AND [ird].[OptionTypeCode] IS NULL))
						AND ([trx].[ClassId] = [ird].[ClassId] OR [trx].[ClassId] IS NULL AND [ird].[ClassId] IS NULL) -- see task IBAL 2109
				),0) -- no columns matches the @TodayDate?
			ELSE 0 -- not external?
			END
	FROM [dbo].[ib_ImbalanceReportDetail] [ird]
		INNER JOIN [dbo].[ib_TemplateCompare] [tc] ON [tc].[TemplateId] = @TemplateId 
			AND [ird].FirmId = [tc].FirmId
		INNER JOIN [dbo].[ib_DataSource] ds ON [tc].[DataSourceId] = [ds].[DataSourceId]
	WHERE [ImbalanceReportId] = @@ib_ImbalanceReportId

	--update the report status
	UPDATE [dbo].[ib_Report]
	SET [Stage] = ''Phase 1: Zero OTEs for Future price type instr''
	WHERE ReportId = @@ReportId

	-- zero out OTE for everything but Future AND Option type instruments
	UPDATE [dbo].[ib_ImbalanceReportDetail]
	SET Internal_YOTE = 0, Internal_TOTE = 0
		, External_YOTE = 0, External_TOTE = 0
	FROM [dbo].[ib_ImbalanceReportDetail] [ird]
		INNER JOIN [dbo].[ib_Instrument] [i]
			ON [i].[InstrumentId] = [ird].[InstrumentId]
		INNER JOIN ib_InstrumentType it ON it.InstrumentTypeId = i.InstrumentTypeId
	WHERE [ImbalanceReportId] = @@ib_ImbalanceReportId
		AND it.Code <> ''F''
		AND it.Code <> ''O''

	--update the report status
	UPDATE [dbo].[ib_Report]
	SET [Stage] = ''Phase 1: Completed''
	WHERE ReportId = @@ReportId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_ImbalanceReport_BuildReport]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_ImbalanceReport_BuildReport]
	@CreateUsername varchar(50) = NULL,
	@UserId uniqueidentifier,	
	@TemplateId int,
	@TodayDate datetime,
	@YesterdayDate datetime,
	@IncludeRowsInBalance bit = 0,
	@OnlyImbalanceRowsFor int = 0,
	@Refresh bit = 1,
	@FilterExchangeId int = NULL,
	@FilterDescription varchar(100) = NULL,
	@FilterCurrencyId int = NULL,
	@@OrderBy varchar(300) = NULL,
	@@StartRowIndex int = NULL,
	@@MaximumRows int = NULL,
	@@ReportId int OUTPUT, 
	@@ImbalanceReportId int OUTPUT

AS
SET NOCOUNT ON

/*

<details>
	<summary> Generates the ib_ImbalanceReport by calling both Phase 1 and Phase 2, and store the results in the Report table</summary>
	<created author="Laurentiu Macovei" Date="Friday, 28 July 2006" />
	<updated author="Laurentiu Macovei (softer)" Date="Friday, 18 August 2006 5:08 PM GMT">
		Added @Refresh parameter and modified the logic of the stored procedure so if Phase1 is already ran
		the results would be reused. Also the @@ReportId and @@ImbalanceReportId params wil be set to NULL if they have zero values.
	</updated>
	<updated author="Laurentiu Macovei" Date="Friday, 20 October 2006 4:45 PM GMT">
		Added filter by Excahnge and By Description/Currency
	</updated>
	<updated author="Laurentiu Macovei" Date="Monday, 20 November 2006 21:01 PM GMT">
		Fixed the creating records in the ib_Report table each time.
		Increased the Order parameter''s size.
		Fixed refresh behavior.
		Fixed re-writting of ''complete'' status over the old record.
	</updated>
	<updated author="Anil Kripalani" Date="1 Dec 2006">
		For tracing ability, don''t delete IRD data
	</updated>
	<updated author="Anil Kripalani" Date="8 Dec 2006">
		Stamp criteria in Notes field
	</updated>
	<updated author="Anil Kripalani" Date="28 Dec 2006">
		BUG FIX 1: Set TargetReportId when report is cached
		BUG FIX 2: Set Notes with criteria even if report is cached
	</updated>
	<updated author="ED" Date="28 Apr 2009">
		Get Also ImbalanceReportSummaryId
	</updated>
	<updated author="Konrad" Date="19 May 2009">
		Added parameter @OnlyImbalanceRowsFor to allow filtering of only Imbalance Rows distinctive for Lots or Variation
        additional to the existing one (@IncludeRowsInBalance) which filters or doesn''t for both. 
	</updated>
	<updated author="KevinP" Date="23 Mar 2010">
		Extracted the SELECT portion of this SP into a new SP called [ib_ImbalanceReport_SelectBuiltReport] for re-use with the CashReport.
	</updated>
</details>
*/
	-- 06 Jan 2011		amk		MBAL-17237: ensure calls to add new report record carry template so site can be saved correctly


--fix the problem when sending zero values to these paramaters
IF @@ReportId <= 0
	SET @@ReportId = null
IF @@ImbalanceReportId = 0
	SET @@ImbalanceReportId = null

--fix the username
IF (@CreateUsername IS NULL)
	SET @CreateUsername = SUSER_NAME()

--EXECUTE everything in a TRY/CATCH
BEGIN TRY

IF @Refresh = 0
BEGIN		
--	IF @@ReportId IS NULL
--	BEGIN
		-- that''s a problem since this sp doesn''t create a report record
		-- i think that''s done by a manual call prior to this call
		-- (which is a little different thank the closeout report, i think)
--		RAISERROR(''ib_ImbalanceReport_BuildReport called for Refresh=0 without @@ReportId'', 16, 1)
--	END

	SET @Refresh = 1
	SELECT TOP 1 @@ImbalanceReportId = IR.[ImbalanceReportId], @Refresh = 0 
	FROM [dbo].[ib_ImbalanceReport] IR 
		INNER JOIN [dbo].[ib_Report] R ON IR.[ImbalanceReportId] = R.[TargetReportId]
			AND R.[ReportType] = ''Imbalance''
			AND IR.[TemplateId] = @TemplateId 
			AND IR.[Yesterday] = @YesterdayDate 
			AND IR.[Today] = @TodayDate
			AND IR.[CreateDate] IN 
				(SELECT MAX([CreateDate]) 
					FROM [dbo].[ib_ImbalanceReport]
					WHERE [TemplateId] = @TemplateId 
						AND [Yesterday] = @YesterdayDate 
						AND [Today] = @TodayDate)
	ORDER BY r.ReportId DESC
	
	IF @Refresh = 0
		UPDATE ib_Report
		SET TargetReportId = @@ImbalanceReportId
		WHERE ReportId = @@ReportId
END

IF @Refresh = 1
BEGIN
	--check if the specified reportId exists, otherwise set it to NULL to create a new one
	--for this operation we''ll use the @Refresh flag
	IF @@ReportId IS NOT NULL
		SELECT @Refresh = 0
			FROM ib_Report
			WHERE ReportId = @@ReportId
	IF @Refresh = 1 -- the reportId was not found
		SET @@ReportId = NULL -- so set it null
	ELSE SET @Refresh = 1 -- otherwise, restore the flag

	IF @@ReportId IS NULL
		EXEC [dbo].[ib_Report_CreateReport] ''Imbalance''
			, @CreateUserName, @UserID, @@ReportId OUTPUT, NULL, @TemplateId

	--validate the reportId
	SELECT @@ReportId = ReportId FROM [dbo].[ib_Report]
		WHERE @@ReportId = ReportId AND ReportType = ''Imbalance''
	IF @@RowCount = 0 
		RAISERROR (N''The specified reportId ''''%d'''' does not exist or is not an ''''Imbalance'''' report!'', 12, 1, @@ReportId)
	--validate the report status
	SELECT @@ReportId = ReportId FROM [dbo].[ib_Report]
		WHERE @@ReportId = ReportId AND ReportType = ''Imbalance'' AND Status = ''Added''
	IF @@RowCount = 0 
		RAISERROR (N''The specified reportId ''''%d'''' has is not in the ''''Added'''' status. Operation cannot continue!'', 12, 1, @@ReportId)

	DECLARE @SiteID int	
	SET @SiteID = -1


	--FIND the siteId for the provided userID that matches the first template
	SELECT TOP 1 @SiteId = su.SiteId 
		FROM [dbo].[ib_SiteUser] su
		INNER JOIN [dbo].[ib_SiteTemplate] st 
			ON  su.UserId = @UserID 
				AND st.SiteID = su.SiteId 
				AND st.TemplateId = @TemplateID

		IF @SiteId = -1
	BEGIN

		--Find the SiteId for the provided userId
		SELECT TOP 1 @SiteId = SiteId FROM ib_SiteUser
			WHERE UserId = @UserID AND IsPrimary = 1

		IF @SiteId = -1
		BEGIN
			--	Try to find a non-isPrimary SiteId for the speicified user
			SELECT TOP 1 @SiteId = SiteId FROM ib_SiteUser
				WHERE UserId = @UserID
			--if still not found, throw error
			IF @SiteId = -1
			BEGIN
				DECLARE @@UserId varchar(100)
				SET @@UserId = Cast(@UserId as varchar(100))
				RAISERROR (N''Provided userId ''''%s'''' does not have an associated site!'', 11, 1, @@UserId)
			END	
		END
	END
	--update the report status
	UPDATE [dbo].[ib_Report]
		SET [Status] = ''Building'',
			[Stage] = ''Calling Step 1'',
			[SiteId] = @SiteId
		WHERE ReportId = @@ReportId

	EXEC [dbo].[ib_ImbalanceReport_BuildReportPhase1] 
		@CreateUsername,
		@TemplateId,
		@TodayDate,
		@YesterdayDate,
		@UserId,
		@@ReportId,
		@@ImbalanceReportId OUTPUT
	
	UPDATE [dbo].[ib_Report]
		SET [Status] = ''Building'',
			[Stage] = ''Calling Step 2'',
			[SiteId] = @SiteId
		WHERE ReportId = @@ReportId
	EXEC [dbo].[ib_ImbalanceReport_BuildReportPhase2] 
		@@ReportId,
		@@ImbalanceReportId

	--update the report status
	UPDATE [dbo].[ib_Report]
		SET [Stage] = ''SQL Job: Cleaning up''
		WHERE ReportId = @@ReportId
	
	--clean-up reportDetail since we don''t need this data
--	DELETE FROM ib_ImbalanceReportDetail
--		WHERE ImbalanceReportId = @@ImbalanceReportId

	--update the report status
	UPDATE [dbo].[ib_Report]
		SET [Stage] = ''SQL Job: Sending data to the output''
		WHERE ReportId = @@ReportId

END

-- Execute the SELECT SP.

 EXEC [dbo].[ib_ImbalanceReport_SelectBuiltReport] @@ImbalanceReportId, 
													@@OrderBy, 
													@@MaximumRows, 	
													@@StartRowIndex,
													@FilterExchangeId,
													@FilterDescription,
													@FilterCurrencyId,
													@IncludeRowsInBalance,
													@OnlyImbalanceRowsFor
--build Notes

DECLARE @TemplateName VARCHAR(100)
SELECT @TemplateName = Description 
FROM ib_Template 
WHERE TemplateId = @TemplateId

DECLARE @Notes VARCHAR(255)
SET @Notes = @TemplateName
	+ '', '' + CONVERT(VARCHAR(10), @YesterdayDate, 103) 
	+ '', '' + CONVERT(VARCHAR(10), @TodayDate, 103) 

--update the report status
UPDATE [dbo].[ib_Report]
	SET [Stage] = ''SQL Job: Complete''
		, [Notes] = @Notes
	WHERE ReportId = @@ReportId

END TRY
BEGIN CATCH
	DECLARE @ErrorMessage NVARCHAR(4000);
	SET @ErrorMessage = ERROR_MESSAGE()
	--update the error
	UPDATE [dbo].[ib_Report]
		SET Status = ''Error'',
			ErrorMessage = @ErrorMessage,
			ErrorDetails = ''The error was thrown in the '' + ERROR_PROCEDURE() + '' stored procedure at line '' + CAST(ERROR_LINE() as varchar(10)) + '' with severity '' + CAST(ERROR_SEVERITY() as varchar(10)) + '', state '' + CAST(ERROR_STATE() as varchar(10)) + '' and error number '' + Cast(ERROR_NUMBER() as varchar(10))
			, [Notes] = @Notes
	WHERE ReportId = @@ReportId
--	RAISERROR (@ErrorMessage, 16, 10) WITH LOG
END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Fee_Add]''
');

GO
EXECUTE ('
/*
Developer	:	Lee Manifold
Date		:	24 Nov 2006
Description	:	Adds a new row to the ib_Fee table

Revision History:
*/
CREATE PROCEDURE [dbo].[ib_Fee_Add]
	(
	@TrxId			int,
	@FeeTypeId		int,
	@CurrencyId		int,
	@Amount			decimal(19,6),
	@@FeeId			int = Null OUTPUT 
	)
AS
SET NOCOUNT ON
	BEGIN TRY
		INSERT INTO [dbo].[ib_Fee]
			   (
				[TrxId]
			   ,[FeeTypeId]
			   ,[CurrencyId]
			   ,[Amount]
				)
		 VALUES
			   (
				@TrxId,			
				@FeeTypeId,		
				@CurrencyId,
				@Amount
				)

		SELECT @@FeeId = Scope_Identity()
	END TRY
	BEGIN CATCH
		EXEC [dbo].[sp_RethrowError]
	END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[C21_Purge]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[C21_Purge]
	(
	@LoadState		TINYINT = 0,
	@FileName       VARCHAR (512) = NULL
	)
AS
BEGIN
	--	15 Jun 2006		lm		Creation
	--	09 Mar 2010		kp		MBAL-14819: Tweak Loaders to Look at Filename. Modified the Purge 
	--							to take into account Filename so it doesn;t trip over other potential processes.
	--	10 Aug 2010		amk		MBAL-16415: Improve concurrency

	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
	--raiserror (''Lee doing specific raiserror in stored proc for testing'', 19, 1) with log

	-- DO NOT delete from the C21_Footer table since it has no filename field
	-- and we don''t want to step on another load

	DELETE FROM [dbo].[C21_Header] 
	WHERE LoadState = @LoadState 
		AND [FileName] = COALESCE(@FileName, [FileName])
	
	DELETE FROM [dbo].[C21_DetailLine] 
	WHERE LoadState = @LoadState 
		AND [FileName] = COALESCE(@FileName, [FileName])
	
	DELETE FROM [dbo].[C21_PreviousDayLine] 
	WHERE LoadState = @LoadState 
		AND [FileName] = COALESCE(@FileName, [FileName])
	
	DELETE FROM [dbo].[C21_ResumeLine] 
	WHERE LoadState = @LoadState 
		AND [FileName] = COALESCE(@FileName, [FileName])

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[Liffe_Position_Delete]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[Liffe_Position_Delete]
	(
	@Exchange		Varchar(3)
	)
AS
-- =============================================
-- Author:		Alister McLeod
-- Create date: 14 Dec 2012
-- Description:	Deletes from the Liffe_Position table by Exchange
-- Revision History:
-- ----------------
-- =============================================
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	DELETE 
	FROM	[dbo].[Liffe_Position] 
	WHERE	[Exchange] = @Exchange
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_RuleCondition_Update]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_RuleCondition_Update]
	 @ConditionId int,
     @InternalExternalCode CHAR(1) = null,
     @FieldId int = null,
     @OperatorId int = null,
     @Value nvarchar(100) = null,
     @SecondFieldId int = null,
     @Description nvarchar(255) = null,
     @IsEnabled bit = null,
     @UpdateUsername nvarchar(50) = null
AS
SET NOCOUNT ON
	SELECT @SecondFieldId = CASE @SecondFieldId WHEN -1 THEN NULL ELSE @SecondFieldId END
	SELECT
		@InternalExternalCode = CASE WHEN @InternalExternalCode IS NULL THEN InternalExternalCode ELSE @InternalExternalCode END
		,@FieldId = CASE WHEN @FieldId IS NULL THEN Field1Id ELSE @FieldId END
		,@OperatorId = CASE WHEN @OperatorId IS NULL THEN OperatorId ELSE @OperatorId END
		,@Value = CASE WHEN @Value IS NULL THEN Value ELSE @Value END
		--,@SecondFieldId = CASE WHEN @SecondFieldId IS NULL THEN Field2Id ELSE @SecondFieldId END
		,@Description = CASE WHEN @Description IS NULL THEN Description ELSE @Description END
		,@IsEnabled = CASE WHEN @IsEnabled IS NULL THEN IsEnabled ELSE @IsEnabled END
		,@UpdateUsername = CASE WHEN @UpdateUsername IS NULL THEN USER_NAME() ELSE @UpdateUsername END
	FROM
		ib_RuleCondition
	WHERE
		RuleConditionId = @ConditionId
		
	UPDATE
		ib_RuleCondition
	SET
		InternalExternalCode = @InternalExternalCode
		,Field1Id = @FieldId
		,OperatorId = @OperatorId
		,Value = @Value
		,Field2Id = @SecondFieldId
		,Description = @Description
		,IsEnabled = @IsEnabled
		,UpdateUsername = @UpdateUsername
		,[UpdateDate] = getdate()
	WHERE
		RuleConditionId = @ConditionId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[vw_Assembly]''
');

GO
EXECUTE ('CREATE VIEW [dbo].[vw_Assembly]
AS
SELECT *, CAST(CASE WHEN [Bin] IS NULL THEN 0 ELSE 1 END AS BIT) AS IsStored
	 FROM ib_Assembly;


');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_InstrumentType_GetInstrumentTypeById]''
');

GO
EXECUTE ('   /*
<details>
 <summary> Selectes an instrument type from the ib_InstrumentType table by its id</summary>
 <created author="Laurentiu Macovei" Date="Tuesday, 12 September 2006 9:34PM GMT" /> 
</details>
*/
create PROCEDURE [dbo].[ib_InstrumentType_GetInstrumentTypeById]
(
	@InstrumentTypeId int
)
AS 
SET NOCOUNT ON


SELECT [InstrumentTypeId]
      ,[Code]
      ,[Name]
      ,[CreateDate]
      ,[CreateUsername]
      ,[UpdateDate]
      ,[UpdateUsername]
  FROM [dbo].[ib_InstrumentType]
WHERE InstrumentTypeId = @InstrumentTypeId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_is_G_FuturesSub]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_is_G_FuturesSub]
(
[ib_is_G_FuturesSubId] [int] NOT NULL IDENTITY(1, 1),
[FuturesSubId] [varchar] (3) NOT NULL,
[Description] [varchar] (50) NOT NULL,
[InstrumentTypeCode] [varchar] (1) NOT NULL,
[OptionTypeCode] [varchar] (1) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_ib_is_G_FuturesSub] on [dbo].[ib_is_G_FuturesSub]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_is_G_FuturesSub] ADD CONSTRAINT [PK_ib_is_G_FuturesSub] PRIMARY KEY CLUSTERED  ([ib_is_G_FuturesSubId])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_is_InstrumentTypeDataSource_GetByCode]''
');

GO
EXECUTE ('
-- =============================================
-- Author:		Lee Manifold
-- Create date: 08 Nov 2006
-- Description:	Retrieves InstrumentTypeCode from ib_is_G_FuturesSub
-- =============================================
CREATE proc [dbo].[ib_is_InstrumentTypeDataSource_GetByCode]
	(
	@tmpFuturesSubID	int,
	@InstrumentTypeCode int Output
	)

AS
SET NOCOUNT ON

	SELECT	@InstrumentTypeCode = InstrumentTypeCode

	FROM	[dbo].[ib_is_G_FuturesSub]
	
	WHERE	[FuturesSubId] = @tmpFuturesSubID
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_is_G_Load]''
');

GO
EXECUTE ('
/*
Developer:  Lee Manifold
Date:		01 Aug 2006

Description:  This stored procedure pulls data from the is_g type
table and inserts it into the ib_Position ./ ib_trx table.  Also, any
new values encountered for firm, account, instrument, and currency create
new values in the lookups, as well as new values in the data tables for
these values.

Whilst iterating through the records in is_G, all 
of these inserts are wrapped in a transaction so that any failure causes
the changes to not commit.

Revision History:
16 Jul 2009	AAJM	Update to account for new DetailAccountId column in ib_Trx table
22 Apr 2010	AAJM	MBAL-14741 Add PositionId as output parameter
09 Jan 2014 ED		EIB 25004 - remove importLog table and use Log table

*/
CREATE PROCEDURE [dbo].[ib_is_G_Load]
	(
	@LocationPath		VARCHAR(100)
	)
AS
SET NOCOUNT ON

	/*
	Logic:  Get all the Positional data. Update the Production tables
			Get all the Transactional data. Updat the Production tables
	*/
	DECLARE @DataSourceCd		varchar(100)
	DECLARE @TrxTypePos			varchar(4)

	SET @DataSourceCd = ''i-Star''
	--SET @TrxTypePos = ''OPN''

	BEGIN TRAN T1

		DECLARE @tmpID					int
		DECLARE	@tmpMarketCode			varchar(2)		 
		DECLARE	@tmpCorporationCode		varchar(4)
		DECLARE	@tmpACNumber			varchar(10)
		DECLARE	@tmpBaseDate			datetime
		DECLARE	@tmpDerivativesCode		varchar(10)
		DECLARE	@tmpQuantity			decimal(15,0)
		DECLARE	@tmpRealizedPLSigned	decimal(15,0)
		DECLARE	@tmpContractMonth		varchar(7)
		DECLARE	@tmpStrikePrice			decimal(11,4)
		DECLARE	@tmpFuturesSubId		varchar(3)			
		DECLARE	@tmpBuySellContractId	varchar(2)
		DECLARE @Started				bit			

		DECLARE @DefaultCurrencyId				int
		DECLARE @ExchangeCd						varchar(25)
		DECLARE @FirmCd							varchar(100)
		DECLARE @AccountCd						varchar(100)
		DECLARE @AsOfDate						datetime
		DECLARE @InstrumentCd					varchar(100)
		DECLARE @QuantityPS						decimal(18,10)
		DECLARE @MarketValue					decimal(19,4)
		DECLARE @ExpiryDate						datetime
		DECLARE @StrikePrice					decimal(19,4)
		DECLARE @TrxTypeCd						varchar(25)
		DECLARE @OptionTypeCd					varchar(25)
		DECLARE @QuantityTR						decimal(18,10)
		DECLARE @TrxDate						datetime
		DECLARE @Price							decimal(19,4)
		DECLARE @ExpYr							smallint
		DECLARE @ExpMth							smallint
		DECLARE @ExpDay							smallint
		DECLARE	@InstrumentTypeCd				varchar(100)
		DECLARE @InstrumentTypeCode				varchar(1)
		DECLARE @ReturnValue					int
		DECLARE @DataSourceId					int
		DECLARE @InstrumentTypeId				int
		DECLARE @CurrencyId						int
		DECLARE @OptionTypeCode					varchar(1)
		DECLARE @TradedLongQuantity				decimal(19,4)
		DECLARE @TradedShortQuantity			decimal(19,4)
		DECLARE @LongQuantity					decimal(19,4)
		DECLARE @ShortQuantity					decimal(19,4)
		DECLARE @CurrencyCode					varchar(100)



		SET @Started = 0

		DECLARE		pos_cursor CURSOR FOR
		SELECT		[GUnclosedContractDetailsId],
					[MarketCode],
					[CorporationCode],
					[ACNumber],
					[BaseDate],
					[DerivativesCode],
					[Quantity],
					[RealizedPLSigned],
					[ContractMonth],
					[StrikePrice],
					[FuturesSubId],
					[BuySellContractId],
					[FuturesSubId]

		FROM		[dbo].[is_GUnclosedContractDetails]		
		WHERE		[LoadState] = 1


		OPEN pos_cursor

		FETCH NEXT FROM pos_cursor
		INTO	
			@tmpID,					
			@tmpMarketCode,		 
			@tmpCorporationCode,
			@tmpACNumber,
			@tmpBaseDate,
			@tmpDerivativesCode,
			@tmpQuantity,
			@tmpRealizedPLSigned,
			@tmpContractMonth,
			@tmpStrikePrice,
			@tmpFuturesSubId,
			@tmpBuySellContractId,
			@tmpFuturesSubId

		-- Check @@FETCH_STATUS to see if there are any more rows to fetch.
		WHILE @@FETCH_STATUS = 0
		BEGIN


			--specify datasource in proc.
			IF @Started = 0
			BEGIN
				--Gets the DataSource and DefaultCurrencyId values
				EXEC @ReturnValue = [dbo].[_ib_DataSource_GetByCodeForOutput] @DataSourceCd, @DataSourceId output, @DefaultCurrencyId output	
				SET @started = 1
			END

			--Get the DataSourceInstrumentTypeCode from the lookup table ib_is_G_Futures_Sub
			EXEC @ReturnValue = ib_is_InstrumentTypeDataSource_GetByCode @tmpFuturesSubID, @InstrumentTypeCode Output

			--***Not sure where this is used ??? @tmpDerivativesCode
			--Gets the InstrumentTypeId
			EXEC @ReturnValue = [dbo].[ib_Instrumenttype_AddAsNeeded] @DataSourceId, @InstrumentTypeCode, @InstrumentTypeId output
						
			--*** Code here to look up Derivatives
			Declare @InstrumentCode	varchar(100)
			Declare @instrumentId	int
			--Sets the InstrumentId and the CurrencyId
			EXEC @ReturnValue= [ib_Instrument_AddAsNeeded] @DataSourceId,@InstrumentTypeId,@InstrumentCode,@CurrencyId, @InstrumentId output, @CurrencyId output	
			IF @CurrencyId IS NULL SET @CurrencyId = @DefaultCurrencyId
			

			SET @ExchangeCd			= @tmpMarketCode
			SET @FirmCd				= @tmpCorporationCode
			SET @AccountCd			= @tmpACNumber
			SET @AsOfDate			= @tmpBaseDate
			SET @TrxTypeCd			= ''UNCLOSED CONTRACT''
			SET @MarketValue		= @tmpRealizedPLSigned
			SET @ExpYr				= LEFT(@tmpContractMonth,4)
			SET @ExpMth				= RIGHT(@tmpContractMonth,2)
			SET @ExpDay				= 0
			SET @StrikePrice		= @StrikePrice
			SET @OptionTypeCode		= @InstrumentTypeCode
			SET @TrxDate			= NULL
			SET @Price				= NULL
			SET @InstrumentTypeCd	= NULL
			SET @CurrencyCode	= NULL
			SET @TradedLongQuantity = NULL
			SET @TradedShortQuantity= NULL

			IF @tmpBuySellContractId = ''20'' 
				SET @QuantityPS		= CAST(@tmpQuantity  AS decimal(18,10)) * -1			
			ELSE
				SET @QuantityPS = CAST(@tmpQuantity  AS decimal(18,10))
					
			--*** Do we use the -ve or +ve Quantity here?
			IF @tmpBuySellContractId = ''10''	
				BEGIN
					SET @LongQuantity	= @tmpQuantity 
					SET @ShortQuantity = 0
				END
			ElSE
				BEGIN
					SET @LongQuantity = 0
					SET @ShortQuantity = @tmpQuantity
				END

		
			--SET @InstrumentCd		= ?
			DECLARE @PositionId INT
			SET @PositionId = NULL
						
			EXEC	[dbo].[ib_Position_Load]
					@DataSourceCd,
					@ExchangeCd,
					@FirmCd,
					@AccountCd,	
					@AsOfDate,
					@InstrumentCd,
					@QuantityPS,
					@MarketValue,
					@ExpYr,
					@ExpMth,
					@ExpDay,
					@StrikePrice,
					@TrxTypeCd,
					@OptionTypeCd,
					@TrxDate,
					@Price,
					@tmpID,
					@InstrumentTypeCd,
					@LocationPath,
					@CurrencyCode,
					@LongQuantity,		
					@ShortQuantity,			 
					@TradedLongQuantity,	
					@TradedShortQuantity,
					@PositionId = @PositionId OUTPUT
			
			--flip processed flag in source table.
			
			UPDATE	[dbo].[is_GUnclosedContractDetails]
			SET		[LoadState] = 2
			WHERE	[GUnclosedContractDetailsId] = @tmpID
			AND		[LoadState] = 1

			FETCH NEXT FROM pos_cursor
			INTO 
				@tmpID,					
				@tmpMarketCode,		 
				@tmpCorporationCode,
				@tmpACNumber,
				@tmpBaseDate,
				@tmpDerivativesCode,
				@tmpQuantity,
				@tmpRealizedPLSigned,
				@tmpContractMonth,
				@tmpStrikePrice,
				@tmpFuturesSubId,
				@tmpBuySellContractId,
				@tmpFuturesSubId
		END

		CLOSE pos_cursor
		DEALLOCATE pos_cursor

	COMMIT TRAN T1

	DROP TABLE #TempPos
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_CurrencyDataSource_GetCurrencyDataSourceById]''
');

GO
EXECUTE (' /*
<details>
 <summary> Selectes a currency data source from the ib_CurrencyDataSource table by its id</summary>
 <created author="Laurentiu Macovei" Date="Tuesday, 12 September 2006 3:11AM GMT" /> 
</details>
*/
create PROCEDURE [dbo].[ib_CurrencyDataSource_GetCurrencyDataSourceById]
(
	@CurrencyDataSourceId int
)
AS
SET NOCOUNT ON

SELECT cds.[CurrencyDataSourceId]
      ,cds.[CurrencyId]
	  ,c.[Code] as CurrencyCode
      ,cds.[DataSourceId]
	  ,ds.[Name] as DataSourceName
      ,cds.[DataSourceCurrencyCode]
      ,cds.[CreateDate]
      ,cds.[CreateUsername]
      ,cds.[UpdateDate]
      ,cds.[UpdateUsername]
FROM [dbo].[ib_CurrencyDataSource] cds
INNER JOIN [dbo].[ib_Currency] c ON c.[CurrencyId] = cds.[CurrencyId]
INNER JOIN [dbo].[ib_DataSource] ds ON ds.[DataSourceId] = cds.[DataSourceId]
WHERE CurrencyDataSourceId = @CurrencyDataSourceId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[C21_ResumeLine_Add]''
');

GO
EXECUTE ('
-- =============================================
-- Author:		Lee Manifold
-- Create date: 09 May 2006
-- Description: Biztalk: Clearing 21 insert into table 10000
--
-- Revision History
-- 
-- 18.05.09	Konrad Added BusinessDate field  
-- 19 Feb 2010 - Added FileName to Add SP
-- =============================================
CREATE PROCEDURE [dbo].[C21_ResumeLine_Add]
	-- Add the parameters for the stored procedure here
	(
	@FileName            VARCHAR (512) = NULL,
	@OrgID					varchar(5),
	@TMF					varchar(10),
    @PA15					varchar(15),
    @Guarantee				varchar(1),
    @SettlementDate			varchar(8),
    @ContractAliasName		varchar(3),
    @ContractAliasExp1		varchar(1),
    @ContractAliasExp2		varchar(1),
    @ContractAliasExp3		varchar(1),
    @ContractAliasExp4		varchar(1),
    @ContractAliasStrike	 varchar(8),
    @ContractAliasCPF		varchar(1),
    @OPEBuyIFT				varchar(1),
    @OPEBuyQMT				varchar(18),
    @OPESellIFT				varchar(1),
    @OPESellQMT				varchar(18),
    @OPEIFTCredit			varchar(1),
    @OPEQMTCredit			varchar(18),
	@OPEIFTDebit			varchar(1),
	@OPEQMTDebit			varchar(18),
	@POSBuy					varchar(18),
    @POSSell				varchar(18),
    @POSIFTDebit			varchar(1),
    @POSQMTDebit			varchar(18),
    @POSIFTCredit			varchar(1),
    @POSQMTCredit			varchar(18),
    @LIQBuy					varchar(14),
    @LIQSell				varchar(14),
    @LIQIFTPrice			varchar(1),
    @LIQQMTPrice			varchar(18),
    @LIQIFTDebit			varchar(1),
    @LIQQMTDebit			varchar(18),
    @LIQIFTCredit			varchar(1),
    @LIQQMTCredit			varchar(18),
    @DCIND					varchar(1),
    @IFTMargin				varchar(1),
    @QMTMargin				varchar(18),
	@BusinessDate			varchar(8)
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON

INSERT INTO [dbo].[C21_ResumeLine]
           (
			[OrgID]
		   ,[TMF]
           ,[PA15]
           ,[Guarantee]
           ,[SettlementDate]
           ,[ContractAliasName]
           ,[ContractAliasExp1]
           ,[ContractAliasExp2]
           ,[ContractAliasExp3]
           ,[ContractAliasExp4]
           ,[ContractAliasStrike]
           ,[ContractAliasCPF]
           ,[OPEBuyIFT]
           ,[OPEBuyQMT]
           ,[OPESellIFT]
           ,[OPESellQMT]
           ,[OPEIFTCredit]
           ,[POSBuy]
           ,[POSSell]
           ,[POSIFTDebit]
           ,[POSQMTDebit]
           ,[POSIFTCredit]
           ,[POSQMTCredit]
           ,[LIQBuy]
           ,[LIQSell]
           ,[LIQIFTPrice]
           ,[LIQQMTPrice]
           ,[LIQIFTDebit]
           ,[LIQQMTDebit]
           ,[LIQIFTCredit]
           ,[LIQQMTCredit]
           ,[DCIND]
           ,[IFTMargin]
           ,[QMTMargin]
		   ,[BusinessDate]
		   ,[FileName]	
			)
     VALUES
           (
			@OrgID					,
			@TMF					,
			@PA15					,
			@Guarantee				,
			@SettlementDate			,
			@ContractAliasName		,
			@ContractAliasExp1		,
			@ContractAliasExp2		,
			@ContractAliasExp3		,
			@ContractAliasExp4		,
			@ContractAliasStrike	,
			@ContractAliasCPF		,
			@OPEBuyIFT				,
			@OPEBuyQMT				,
			@OPESellIFT				,
			@OPESellQMT				,
			@OPEIFTCredit			,
			@POSBuy					,
			@POSSell				,
			@POSIFTDebit			,
			@POSQMTDebit			,
			@POSIFTCredit			,
			@POSQMTCredit			,
			@LIQBuy					,
			@LIQSell				,
			@LIQIFTPrice			,
			@LIQQMTPrice			,
			@LIQIFTDebit			,
			@LIQQMTDebit			,
			@LIQIFTCredit			,
			@LIQQMTCredit			,
			@DCIND					,
			@IFTMargin				,
			@QMTMargin				,
			@BusinessDate			,
			@FileName
			)
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_ScheduledTask_AddQueueLogItem]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_ScheduledTask_AddQueueLogItem]
	@message nvarchar(300),
	@level int,
	@category int,
	@queueItemId int
AS
SET NOCOUNT ON
	INSERT INTO 
		ib_QueueLog (Message, Level, Category, QueueItemId, CreatedOn) 
	VALUES 
		(@message,@level,@category,@queueItemId, getdate())
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_InstrumentType_GetUsed]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_InstrumentType_GetUsed]
AS
SET NOCOUNT ON
-- Description: get used instrument types
-- 07 May 2014	ED	EIB 25601 - Created

	SELECT Code, InstrumentTypeId FROM ib_InstrumentType 
		WHERE InstrumentTypeId IN (SELECT DISTINCT InstrumentTypeId FROM ib_Instrument WHERE IsActive = 1)
	ORDER BY Code
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_GetBusinessDate]''
');

GO
EXECUTE ('-- =============================================
-- Author:		Lee Manifold
-- Create date: 27 Nov 2006
-- Description:	Pulls back a Businessdate for the file depending
--				on the date the file was submitted. 		
-- Revision History:
-- 21 Apr 2010	amk		MBAL-15365: get as of date from filename rather than current date
-- 22 Apr 2010	amk		MBAL-15365: Forgot to specify style on convert to datetime
-- =============================================
CREATE PROCEDURE [dbo].[ib_GetBusinessDate]
	(
		@Filename VARCHAR(100)
		, @AsofDate DATETIME OUTPUT
	)
AS
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
	BEGIN TRY
		-- first try and extract date from filename
		DECLARE @BaseFilename VARCHAR(100)
		DECLARE @DayFromFilename VARCHAR(2)
		DECLARE @MonthFromFilename VARCHAR(2)
		DECLARE @NumericMonthFromFilename INT
		DECLARE @Year INT
		DECLARE @BackslashPosition INT
		DECLARE @NewBackslashPosition INT
		SET @BackslashPosition = 1
		SET @NewBackslashPosition = 1

		-- find last backslash in filename
		WHILE @NewBackslashPosition <> 0
		BEGIN
			SET @BackslashPosition = @NewBackslashPosition
			SET @NewBackslashPosition = CHARINDEX(''\'', @Filename, @BackslashPosition + 1)
		END
		SET @BaseFilename = RIGHT(@Filename, LEN(@Filename) - @BackslashPosition)

		SET @DayFromFilename = SUBSTRING(@BaseFilename, 5, 2)
		SET @MonthFromFilename = SUBSTRING(@BaseFilename, 7, 2)
		SET @NumericMonthFromFilename = CONVERT(INT, @MonthFromFilename)

		IF @NumericMonthFromFilename <= MONTH(GETDATE())
			SET @Year = YEAR(GETDATE())
		ELSE
			SET @Year = YEAR(GETDATE()) - 1

		SET @AsofDate = CONVERT(DATETIME, @MonthFromFilename + ''/'' + @DayFromFilename + ''/'' + CONVERT(VARCHAR(4), @Year), 101)
	END TRY
	BEGIN CATCH
		-- fall back to current date
		SET @AsofDate =	DATEADD(dd, -1, GETDATE())  		
		IF DATENAME(Weekday, @AsofDate) = ''Saturday'' 
			SET @AsOfDate = DATEADD(dd, -1, @AsOfDate)
		IF DATENAME(Weekday, @AsofDate) = ''Sunday'' 
			SET @AsOfDate = DATEADD(dd, -2, @AsOfDate)
	END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_LCH_TypeNT_Load]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_LCH_TypeNT_Load]
	@LocationPath VARCHAR(100)
AS
SET NOCOUNT ON
	--	23 Mar 2010		amk		Creation
	--	27 Apr 2010		amk		Continue work
	--	28 Apr 2010		amk		Continue work
	--  29 Apr 2010		AAJM	MBAL-15310: Ensure IPE/ICE uses Physical Commodity Field in new Instrument Code
	--  21 Jun 2010     ED		MBAL-15877 - invers quantity in case of transfer records
	--  21 Jun 2010     ED		MBAL-15878 - Get TrxType=''J'' too(Expiry Slip Type)
	--  22 Jun 2010     ED      MBAL-15879 - Correct Option Exercise and Assignment Records(A,E)
	--  06 Jul 2010     ED		MBAL-15878 - invers sign in case of Result of Exercise or Alocations(H/R)
	--	07 Jul 2010		ED		MBAL-16041 2a), 2b) - invers A/E volume
	--  07 Jul 2010		ED		MBAL-16089	- invers quantity sign in case of ''B'' - delete, too
	--	19 Aug 2010		amk		MBAL-16476 ignore action flag of E or R
	--							MBAL-16462 don''t import type T (transfer) where action flag is D (delete)
	--	01 Aug 2012		ED		MBAL-21230: add row to importFile table
	--  09 Jan 2014		ED		EIB 25004 - remove importLog table and use Log table
	--  14 May 2014		ED		EIB 25636 - pass LocationPath to ib_trx_load

	DECLARE @DataSourceCd VARCHAR(100)
	DECLARE @DataSourceId INT
	DECLARE @Code VARCHAR(100)
	DECLARE @ReturnValue INT
	DECLARE @Output INT 
	DECLARE @Output2 INT
	DECLARE @DefaultCurrencyId INT
			
	--specify datasource in proc.
	SET @DataSourceCd = ''LCH''

	SET @Code = @DataSourceCd
	EXEC @ReturnValue= [_ib_DataSource_GetByCodeForOutput] @Code, @OutPut OUTPUT, @Output2 OUTPUT
	SET @DataSourceId = @Output
	SET @DefaultCurrencyId = @Output2	

	UPDATE LCH_TypeNT
	SET LoadState = 1
	WHERE LoadState = 0
		AND Filename = @LocationPath

	-- Duplicate file check										
	DECLARE @IsFileAlreadyLoaded INT
	EXEC @IsFileALreadyLoaded = HasFileBeenLoaded @LocationPath, @DataSourceId

	IF @IsFileAlreadyLoaded = 1
		BEGIN					
			UPDATE [dbo].[LCH_TypeNT]
			SET [LoadState] = 3
			WHERE [LoadState] = 1
				AND [FileName] = @LocationPath		
			RETURN
		END
	DECLARE @ImportFileId INT
	EXEC ib_ImportFile_Add @DataSourceId, @LocationPath, @ImportFileId output	
	DECLARE @SelectedAsOfDate DATETIME	
	EXEC [ib_GetBusinessDate] @LocationPath, @SelectedAsOfDate OUTPUT
	UPDATE ib_ImportFile SET AsOfDate= @SelectedAsOfDate WHERE ImportFileId=@ImportFileId
	--creating Temp Table just for use in this process
	--for iterating through the records.
	CREATE TABLE #temp1
	(
	LCH_TypeNTID INT,
	Exchange VARCHAR(3),
	OriginatingMemberName VARCHAR(3),
	AccountCode VARCHAR(1), 	
	PhysicalCommodity VARCHAR(3),
	ContractType VARCHAR(1),
	GenericContractType VARCHAR(1),
	LongExpiryDate VARCHAR(8),
	ExercisePrice VARCHAR(9),
	Volume VARCHAR(11),
	LongOrShort VARCHAR(1),
	Price VARCHAR(9),
	TradingDayOfTrade VARCHAR(6),
	NotificationSlipType VARCHAR(1),
	TradingDay VARCHAR(6)
	)

	INSERT INTO #temp1
	(
	LCH_TypeNTID,
	Exchange,
	OriginatingMemberName,
	AccountCode,
	PhysicalCommodity,
	ContractType,
	GenericContractType,
	LongExpiryDate,
	ExercisePrice,
	Volume,
	LongOrShort,
	Price,
	TradingDayOfTrade,
	NotificationSlipType,
	TradingDay
	)
	SELECT 
		LCH_TypeNTID,
		Exchange,
		OriginatingMemberName,
		AccountCode,
		PhysicalCommodity,
		ContractType,
		GenericContractType,
		LongExpiryDate,
		ExercisePrice,
		VolumeToAdjust,
		LongOrShort,
		ValuationPrice,
		TradingDayOfTrade,
		NotificationSlipType,
		TradingDay
	FROM [dbo].[lch_typent]
	WHERE LoadState = 1
		AND [FileName] = @LocationPath
		AND (
			NotificationSlipType IN (''A'', ''B'', ''E'', ''T'')
			OR (NotificationSlipType IN (''H'', ''R'') AND GenericContractType <> ''Z'')
			OR (NotificationSlipType = ''J'' AND GenericContractType <> ''Z'' AND VolumeToAdjust != 0)
			)
		AND (actionflag NOT IN (''E'', ''R'') OR actionflag IS NULL)
		AND NOT (NotificationSlipType = ''T'' AND actionflag = ''D'')

	BEGIN TRANSACTION t1

	-- BizTalk''s SQL Adapter uses more restrictive read serializable
	-- so this is necessary to relax it to something that is default
	-- and perfectly acceptable!
	SET TRANSACTION ISOLATION LEVEL READ COMMITTED

	DECLARE 
		@LCH_TypeNTID INT,
		@Exchange VARCHAR(100),
		@OriginatingMemberName VARCHAR(100),
		@AccountCode VARCHAR(100),
		@PhysicalCommodity VARCHAR(100),
		@ContractType VARCHAR(100),
		@GenericContractType VARCHAR(100),
		@LongExpiryDate VARCHAR(25),
		@ExercisePrice DECIMAL(19,4),
		@Volume DECIMAL(18,10),
		@LongOrShort VARCHAR(100),
		@Price VARCHAR(9),
		@TradingDayOfTrade VARCHAR(6),
		@NotificationSlipType VARCHAR(1),
		@TradingDay VARCHAR(6)

    DECLARE @MarexFirmId INT
    SET @MarexFirmId = [dbo].[udf_GetMarexFirmId]()

	DECLARE trx_cursor CURSOR FOR
	SELECT LCH_TypeNTID,
		Exchange,
		OriginatingMemberName,
		AccountCode,
		PhysicalCommodity,
		ContractType,
		GenericContractType,
		LongExpiryDate,
		ExercisePrice,
		Volume,
		LongOrShort,
		Price,
		TradingDayOfTrade,
		NotificationSlipType,
		TradingDay
	FROM #temp1

	OPEN trx_cursor

	-- Perform the first fetch and store the values in variables.
	-- Note: The variables are in the same order as the columns
	-- in the SELECT statement. 

	FETCH NEXT FROM trx_cursor
	INTO @LCH_TypeNTID,
	@Exchange,
	@OriginatingMemberName,
	@AccountCode,
	@PhysicalCommodity,
	@ContractType,
	@GenericContractType,
	@LongExpiryDate,
	@ExercisePrice,
	@Volume,
	@LongOrShort,
	@Price,
	@TradingDayOfTrade,
	@NotificationSlipType,
	@TradingDay

	-- Check @@FETCH_STATUS to see if there are any more rows to fetch.
	WHILE @@FETCH_STATUS = 0
	BEGIN
		
		DECLARE @ExchangeCd varchar(25)
		DECLARE @FirmCd varchar(100)
		DECLARE @AccountCd varchar(100)
		DECLARE @InstrumentTypeCd VARCHAR(100)
		DECLARE @InstrumentCd varchar(100)
		DECLARE @ExpYr smallint
		DECLARE @ExpMth smallint
		DECLARE @ExpDay smallint
		DECLARE @StrikePrice decimal(19,4)
		DECLARE @TrxTypeCd varchar(25)
		DECLARE @OptionTypeCd varchar(25)
		DECLARE @Quantity decimal(18,10)
		DECLARE	@QuantityLong int
		DECLARE @QuantityShort int
		DECLARE @TrxDate datetime
		DECLARE @PriceDec decimal(24,10)
		DECLARE @AsOfDate datetime

		SET @ExchangeCd = @exchange
		
		SET @Output = null
		DECLARE @InstrumentTypeId INT
		SET @InstrumentTypeCd = RTRIM(@genericcontracttype)
		EXEC @ReturnValue = ib_Instrumenttype_AddAsNeeded @DataSourceId, @InstrumentTypeCd, @OutPut OUTPUT
		SET @InstrumentTypeId = @Output

		DECLARE @CurrencyId INT

		SET @Output = null
		SET @Output2 = null
		DECLARE @InstrumentId int
		
		-- MBAL-15310 Update the Instrument code
		SET @InstrumentCd = @InstrumentTypeCd + ''_'' + @ExchangeCd + ''_'' + @PhysicalCommodity
			
		EXEC @ReturnValue= [ib_Instrument_AddAsNeeded] @DataSourceId, @InstrumentTypeId
			,@InstrumentCd, @CurrencyId, @OutPut OUTPUT, @Output2 OUTPUT
		SET @InstrumentId = @Output
		SET @CurrencyId = @Output2
		IF @Output2 = NULL
			SET @CurrencyId = @DefaultCurrencyId

		DECLARE @TickSize int
		SELECT @TickSize = ticksize 
		FROM ib_instrument 
		WHERE instrumentid = @InstrumentId

		SET @FirmCd = @originatingmembername
		SET @AccountCd = @accountcode
		
		DECLARE @StrikePriceDivisor DECIMAL(19,4)
		DECLARE @PriceDivisor DECIMAL(19,4)

		SET @StrikePriceDivisor = NULL
		SET @PriceDivisor = NULL
		
		SELECT @StrikePriceDivisor = StrikePriceDivisor
			, @PriceDivisor = PriceDivisor
		FROM [dbo].[ib_InstrumentDataSource]
		WHERE DataSourceId = @DataSourceId
			AND DataSourceInstrumentCode = @InstrumentCd 

		IF @PriceDivisor IS NULL 
			SET @PriceDivisor = 1
			
		IF @NotificationSlipType  IN (''J'', ''A'', ''E'')
			SET @PriceDec = 0
		ELSE	
			SET @PriceDec = CONVERT(DECIMAL(24, 10), @Price) / @PriceDivisor

		IF @StrikePriceDivisor IS NULL -- Then get the default
			BEGIN
				DECLARE @ExchangeId INT
				SELECT @ExchangeId = ExchangeId 
				FROM ib_Exchange 
				WHERE [Code] = @ExchangeCd
				
				SET @StrikePriceDivisor = [dbo].[udf_GetDefaultStrikePriceDivisor](@DataSourceId, @ExchangeId)
			END

		SET @StrikePrice = (@ExercisePrice/@StrikePriceDivisor)
		
		SET @TrxTypeCd = @NotificationSlipType
		SET @OptionTypeCd = @contracttype
		EXEC [ib_GetBusinessDate] @LocationPath, @AsOfDate OUTPUT

		SET @TrxDate = DATEADD(d
			, (CONVERT(INT, @TradingDay) - CONVERT(INT, @TradingDayOfTrade)) * -1
			, @AsOfDate
			)
		--  	MBAL-15877 - invers quantity in case of transfer records
		--		MBAL 15878 - invers quantity in case of Result of allocation/exercise (H/R)
		--		MBAL 16041 2a), 2b) - invers A/E volume
		--		MBAL 16089	- invers quantity sign in case of ''B'' - delete, too
		IF @NotificationSlipType IN (''T'', ''J'', ''H'', ''R'', ''A'', ''E'', ''B'')
			SET @volume = @volume * -1
		
		SET @Quantity = @volume
		
		IF (@LongOrShort = ''L'')
		BEGIN
			SET @QuantityLong = @volume 
			SET @QuantityShort = 0
		END
		ELSE
		BEGIN
			SET @QuantityLong = 0
			SET @QuantityShort = @volume
		END
		
		SET @ExpYr = LEFT(@LongExpiryDate,4)
		SET @ExpMth = SUBSTRING(@LongExpiryDate,5,2)
		SET @ExpDay = RIGHT(@LongExpiryDate,2)
		SET @ExpDay = dbo.udf_OnLoad_ExpiryDate_Get_Day(@ExpYr, @ExpMth, @ExpDay)

		EXEC [ib_Trx_Load]
		@DataSourceCd,
		@ExchangeCd,
		@FirmCd,
		@AccountCd,
		NULL,
		@InstrumentCd,
		@ExpYr,
		@ExpMth,
		@ExpDay,
		@StrikePrice,
		@TrxTypeCd,
		@OptionTypeCd,
		@Quantity,
		@TrxDate,
		@PriceDec,
		@LCH_TypeNTID,
		@GenericContractType,
		@AsOfDate,
		@LocationPath = @LocationPath,
		@MarexFirmId = @MarexFirmId,
		@QuantityLong = @QuantityLong,
		@QuantityShort = @QuantityShort

		--flip processed flag in source table.
		UPDATE LCH_TypeNT
		SET LoadState = 2
		WHERE LCH_TypeNTID = @LCH_TypeNTID
			AND LoadState = 1

		FETCH NEXT FROM trx_cursor
		INTO @LCH_TypeNTID,
		@Exchange,
		@OriginatingMemberName,
		@AccountCode,
		@PhysicalCommodity,
		@ContractType,
		@GenericContractType,
		@LongExpiryDate,
		@ExercisePrice,
		@Volume,
		@LongOrShort,
		@Price,
		@TradingDayOfTrade,
		@NotificationSlipType,
		@TradingDay
	END

	CLOSE trx_cursor
	DEALLOCATE trx_cursor

	COMMIT TRANSACTION t1

	DROP TABLE #temp1

RETURN 0
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Firm_Delete]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Firm_Delete]
(
	@FirmId int
)
AS
SET NOCOUNT ON

-- Deletes a firm by its id from the ib_Firm table

--	10 Sep 2006		laurentiu		create
--	15 Jul 2010		amk				MBAL-16177: Cascade delete to child tables

	BEGIN TRANSACTION

	BEGIN TRY
		DELETE FROM [dbo].[ib_Account]
			WHERE FirmId = @FirmId

		DELETE FROM [dbo].[ib_FirmDataSource]
			WHERE FirmId = @FirmId

		DELETE FROM [dbo].[ib_Firm]
			WHERE FirmId = @FirmId
			
		COMMIT TRANSACTION
	END TRY
	BEGIN CATCH
		ROLLBACK TRANSACTION
		EXEC [dbo].[sp_RethrowError] ''Firm is currently in use.''	
	END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[Config_GetValueForKey]''
');

GO
EXECUTE ('
-- =============================================
-- Author:		Petru Konrad Bercea
-- Create date: 02 March 2009
-- Description:	Retrieve the Value for the Key
-- =============================================

CREATE proc [dbo].[Config_GetValueForKey]
	(	
	@KeyCode				nvarchar(50)
	)
AS
SET NOCOUNT ON

	SELECT	[cfg].Value 
	FROM	[dbo].[Config] AS [cfg]
	WHERE	[cfg].[Key] = @KeyCode
');

GO
EXECUTE ('PRINT N''Creating [dbo].[Liffe_Position_Purge]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[Liffe_Position_Purge]
(
	@LoadState		TINYINT = 0,
	@FileName       VARCHAR (512)= NULL
)
AS
-- =============================================
-- Author:		Alister McLeod
-- Create date: 14 Dec 2012
-- Description:	Deletes from all Position type files where the LoadState is 0
-- Revision History:
-- ----------------
-- =============================================
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
	DELETE FROM [dbo].[Liffe_Position] WHERE LoadState= @LoadState AND [FileName] = Coalesce(@FileName, [FileName])
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_ScheduledTask_Delete]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_ScheduledTask_Delete]
	@scheduledTaskId int
	
AS
SET NOCOUNT ON
	DELETE FROM ib_ScheduledTask WHERE ScheduledTaskId = @scheduledTaskId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_InstrumentType_Update]''
');

GO
EXECUTE (' /*
<details>
 <summary>Updates an instrument type from the ib_InstrumentType table by its id</summary>
 <created author="Laurentiu Macovei" Date=" Sunday, 10 September 2006 2:26PM GMT" /> 
</details>
*/
create PROCEDURE [dbo].[ib_InstrumentType_Update]
(
	@InstrumentTypeId int,
	@Code varchar(100),
	@Name varchar(100),
    @UpdateUsername varchar(50)
)

AS 
SET NOCOUNT ON

UPDATE [dbo].[ib_InstrumentType]
   SET [Code] = @Code,
       [Name] = @Name,
       [UpdateUsername] = @UpdateUsername
 WHERE InstrumentTypeId = @InstrumentTypeId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_LCH_TypePS_0101_Load]''
');

GO
EXECUTE ('CREATE procedure [dbo].[ib_LCH_TypePS_0101_Load]
(
	@LocationPath	varchar(100) = NULL
)
/*
Developer:  McQuien
Date:  28/06/06

Description:  This stored procedure pulls data from the LCH_TypePS_0101
table and inserts it into the ib_Position.  Also, any
new values encountered for firm, account, instrument, and currency create
new values in the lookups, as well as new values in the data tables for
these values.

Whilst iterating through the records in LCH_TypePS_0101, all 
of these inserts are wrapped in a transaction so that any failure causes
the changes to not commit.

Revision History

09 Aug 2006		amk		Separate MarketValues for PS and TR
15 Aug 2006		amk		1) Use LogicalCommodity as needed
						2) Divide Strike Price
16 Aug 2006		amk		New MarketValueDivisor operation
19 Sep 2006		LM		Added Null as value for currency code 
						for [ib_Position_W_Trans_Load].
26 Sep 2006		LM		1) Added @StrikePriceDivisor.
						2) @MarketValuePS * -1, @MarketValueTR * -1
08 Nov 2006		LM		1) Only run datasource lookup once.
						2) Logs start and end of sp with entry into ib_ImportLog.

27 Nov 2006		LM		1) Added  [ib_GetBusinessDate] for @AsofDate

07 Dec 2006		LM		1) Changed DatasourceCd from LIFFE to LCH

20 May 2009     Konrad  Exp Day set to the last day of the Exp Month and Exp Year if Exp Month and Exp Year are valid
22 Jul 2009		AAJM	MBAL-12377 use common source for default Strike Price Divisor
17 Feb 2010		AAJM	MBAL-13937 Stop same file being imported again		
03 Mar 2010		KevinP	MBAL-14819 Add ability to filter SELECT records by new [FileName] Column
03 Mar 2010		amk		MBAL-14836 adjust transaction isolation level
31 Mar 2010		amk		1) MBAL-15029 loadstatechange no longer changes state 0 to 1 so do that here at start
						2) Move log of started marker higher
21 Apr 2010		amk		MBAL-15365: get as of date from filename, not current date
22 Apr 2010		AAJM	MBAL-14741: Store settlement prices
22 Apr 2010		amk		MBAL-15390: mult market value by number of days in expiry month
27 Apr 2010		amk		MBAL-15427: get trx date from filename, not current date 
29 Apr 2010		AAJM	MBAL-15310: Ensure IPE/ICE uses Physical Commodity Field in new Instrument Code
18 May 2010		amk		MBAL-15566: reduce deadlocks - improve speed
-- 02 Jun 2010  ED      MBAL-15687 populate ib_ImportFile.AsOfDate
-- 25 Jun 2010	ED      MBAL 15578 - for Exchange=''FOX'', ignore price divisor
-- 05 Jul 2010  ED		MBAL 16052 - use LotsSize for MarketValue, not number of days
-- 14 Jul 2010  ED		MBAL 15856 - Set Quantity to Premium trx
-- 09 Jan 2014	ED		EIB 25004 - remove importLog table and use Log table
*/

AS
SET NOCOUNT ON

	DECLARE @DataSourceCd VARCHAR(100)
	DECLARE @DataSourceId INT
	DECLARE @Code VARCHAR(100)
	DECLARE @ReturnValue INT
	DECLARE @Output INT
	DECLARE @Output2 INT
	DECLARE @DefaultCurrencyId INT
			
	--specify datasource in proc.
	SET @DataSourceCd = ''LCH''
	IF @LocationPath IS NULL SET @LocationPath = @DataSourceCd

	SET @Code = @DataSourceCd
	EXEC @ReturnValue= [_ib_DataSource_GetByCodeForOutput] @Code,@OutPut output,@Output2 output	
	SET @DataSourceId = @Output
	SET @DefaultCurrencyId = @Output2	

	-- Duplicate file check										
	DECLARE @IsFileAlreadyLoaded INT
	EXEC @IsFileALreadyLoaded = HasFileBeenLoaded @LocationPath, @DataSourceId

	IF @IsFileAlreadyLoaded = 1
		BEGIN					
			UPDATE [dbo].[LCH_TypePS_0101]
			SET [LoadState] = 3
			WHERE [LoadState] = 1
				AND [FileName] = @LocationPath				

			RETURN
		END
					
	-- Store ImportFile record to be associated with Settlement Price load
	DECLARE @ImportFileId INT
	EXEC ib_ImportFile_Add @DataSourceId, @LocationPath, @ImportFileId output
	DECLARE @SelectedAsOfDate DATETIME
	DECLARE @AsOfDate DATETIME
	EXEC [ib_GetBusinessDate] @LocationPath, @AsOfDate OUTPUT

	-- There really isn''t any need for orchestration to call a LoadStateChange anymore
	-- since we only process rows for single file now
	-- but to keep consistent with other loaders - we''ll update to LoadState 1 at 
	-- start of this Load stored procedure
	UPDATE [LCH_TypePS_0101]
	SET LoadState = 1
	WHERE LoadState = 0
		AND Filename = @LocationPath

	CREATE TABLE #temp1
	(
		LCH_TypePS_0101_ID		int,
		Exchange				varchar(3),
		OriginatingMemberName	varchar(3),
		AccountCode				varchar(1),
		PhysicalCommodity		varchar(3),
		ContractType			varchar(1),
		GenericContractType		varchar(1),
		LongExpiryDate			varchar(8),
		ExercisePrice			varchar(9),
		LongAccountVolume		varchar(11),
		ShortAccountVolume		varchar(11),
		PayCollect				varchar(15),
		PremiumPayCollect		varchar(15),
		LongLotsTraded			varchar(7),			
		ShortLotsTraded			varchar(7),
		ValuationPrice			varchar(9),
		LotsSize				VARCHAR(5)
	)

	INSERT INTO #temp1
	(
		LCH_TypePS_0101_ID,
		Exchange,
		OriginatingMemberName,
		AccountCode,
		PhysicalCommodity,
		ContractType,
		GenericContractType,
		LongExpiryDate,
		ExercisePrice,
		LongAccountVolume,
		ShortAccountVolume,
		PayCollect,
		PremiumPayCollect,
		LongLotsTraded,
		ShortLotsTraded,
		ValuationPrice,
		LotsSize
	)
	SELECT 	LCH_TypePS_0101_ID,
			Exchange,
			OriginatingMemberName,
			AccountCode,
			PhysicalCommodity,
			ContractType,
			GenericContractType,
			LongExpiryDate,
			ExercisePrice,
			LongAccountVolume,
			ShortAccountVolume,
			PayCollect,
			PremiumPayCollect,
			LongLotsTraded,
			ShortLotsTraded,
			ValuationPrice,
			LotsSize
	FROM [dbo].[lch_typeps_0101]
	WHERE LoadState = 1
		AND [FileName] = @LocationPath

	BEGIN TRAN T1

	-- BizTalk''s SQL Adapter uses more restrictive read serializable
	-- so this is necessary to relax it to something that is default
	-- and perfectly acceptable!
	SET TRANSACTION ISOLATION LEVEL READ COMMITTED

	DECLARE @LCH_TypePS_0101_ID		int
	DECLARE @Exchange				varchar(100)
	DECLARE @OriginatingMemberName	varchar(100)
	DECLARE @AccountCode			varchar(100)
	DECLARE @PhysicalCommodity		varchar(100)
	DECLARE @ContractType			varchar(100)
	DECLARE @GenericContractType	varchar(100)
	DECLARE @LongExpiryDate			varchar(25)
	DECLARE @ExercisePrice			decimal(19,4)
	DECLARE @LongAccountVolume		decimal(18,10)
	DECLARE @ShortAccountVolume		decimal(18,10)
	DECLARE @PayCollect				decimal(19,4)
	DECLARE @PremiumPayCollect		decimal(19,4)
	DECLARE @LongLotsTraded			varchar(7)
	DECLARE	@ShortLotsTraded		varchar(7)
	DECLARE @ValuationPrice			varchar(9)
	DECLARE @LotsSize				VARCHAR(5)
	DECLARE pos_cursor CURSOR FOR
	SELECT	LCH_TypePS_0101_ID,
			Exchange,
			OriginatingMemberName,
			AccountCode,
			PhysicalCommodity,
			ContractType,
			GenericContractType,
			LongExpiryDate,
			ExercisePrice,
			LongAccountVolume,
			ShortAccountVolume,
			PayCollect,
			PremiumPayCollect,
			LongLotsTraded,
			ShortLotsTraded,
			ValuationPrice,
			LotsSize
	FROM	#temp1

	OPEN pos_cursor

	FETCH NEXT FROM pos_cursor
	INTO 
		@LCH_TypePS_0101_ID,
		@Exchange,
		@OriginatingMemberName,
		@AccountCode,
		@PhysicalCommodity,
		@ContractType,
		@GenericContractType,
		@LongExpiryDate,
		@ExercisePrice,
		@LongAccountVolume,
		@ShortAccountVolume,
		@PayCollect,
		@PremiumPayCollect,
		@LongLotsTraded,	
		@ShortLotsTraded,
		@ValuationPrice,
		@LotsSize

		-- Check @@FETCH_STATUS to see IF there are any more rows to fetch.
		WHILE @@FETCH_STATUS = 0
		BEGIN
	
			DECLARE @ExchangeCd				varchar(25)
			DECLARE @FirmCd					varchar(100)
			DECLARE @AccountCd				varchar(100)
			DECLARE @InstrumentCd			varchar(100)
			DECLARE @InstrumentTypeCd		VARCHAR(100)
			DECLARE @QuantityPS				decimal(18,10)
			DECLARE @MarketValuePS			decimal(19,4)
			DECLARE @MarketValueTR			decimal(19,4)
			DECLARE @ExpiryDate				datetime
			DECLARE @StrikePrice			decimal(19,4)
			DECLARE @TrxTypeCdPS			varchar(25)
			DECLARE @TrxTypeCdTR			varchar(25)
			DECLARE @OptionTypeCd			varchar(25)
			DECLARE @QuantityTR				decimal(18,10)
			DECLARE @TrxDate				datetime
			DECLARE @Price					decimal(19,4)
			DECLARE @ExpYr					smallint
			DECLARE @ExpMth					smallint
			DECLARE @ExpDay					smallint
			DECLARE	@LongQuantity			decimal(19,4) 
			DECLARE @ShortQuantity			decimal(19,4) 
			DECLARE @TradedLongQuantity		decimal(19,4) 
			DECLARE @TradedShortQuantity	decimal(19,4)

			SET @ExchangeCd = @exchange
			
			SET @Output = null
			DECLARE @InstrumentTypeId int
			SELECT @InstrumentTypeCd = RTRIM(@GenericContractType)
			EXEC @ReturnValue = ib_Instrumenttype_AddAsNeeded @DataSourceId,@InstrumentTypeCd,@OutPut output
			SET @InstrumentTypeId = @Output
			
			DECLARE @CurrencyId int
					
			SET @Output2 = null
			SET @Output = null
			DECLARE @InstrumentId int
			
			-- MBAL-15310 Update the Instrument code
			SET @InstrumentCd = @InstrumentTypeCd + ''_'' + @ExchangeCd + ''_'' + @PhysicalCommodity
		
			EXEC @ReturnValue= [ib_Instrument_AddAsNeeded] @DataSourceId,@InstrumentTypeId,@InstrumentCd,@CurrencyId,@OutPut output,@OutPut2 output	
			SET @InstrumentId = @Output
			SET @CurrencyId = @Output2
			IF @CurrencyId is null
			BEGIN
				SET @CurrencyId = @DefaultCurrencyId
			END

			DECLARE @TickSize int
			SELECT @TickSize = ticksize from ib_instrument where instrumentid = @InstrumentId

			DECLARE @MarketValueDivisor		Decimal(19,4)
			DECLARE	@StrikePriceDivisor		Decimal(19,4)
			DECLARE @PriceDivisor			DECIMAL(19,4)
			
			SET @MarketValueDivisor = NULL
			SET @StrikePriceDivisor = NULL
			SET @PriceDivisor = NULL
			
			SELECT @MarketValueDivisor = MarketValueDivisor
					, @StrikePriceDivisor	= StrikePriceDivisor
					, @PriceDivisor = PriceDivisor
			FROM [dbo].[ib_InstrumentDataSource]
			WHERE DataSourceId = @DataSourceId
				AND DataSourceInstrumentCode = @InstrumentCd 
			
			IF @MarketValueDivisor IS NULL SET @MarketValueDivisor = 1

			SET @FirmCd=@originatingmembername
			SET @AccountCd = @accountcode
			SET @QuantityPS = cast(@longaccountvolume as decimal(18,10)) - cast(@shortaccountvolume as decimal(18,10))
			SET @MarketValuePS = case when @TickSize > 0 then (@paycollect * @TickSize / @MarketValueDivisor) else @paycollect END
			SET @MarketValueTR = case when @TickSize > 0 then @premiumpaycollect * @TickSize / @MarketValueDivisor else @premiumpaycollect END
			
			SET @MarketValuePS = @MarketValuePS * -1			
			SET @MarketValueTR = @MarketValueTR * -1

			IF @StrikePriceDivisor IS NULL -- Then get the default
			BEGIN
				DECLARE @ExchangeId INT
				SELECT @ExchangeId = ExchangeId FROM ib_Exchange WHERE [Code] = @ExchangeCd
				
				SET @StrikePriceDivisor = [dbo].[udf_GetDefaultStrikePriceDivisor](@DataSourceId, @ExchangeId)
			END

			SET @StrikePrice = (@ExercisePrice/@StrikePriceDivisor)

			-- Set Settlement Price				
			IF @PriceDivisor IS NULL OR @ExchangeCd = ''FOX'' -- for fox, ignore price divisor(MBAL 15578)
				SET @PriceDivisor = 1
					
			DECLARE @SettlementPrice DECIMAL(24,10)
			SET @SettlementPrice = CONVERT(DECIMAL(24,10), @ValuationPrice) / @PriceDivisor
			
			SET @TrxTypeCdPS = ''Position''
			SET @TrxTypeCdTR = ''Premium''
			SET @OptionTypeCd=@contracttype
			SET @TrxDate = @AsOfDate
			SET @SelectedAsOfDate = @AsOfDate
			-- MBAL 15856 - Set Quantity = 0 to Premium trx
			-- SET @QuantityTR = case when @TickSize > 0 then @premiumpaycollect/@TickSize else @premiumpaycollect END
			SET @QuantityTR = 0
			
			--SET @LongExpiryDate = @LongExpiryDate as datetime)
			SET @ExpYr = LEFT(@LongExpiryDate,4)
			SET @ExpMth = SUBSTRING(@LongExpiryDate,5,2)
			SET @ExpDay = RIGHT(@LongExpiryDate,2)
			SET @ExpDay = dbo.udf_OnLoad_ExpiryDate_Get_Day(@ExpYr,@ExpMth,@ExpDay)
			SET @InstrumentTypeCd = @genericcontracttype
			
			DECLARE @LotsSizeInt			INT
			
			SET @LotsSizeInt = CONVERT(INT, @LotsSize)
			
			IF @LotsSizeInt IS NULL
				SET @LotsSizeInt = 1
			
			IF UPPER(RTRIM(@GenericContractType)) = ''M''
				SET @MarketValuePS = @MarketValuePS * @LotsSizeInt

			SET @LongQuantity = @LongAccountVolume
			SET @ShortQuantity = @ShortAccountVolume
			SET @TradedLongQuantity = @LongLotsTraded 
			SET @TradedShortQuantity = @ShortLotsTraded
			
			DECLARE @PositionId INT
			SET @PositionId = NULL
			
			EXEC [ib_Position_W_Trans_Load]
			@DataSourceCd,
			@ExchangeCd,
			@FirmCd,
			@AccountCd,	
			@AsOfDate,
			@InstrumentCd,
			@QuantityPS,
			@MarketValuePS,
			@MarketValueTR,
			@ExpYr,
			@ExpMth,
			@ExpDay,
			@StrikePrice,
			@TrxTypeCdPS,
			@TrxTypeCdTR,
			@OptionTypeCd,
			@QuantityTR,
			@TrxDate,
			@Price,
			@LCH_TypePS_0101_ID,
			@InstrumentTypeCd,
			NULL,
			@LongQuantity, 
			@ShortQuantity, 
			@TradedLongQuantity, 
			@TradedShortQuantity,
			@PositionId = @PositionId OUTPUT


			-- Add Settlement Price											
			EXEC ib_Price_AddFromPositionLoad
				@PositionId
				, @ImportFileId
				, @SettlementPrice 	
				
			--flip processed flag in source table.
			UPDATE [LCH_TypePS_0101]
			SET [LoadState] = 2
			WHERE [LCH_TypePS_0101_ID] = @LCH_TypePS_0101_ID
				AND [LoadState] = 1

			FETCH NEXT FROM pos_cursor
			INTO 
			@LCH_TypePS_0101_ID,
			@Exchange,
			@OriginatingMemberName,
			@AccountCode,
			@PhysicalCommodity,
			@ContractType,
			@GenericContractType,
			@LongExpiryDate,
			@ExercisePrice,
			@LongAccountVolume,
			@ShortAccountVolume,
			@PayCollect,
			@PremiumPayCollect,
			@LongLotsTraded,	
			@ShortLotsTraded,
			@ValuationPrice,
			@LotsSize

		END

	CLOSE pos_cursor
	DEALLOCATE pos_cursor

	UPDATE ib_ImportFile SET AsOfDate= @SelectedAsOfDate WHERE ImportFileId=@ImportFileId
	COMMIT TRAN T1

	DROP TABLE #temp1
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Firm_Update]''
');

GO
EXECUTE (' /*
<details>
 <summary>Updates a firm from the ib_Firm table by its id</summary>
 <created author="Laurentiu Macovei" Date=" Sunday, 10 September 2006 9:26PM GMT" /> 
 <updated author="Laurentiu Macovei" Date=" Sunday, 24 September 2006 3:40PM GMT"> 
	Added check for duplicate feature
 </updated>
</details>
*/ 
CREATE PROCEDURE [dbo].[ib_Firm_Update]
(
	@FirmId int,
	@Code varchar(100),
    @Name varchar(100),
    @IsApproved bit,
    @UpdateUsername varchar(50)
)
AS 
SET NOCOUNT ON


BEGIN TRY
--check for duplicates 
EXEC [dbo].[ib_Firm_CheckForDuplicate] @Code, @Name, @FirmId

UPDATE [dbo].[ib_Firm]
   SET [Code] = @Code,
       [Name] = @Name,
       [IsApproved] = @IsApproved,
       [UpdateUsername] = @UpdateUsername
 WHERE FirmId = @FirmId
END TRY
BEGIN CATCH
	EXEC [dbo].[sp_RethrowError]
END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[CreditSuisse_Position_Add]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[CreditSuisse_Position_Add]
(
  @PRECID				VARCHAR(1)	= NULL 
  , @PFIRM	   			VARCHAR(1)	= NULL
  , @POFFIC				VARCHAR(3)	= NULL
  , @PACCT				VARCHAR(5)	= NULL
  , @PCTYM				VARCHAR(6)	= NULL
  , @PSBCUS				VARCHAR(2)	= NULL
  , @PSTYPE				VARCHAR(2)	= NULL
  , @PSUBTY				VARCHAR(1)	= NULL
  , @PSTYP2				VARCHAR(1)	= NULL
  , @PSTRIK				VARCHAR(15)	= NULL
  , @PEXPDT				VARCHAR(8)	= NULL
  , @PSUBAC				VARCHAR(10)	= NULL
  , @PTDATE				VARCHAR(8)	= NULL
  , @PTPRIC				VARCHAR(15)	= NULL
  , @PBS				VARCHAR(1)	= NULL
  , @PBROKR				VARCHAR(2)	= NULL
  , @PTRACE				VARCHAR(10)	= NULL
  , @PICODE				VARCHAR(3)	= NULL
  , @PREFNO				VARCHAR(12)	= NULL
  , @PCLASS				VARCHAR(1)	= NULL
  , @PSUBCL				VARCHAR(1)	= NULL
  , @PQTY				VARCHAR(15)	= NULL
  , @PPRTQ				VARCHAR(15)	= NULL
  , @PSDSC1				VARCHAR(3)	= NULL
  , @PMKVAL				VARCHAR(15)	= NULL
  , @PSDATE				VARCHAR(8)	= NULL
  , @PEXCH				VARCHAR(2)	= NULL
  , @PFC				VARCHAR(2)	= NULL 
  , @PTYPE				VARCHAR(1)	= NULL
  , @PSYMBL				VARCHAR(6)	= NULL
  , @PSUBEX				VARCHAR(1)	= NULL
  , @PPRTPR				VARCHAR(11)	= NULL
  , @PCLOSE				VARCHAR(15)	= NULL
  , @PPRCDT				VARCHAR(8)	= NULL
  , @PPRTCP				VARCHAR(11) = NULL
  , @PPRICE				VARCHAR(12) = NULL
  , @PCURSY				VARCHAR(3)	= NULL
  , @PGROSS				VARCHAR(15) = NULL
  , @FileName			VARCHAR (512)= NULL
)
AS

-- ====================================================
-- Author:		AAJM
-- Create date: 06 Apr 2011
-- Description:	Insert into CreditSuisse_Position table
--
-- Revision History
-- 17 May 2011	AAJM	Add PSUBEX for Sub Exchange Code
-- 18 May 2011	AAJM	Add PPRTPR Printable Price
-- 18 May 2011	AAJM	Add PPRTCP Printable Closing Price
-- =====================================================

BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

  INSERT INTO [dbo].[CreditSuisse_Position]
			( 
		    	[PRECID]
				, [PFIRM]
    			, [POFFIC]
			    , [PACCT]
    			, [PCTYM]
			    , [PSBCUS]
			    , [PSTYPE]
    			, [PSUBTY]
    			, [PSTYP2]
    			, [PSTRIK]
    			, [PEXPDT]
    			, [PSUBAC]
    			, [PTDATE]
    			, [PTPRIC]
    			, [PBS]
    			, [PBROKR]
    			, [PTRACE]
    			, [PICODE]
    			, [PREFNO]
    			, [PCLASS]
    			, [PSUBCL]
    			, [PQTY]
    			, [PPRTQ]
    			, [PSDSC1]
    			, [PMKVAL]
    			, [PSDATE]
    			, [PEXCH]
    			, [PFC]
    			, [PTYPE]
    			, [PSYMBL]
    			, [PSUBEX]
    			, [PPRTPR]
    			, [PCLOSE]
    			, [PPRCDT]
    			, [PPRTCP]
    			, [PPRICE]
    			, [PCURSY]
    			, [PGROSS]
    			, [FileName]
			)
    VALUES
			( 
    			@PRECID
    			, @PFIRM
    			, @POFFIC
    			, @PACCT
    			, @PCTYM
    			, @PSBCUS
    			, @PSTYPE
    			, @PSUBTY
    			, @PSTYP2
    			, @PSTRIK
    			, @PEXPDT
    			, @PSUBAC
    			, @PTDATE
    			, @PTPRIC
    			, @PBS
    			, @PBROKR
    			, @PTRACE
    			, @PICODE
    			, @PREFNO
    			, @PCLASS
    			, @PSUBCL
    			, @PQTY
    			, @PPRTQ
    			, @PSDSC1
    			, @PMKVAL
    			, @PSDATE
    			, @PEXCH
    			, @PFC
    			, @PTYPE
    			, @PSYMBL
    			, @PSUBEX
    			, @PPRTPR
    			, @PCLOSE
    			, @PPRCDT
    			, @PPRTCP
    			, @PPRICE
    			, @PCURSY
    			, @PGROSS
    			, @FileName
			)
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[Liffe_TradeReport_Add]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[Liffe_TradeReport_Add]
(
	@RowId					VARCHAR(19) = NULL
    , @System					VARCHAR(7) = NULL
    , @Version					VARCHAR(3) = NULL
    , @RecType					VARCHAR(3) = NULL
    , @Exchange					VARCHAR(1) = NULL
    , @ExchangeMnemonic			VARCHAR(10) = NULL
    , @ClearingSlipId			VARCHAR(19) = NULL 
    , @TrdId					VARCHAR(50) = NULL 
    , @SubTradeSequence			VARCHAR(19) = NULL
    , @ParentTrdId				VARCHAR(50) = NULL
    , @SlipType					VARCHAR(1) = NULL
    , @TrdSubTyp				VARCHAR(3) = NULL
    , @TrdTyp					VARCHAR(3) = NULL
    , @TradeType				VARCHAR(1) = NULL
    , @StrtPrmNme				VARCHAR(1) = NULL
    , @CrossType				VARCHAR(1) = NULL
    , @Status					VARCHAR(2) = NULL
    , @OrgClearer				VARCHAR(3) = NULL 
    , @OrgMember				VARCHAR(3) = NULL 
    , @OrgTrader				VARCHAR(3) = NULL 
    , @CptyTrader				VARCHAR(3) = NULL 
    , @CptyMember				VARCHAR(3) = NULL 
    , @BuySell					VARCHAR(1) = NULL 
    , @ContractType				VARCHAR(1) = NULL 
    , @GenContractType			VARCHAR(1) = NULL 
    , @Commodity				VARCHAR(3) = NULL 
    , @LogCommodity				VARCHAR(3) = NULL 
    , @MonthCode				VARCHAR(1) = NULL 
    , @ExpiryMonth				VARCHAR(5) = NULL 
    , @ExpiryDate				VARCHAR(10) = NULL 
    , @LongExpiryDate			VARCHAR(10) = NULL 
    , @Strike					VARCHAR(24) = NULL
    , @Price					VARCHAR(24) = NULL
    , @Volume					VARCHAR(19) = NULL
    , @Account					VARCHAR(25) = NULL 
    , @AllTrader				VARCHAR(3) = NULL
    , @AllMember				VARCHAR(3) = NULL
    , @OpenClose				VARCHAR(1) = NULL
    , @EnteredDate				VARCHAR(10) = NULL
    , @EnteredTime				VARCHAR(8) = NULL
    , @TradeTime				VARCHAR(8) = NULL
    , @ModifiedTime				VARCHAR(8) = NULL
    , @AssignedTime				VARCHAR(8) = NULL
    , @TimeMatched				VARCHAR(8) = NULL
    , @TRSOperator				VARCHAR(50) = NULL
    , @OrderSlipId				VARCHAR(19) = NULL
    , @TraderCardReference		VARCHAR(100) = NULL
    , @UserSpecifiedData		VARCHAR(100) = NULL
    , @PMA						VARCHAR(25) = NULL
    , @MarginAccount			VARCHAR(1) = NULL
    , @TradeDate				VARCHAR(10) = NULL
    , @TimeBracket				VARCHAR(2) = NULL
    , @TradingEnv				VARCHAR(1) = NULL
    , @CTrdSlipId				VARCHAR(19) = NULL
    , @CntraTrdId				VARCHAR(5) = NULL
    , @CtrdSubAcc				VARCHAR(4) = NULL
    , @CounterclaimSlipId		VARCHAR(50) = NULL
    , @RemClearer				VARCHAR(4) = NULL
    , @TransferInd				VARCHAR(1) = NULL
    , @OffsetDate				VARCHAR(2) = NULL
    , @StrategyCode				VARCHAR(1) = NULL
    , @DesignatedAccount		VARCHAR(50) = NULL
    , @PostingCode				VARCHAR(19) = NULL
    , @SessionId				VARCHAR(19) = NULL
    , @CustomerReference		VARCHAR(256) = NULL
    , @Aggressor				VARCHAR(1) = NULL
    , @VenuTyp					VARCHAR(1) = NULL
    , @RptSideCntraClaimTrdId	VARCHAR(50) = NULL
    , @RptSideCntraTrdId		VARCHAR(50) = NULL
    , @HalfTradeId				VARCHAR(50) = NULL
    , @TradeClipId				VARCHAR(19) = NULL
    , @ReportTime				VARCHAR(19) = NULL 
    , @FileName					VARCHAR (512) = NULL
)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON

	INSERT INTO [dbo].[Liffe_TradeReport] 
	(
	[RowId]					
    , [System]					
    , [Version]		
    , [RecType]		
    , [Exchange]	
    , [ExchangeMnemonic]
    , [ClearingSlipId]	
    , [TrdId]			
    , [SubTradeSequence]
    , [ParentTrdId]		
    , [SlipType]		
    , [TrdSubTyp]		
    , [TrdTyp]			
    , [TradeType]		
    , [StrtPrmNme]		
    , [CrossType]		
    , [Status]			
    , [OrgClearer]		
    , [OrgMember]		
    , [OrgTrader]		
    , [CptyTrader]		
    , [CptyMember]		
    , [BuySell]			
    , [ContractType]	
    , [GenContractType]			
    , [Commodity]				
    , [LogCommodity]			
    , [MonthCode]				
    , [ExpiryMonth]				
    , [ExpiryDate]				
    , [LongExpiryDate]			
    , [Strike]					
    , [Price]					
    , [Volume]					
    , [Account]					
    , [AllTrader]				
    , [AllMember]				
    , [OpenClose]				
    , [EnteredDate]				
    , [EnteredTime]				
    , [TradeTime]				
    , [ModifiedTime]			
    , [AssignedTime]			
    , [TimeMatched]				
    , [TRSOperator]				
    , [OrderSlipId]				
    , [TraderCardReference]		
    , [UserSpecifiedData]		
    , [PMA]						
    , [MarginAccount]			
    , [TradeDate]				
    , [TimeBracket]				
    , [TradingEnv]				
    , [CTrdSlipId]				
    , [CntraTrdId]				
    , [CtrdSubAcc]				
    , [CounterclaimSlipId]		
    , [RemClearer]				
    , [TransferInd]				
    , [OffsetDate]				
    , [StrategyCode]			
    , [DesignatedAccount]		
    , [PostingCode]				
    , [SessionId]				
    , [CustomerReference]		
    , [Aggressor]				
    , [VenuTyp]					
    , [RptSideCntraClaimTrdId]			
    , [RptSideCntraTrdId]				
    , [HalfTradeId]				
    , [TradeClipId]				
    , [ReportTime]				
    , [FileName]				
	
	)
	VALUES
	(
	@RowId					
    , @System					
    , @Version					
    , @RecType					
    , @Exchange					
    , @ExchangeMnemonic			
    , @ClearingSlipId			
    , @TrdId					
    , @SubTradeSequence			
    , @ParentTrdId				
    , @SlipType					
    , @TrdSubTyp				
    , @TrdTyp					
    , @TradeType				
    , @StrtPrmNme				
    , @CrossType				
    , @Status					
    , @OrgClearer				
    , @OrgMember				
    , @OrgTrader				
    , @CptyTrader				
    , @CptyMember				
    , @BuySell					
    , @ContractType				
    , @GenContractType			
    , @Commodity				
    , @LogCommodity				
    , @MonthCode				
    , @ExpiryMonth				
    , @ExpiryDate				
    , @LongExpiryDate			
    , @Strike					
    , @Price					
    , @Volume					
    , @Account					
    , @AllTrader				
    , @AllMember				
    , @OpenClose				
    , @EnteredDate				
    , @EnteredTime				
    , @TradeTime				
    , @ModifiedTime				
    , @AssignedTime				
    , @TimeMatched				
    , @TRSOperator				
    , @OrderSlipId				
    , @TraderCardReference		
    , @UserSpecifiedData		
    , @PMA						
    , @MarginAccount			
    , @TradeDate				
    , @TimeBracket				
    , @TradingEnv				
    , @CTrdSlipId				
    , @CntraTrdId				
    , @CtrdSubAcc				
    , @CounterclaimSlipId		
    , @RemClearer				
    , @TransferInd				
    , @OffsetDate				
    , @StrategyCode				
    , @DesignatedAccount		
    , @PostingCode				
    , @SessionId				
    , @CustomerReference		
    , @Aggressor				
    , @VenuTyp					
    , @RptSideCntraClaimTrdId			
    , @RptSideCntraTrdId				
    , @HalfTradeId				
    , @TradeClipId				
    , @ReportTime				
    , @FileName					
	)
	
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_ScheduledTask_DeleteQueueItem]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_ScheduledTask_DeleteQueueItem]
	@queueItemId int 
AS
SET NOCOUNT ON
	DECLARE @code nvarchar(10)
	DECLARE @statusId INT
	
	SELECT	
		@statusId = I.StatusId,
		@code = S.Code
	FROM 
		ib_QueueItem I
	INNER JOIN
		ib_QueueStatus S ON S.QueueStatusId = I.StatusId
	WHERE
		QueueItemId = @queueItemId
		
	IF (ISNULL(@statusId,-1) <> -1)
	BEGIN
		IF (@code <> ''StandBy'' AND @code <> ''Waiting'')
		BEGIN
			RAISERROR (''Queue Item cannot be deleted. Only items with status "Stand By" or "Waiting For Run" can be removed'', 16, 2)
		END
		ELSE
		BEGIN
			DELETE FROM ib_QueueItem WHERE QueueItemId = @queueItemId
		END
	END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_LCH_TypeTR_Load]''
');

GO
EXECUTE ('CREATE procedure [dbo].[ib_LCH_TypeTR_Load]
(
	@LocationPath	varchar(100) = NULL
)
/*
Developer:  McQuien
Date:  28/06/06

Description:  This stored procedure pulls data from the LCH_TypePS_0101
table and inserts it into the ib_Position.  Also, any
new values encountered for firm, account, instrument, and currency create
new values in the lookups, as well as new values in the data tables for
these values.

Whilst iterating through the records in LCH_TypePS_0101, all 
of these inserts are wrapped in a transaction so that any failure causes
the changes to not commit.

Revision History

15 Aug 2006		amk		1) Use LogicalCommodity as needed
						2) Divide Strike Price
26 Sep 2006		LM		Added StrikePriceDivisor Logic.
08 Nov 2006		LM		1) Only run datasource lookup once.
						2) Logs start and end of sp with entry into ib_ImportLog.
27 Nov 2006		LM		1) Added  [ib_GetBusinessDate] for @AsofDate
28 Nov 2006		LM		Changed logic so that @LocationPath = ''Liffe'' when NULL
07 Dec 2006		LM		1) Changed DatasourceCd from LIFFE to LCH
20 May 2009     Konrad  Exp Day set to the last day of the Exp Month and Exp Year if Exp Month and Exp Year are valid
10 July 2009	Konrad  Set field Price value in table ib_Trx from field Price value in table lch_typetr.
16 Jul 2009		AAJM	Update to account for new DetailAccountId column in ib_Trx table - see MBAL-12454
21 Jul 2009		AAJM	Add MarexFirmId to ensure correct DetailAccountId is obtained
22 Jul 2009		AAJM	MBAL-12575 Fix wrong number of variables declared in the INTO list
22 Jul 2009		AAJM	MBAL-12377 use common source for default Strike Price Divisor
28 Jul 2009		AAJM	MBAL-12623 Include QuantityLong and QuantityShort
08 Oct 2009		amk		New PriceDivisor
17 Feb 2010		AAJM	MBAL-13937 Stop same file being imported again
03 Mar 2010		KevinP	MBAL-14819 Add ability to filter SELECT records by new [FileName] Column
03 Mar 2010		amk		MBAL-14836 adjust transaction isolation level
31 Mar 2010		amk		1) MBAL-15029 loadstatechange no longer changes state 0 to 1 so do that here at start
						2) Move log of started marker higher
21 Apr 2010		amk		MBAL-15365: get as of date from filename, not current date 
27 Apr 2010		amk		MBAL-15427: get trx date from filename, not current date 
29 Apr 2010		AAJM	MBAL-15310: Ensure IPE/ICE uses Physical Commodity Field in new Instrument Code
18 May 2010		amk		MBAL-15566: reduce deadlocks - improve speed
01 Aug 2012		ED		MBAL-21230: add row to importFile table
09 Jan 2014		ED		EIB 25004 - remove importLog table and use Log table
14 May 2014		ED		EIB 25636 - pass LocationPath to ib_trx_load

*/

AS
SET NOCOUNT ON

	DECLARE @DataSourceCd VARCHAR(100)
	DECLARE @DataSourceId INT
	DECLARE @Code VARCHAR(100)
	DECLARE @ReturnValue INT
	DECLARE @Output INT
	DECLARE @Output2 INT
	DECLARE @DefaultCurrencyId INT
			
	--specify datasource in proc.
	SET @DataSourceCd = ''LCH''
	IF @LocationPath IS NULL SET @LocationPath = @DataSourceCd

	SET @Code = @DataSourceCd
	EXEC @ReturnValue= [_ib_DataSource_GetByCodeForOutput] @Code,@OutPut output,@Output2 output	
	SET @DataSourceId = @Output
	SET @DefaultCurrencyId = @Output2	

	-- Duplicate file check										
	DECLARE @IsFileAlreadyLoaded INT
	EXEC @IsFileALreadyLoaded = HasFileBeenLoaded @LocationPath, @DataSourceId

	IF @IsFileAlreadyLoaded = 1
		BEGIN					
			UPDATE [dbo].[LCH_TypeTR]
			SET [LoadState] = 3
			WHERE [LoadState] = 1
				AND [FileName] = @LocationPath		

			RETURN
		END
			
	DECLARE @ImportFileId INT
	EXEC ib_ImportFile_Add @DataSourceId, @LocationPath, @ImportFileId output
	DECLARE @SelectedAsOfDate DATETIME	
	EXEC [ib_GetBusinessDate] @LocationPath, @SelectedAsOfDate OUTPUT
	UPDATE ib_ImportFile SET AsOfDate= @SelectedAsOfDate WHERE ImportFileId=@ImportFileId
	-- There really isn''t any need for orchestration to call a LoadStateChange anymore
	-- since we only process rows for single file now
	-- but to keep consistent with other loaders - we''ll update to LoadState 1 at 
	-- start of this Load stored procedure
	UPDATE [lch_typetr]
	SET LoadState = 1
	WHERE LoadState = 0
		AND Filename = @LocationPath

	--creating Temp Table just for use in this process
	--for iterating through the records.
	create table #temp1
	(
	LIFFE_TRID int,
	Exchange varchar(3),
	OriginatingMemberName varchar(3),
	AccountCode varchar(1), 	
	DetailAccountCode varchar(14), -- AAJM Added for MBAL-12454	
	PhysicalCommodity varchar(3),
	ContractType varchar(1),
	GenericContractType varchar(1),
	LongExpiryDate varchar(8),
	ExercisePrice varchar(9),
	Volume varchar(6),
	BuyOrSell varchar(1),
	TradeType varchar(1),
	HalfTradeStatus varchar(2),
	Price varchar(9)	
	)

	insert into #temp1
	(
	LIFFE_TRID,
	Exchange,
	OriginatingMemberName,
	AccountCode,
	DetailAccountCode, -- AAJM Added for MBAL-12454	
	PhysicalCommodity,
	ContractType,
	GenericContractType,
	LongExpiryDate,
	ExercisePrice,
	Volume,
	BuyOrSell,
	TradeType,
	HalfTradeStatus,
	Price
	)
	SELECT 
		LIFFE_TRID,
		Exchange,
		OriginatingMemberName,
		AccountCode,
		UserSpecifiedData, -- AAJM Added for MBAL-12454	
		PhysicalCommodity,
		ContractType,
		GenericContractType,
		LongExpiryDate,
		ExercisePrice,
		Volume,
		BuyOrSell,
		TradeType,
		HalfTradeStatus,
		Price
	FROM [dbo].[lch_typetr]
	WHERE LoadState = 1
	  AND [FileName] = @LocationPath

	begin tran t1

	-- BizTalk''s SQL Adapter uses more restrictive read serializable
	-- so this is necessary to relax it to something that is default
	-- and perfectly acceptable!
	SET TRANSACTION ISOLATION LEVEL READ COMMITTED

	DECLARE 
				@LIFFE_TRID int,
				@Exchange varchar(100),
				@OriginatingMemberName varchar(100),
				@AccountCode varchar(100),
				@DetailAccountCode varchar(14), -- AAJM Added for MBAL-12454	
				@PhysicalCommodity varchar(100),
				@ContractType varchar(100),
				@GenericContractType varchar(100),
				@LongExpiryDate varchar(25),
				@ExercisePrice decimal(19,4),
				@Volume decimal(18,10),
				@BuyOrSell varchar(100),
				@TradeType varchar(100),
				@HalfTradeStatus varchar(100),
				@Price varchar(9)

    DECLARE @MarexFirmId INT
    SET @MarexFirmId = [dbo].[udf_GetMarexFirmId]() -- AAJM Added for MBAL-12454	

	DECLARE @AsOfDate DATETIME
	EXEC [ib_GetBusinessDate] @LocationPath, @AsOfDate OUTPUT

	DECLARE trx_cursor CURSOR FOR
	SELECT LIFFE_TRID,
		Exchange,
		OriginatingMemberName,
		AccountCode,
		DetailAccountCode, -- AAJM Added for MBAL-12454	
		PhysicalCommodity,
		ContractType,
		GenericContractType,
		LongExpiryDate,
		ExercisePrice,
		Volume,
		BuyOrSell,
		TradeType,
		HalfTradeStatus,
		Price
	FROM #temp1

	OPEN trx_cursor

	-- Perform the first fetch and store the values in variables.
	-- Note: The variables are in the same order as the columns
	-- in the SELECT statement. 

	FETCH NEXT FROM trx_cursor
	INTO @LIFFE_TRID,
	@Exchange,
	@OriginatingMemberName,
	@AccountCode,
	@DetailAccountCode, -- AAJM Added for MBAL-12454	
	@PhysicalCommodity,
	@ContractType,
	@GenericContractType,
	@LongExpiryDate,
	@ExercisePrice,
	@Volume,
	@BuyOrSell,
	@TradeType,
	@HalfTradeStatus,
	@Price

	-- Check @@FETCH_STATUS to see if there are any more rows to fetch.
		WHILE @@FETCH_STATUS = 0
		BEGIN
		
		declare @ExchangeCd varchar(25)
		declare @FirmCd varchar(100)
		declare @AccountCd varchar(100)
		declare @DetailAccountCd varchar(14)
		declare @InstrumentCd varchar(100)
		declare @InstrumentTypeCd varchar(100)
		--declare @ExpiryDate datetime
		declare @ExpYr smallint
		declare @ExpMth smallint
		declare @ExpDay smallint
		declare @StrikePrice decimal(19,4)
		declare @TrxTypeCd varchar(25)
		declare @OptionTypeCd varchar(25)
		declare @Quantity decimal(18,10)
		DECLARE	@QuantityLong int
		DECLARE @QuantityShort int
		declare @TrxDate datetime
		declare @PriceDec decimal(19,4)

		set @ExchangeCd = @exchange
		
		set @Output = null
		declare @InstrumentTypeId int
		set @InstrumentTypeCd = @genericcontracttype 
		exec @ReturnValue = ib_Instrumenttype_AddAsNeeded @DataSourceId,@InstrumentTypeCd,@OutPut output
		set @InstrumentTypeId = @Output

		declare @CurrencyId int

		set @Output = null
		set @Output2 = null
		declare @InstrumentId int
		
		-- MBAL-15310 Update the Instrument code
		SET @InstrumentCd = @InstrumentTypeCd + ''_'' + @ExchangeCd + ''_'' + @PhysicalCommodity
				
		exec @ReturnValue= [ib_Instrument_AddAsNeeded] @DataSourceId,@InstrumentTypeId,@InstrumentCd,@CurrencyId,@OutPut output,@Output2 output	
		set @InstrumentId = @Output
		set @CurrencyId = @Output2
		if @Output2 = null
		begin
		set @CurrencyId = @DefaultCurrencyId
		end

		declare @TickSize int
		select @TickSize = ticksize from ib_instrument where instrumentid = @InstrumentId

		set @FirmCd=@originatingmembername
		set @AccountCd = @accountcode
		set @DetailAccountCd = @DetailAccountCode -- AAJM Added for MBAL-12454	
		
		DECLARE @StrikePriceDivisor DECIMAL(19,4)
		DECLARE @PriceDivisor DECIMAL(19,4)

		SELECT @StrikePriceDivisor = StrikePriceDivisor
			, @PriceDivisor = PriceDivisor
		FROM [dbo].[ib_InstrumentDataSource]
		WHERE DataSourceId = @DataSourceId
			AND DataSourceInstrumentCode = @InstrumentCd 

		IF @PriceDivisor IS NULL 
			SET @PriceDivisor = 1
		SET @PriceDec = CONVERT(DECIMAL(19, 4), @Price) / @PriceDivisor

		IF @StrikePriceDivisor IS NULL -- Then get the default
			BEGIN
				DECLARE @ExchangeId INT
				SELECT @ExchangeId = ExchangeId FROM ib_Exchange WHERE [Code] = @ExchangeCd
				
				SET @StrikePriceDivisor = [dbo].[udf_GetDefaultStrikePriceDivisor](@DataSourceId, @ExchangeId)
			END

		SET @StrikePrice = (@ExercisePrice/@StrikePriceDivisor)
		
		set @TrxTypeCd = @tradetype + @halftradestatus
		set @OptionTypeCd = @contracttype
		set @TrxDate = @AsOfDate
				
		IF (@buyorsell = ''B'')
			BEGIN
				SET @Quantity = @volume
				SET @QuantityLong = @volume
				SET @QuantityShort = 0
			END
		ELSE
			BEGIN
				SET @Quantity = @volume * -1
				SET @QuantityLong = 0
				SET @QuantityShort = @volume
			END
		
		SET @ExpYr = LEFT(@LongExpiryDate,4)
		SET @ExpMth = SUBSTRING(@LongExpiryDate,5,2)
		SET @ExpDay = RIGHT(@LongExpiryDate,2)
		SET @ExpDay = dbo.udf_OnLoad_ExpiryDate_Get_Day(@ExpYr,@ExpMth,@ExpDay)

		EXEC [ib_Trx_Load]
		@DataSourceCd,
		@ExchangeCd,
		@FirmCd,
		@AccountCd,
		@DetailAccountCd, -- AAJM Added for MBAL-12454	
		@InstrumentCd,
		@ExpYr,
		@ExpMth,
		@ExpDay,
		@StrikePrice,
		@TrxTypeCd,
		@OptionTypeCd,
		@Quantity,
		@TrxDate,
		@PriceDec,
		@LIFFE_TRID,
		@GenericContractType,
		@AsOfDate,
		@LocationPath = @LocationPath,
		@MarexFirmId = @MarexFirmId,
		@QuantityLong = @QuantityLong,
		@QuantityShort = @QuantityShort

		--flip processed flag in source table.
		update LCH_TypeTR
		set LoadState = 2
		where LIFFE_TRID = @LIFFE_TRID
		and LoadState = 1

		FETCH NEXT FROM trx_cursor
		INTO @LIFFE_TRID,
		@Exchange,
		@OriginatingMemberName,
		@AccountCode,
		@DetailAccountCode, -- AAJM Added for MBAL-12454 and MBAL-12575
		@PhysicalCommodity,
		@ContractType,
		@GenericContractType,
		@LongExpiryDate,
		@ExercisePrice,
		@Volume,
		@BuyOrSell,
		@TradeType,
		@HalfTradeStatus,
		@Price

		end

	CLOSE trx_cursor
	DEALLOCATE trx_cursor

	commit tran t1

drop table #temp1
');

GO
EXECUTE ('PRINT N''Creating [dbo].[CreditSuisse_Position_LoadStateChange]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[CreditSuisse_Position_LoadStateChange] 
	-- Add the parameters for the stored procedure here
	(
		@OldLoadState	TINYINT,
		@NewLoadState	TINYINT
	)
AS
-- =============================================
-- Author:		Alister McLeod
-- Create date: 06 Apr 2011
-- Description:	Changes the LoadState of the CreditSuisse_Position type table
-- =============================================
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

		UPDATE [dbo].[CreditSuisse_Position] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[Liffe_TradeReport_Delete]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[Liffe_TradeReport_Delete]
	(
	@Exchange		Varchar(3)
	)
AS
-- =============================================
-- Author:		Alister McLeod
-- Create date: 14 Dec 2012
-- Description:	Deletes from the Liffe_TradeReport table by Exchange
-- Revision History:
-- ----------------
-- =============================================
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	DELETE 
	FROM	[dbo].[Liffe_TradeReport] 
	WHERE	[Exchange] = @Exchange
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Liffe_GetBusinessDateFromFilename]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Liffe_GetBusinessDateFromFilename]
	(
		@Filename VARCHAR(100)
		, @ReturnDate DATETIME OUTPUT
		, @DataSourceId INT = -1
		, @ReceiveLocationSysId INT
		, @RunId INT
	)
AS
-- =============================================
-- Author:		Alister McLeod
-- Create date: 14 Dec 2012
-- Description:	Pulls back a Businessdate from the filename.
--				Includes future change which will add version at the end of filename before extension
-- Revision History:
-- 24 Jan 2013	AAJM	Fixed DateTime convert and test for @VersionChars bug
-- 09 Jan 2014	ED		EIB 25004 - remove importLog table and use Log table
-- =============================================

-- SET NOCOUNT ON added to prevent extra result sets from
-- interfering with SELECT statements.
SET NOCOUNT ON;
	
BEGIN
	
	SET @ReturnDate = NULL
	
	DECLARE @FileNameWithoutExtension VARCHAR(512)
	SET @FileNameWithoutExtension = [dbo].[GetFilenameWithoutExtension](@Filename)

	-- Check if the righthand four characters is a version (to be introduced to Liffe filenames end of 2012)
	-- Version will be in format _NNN where NNN is the version e.g. 001
	DECLARE @VersionChars VARCHAR(4)
	
	SET @VersionChars = RIGHT(@FileNameWithoutExtension, 4)

	IF LEN(@VersionChars) < 4 -- Filename is too short
		RETURN 
		
	DECLARE @FileNameWithoutVersion VARCHAR(512)
	
	IF (LEFT(@VersionChars, 1) = ''_'') AND (ISNUMERIC(RIGHT(@VersionChars,3))  = 1)
		BEGIN
			-- Then remove these last four characters
			SET @FileNameWithoutVersion = LEFT (@FileNameWithoutExtension, LEN(@FileNameWithoutExtension)- 4)
		END
	ELSE	-- There''s no version
		BEGIN
			SET @FileNameWithoutVersion = @FileNameWithoutExtension
		END
	
	DECLARE @DateChr VARCHAR(8)
	SET @DateChr = RIGHT(@FileNameWithoutVersion, 8)

	BEGIN TRY
		-- Add hyphens in to date then convert to datetime
		SET @ReturnDate = (SELECT CONVERT(DATETIME, STUFF(STUFF(@DateChr,5,0,''/''),8,0,''/''), 111) )

	END TRY
	BEGIN CATCH
	
		DECLARE     @ErrorMessage			VARCHAR(1024)
		DECLARE		@ErrorSeverity			INT
		DECLARE		@ErrorState				INT
	
		SELECT @ErrorMessage= ERROR_MESSAGE()
					, @ErrorSeverity = ERROR_SEVERITY()
					, @ErrorState = ERROR_STATE()
					
				IF XACT_STATE() = -1
					BEGIN
						-- transaction must get rolled back so need to fail this whole operation
						-- rollback seems to work whether or not xact_abort is on
						ROLLBACK TRANSACTION

						-- Use RAISERROR inside the CATCH block to return error
						-- information about the original error that caused
						-- execution to jump to the CATCH block.
						RAISERROR (@ErrorMessage, @ErrorSeverity, @ErrorState);
						RETURN	-- can''t do any writes so no point continuing (otherwise need to check every write / commit)
					END
				ELSE
				EXEC Log_Insert @ReceiveLocationSysId, @Filename, ''Orchestrated'', @ErrorMessage, ''Success'', '''', @RunId
	END CATCH
	
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Liffe_Notification_Load]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Liffe_Notification_Load]
(
	@LocationPath		VARCHAR(100)
	,@ReceiveLocationSysId INT
	,@RunId INT
)
AS
SET NOCOUNT ON
	
	-- 02 Jan 2014	RD		MBAL-24931 Added checking file age
	-- 09 Jan 2014	ED		EIB 25004 - remove importLog table and use Log table
	-- 25 Apr 2014	ED		EIB 25473 - raise error if file is too old and mark temp records as LoadState=3
	-- 14 May 2014	ED		EIB 25636 - pass LocationPath to ib_trx_load

	DECLARE     @ErrorMessage			VARCHAR(1024)
	DECLARE		@ErrorSeverity			INT
	DECLARE		@ErrorState				INT
	
    DECLARE @DataSourceCd VARCHAR(100)
	DECLARE @DataSourceId INT
	DECLARE @Code VARCHAR(100)
	DECLARE @ReturnValue INT
	DECLARE @Output INT 
	DECLARE @Output2 INT
	DECLARE @DefaultCurrencyId INT
			
	--specify datasource in proc.
	SET @DataSourceCd = ''LIFFE''
	IF @LocationPath IS NULL SET @LocationPath = @DataSourceCd

	SET @Code = @DataSourceCd
	EXEC @ReturnValue= [_ib_DataSource_GetByCodeForOutput] @Code, @OutPut OUTPUT, @Output2 OUTPUT
	SET @DataSourceId = @Output
	SET @DefaultCurrencyId = @Output2	

	UPDATE LIFFE_Notification
	SET LoadState = 1
	WHERE LoadState = 0
		AND Filename = @LocationPath

	-- Duplicate file check										
	DECLARE @IsFileAlreadyLoaded INT
	EXEC @IsFileALreadyLoaded = HasFileBeenLoaded @LocationPath, @DataSourceId

	IF @IsFileAlreadyLoaded = 1
		BEGIN					
			UPDATE [dbo].[Liffe_Notification]
			SET [LoadState] = 3
			WHERE [LoadState] = 1
				AND [FileName] = @LocationPath		
			RETURN
		END
		
	DECLARE @ImportFileId INT
	EXEC ib_ImportFile_Add @DataSourceId, @LocationPath, @ImportFileId output	
	
	DECLARE @SelectedAsOfDate DATETIME	
	EXEC [dbo].[ib_Liffe_GetBusinessDateFromFilename] @LocationPath, @SelectedAsOfDate OUTPUT, @DataSourceId, @ReceiveLocationSysId, @RunId
	
	UPDATE ib_ImportFile SET AsOfDate= @SelectedAsOfDate WHERE ImportFileId=@ImportFileId
	
	--rd - make sure the As Of Date is not older than acceptable
	DECLARE @IsAcceptable bit
	EXECUTE [dbo].[Load_IsFileTooOld] @DataSourceId,@LocationPath,@SelectedAsOfDate,@IsAcceptable OUTPUT, @ReceiveLocationSysId, @RunId
	IF (@IsAcceptable = 0)
	BEGIN
		UPDATE Liffe_Notification SET [LoadState] = 3 WHERE [Filename] = @LocationPath
		RAISERROR (''File is too old.'', 18, 0)
		RETURN
	END	
	
	--creating Temp Table just for use in this process
	--for iterating through the records.
	CREATE TABLE #temp1
	(
	Liffe_NotificationId INT,
	Exchange				varchar(5),
	OriginatingMemberName VARCHAR(3),
	AccountCode				varchar(25), 	
	PhysicalCommodity VARCHAR(3),
	ContractType VARCHAR(1),
	GenericContractType VARCHAR(1),
	ExpiryMonth VARCHAR(5),
	ExercisePrice VARCHAR(24),
	Volume VARCHAR(19),
	LongOrShort VARCHAR(1),
	Price VARCHAR(24),
	TradingDayOfTrade VARCHAR(19),
	NotificationSlipType VARCHAR(1),
	TradingDate VARCHAR(10)
	)

	INSERT INTO #temp1
	(
	Liffe_NotificationId,
	Exchange,
	OriginatingMemberName,
	AccountCode,
	PhysicalCommodity,
	ContractType,
	GenericContractType,
	ExpiryMonth,
	ExercisePrice,
	Volume,
	LongOrShort,
	Price,
	TradingDayOfTrade,
	NotificationSlipType,
	TradingDate
	)
	SELECT 
		Liffe_NotificationId,
		ExchangeMnemonic,
		OrgMember,
		Account,
		Commodity,
		ContractType,
		GenContractType,
		ExpiryMonth,
		Strike,
		VolumeToAdjust,
		LongShort,
		ValPrice,
		TradingDayTrade,
		NotificationSlipType,
		TradingDate
	FROM [dbo].[Liffe_Notification]
	WHERE LoadState = 1
		AND [FileName] = @LocationPath
		AND (
			NotificationSlipType IN (''A'', ''B'', ''E'', ''T'')
			OR (NotificationSlipType IN (''H'', ''R'') AND GenContractType <> ''Z'')
			OR (NotificationSlipType = ''J'' AND GenContractType <> ''Z'' AND VolumeToAdjust != 0)
			)
			
	SET XACT_ABORT ON 

	BEGIN TRAN T1

	-- BizTalk''s SQL Adapter uses more restrictive read serializable
	-- so this is necessary to relax it to something that is default
	-- and perfectly acceptable!
	SET TRANSACTION ISOLATION LEVEL READ COMMITTED
	
	BEGIN TRY

	DECLARE 
		@Liffe_NotificationId INT,
		@Exchange VARCHAR(100),
		@OriginatingMemberName VARCHAR(100),
		@AccountCode VARCHAR(100),
		@PhysicalCommodity VARCHAR(100),
		@ContractType VARCHAR(100),
		@GenericContractType VARCHAR(100),
		@ExpiryMonth VARCHAR(5),
		@ExercisePriceChr VARCHAR(24),
		@Volume DECIMAL(18,10),
		@LongOrShort VARCHAR(100),
		@PriceChr VARCHAR(24),
		@TradingDayOfTrade VARCHAR(19),
		@NotificationSlipType VARCHAR(1),
		@TradingDate VARCHAR(10)

    DECLARE @MarexFirmId INT
    SET @MarexFirmId = [dbo].[udf_GetMarexFirmId]()

	DECLARE trx_cursor CURSOR FOR
	SELECT Liffe_NotificationId,
		Exchange,
		OriginatingMemberName,
		AccountCode,
		PhysicalCommodity,
		ContractType,
		GenericContractType,
		ExpiryMonth,
		ExercisePrice,
		Volume,
		LongOrShort,
		Price,
		TradingDayOfTrade,
		NotificationSlipType,
		TradingDate
	FROM #temp1

	OPEN trx_cursor

	-- Perform the first fetch and store the values in variables.
	-- Note: The variables are in the same order as the columns
	-- in the SELECT statement. 

	FETCH NEXT FROM trx_cursor
	INTO @Liffe_NotificationId,
	@Exchange,
	@OriginatingMemberName,
	@AccountCode,
	@PhysicalCommodity,
	@ContractType,
	@GenericContractType,
	@ExpiryMonth,
	@ExercisePriceChr,
	@Volume,
	@LongOrShort,
	@PriceChr,
	@TradingDayOfTrade,
	@NotificationSlipType,
	@TradingDate

	-- Check @@FETCH_STATUS to see if there are any more rows to fetch.
	WHILE @@FETCH_STATUS = 0
	BEGIN
		
		DECLARE @ExchangeCd varchar(25)
		DECLARE @FirmCd varchar(100)
		DECLARE @AccountCd varchar(100)
		DECLARE @InstrumentTypeCd VARCHAR(100)
		DECLARE @InstrumentCd varchar(100)
		DECLARE @ExpYr smallint
		DECLARE @ExpMth smallint
		DECLARE @ExpDay smallint
		DECLARE @StrikePrice decimal(19,4)
		DECLARE @TrxTypeCd varchar(25)
		DECLARE @OptionTypeCd varchar(25)
		DECLARE @Quantity decimal(18,10)
		DECLARE	@QuantityLong int
		DECLARE @QuantityShort int
		DECLARE @TrxDate datetime
		DECLARE @PriceDec decimal(24,10)
		DECLARE @AsOfDate datetime

		SET @ExchangeCd = @exchange
		
		SET @Output = null
		DECLARE @InstrumentTypeId INT
		SET @InstrumentTypeCd = RTRIM(@genericcontracttype)
		EXEC @ReturnValue = ib_Instrumenttype_AddAsNeeded @DataSourceId, @InstrumentTypeCd, @OutPut OUTPUT
		SET @InstrumentTypeId = @Output

		DECLARE @CurrencyId INT

		SET @Output = null
		SET @Output2 = null
		DECLARE @InstrumentId int
		
		-- MBAL-15310 Update the Instrument code
		SET @InstrumentCd = @InstrumentTypeCd + ''_'' + @ExchangeCd + ''_'' + @PhysicalCommodity
			
		EXEC @ReturnValue= [ib_Instrument_AddAsNeeded] @DataSourceId, @InstrumentTypeId
			,@InstrumentCd, @CurrencyId, @OutPut OUTPUT, @Output2 OUTPUT
		SET @InstrumentId = @Output
		SET @CurrencyId = @Output2
		IF @Output2 = NULL
			SET @CurrencyId = @DefaultCurrencyId

		DECLARE @TickSize int
		SELECT @TickSize = ticksize 
		FROM ib_instrument 
		WHERE instrumentid = @InstrumentId

		SET @FirmCd = @originatingmembername
		SET @AccountCd = @accountcode
		
		DECLARE @StrikePriceDivisor DECIMAL(19,4)
		DECLARE @PriceDivisor DECIMAL(19,4)

		SET @StrikePriceDivisor = NULL
		SET @PriceDivisor = NULL
		
		SELECT @StrikePriceDivisor = StrikePriceDivisor
			, @PriceDivisor = PriceDivisor
		FROM [dbo].[ib_InstrumentDataSource]
		WHERE DataSourceId = @DataSourceId
			AND DataSourceInstrumentCode = @InstrumentCd 

		IF @PriceDivisor IS NULL 
			SET @PriceDivisor = 1
			
		IF @NotificationSlipType  IN (''J'', ''A'', ''E'')
			SET @PriceDec = 0
		ELSE	
			SET @PriceDec = CONVERT(DECIMAL(24, 10), @PriceChr) / @PriceDivisor

		IF @StrikePriceDivisor IS NULL -- Then get the default
			BEGIN
				DECLARE @ExchangeId INT
				SELECT @ExchangeId = ExchangeId 
				FROM ib_Exchange 
				WHERE [Code] = @ExchangeCd
				
				SET @StrikePriceDivisor = [dbo].[udf_GetDefaultStrikePriceDivisor](@DataSourceId, @ExchangeId)
			END
			
			IF @ExercisePriceChr IS NULL OR LTRIM(RTRIM(@ExercisePriceChr)) = '''' 
				SET @StrikePrice = 0
			ELSE
				SET @StrikePrice = CONVERT(DECIMAL(19,4), @ExercisePriceChr)/@StrikePriceDivisor
		
		SET @TrxTypeCd = @NotificationSlipType
		SET @OptionTypeCd = @contracttype
		
		SET @AsOfDate = @SelectedAsOfDate

		-- Convert date chars from YYYY-MM-DD to DateTime
		SET @TradingDate = REPLACE(LTRIM(RTRIM(@TradingDate)),''-'', ''/'') 
		SET @TrxDate = convert(datetime, @TradingDate, 111)
		
		SET @Quantity = @volume
		
		IF (@LongOrShort = ''L'')
		BEGIN
			SET @QuantityLong = @volume 
			SET @QuantityShort = 0
		END
		ELSE
		BEGIN
			SET @QuantityLong = 0
			SET @QuantityShort = @volume
		END
		
			-- Get expiry from ExpiryMonth string like MAR13
			DECLARE @ExtractedMonth varchar(3)
			DECLARE @ExtractedYear varchar(4)
			SET @ExtractedMonth = LEFT(@ExpiryMonth, 3)
			SET @ExtractedYear = ''20'' + RIGHT(@ExpiryMonth, 2)
			SET @ExpMth = 
				CASE  
					WHEN @ExtractedMonth = ''JAN'' THEN 1
					WHEN @ExtractedMonth = ''FEB'' THEN 2
					WHEN @ExtractedMonth = ''MAR'' THEN 3
					WHEN @ExtractedMonth = ''APR'' THEN 4
					WHEN @ExtractedMonth = ''MAY'' THEN 5
					WHEN @ExtractedMonth = ''JUN'' THEN 6
					WHEN @ExtractedMonth = ''JUL'' THEN 7
					WHEN @ExtractedMonth = ''AUG'' THEN 8
					WHEN @ExtractedMonth = ''SEP'' THEN 9
					WHEN @ExtractedMonth = ''OCT'' THEN 10
					WHEN @ExtractedMonth = ''NOV'' THEN 11
					WHEN @ExtractedMonth = ''DEC'' THEN 12
				END	
			SET @ExpYr = CONVERT(SMALLINT, @ExtractedYear)
			SET @ExpDay = dbo.udf_OnLoad_ExpiryDate_Get_Day(@ExpYr,@ExpMth,0)

		EXEC [ib_Trx_Load]
		@DataSourceCd,
		@ExchangeCd,
		@FirmCd,
		@AccountCd,
		NULL,
		@InstrumentCd,
		@ExpYr,
		@ExpMth,
		@ExpDay,
		@StrikePrice,
		@TrxTypeCd,
		@OptionTypeCd,
		@Quantity,
		@TrxDate,
		@PriceDec,
		@Liffe_NotificationId,
		@GenericContractType,
		@AsOfDate,
		@LocationPath,
		@MarexFirmId,
		@QuantityLong = @QuantityLong,
		@QuantityShort = @QuantityShort,
		@ReceiveLocationSysId = @ReceiveLocationSysId,
		@RunId = @RunId

		--flip processed flag in source table.
		UPDATE Liffe_Notification
		SET LoadState = 2
		WHERE Liffe_NotificationId = @Liffe_NotificationId
			AND LoadState = 1

		FETCH NEXT FROM trx_cursor
		INTO @Liffe_NotificationId,
		@Exchange,
		@OriginatingMemberName,
		@AccountCode,
		@PhysicalCommodity,
		@ContractType,
		@GenericContractType,
		@ExpiryMonth,
		@ExercisePriceChr,
		@Volume,
		@LongOrShort,
		@PriceChr,
		@TradingDayOfTrade,
		@NotificationSlipType,
		@TradingDate
	END

	CLOSE trx_cursor
	DEALLOCATE trx_cursor


	COMMIT TRANSACTION t1

	DROP TABLE #temp1
	
	END TRY
	BEGIN CATCH
			
				SELECT @ErrorMessage= ERROR_MESSAGE()
					, @ErrorSeverity = ERROR_SEVERITY()
					, @ErrorState = ERROR_STATE()
					
				IF XACT_STATE() = -1
					BEGIN
						-- transaction must get rolled back so need to fail this whole operation
						-- rollback seems to work whether or not xact_abort is on
						ROLLBACK TRANSACTION

						-- Use RAISERROR inside the CATCH block to return error
						-- information about the original error that caused
						-- execution to jump to the CATCH block.
						RAISERROR (@ErrorMessage, @ErrorSeverity, @ErrorState);
						RETURN	-- can''t do any writes so no point continuing (otherwise need to check every write / commit)
					END
				ELSE
					EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @ErrorMessage, ''Error'', '''', @RunId
	END CATCH



	SET XACT_ABORT OFF
	
RETURN 0
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_DataSource_Add]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_DataSource_Add]
(
 @Code VARCHAR(100)
,@Name VARCHAR(100)
,@DefaultCurrencyId INT
,@ProvidesVariation BIT
,@CreateUsername VARCHAR(50)
,@IncludeDetailAccountInTradeReconciliation BIT = NULL
,@UseTrxsForTradedOnDay BIT = NULL
,@@DataSourceId INT OUTPUT
)
AS 
SET NOCOUNT ON

IF EXISTS ( SELECT
                DataSourceId
            FROM
                [dbo].[ib_DataSource]
            WHERE
                [Code] = @Code ) 
    BEGIN
        SELECT
            @@DataSourceId = -1
        RAISERROR
	(N''There is already another Data Source with the same code (%s). Please specify other code!'', 11, 1, @Code)
    END
ELSE 
    BEGIN
        INSERT  INTO [dbo].[ib_DataSource]
                ( [Code]
                ,[Name]
                ,[DefaultCurrencyId]
                ,[ProvidesVariation]
                ,[CreateUsername]
                ,[UseTrxsForTradedOnDay]
                ,[IncludeDetailAccountInTradeReconciliation]
                )
        VALUES
                ( @Code
                ,@Name
                ,@DefaultCurrencyId
                ,@ProvidesVariation
                ,@CreateUsername
                ,ISNULL(@UseTrxsForTradedOnDay, 0)
                ,ISNULL(@IncludeDetailAccountInTradeReconciliation, 0)
                )

        SELECT
            @@DataSourceId = SCOPE_IDENTITY()
    END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[CreditSuisse_Position_Purge]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[CreditSuisse_Position_Purge] 
	(
		@LoadState		TINYINT = 0,
		@FileName       VARCHAR (512)= NULL
	)
AS

-- =============================================
-- Author:		Alister McLeod
-- Create date: 06 Apr 2011
-- Description:	Deletes from CreditSuisse_Position table all the records where the LoadState is 0
-- =============================================
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
		DELETE FROM [dbo].[CreditSuisse_Position] WHERE LoadState= @LoadState AND [FileName] = Coalesce(@FileName, [FileName])

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Liffe_Position_Load]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Liffe_Position_Load]
(
	@LocationPath		VARCHAR(100)
	,@ReceiveLocationSysId INT
	,@RunId INT
)
AS
SET NOCOUNT ON

-- Revision History:
-- 23 Jan 2013	AAJM	Removed Market Value calculations and replaced MarketValuePS with ProfitLoss value, and
--						MarketValueTR value with Premium value from file.
-- 02 Jan 2014	RD		MBAL-24931 Added checking file age
-- 09 Jan 2014	ED		EIB 25004 - remove importLog table and use Log table
-- 25 Apr 2014	ED		EIB 25473 - raise error if file is too old and mark temp records as LoadState=3

	DECLARE     @ErrorMessage			VARCHAR(1024)
	DECLARE		@ErrorSeverity			INT
	DECLARE		@ErrorState				INT
	
	DECLARE @DataSourceCd VARCHAR(100)
	DECLARE @DataSourceId INT
	DECLARE @Code VARCHAR(100)
	DECLARE @ReturnValue INT
	DECLARE @Output INT
	DECLARE @Output2 INT
	DECLARE @DefaultCurrencyId INT
			
	--specify datasource in proc.
	SET @DataSourceCd = ''LIFFE''
	IF @LocationPath IS NULL SET @LocationPath = @DataSourceCd

	SET @Code = @DataSourceCd
	EXEC @ReturnValue= [_ib_DataSource_GetByCodeForOutput] @Code,@OutPut output,@Output2 output	
	SET @DataSourceId = @Output
	SET @DefaultCurrencyId = @Output2	

	-- Duplicate file check										
	DECLARE @IsFileAlreadyLoaded INT
	EXEC @IsFileALreadyLoaded = HasFileBeenLoaded @LocationPath, @DataSourceId

	IF @IsFileAlreadyLoaded = 1
		BEGIN					
			UPDATE [dbo].[LIFFE_Position]
			SET [LoadState] = 3
			WHERE [LoadState] = 1
				AND [FileName] = @LocationPath				

			RETURN
		END
					
	-- Store ImportFile record to be associated with Settlement Price load
	DECLARE @ImportFileId INT
	EXEC ib_ImportFile_Add @DataSourceId, @LocationPath, @ImportFileId output

	DECLARE @AsOfDate DATETIME
	EXEC [dbo].[ib_Liffe_GetBusinessDateFromFilename] @LocationPath, @AsOfDate OUTPUT, @DataSourceId, @ReceiveLocationSysId, @RunId
	UPDATE ib_ImportFile SET AsOfDate= @AsOfDate WHERE ImportFileId=@ImportFileId

	--rd - make sure the As Of Date is not older than acceptable
	DECLARE @IsAcceptable bit
	EXECUTE [dbo].[Load_IsFileTooOld] @DataSourceId,@LocationPath,@AsOfDate,@IsAcceptable OUTPUT, @ReceiveLocationSysId, @RunId
	IF (@IsAcceptable = 0)
	BEGIN
		UPDATE Liffe_Position SET [LoadState] = 3 WHERE [Filename] = @LocationPath
		RAISERROR (''File is too old.'', 18, 0)
		RETURN
	END	

	-- There really isn''t any need for orchestration to call a LoadStateChange anymore
	-- since we only process rows for single file now
	-- but to keep consistent with other loaders - we''ll update to LoadState 1 at 
	-- start of this Load stored procedure
	UPDATE [LIFFE_Position]
	SET LoadState = 1
	WHERE LoadState = 0
		AND Filename = @LocationPath

	CREATE TABLE #temp1
	(
		Liffe_PositionId		int,
		Exchange				varchar(5),
		OriginatingMemberName	varchar(3),
		AccountCode				varchar(25), 	
		PhysicalCommodity		varchar(3),
		ContractType			varchar(1),
		GenericContractType		varchar(1),
		LongExpiryDate			varchar(10),
		ExercisePrice			varchar(24),
		LongAccountVolume		varchar(19),
		ShortAccountVolume		varchar(19),
		PayCollect				varchar(15),
		PremiumPayCollect		VARCHAR(24),
		LongLotsTraded			varchar(19),			
		ShortLotsTraded			varchar(19),
		ValuationPrice			varchar(24),
		LotsSize				VARCHAR(19)
	)

	INSERT INTO #temp1
	(
		LIFFE_PositionId,
		Exchange,
		OriginatingMemberName,
		AccountCode,
		PhysicalCommodity,
		ContractType,
		GenericContractType,
		LongExpiryDate,
		ExercisePrice,
		LongAccountVolume,
		ShortAccountVolume,
		PayCollect,
		PremiumPayCollect,
		LongLotsTraded,
		ShortLotsTraded,
		ValuationPrice,
		LotsSize
	)
	SELECT 	LIFFE_PositionId,
			ExchangeMnemonic,
			OrgMember,
			Account,
			Commodity,
			ContractType,
			GenContractType,
			LongExpiryDate,
			Strike,
			LongPositionVol,
			ShortPositionVol,
			ProfitLoss,
			Premium,
			LongTradedVol,
			ShortTradedVol,
			ValPrice,
			LotSize
	FROM [dbo].[LIFFE_Position]
	WHERE LoadState = 1
		AND [FileName] = @LocationPath

	SET XACT_ABORT ON 

	BEGIN TRAN T1

	-- BizTalk''s SQL Adapter uses more restrictive read serializable
	-- so this is necessary to relax it to something that is default
	-- and perfectly acceptable!
	SET TRANSACTION ISOLATION LEVEL READ COMMITTED
	
	BEGIN TRY
		
	DECLARE @LIFFE_PositionId		int
	DECLARE @Exchange				varchar(100)
	DECLARE @OriginatingMemberName	varchar(100)
	DECLARE @AccountCode			varchar(100)
	DECLARE @PhysicalCommodity		varchar(100)
	DECLARE @ContractType			varchar(100)
	DECLARE @GenericContractType	varchar(100)
	DECLARE @LongExpiryDate			varchar(25)
	DECLARE @ExercisePriceChr		varchar(24)
	DECLARE @LongAccountVolume		varchar(29)
	DECLARE @ShortAccountVolume		varchar(29)
	DECLARE @ProfitLoss				varchar(24)
	DECLARE @PremiumProfitLoss		varchar(24)
	DECLARE @LongLotsTraded			varchar(19)
	DECLARE	@ShortLotsTraded		varchar(19)
	DECLARE @ValuationPrice			varchar(24)
	DECLARE @LotsSize				VARCHAR(19)
	DECLARE pos_cursor CURSOR FOR
	SELECT	LIFFE_PositionId,
			Exchange,
			OriginatingMemberName,
			AccountCode,
			PhysicalCommodity,
			ContractType,
			GenericContractType,
			LongExpiryDate,
			ExercisePrice,
			LongAccountVolume,
			ShortAccountVolume,
			PayCollect,
			PremiumPayCollect,
			LongLotsTraded,
			ShortLotsTraded,
			ValuationPrice,
			LotsSize
	FROM	#temp1

	OPEN pos_cursor

	FETCH NEXT FROM pos_cursor
	INTO 
		@LIFFE_PositionId,
		@Exchange,
		@OriginatingMemberName,
		@AccountCode,
		@PhysicalCommodity,
		@ContractType,
		@GenericContractType,
		@LongExpiryDate,
		@ExercisePriceChr,
		@LongAccountVolume,
		@ShortAccountVolume,
		@ProfitLoss,
		@PremiumProfitLoss,
		@LongLotsTraded,	
		@ShortLotsTraded,
		@ValuationPrice,
		@LotsSize

		-- Check @@FETCH_STATUS to see IF there are any more rows to fetch.
		WHILE @@FETCH_STATUS = 0
		BEGIN
	
			DECLARE @ExchangeCd				varchar(25)
			DECLARE @FirmCd					varchar(100)
			DECLARE @AccountCd				varchar(100)
			DECLARE @InstrumentCd			varchar(100)
			DECLARE @InstrumentTypeCd		VARCHAR(100)
			DECLARE @QuantityPS				decimal(18,10)
			DECLARE @MarketValuePS			decimal(19,4)
			DECLARE @MarketValueTR			decimal(19,4)
			DECLARE @ExpiryDate				datetime
			DECLARE @StrikePrice			decimal(19,4)
			DECLARE @TrxTypeCdPS			varchar(25)
			DECLARE @TrxTypeCdTR			varchar(25)
			DECLARE @OptionTypeCd			varchar(25)
			DECLARE @QuantityTR				decimal(18,10)
			DECLARE @TrxDate				datetime
			DECLARE @PriceDec				decimal(24,10)
			DECLARE @ExpYr					smallint
			DECLARE @ExpMth					smallint
			DECLARE @ExpDay					smallint
			DECLARE	@LongQuantity			decimal(19,4) 
			DECLARE @ShortQuantity			decimal(19,4) 
			DECLARE @TradedLongQuantity		decimal(19,4) 
			DECLARE @TradedShortQuantity	decimal(19,4)
			
			IF (@LongAccountVolume = '''')
				SET @LongAccountVolume = ''0''
			IF (@ShortAccountVolume = '''')
				SET @ShortAccountVolume = ''0''
			IF (@ProfitLoss = '''')
				SET @ProfitLoss = ''0''
			IF (@PremiumProfitLoss = '''')
				SET @PremiumProfitLoss = ''0''

			SET @ExchangeCd = @exchange
			
			SET @Output = null
			DECLARE @InstrumentTypeId int
			SELECT @InstrumentTypeCd = RTRIM(@GenericContractType)
			EXEC @ReturnValue = ib_Instrumenttype_AddAsNeeded @DataSourceId,@InstrumentTypeCd,@OutPut output
			SET @InstrumentTypeId = @Output
			
			DECLARE @CurrencyId int
					
			SET @Output2 = null
			SET @Output = null
			DECLARE @InstrumentId int
			
			-- MBAL-15310 Update the Instrument code
			SET @InstrumentCd = @InstrumentTypeCd + ''_'' + @ExchangeCd + ''_'' + @PhysicalCommodity
		
			EXEC @ReturnValue= [ib_Instrument_AddAsNeeded] @DataSourceId,@InstrumentTypeId,@InstrumentCd,@CurrencyId,@OutPut output,@OutPut2 output	
			SET @InstrumentId = @Output
			SET @CurrencyId = @Output2
			IF @CurrencyId is null
			BEGIN
				SET @CurrencyId = @DefaultCurrencyId
			END

			DECLARE @TickSize int
			SELECT @TickSize = ticksize from ib_instrument where instrumentid = @InstrumentId

			DECLARE @MarketValueDivisor		Decimal(19,4)
			DECLARE	@StrikePriceDivisor		Decimal(19,4)
			DECLARE @PriceDivisor			DECIMAL(19,4)
			
			SET @MarketValueDivisor = NULL
			SET @StrikePriceDivisor = NULL
			SET @PriceDivisor = NULL
			
			SELECT @MarketValueDivisor = MarketValueDivisor
					, @StrikePriceDivisor	= StrikePriceDivisor
					, @PriceDivisor = PriceDivisor
			FROM [dbo].[ib_InstrumentDataSource]
			WHERE DataSourceId = @DataSourceId
				AND DataSourceInstrumentCode = @InstrumentCd 
			
			IF @MarketValueDivisor IS NULL SET @MarketValueDivisor = 1

			SET @FirmCd=@originatingmembername
			SET @AccountCd = @accountcode
			SET @QuantityPS = cast(@longaccountvolume as decimal(18,10)) - cast(@shortaccountvolume as decimal(18,10))
			
			-- New LIFFE files have records ''ProfitLoss'' which seems to equal previous MarketValuePS calculation
			-- and Premium field that seems to equal previous MarketValueTR calculation.
			SET @MarketValuePS = CONVERT(decimal(19,4), @ProfitLoss) / @MarketValueDivisor
			SET @MarketValueTR = CONVERT(decimal(19,4), @PremiumProfitLoss) / @MarketValueDivisor
						
			IF @StrikePriceDivisor IS NULL -- Then get the default
			BEGIN
				DECLARE @ExchangeId INT
				SELECT @ExchangeId = ExchangeId FROM ib_Exchange WHERE [Code] = @ExchangeCd
				
				SET @StrikePriceDivisor = [dbo].[udf_GetDefaultStrikePriceDivisor](@DataSourceId, @ExchangeId)
			END

			IF @ExercisePriceChr IS NULL OR LTRIM(RTRIM(@ExercisePriceChr)) = '''' 
				SET @StrikePrice = 0
			ELSE
				SET @StrikePrice = CONVERT(DECIMAL(19,4), @ExercisePriceChr)/@StrikePriceDivisor
			
			-- Set Settlement Price				
			IF @PriceDivisor IS NULL OR @ExchangeCd = ''FOX'' -- for fox, ignore price divisor(MBAL 15578)
				SET @PriceDivisor = 1
					
			DECLARE @SettlementPrice DECIMAL(24,10)
			SET @SettlementPrice = CONVERT(DECIMAL(24,10), @ValuationPrice) / @PriceDivisor
			
			SET @TrxTypeCdPS = ''Position''
			SET @TrxTypeCdTR = ''Premium''
			SET @OptionTypeCd=@contracttype
			SET @TrxDate = @AsOfDate
			-- MBAL 15856 - Set Quantity = 0 to Premium trx
			-- SET @QuantityTR = case when @TickSize > 0 then @PremiumProfitLoss/@TickSize else @PremiumProfitLoss END
			SET @QuantityTR = 0
			
			-- Long Expiry Date Format: YYYY-MM-00
			SET @LongExpiryDate = RTRIM(LTRIM(@LongExpiryDate))
			SET @ExpYr = CONVERT(SMALLINT, LEFT(@LongExpiryDate,4))
			SET @ExpMth = CONVERT(SMALLINT, SUBSTRING(@LongExpiryDate,6,2))
			SET @ExpDay = CONVERT(SMALLINT, RIGHT(@LongExpiryDate,2))
			SET @ExpDay = dbo.udf_OnLoad_ExpiryDate_Get_Day(@ExpYr,@ExpMth,@ExpDay)

			SET @InstrumentTypeCd = @genericcontracttype
			
			DECLARE @LotsSizeInt			INT
			
			SET @LotsSizeInt = CONVERT(INT, @LotsSize)
			
			IF @LotsSizeInt IS NULL
				SET @LotsSizeInt = 1
			
			IF UPPER(RTRIM(@GenericContractType)) = ''M''
				SET @MarketValuePS = @MarketValuePS * @LotsSizeInt

			SET @LongQuantity = @LongAccountVolume
			SET @ShortQuantity = @ShortAccountVolume
			IF (@LongLotsTraded = '''')
				SET @TradedLongQuantity = 0
			ELSE
				SET @TradedLongQuantity = @LongLotsTraded
			IF (@ShortLotsTraded = '''')
				SET @TradedShortQuantity = 0
			ELSE
				SET @TradedShortQuantity = @ShortLotsTraded
			
			DECLARE @PositionId INT
			SET @PositionId = NULL
			
			EXEC [ib_Position_W_Trans_Load]
			@DataSourceCd,
			@ExchangeCd,
			@FirmCd,
			@AccountCd,	
			@AsOfDate,
			@InstrumentCd,
			@QuantityPS,
			@MarketValuePS,
			@MarketValueTR,
			@ExpYr,
			@ExpMth,
			@ExpDay,
			@StrikePrice,
			@TrxTypeCdPS,
			@TrxTypeCdTR,
			@OptionTypeCd,
			@QuantityTR,
			@TrxDate,
			@PriceDec,
			@LIFFE_PositionId,
			@InstrumentTypeCd,
			NULL,
			@LongQuantity, 
			@ShortQuantity, 
			@TradedLongQuantity, 
			@TradedShortQuantity,
			@PositionId = @PositionId OUTPUT, 
			@ReceiveLocationSysId = @ReceiveLocationSysId, 
			@RunId = @RunId,
			@LocationPath = @LocationPath


			-- Add Settlement Price											
			EXEC ib_Price_AddFromPositionLoad
				@PositionId
				, @ImportFileId
				, @SettlementPrice 	
				
			--flip processed flag in source table.
			UPDATE [LIFFE_Position]
			SET [LoadState] = 2
			WHERE [LIFFE_PositionId] = @LIFFE_PositionId
				AND [LoadState] = 1

			FETCH NEXT FROM pos_cursor
			INTO 
			@LIFFE_PositionId,
			@Exchange,
			@OriginatingMemberName,
			@AccountCode,
			@PhysicalCommodity,
			@ContractType,
			@GenericContractType,
			@LongExpiryDate,
			@ExercisePriceChr,
			@LongAccountVolume,
			@ShortAccountVolume,
			@ProfitLoss,
			@PremiumProfitLoss,
			@LongLotsTraded,	
			@ShortLotsTraded,
			@ValuationPrice,
			@LotsSize

		END

	CLOSE pos_cursor
	DEALLOCATE pos_cursor

	COMMIT TRAN T1

	DROP TABLE #temp1
	
	
	END TRY
	BEGIN CATCH
			
				SELECT @ErrorMessage= ERROR_MESSAGE()
					, @ErrorSeverity = ERROR_SEVERITY()
					, @ErrorState = ERROR_STATE()
					
				IF XACT_STATE() = -1
					BEGIN
						-- transaction must get rolled back so need to fail this whole operation
						-- rollback seems to work whether or not xact_abort is on
						ROLLBACK TRANSACTION

						-- Use RAISERROR inside the CATCH block to return error
						-- information about the original error that caused
						-- execution to jump to the CATCH block.
						RAISERROR (@ErrorMessage, @ErrorSeverity, @ErrorState);
						RETURN	-- can''t do any writes so no point continuing (otherwise need to check every write / commit)
					END
				ELSE
					EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @ErrorMessage, ''Error'', '''', @RunId
	END CATCH



	SET XACT_ABORT OFF

RETURN 0
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_DataSource_CopyTrxTypes]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_DataSource_CopyTrxTypes]
    @OriginalDataSourceId INT
   ,@DestinationDataSourceId INT
   ,@@AffectedRows INT OUTPUT
AS 
SET NOCOUNT ON

BEGIN

    SET @@AffectedRows = 0
    DECLARE @trxTypeId INT
    DECLARE @Code NVARCHAR(100)
    DECLARE @Description NVARCHAR(MAX)
    DECLARE @IsPosition BIT
    DECLARE @IsPremium BIT
    DECLARE @IsPandS BIT
    DECLARE @IsPandL BIT
    DECLARE @IsTrade BIT
    DECLARE @ExcludeFromTradeRec BIT
    DECLARE @IsCancellation BIT
    DECLARE @IsOptionMarketValue BIT
    DECLARE @IsAutMatched BIT
	
    DECLARE crTrxTypes CURSOR
    FOR
    SELECT
        TrxTypeId
    FROM
        ib_TrxType
    WHERE
        DataSourceId = @OriginalDataSourceId
	
    OPEN crTrxTypes
	
    BEGIN TRAN
	
    FETCH NEXT FROM crTrxTypes INTO @trxTypeId
	
    WHILE @@FETCH_STATUS = 0 
        BEGIN
            SELECT
                @Code = Code
               ,@Description = [Description]
               ,@IsPosition = IsPosition
               ,@IsPremium = IsPremium
               ,@IsPandS = IsPandS
               ,@IsPandL = IsPandL
               ,@IsTrade = IsTrade
               ,@ExcludeFromTradeRec = ExcludeFromTradeRec
               ,@IsCancellation = IsCancellation
               ,@IsOptionMarketValue = IsOptionMarketValue
               ,@IsAutMatched = IsAutoMatched
            FROM
                ib_TrxType
            WHERE
                TrxTypeId = @trxTypeId
	
            IF NOT EXISTS ( SELECT
                                TrxTypeId
                            FROM
                                ib_TrxType
                            WHERE
                                Code = @Code AND
                                DataSourceId = @DestinationDataSourceId ) 
                BEGIN
                    INSERT  INTO ib_TrxType
                            ( DataSourceId
                            ,Code
                            ,[Description]
                            ,IsPosition
                            ,IsPremium
                            ,IsPandS
                            ,IsPandL
                            ,IsTrade
                            ,ExcludeFromTradeRec
                            ,IsCancellation
                            ,IsOptionMarketValue
                            ,IsAutoMatched
                            ,CreateUsername
                            ,CreateDate
                            )
                    VALUES
                            ( @DestinationDataSourceId
                            ,@Code
                            ,@Description
                            ,@IsPosition
                            ,@IsPremium
                            ,@IsPandS
                            ,@IsPandL
                            ,@IsTrade
                            ,@ExcludeFromTradeRec
                            ,@IsCancellation
                            ,@IsOptionMarketValue
                            ,@IsAutMatched
                            ,SUSER_SNAME()
                            ,GETDATE()
                            )
			
                    IF @@ERROR != 0 
                        BEGIN
                            ROLLBACK TRANSACTION
                            CLOSE crTrxTypes
                            DEALLOCATE crTrxTypes
                            RETURN
                        END
			
                    SET @@AffectedRows = @@AffectedRows + 1
                END
		
            FETCH NEXT FROM crTrxTypes INTO @trxTypeId
        END
    COMMIT TRAN
    CLOSE crTrxTypes
    DEALLOCATE crTrxTypes
	
    RETURN @@AffectedRows
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[CreditSuisse_Transaction_Add]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[CreditSuisse_Transaction_Add]
(
  @PRECID				VARCHAR(1)	= NULL 
  , @PFIRM	   			VARCHAR(1)	= NULL
  , @POFFIC				VARCHAR(3)	= NULL
  , @PACCT				VARCHAR(5)	= NULL
  , @PCTYM				VARCHAR(6)	= NULL
  , @PSBCUS				VARCHAR(2)	= NULL
  , @PSTYPE				VARCHAR(2)	= NULL
  , @PSUBTY				VARCHAR(1)	= NULL
  , @PSTYP2				VARCHAR(1)	= NULL
  , @PSTRIK				VARCHAR(15)	= NULL
  , @PEXPDT				VARCHAR(8)	= NULL
  , @PSUBAC				VARCHAR(10)	= NULL
  , @PTDATE				VARCHAR(8)	= NULL
  , @PTPRIC				VARCHAR(15)	= NULL
  , @PBS				VARCHAR(1)	= NULL
  , @PBROKR				VARCHAR(2)	= NULL
  , @PTRACE				VARCHAR(10)	= NULL
  , @PICODE				VARCHAR(3)	= NULL
  , @PREFNO				VARCHAR(12)	= NULL
  , @PCLASS				VARCHAR(1)	= NULL
  , @PSUBCL				VARCHAR(1)	= NULL
  , @PQTY				VARCHAR(15)	= NULL
  , @PPRTQ				VARCHAR(15)	= NULL
  , @PSDSC1				VARCHAR(3)	= NULL
  , @PMKVAL				VARCHAR(15)	= NULL
  , @PSDATE				VARCHAR(8)	= NULL
  , @PEXCH				VARCHAR(2)	= NULL
  , @PFC				VARCHAR(2)	= NULL 
  , @PTYPE				VARCHAR(1)	= NULL
  , @PSYMBL				VARCHAR(6)	= NULL
  , @PSUBEX				VARCHAR(1)	= NULL
  , @PPRTPR				VARCHAR(11)	= NULL
  , @PCLOSE				VARCHAR(15)	= NULL
  , @PPRCDT				VARCHAR(8)	= NULL
  , @PPRTCP				VARCHAR(11) = NULL
  , @PPRICE				VARCHAR(12) = NULL
  , @PCURSY				VARCHAR(3)	= NULL
  , @PGROSS				VARCHAR(15) = NULL
  , @FileName			VARCHAR (512)= NULL
)
AS

-- ====================================================
-- Author:		AAJM
-- Create date: 06 Apr 2011
-- Description:	Insert into CreditSuisse_Transaction table
--
-- Revision History
-- 17 May 2011	AAJM	Add PSUBEX for Sub Exchange Code
-- 18 May 2011	AAJM	Add PPRTPR Printable Price
-- 18 May 2011	AAJM	Add PPRTCP Printable Closing Price
-- =====================================================

BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

  INSERT INTO [dbo].[CreditSuisse_Transaction]
			( 
		    	[PRECID]
				, [PFIRM]
    			, [POFFIC]
			    , [PACCT]
    			, [PCTYM]
			    , [PSBCUS]
			    , [PSTYPE]
    			, [PSUBTY]
    			, [PSTYP2]
    			, [PSTRIK]
    			, [PEXPDT]
    			, [PSUBAC]
    			, [PTDATE]
    			, [PTPRIC]
    			, [PBS]
    			, [PBROKR]
    			, [PTRACE]
    			, [PICODE]
    			, [PREFNO]
    			, [PCLASS]
    			, [PSUBCL]
    			, [PQTY]
    			, [PPRTQ]
    			, [PSDSC1]
    			, [PMKVAL]
    			, [PSDATE]
    			, [PEXCH]
    			, [PFC]
    			, [PTYPE]
    			, [PSYMBL]
    			, [PSUBEX]
    			, [PPRTPR]
    			, [PCLOSE]
    			, [PPRCDT]
    			, [PPRTCP]
    			, [PPRICE]
    			, [PCURSY]
    			, [PGROSS]
    			, [FileName]
			)
    VALUES
			( 
    			@PRECID
    			, @PFIRM
    			, @POFFIC
    			, @PACCT
    			, @PCTYM
    			, @PSBCUS
    			, @PSTYPE
    			, @PSUBTY
    			, @PSTYP2
    			, @PSTRIK
    			, @PEXPDT
    			, @PSUBAC
    			, @PTDATE
    			, @PTPRIC
    			, @PBS
    			, @PBROKR
    			, @PTRACE
    			, @PICODE
    			, @PREFNO
    			, @PCLASS
    			, @PSUBCL
    			, @PQTY
    			, @PPRTQ
    			, @PSDSC1
    			, @PMKVAL
    			, @PSDATE
    			, @PEXCH
    			, @PFC
    			, @PTYPE
    			, @PSYMBL
    			, @PSUBEX
    			, @PPRTPR
    			, @PCLOSE
    			, @PPRCDT
    			, @PPRTCP
    			, @PPRICE
    			, @PCURSY
    			, @PGROSS
    			, @FileName
			)
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[Liffe_TradeReport_Purge]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[Liffe_TradeReport_Purge]
(
	@LoadState		TINYINT = 0,
	@FileName       VARCHAR (512)= NULL
)
AS
-- =============================================
-- Author:		Alister McLeod
-- Create date: 14 Dec 2012
-- Description:	Deletes from all TradeReport type files where the LoadState is 0
-- Revision History:
-- ----------------
-- =============================================
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
	DELETE FROM [dbo].[Liffe_TradeReport] WHERE LoadState= @LoadState AND [FileName] = Coalesce(@FileName, [FileName])
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_InstrumentTypeDataSource_Delete]''
');

GO
EXECUTE ('  /*
<details>
 <summary>Deletes an instrument type data source by its id from the ib_InstrumentTypeDataSource table</summary>
 <created author="Laurentiu Macovei" Date=" Sunday, 10 September 2006 2:26PM GMT" /> 
</details>
*/
create PROCEDURE [dbo].[ib_InstrumentTypeDataSource_Delete]
(
	@InstrumentTypeDataSourceId int
)
AS
SET NOCOUNT ON

DELETE FROM [dbo].[ib_InstrumentTypeDataSource]
      WHERE InstrumentTypeDataSourceId = @InstrumentTypeDataSourceId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Liffe_TradeReport_Load]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Liffe_TradeReport_Load]
(
	@LocationPath		VARCHAR(100)
	,@ReceiveLocationSysId INT
	,@RunId INT
)
AS
SET NOCOUNT ON

	-- 02 Jan 2014	RD		MBAL-24931 Added checking file age
	-- 09 Jan 2014	ED		EIB 25004 - remove importLog table and use Log table
	-- 25 Apr 2014	ED		EIB 25473 - raise error if file is too old and mark temp records as LoadState=3
	-- 14 May 2014	ED		EIB 25636 - pass LocationPath to ib_trx_load

	DECLARE     @ErrorMessage			VARCHAR(1024)
	DECLARE		@ErrorSeverity			INT
	DECLARE		@ErrorState				INT
					
	DECLARE @DataSourceCd VARCHAR(100)
	DECLARE @DataSourceId INT
	DECLARE @Code VARCHAR(100)
	DECLARE @ReturnValue INT
	DECLARE @Output INT
	DECLARE @Output2 INT
	DECLARE @DefaultCurrencyId INT
			
	--specify datasource in proc.
	SET @DataSourceCd = ''LIFFE''
	IF @LocationPath IS NULL SET @LocationPath = @DataSourceCd

	SET @Code = @DataSourceCd
	EXEC @ReturnValue= [_ib_DataSource_GetByCodeForOutput] @Code,@OutPut output,@Output2 output	
	SET @DataSourceId = @Output
	SET @DefaultCurrencyId = @Output2	
	
	-- Duplicate file check										
	DECLARE @IsFileAlreadyLoaded INT
	EXEC @IsFileALreadyLoaded = HasFileBeenLoaded @LocationPath, @DataSourceId

	IF @IsFileAlreadyLoaded = 1
		BEGIN					
			UPDATE [dbo].[LIFFE_TradeReport]
			SET [LoadState] = 3
			WHERE [LoadState] = 1
				AND [FileName] = @LocationPath		

			RETURN
		END
			
	DECLARE @ImportFileId INT
	EXEC ib_ImportFile_Add @DataSourceId, @LocationPath, @ImportFileId output
	DECLARE @SelectedAsOfDate DATETIME	
	EXEC [dbo].[ib_Liffe_GetBusinessDateFromFilename] @LocationPath, @SelectedAsOfDate OUTPUT, @DataSourceId, @ReceiveLocationSysId, @RunId
	UPDATE ib_ImportFile SET AsOfDate= @SelectedAsOfDate WHERE ImportFileId=@ImportFileId
	
	--rd - make sure the As Of Date is not older than acceptable
	DECLARE @IsAcceptable bit
	EXECUTE [dbo].[Load_IsFileTooOld] @DataSourceId,@LocationPath,@SelectedAsOfDate,@IsAcceptable OUTPUT, @ReceiveLocationSysId, @RunId
	IF (@IsAcceptable = 0)
	BEGIN
		UPDATE Liffe_TradeReport SET [LoadState] = 3 WHERE [Filename] = @LocationPath
		RAISERROR (''File is too old.'', 18, 0)
		RETURN
	END	

	-- There really isn''t any need for orchestration to call a LoadStateChange anymore
	-- since we only process rows for single file now
	-- but to keep consistent with other loaders - we''ll update to LoadState 1 at 
	-- start of this Load stored procedure
	UPDATE [LIFFE_TradeReport]
	SET LoadState = 1
	WHERE LoadState = 0
		AND Filename = @LocationPath

	--creating Temp Table just for use in this process
	--for iterating through the records.
	create table #temp1
	(
	Liffe_TradeReportId int,
	Exchange varchar(5),
	OriginatingMemberName varchar(3),
	AccountCode varchar(25), 	
	DetailAccountCode varchar(100), -- AAJM Added for MBAL-12454	
	PhysicalCommodity varchar(3),
	ContractType varchar(1),
	GenericContractType varchar(1),
	LongExpiryDate varchar(10),
	ExercisePrice varchar(24),
	Volume varchar(19),
	BuyOrSell varchar(1),
	TradeType varchar(1),
	HalfTradeStatus varchar(2),
	Price varchar(24)	
	)

	insert into #temp1
	(
	Liffe_TradeReportId,
	Exchange,
	OriginatingMemberName,
	AccountCode,
	DetailAccountCode, -- AAJM Added for MBAL-12454	
	PhysicalCommodity,
	ContractType,
	GenericContractType,
	LongExpiryDate,
	ExercisePrice,
	Volume,
	BuyOrSell,
	TradeType,
	HalfTradeStatus,
	Price
	)
	SELECT 
		Liffe_TradeReportId,
		ExchangeMnemonic,
		OrgMember,
		Account,
		UserSpecifiedData, -- AAJM Added for MBAL-12454	
		Commodity,
		ContractType,
		GenContractType,
		LongExpiryDate,
		Strike,
		Volume,
		BuySell,
		TradeType,
		Status,
		Price
	FROM [dbo].[LIFFE_TradeReport]
	WHERE LoadState = 1
	  AND [FileName] = @LocationPath
	  
	SET XACT_ABORT ON 

	BEGIN TRAN T1

		-- BizTalk''s SQL Adapter uses more restrictive read serializable
		-- so this is necessary to relax it to something that is default
		-- and perfectly acceptable!
		SET TRANSACTION ISOLATION LEVEL READ COMMITTED

		BEGIN TRY

	DECLARE 
				@Liffe_TradeReportId int,
				@Exchange varchar(100),
				@OriginatingMemberName varchar(100),
				@AccountCode varchar(100),
				@DetailAccountCode varchar(100), -- AAJM Added for MBAL-12454	
				@PhysicalCommodity varchar(100),
				@ContractType varchar(100),
				@GenericContractType varchar(100),
				@LongExpiryDate varchar(25),
				@ExercisePrice varchar(24),
				@VolumeChr VARCHAR(19),
				@Volume decimal(19,4),
				@BuyOrSell varchar(100),
				@TradeType varchar(1),
				@HalfTradeStatus varchar(2),
				@PriceChr varchar(24)

    DECLARE @MarexFirmId INT
    SET @MarexFirmId = [dbo].[udf_GetMarexFirmId]() -- AAJM Added for MBAL-12454	

	DECLARE @AsOfDate DATETIME
	SET @AsOfDate = @SelectedAsOfDate

	DECLARE trx_cursor CURSOR FOR
	SELECT Liffe_TradeReportId,
		Exchange,
		OriginatingMemberName,
		AccountCode,
		DetailAccountCode, -- AAJM Added for MBAL-12454	
		PhysicalCommodity,
		ContractType,
		GenericContractType,
		LongExpiryDate,
		ExercisePrice,
		Volume,
		BuyOrSell,
		TradeType,
		HalfTradeStatus,
		Price
	FROM #temp1

	OPEN trx_cursor

	-- Perform the first fetch and store the values in variables.
	-- Note: The variables are in the same order as the columns
	-- in the SELECT statement. 

	FETCH NEXT FROM trx_cursor
	INTO @Liffe_TradeReportId,
	@Exchange,
	@OriginatingMemberName,
	@AccountCode,
	@DetailAccountCode, -- AAJM Added for MBAL-12454	
	@PhysicalCommodity,
	@ContractType,
	@GenericContractType,
	@LongExpiryDate,
	@ExercisePrice,
	@VolumeChr,
	@BuyOrSell,
	@TradeType,
	@HalfTradeStatus,
	@PriceChr

	-- Check @@FETCH_STATUS to see if there are any more rows to fetch.
		WHILE @@FETCH_STATUS = 0
		BEGIN
		
		declare @ExchangeCd varchar(25)
		declare @FirmCd varchar(100)
		declare @AccountCd varchar(100)
		declare @DetailAccountCd varchar(100)
		declare @InstrumentCd varchar(100)
		declare @InstrumentTypeCd varchar(100)
		--declare @ExpiryDate datetime
		declare @ExpYr smallint
		declare @ExpMth smallint
		declare @ExpDay smallint
		declare @StrikePrice DECIMAL(19,4)
		declare @TrxTypeCd varchar(25)
		declare @OptionTypeCd varchar(25)
		declare @Quantity decimal(19,4)
		DECLARE	@QuantityLong int
		DECLARE @QuantityShort int
		declare @TrxDate datetime
		declare @PriceDec decimal(24,10)

		set @ExchangeCd = @exchange
		
		set @Output = null
		declare @InstrumentTypeId int
		set @InstrumentTypeCd = @genericcontracttype 
		exec @ReturnValue = ib_Instrumenttype_AddAsNeeded @DataSourceId,@InstrumentTypeCd,@OutPut output
		set @InstrumentTypeId = @Output

		declare @CurrencyId int

		set @Output = null
		set @Output2 = null
		declare @InstrumentId int
		
		-- MBAL-15310 Update the Instrument code
		SET @InstrumentCd = @InstrumentTypeCd + ''_'' + @ExchangeCd + ''_'' + @PhysicalCommodity

		
		exec @ReturnValue= [ib_Instrument_AddAsNeeded] @DataSourceId,@InstrumentTypeId,@InstrumentCd,@CurrencyId,@OutPut output,@Output2 output	
		set @InstrumentId = @Output
		set @CurrencyId = @Output2
		if @Output2 = null
		begin
		set @CurrencyId = @DefaultCurrencyId
		end

		declare @TickSize int
		select @TickSize = ticksize from ib_instrument where instrumentid = @InstrumentId

		set @FirmCd=@originatingmembername
		set @AccountCd = @accountcode
		set @DetailAccountCd = @DetailAccountCode -- AAJM Added for MBAL-12454	
		
		DECLARE @StrikePriceDivisor DECIMAL(19,4)
		DECLARE @PriceDivisor DECIMAL(19,4)

		SELECT @StrikePriceDivisor = StrikePriceDivisor
			, @PriceDivisor = PriceDivisor
		FROM [dbo].[ib_InstrumentDataSource]
		WHERE DataSourceId = @DataSourceId
			AND DataSourceInstrumentCode = @InstrumentCd 

		IF @PriceDivisor IS NULL 
			SET @PriceDivisor = 1
		SET @PriceDec = CONVERT(DECIMAL(24,10), @PriceChr) / @PriceDivisor

		IF @StrikePriceDivisor IS NULL -- Then get the default
			BEGIN
				DECLARE @ExchangeId INT
				SELECT @ExchangeId = ExchangeId FROM ib_Exchange WHERE [Code] = @ExchangeCd
				
				SET @StrikePriceDivisor = [dbo].[udf_GetDefaultStrikePriceDivisor](@DataSourceId, @ExchangeId)
			END
						
		IF @ExercisePrice IS NULL OR LTRIM(RTRIM(@ExercisePrice)) = '''' 
			SET @StrikePrice = 0
		ELSE
			SET @StrikePrice = CONVERT(DECIMAL(19,4), @ExercisePrice)/@StrikePriceDivisor
		
		set @TrxTypeCd = @tradetype + @halftradestatus
		set @OptionTypeCd = @contracttype
		set @TrxDate = @AsOfDate
		

		SET @volume = CONVERT(decimal(19,4), @VolumeChr)
		

		IF (@buyorsell = ''B'')
			BEGIN
				SET @Quantity = @volume
				SET @QuantityLong = @volume
				SET @QuantityShort = 0
			END
		ELSE
			BEGIN
				SET @Quantity = @volume * -1
				SET @QuantityLong = 0
				SET @QuantityShort = @volume
			END
		
		-- Long Expiry Date Format: YYYY-MM-00
		SET @LongExpiryDate = RTRIM(LTRIM(@LongExpiryDate))
		SET @ExpYr = CONVERT(SMALLINT, LEFT(@LongExpiryDate,4))
		SET @ExpMth = CONVERT(SMALLINT, SUBSTRING(@LongExpiryDate,6,2))
		SET @ExpDay = CONVERT(SMALLINT, RIGHT(@LongExpiryDate,2))
		SET @ExpDay = dbo.udf_OnLoad_ExpiryDate_Get_Day(@ExpYr,@ExpMth,@ExpDay)

		
		EXEC [ib_Trx_Load]
		@DataSourceCd,
		@ExchangeCd,
		@FirmCd,
		@AccountCd,
		@DetailAccountCd, -- AAJM Added for MBAL-12454	
		@InstrumentCd,
		@ExpYr,
		@ExpMth,
		@ExpDay,
		@StrikePrice,
		@TrxTypeCd,
		@OptionTypeCd,
		@Quantity,
		@TrxDate,
		@PriceDec,
		@Liffe_TradeReportId,
		@GenericContractType,
		@AsOfDate,
		@LocationPath,
		@MarexFirmId,
		@QuantityLong = @QuantityLong,
		@QuantityShort = @QuantityShort,
		@ReceiveLocationSysId = @ReceiveLocationSysId,
		@RunId = @RunId


		--flip processed flag in source table.
		update LIFFE_TradeReport
		set LoadState = 2
		where Liffe_TradeReportId = @Liffe_TradeReportId
		and LoadState = 1

		FETCH NEXT FROM trx_cursor
		INTO @Liffe_TradeReportId,
		@Exchange,
		@OriginatingMemberName,
		@AccountCode,
		@DetailAccountCode, -- AAJM Added for MBAL-12454 and MBAL-12575
		@PhysicalCommodity,
		@ContractType,
		@GenericContractType,
		@LongExpiryDate,
		@ExercisePrice,
		@VolumeChr,
		@BuyOrSell,
		@TradeType,
		@HalfTradeStatus,
		@PriceChr

		end

	CLOSE trx_cursor
	DEALLOCATE trx_cursor

	COMMIT TRAN T1

	drop table #temp1
	
	END TRY
	BEGIN CATCH
			
				SELECT @ErrorMessage= ERROR_MESSAGE()
					, @ErrorSeverity = ERROR_SEVERITY()
					, @ErrorState = ERROR_STATE()
					
				IF XACT_STATE() = -1
					BEGIN
						-- transaction must get rolled back so need to fail this whole operation
						-- rollback seems to work whether or not xact_abort is on
						ROLLBACK TRANSACTION

						-- Use RAISERROR inside the CATCH block to return error
						-- information about the original error that caused
						-- execution to jump to the CATCH block.
						RAISERROR (@ErrorMessage, @ErrorSeverity, @ErrorState);
						RETURN	-- can''t do any writes so no point continuing (otherwise need to check every write / commit)
					END
				ELSE
					EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @ErrorMessage, ''Error'', '''', @RunId
	END CATCH



	SET XACT_ABORT OFF

RETURN 0
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_DataSource_GetAll]''
');

GO
EXECUTE ('  /*
<details>
 <summary>Returns all the exchanges</summary>
 <created author="anil.kripalani" date="18 Oct 2006"/>
</details>
*/
create PROCEDURE [dbo].[ib_DataSource_GetAll]
AS
SET NOCOUNT ON
SELECT DataSourceId, Code, [Name]
	FROM ib_DataSource
	ORDER BY [Name]
');

GO
EXECUTE ('PRINT N''Creating [dbo].[CreditSuisse_Transaction_LoadStateChange]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[CreditSuisse_Transaction_LoadStateChange] 
	-- Add the parameters for the stored procedure here
	(
		@OldLoadState	TINYINT,
		@NewLoadState	TINYINT
	)
AS
-- =============================================
-- Author:		Alister McLeod
-- Create date: 06 Apr 2011
-- Description:	Changes the LoadState of the CreditSuisse_Transaction type table
-- =============================================
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

		UPDATE [dbo].[CreditSuisse_Transaction] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[Log_GetErrorsByReceiveLocationSysIdFileNameRunId]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[Log_GetErrorsByReceiveLocationSysIdFileNameRunId]
	(
		@ReceiveLocationSysId INT,
		@FileName VARCHAR(255),
		@RunId INT
	)
AS
SET NOCOUNT ON
-- =============================================
-- Author:		damiane
-- Create date: 18 Oct 2013
-- Description:	EIB 24539 - get errors
-- 07 Nov 2013  EIB-24637 - ED - limit output 
-- 20 Jan 2014  ED   EIB 25063 - READPAST on Log table so it does not lock Monitor page on loading
-- =============================================

BEGIN
	DECLARE @csv VARCHAR(8000)
	
	SELECT @csv = coalesce(@csv+'','','''') + Exception
		FROM 
		(
			SELECT DISTINCT(Exception)
			FROM dbo.[Log] l (READPAST) INNER JOIN dbo.LogStatus ls ON ls.LogStatusSysId = l.LogStatusSysId
			WHERE ReceiveLocationSysId = @ReceiveLocationSysId AND [FileName] = @FileName AND RunId = @RunId AND ls.LogStatusName = ''Error'' AND [Exception] != ''''
		) AS Exceptions
	SELECT
	 CASE WHEN LEN(@csv) < 1000 
			THEN @Csv 
			ELSE SUBSTRING(@csv,0,1000)+''...[see the Monitor page on the I-Balancer website for more information].''  
	 END AS ErrorText

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[Peoplesoft]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[Peoplesoft]
(
[PeoplesoftID] [int] NOT NULL IDENTITY(1, 1),
[OpeningBalance] [varchar] (50) NULL,
[AccountNumber] [varchar] (35) NULL,
[TransactionDate] [varchar] (8) NULL,
[ValueDate] [varchar] (8) NULL,
[Narrative] [varchar] (34) NULL,
[InternalReference] [varchar] (16) NULL,
[ExternalReference] [varchar] (16) NULL,
[Type] [varchar] (4) NULL,
[Department] [varchar] (50) NULL,
[UserField1] [varchar] (10) NULL,
[UserField2] [varchar] (10) NULL,
[UserField3] [varchar] (10) NULL,
[BusinessUnit] [varchar] (10) NULL,
[UserField5] [varchar] (19) NULL,
[UserField6] [varchar] (10) NULL,
[Currency] [varchar] (3) NULL,
[OriginalAmount] [varchar] (20) NULL,
[ReceiptAmount] [varchar] (20) NULL,
[PaymentAmount] [varchar] (20) NULL,
[Quantity] [varchar] (12) NULL,
[Percent] [varchar] (3) NULL,
[UnitPrice] [varchar] (20) NULL,
[UserDateA] [varchar] (50) NULL,
[UserDateB] [varchar] (50) NULL,
[UserId] [varchar] (50) NULL,
[UserField8] [varchar] (50) NULL,
[FlagA] [varchar] (1) NULL,
[FlagB] [varchar] (1) NULL,
[FlagC] [varchar] (1) NULL,
[FlagD] [varchar] (1) NULL,
[FlagE] [varchar] (1) NULL,
[FlagF] [varchar] (1) NULL,
[FlagG] [varchar] (1) NULL,
[FlagH] [varchar] (1) NULL,
[IsStatement] [varchar] (1) NULL,
[IsHolding] [varchar] (1) NULL,
[wf_Ref] [varchar] (20) NULL,
[Period] [varchar] (25) NULL,
[UserField9] [varchar] (25) NULL,
[UserField10] [varchar] (25) NULL,
[FiscalYear] [varchar] (4) NULL,
[AccountingPeriodOfFiscalYear] [varchar] (2) NULL,
[UserField13] [varchar] (25) NULL,
[UserField14] [varchar] (25) NULL,
[UserField15] [varchar] (25) NULL,
[UserField16] [varchar] (25) NULL,
[UserDateC] [varchar] (12) NULL,
[UserDateD] [varchar] (12) NULL,
[UserDecimalB] [varchar] (25) NULL,
[UserDecimalC] [varchar] (25) NULL,
[UserDecimalD] [varchar] (25) NULL,
[ClosingBalance] [varchar] (25) NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_Peoplesoft_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_Peoplesoft_CreateDate] DEFAULT (getdate()),
[FileName] [varchar] (512) NULL CONSTRAINT [DF__Peoplesof__FileN__430E6E35] DEFAULT (NULL)
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_Peoplesoft] on [dbo].[Peoplesoft]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[Peoplesoft] ADD CONSTRAINT [PK_Peoplesoft] PRIMARY KEY CLUSTERED  ([PeoplesoftID])
');

GO
EXECUTE ('PRINT N''Creating index [IX_filename_loadstate_accountNumber] on [dbo].[Peoplesoft]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_filename_loadstate_accountNumber] ON [dbo].[Peoplesoft] ([FileName], [LoadState], [AccountNumber])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_PeoplesoftLog_StoreNostroBalance]''
');

GO
EXECUTE ('-- =============================================
-- Author:		Konrad	
-- Create date: 03.07.2009
-- Description:	Stores the Nostro Balance for a certain Account and Currency and its comparison with the 
--				Peoplesoft Closing Balance for the same Account and Currency and a FileName
--
-- Revision History
--
-- 10.07.2009 Konrad Fixed setting the correct NostroBalance on Peoplesoft Log table.
-- =============================================
CREATE PROCEDURE [dbo].[ib_PeoplesoftLog_StoreNostroBalance]
	@AccountId		int,
	@CurrencyId		int,
	@ClosingBalance money,
	@FileName	    varchar(512)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

			DECLARE @MatchCode		varchar(100)
			DECLARE	@TemplateId		int 
			DECLARE	@OutPut			int, @ReturnValue int, @Output2 int
			

			SELECT @MatchCode = tg.Description, @TemplateId = tg.TemplateId
			FROM [ib_TemplateGroup] tg
			WHERE tg.AccountId = @AccountId AND
				  tg.CurrencyId = @CurrencyId
	
			IF @TemplateId IS NOT NULL 
			BEGIN
				
				DECLARE @InternalExternalCode	char(1)
				DECLARE @NostroBalance			money
				DECLARE @DataSourceId			int	
				DECLARE @MatchCodeId			int
				DECLARE @FirmId					int

				SELECT @FirmId = a.FirmId
				FROM [ib_Account] a
				WHERE a.AccountId = @AccountId

				EXEC @ReturnValue= [_ib_DataSource_GetByCodeForOutput] ''Peoplesoft'',@OutPut output,@Output2 output
				SET  @DataSourceId = @OutPut

				SELECT @InternalExternalCode = tc.InternalExternalCode
				FROM [ib_TemplateCompare] tc
				WHERE tc.DataSourceId = @DataSourceId AND
				tc.FirmId = @FirmId AND tc.TemplateId = @TemplateId

				SELECT @MatchCodeId = mc.MatchCodeId
				FROM [ib_MatchCode] mc
				WHERE mc.MatchCode = @MatchCode AND mc.TemplateId = @TemplateId

--KevinP 27 Aug 2009 - I don''t understand why the NostroBalance is being set to the Internal Or External Balance(Depending 
--						on the InternalExternalCode passed in). Surely this doesn''t make sense?
				SELECT 
						@NostroBalance = (CASE WHEN @InternalExternalCode = ''I'' THEN convert(money,InternalBalance)
						ELSE convert(money,ExternalBalance) END) 

                FROM   ib_NostroBalance
				WHERE  MatchCodeId = @MatchCodeId and CreateDate = 
                         (
							select max(inb.[CreateDate]) from ib_NostroBalance inb where inb.[MatchCodeId] = @MatchCodeId
                         )

                UPDATE [dbo].[ib_PeoplesoftBalancesLog] 
				SET    NostroBalance = @NostroBalance
				WHERE  [AccountId] = @AccountId AND [CurrencyId] = @CurrencyId AND [FileName] = @FileName

			END	

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_PeoplesoftBalancesLog_AddAsNeeded]''
');

GO
EXECUTE ('-- =============================================
-- Author:		Konrad
-- Create date: 03.07.2009
-- Description:	Adds a new record into the "ib_PeoplesoftBalancesLog" table if no other exists for the same FileName, Account and Currency
-- 17 Sep 2009	amk		Use NOT EXISTS instead of COUNT(*) = 0 to reduce contention
-- =============================================
CREATE PROCEDURE [dbo].[ib_PeoplesoftBalancesLog_AddAsNeeded] 

	@AccountCd			varchar(35),
	@CurrencyCd			varchar(3),
	@FirmCd				varchar(3),
	@OpeningBalance		money,
    @ClosingBalance		money,
	@FileName			varchar(512)

AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
    
	-- Need the AccountId for the table ib_PeoplesoftBalancesLog
	-- FirmId 

			DECLARE @ReturnValue		int, @OutPut int, @OutPut2 int
			DECLARE @DataSourceId		int
			DECLARE @DefaultCurrencyId 	int
			DECLARE @Code 			varchar(100)

			-- DataSourceId, DefaultCurrencyId 
			SET  @Code = ''Peoplesoft''
			EXEC @ReturnValue= [_ib_DataSource_GetByCodeForOutput] @Code,@OutPut output,@Output2 output
			SET  @DataSourceId = @OutPut
			SET  @DefaultCurrencyId = @OutPut2

			SET  @Output = null

			-- CurrencyId 
			DECLARE @CurrencyId int
			EXEC @ReturnValue = [ib_Currency_AddAsNeeded] @DataSourceId, @CurrencyCd, @Output output
			SET  @CurrencyId = @Output

			DECLARE @FirmId int 
			SET  @Code = @FirmCd
			EXEC @ReturnValue= [ib_Firm_AddAsNeeded] @DataSourceId,@Code,@OutPut output
			SET  @FirmId = @OutPut

			SET  @Output = null

			-- AccountId 
			DECLARE @AccountId int
			SET  @Code = @AccountCd
			EXEC @ReturnValue= [ib_Account_AddAsNeeded] @Code,@FirmId,@OutPut output
			SET  @AccountId = @OutPut
			
			DECLARE @OpeningBalanceMon		money
			DECLARE @ClosingBalanceMon		money

			IF ISNUMERIC(@OpeningBalance) = 1 SET @OpeningBalanceMon = CONVERT(money, @OpeningBalance)
			IF ISNUMERIC(@ClosingBalance) = 1 SET @ClosingBalanceMon = CONVERT(money, @ClosingBalance)

	IF NOT EXISTS(
			SELECT *
			FROM dbo.[ib_PeoplesoftBalancesLog]
			WHERE  AccountId = @AccountId AND 
					CurrencyId = @CurrencyId AND	
					[FileName] = @FileName	
       )
    BEGIN

		INSERT INTO dbo.[ib_PeoplesoftBalancesLog]
				(
					[AccountId],
					[CurrencyId],
					[OpenBalance],
					[ClosingBalance],
					[Filename]
				)
		SELECT
				@AccountId,
				@CurrencyId,
				@OpeningBalanceMon,
				@ClosingBalanceMon,
				@FileName	

	END

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Peoplesoft_Validate_Load]''
');

GO
EXECUTE ('/*
This SP will Validate all the data for a particular File Load making sure that:
1. The opening Balance on the file is equal to the closing balance of the system
2. The Opening Balance + SUM(Debits) + SUM(Credits) should = the closing balance for that account.

Note that even though we return @ValidationSucceeded if one or more accounts failed
validation check, we mark those source records as loadstate 0 so that caller can
continue and process other accounts

*/
-- ******************** COMMENTS **************
-- Date				Author		Description
-- 17 Aug 2009		KevinP		Added in Validation of data imported. If data validation fails, set everything to -1 LoadState.
-- 25 Aug 2009		AAJM		MBAL-12917 Added subquery to ensure only latest Closing Balance is returned from ib_PeoplesoftBalancesLog when matching
--								Opening and Closing balances
-- 26 Aug 2009		amk			For any accounts that fail either validation, mark them failed
--								we''ll let other accounts load
-- 17 Sep 2009		amk			Change queries to just check on filename, not rtrim ltrim so it''s optimized (new index on filename) and hopefully does less locking
-- 09 Jan 2014		ED			EIB 25004 - remove importLog table and use Log table
-- 07 May 2014		ED			EIB 25597 - log as warning if integrity valodation fails
-- =============================================
CREATE PROCEDURE [dbo].[ib_Peoplesoft_Validate_Load] 
	-- Add the parameters for the stored procedure here
	(
		@FileNameAndPath	varchar(500) = NULL
		,@ValidationSucceeded BIT OUTPUT
		,@ReceiveLocationSysId INT
		,@RunId INT
	)
AS
SET NOCOUNT ON
	SET @ValidationSucceeded = 1

	--Debug only
	--DECLARE @FileNameAndPath varchar(500)
	--SET @FileNameAndPath = ''C:\BizTalk DATA\Peoplesoft\in\MARGLEXT_06012009.csv''
	
	--***********************************************
	--this is a hack
	--we need to seed the ib_PeoplesoftBalancesLog table
	--or else check of first statements open balance against system balance
	--doesn''t work
	--so this script loads the table first time automatically
	-- KevinP - Please note, the one downfall of this hack is that, once the table IS fully loaded initially, then if a new account comes in, 
	--			and it has incorrect figures etc - i.e. where the validation should fail - then this validation will always pass for the first time 
	--			for this new account because there''s nothing in the ib_NostroBalance table for this account, therefore we can''t populate the 
	--			ib_peoplesoftbalanceslog table.

	if not exists (select top 1 peoplesoftbalanceslogid from ib_peoplesoftbalanceslog)
	insert into ib_peoplesoftbalanceslog 
		(accountid, currencyid, openbalance, closingbalance, nostrobalance, filename)
	select tg.accountid, tg.currencyid, 0, 0, nb.internalbalance, ''initial load''
	from ib_nostrobalance nb
		join ib_matchcode mc on mc.matchcodeid = nb.matchcodeid
		join ib_templategroup tg on tg.templateid = mc.templateid and tg.description = mc.matchcode
	where nb.nostrobalanceid = 
		(select top 1 nostrobalanceid
			from ib_nostrobalance nb2
			where nb2.matchcodeid = nb.matchcodeid
			order by nb2.balancedate desc
		)
	--*************************************************
	
	
	CREATE TABLE #FailedAccounts (AccountNumber VARCHAR(35) COLLATE Latin1_General_CI_AS NOT NULL)

	DECLARE @ValidationMessage VARCHAR(500)

	DECLARE @InitialLoadState INT
	SET @InitialLoadState = 1

	DECLARE @DataSourceCode  AS VARCHAR(25)
	SET @DataSourceCode = ''Peoplesoft''
	DECLARE @DataSourceId INT
	DECLARE @DefaultCurrencyId INT
	EXEC [_ib_DataSource_GetByCodeForOutput] @DataSourceCode, @DataSourceId output, @DefaultCurrencyId output

	EXEC Log_Insert @ReceiveLocationSysId, @FileNameAndPath, ''Orchestrated'', ''Integrity Validation Started.'', ''Success'', '''', @RunId

	--1. We need to figure out all the accountId''s and see what their Opening balance on the file is and their Closing balances  in the DB are.
	-- we also need to do a cursor here too....
	-- We need to get AccountId from AccountNumber here...

	DECLARE @PeopleSoft_ValidationForLoad_ClosingBalanceInDB TABLE
	(
		AccountId INT NULL,
		AccountNumber VARCHAR(35) NOT NULL,
		FirmId INT NULL,
		FirmCode Varchar(3) NOT NULL,
		CurrencyCode varchar(3) NOT NULL,
		CurrencyId INT NULL,
		FileOpeningBalance DECIMAL(20,6) NOT NULL
	)

	INSERT INTO @PeopleSoft_ValidationForLoad_ClosingBalanceInDB
	(
		AccountNumber,
		FirmCode,
		CurrencyCode,
		FileOpeningBalance
	)
	SELECT AccountNumber, BusinessUnit AS FirmCode,Currency AS CurrencyCode, MIN(OpeningBalance) FileOpeningBalance
	FROM dbo.PeopleSoft
	WHERE LoadState = @InitialLoadState
		AND [FileName] = @FileNameAndPath
	GROUP BY AccountNumber, BusinessUnit, Currency

	--declare the cursor here to update the Id''s appriopriately so that we can join back.
	DECLARE cur_UpdateIds CURSOR FOR
	SELECT DISTINCT AccountNumber,
					FirmCode,
					CurrencyCode
	FROM @PeopleSoft_ValidationForLoad_ClosingBalanceInDB
	WHERE Accountid IS NULL OR FirmId IS NULL OR CurrencyId IS NULL

	-- Declare CURSOR Variables
	DECLARE @FirmId int 
    DECLARE @FirmCode varchar(3)
	DECLARE @AccountId int
	DECLARE @AccountNumber varchar(35)
	DECLARE @CurrencyCode varchar(3)
	DECLARE @CurrencyId INT

	OPEN cur_UpdateIds

	FETCH NEXT FROM cur_UpdateIds
	INTO @AccountNumber, @FirmCode, @CurrencyCode

	-- Check @@FETCH_STATUS to see IF there are any more rows to fetch.
	WHILE @@FETCH_STATUS = 0
	BEGIN
		--FirmId
		EXEC [ib_Firm_AddAsNeeded] @DataSourceId, @FirmCode, @FirmId OUTPUT

		UPDATE @PeopleSoft_ValidationForLoad_ClosingBalanceInDB SET FirmId = @FirmId
		WHERE FirmCode = @FirmCode
		  AND FirmId IS NULL

		-- AccountId 
		DECLARE @tmpAccount VARCHAR(9)
		SET @tmpAccount = SUBSTRING(@AccountNumber,1,8)
		EXEC [ib_Account_AddAsNeeded] @tmpAccount, @FirmId, @AccountId OUTPUT
		
		UPDATE @PeopleSoft_ValidationForLoad_ClosingBalanceInDB SET AccountId = @AccountId
		WHERE AccountNumber = @AccountNumber
		  AND AccountId IS NULL

		-- CurrencyId 
		EXEC [ib_Currency_AddAsNeeded] @DataSourceId, @CurrencyCode, @CurrencyId output
		
		UPDATE @PeopleSoft_ValidationForLoad_ClosingBalanceInDB 
		SET CurrencyId = @CurrencyId 
		WHERE CurrencyCode = @CurrencyCode
		  AND CurrencyId IS NULL

		-- Fetch next record
		FETCH NEXT FROM cur_UpdateIds
		INTO @AccountNumber, @FirmCode, @CurrencyCode

	END
		
	CLOSE cur_UpdateIds
	DEALLOCATE cur_UpdateIds

	--Now its finally time to try and match the closing balances to the accounts by accountId!

	--SELECT * From ib_Account
	--SELECT * FROM ib_Firm
	--SELECT * FROM [ib_PeoplesoftBalancesLog]
	--
	--SELECT AccountId, CurrencyId, openBalance, ClosingBalance, NostroBalance, MAX(CreateDate)
	--FROM [ib_PeoplesoftBalancesLog]
	--GROUP BY AccountId, CurrencyId, openBalance, ClosingBalance, NostroBalance

	--Perform a cursor here and log each record thats out of loop here.

	-------------------------------------------------
	DECLARE cursor_OpenBalanceMisMatchesPreviousCloseBalance CURSOR FOR
	SELECT	AccountNumber,
			FileOpeningBalance,
			tmpPBL.NostroBalance AS SystemClosingBalance
	FROM	@PeopleSoft_ValidationForLoad_ClosingBalanceInDB tmp
	INNER JOIN (	SELECT AccountId, CurrencyId, OpenBalance, ClosingBalance, NostroBalance, CreateDate AS MaxCreateDate
					FROM ib_PeoplesoftBalancesLog pbl 
					WHERE pbl.PeoplesoftBalancesLogId = (SELECT TOP(1) PeoplesoftBalancesLogId FROM ib_PeoplesoftBalancesLog pbl2 WHERE pbl.AccountId = pbl2.AccountId AND pbl.CurrencyId = pbl2.CurrencyId ORDER BY CreateDate DESC)
					GROUP BY pbl.AccountId, pbl.CurrencyId, pbl.OpenBalance, pbl.ClosingBalance, pbl.NostroBalance, CreateDate
			   ) tmpPBL ON tmpPBL.AccountId = tmp.AccountId AND tmpPBL.CurrencyId = tmp.CurrencyId
	WHERE FileOpeningBalance <> tmpPBL.NostroBalance
	-- want to select the latest one

	-- Declare CURSOR Variables
	DECLARE	@SystemClosingBalance DECIMAL(20,6)
	DECLARE	@FileOpeningBalance	DECIMAL(20,6)

	OPEN cursor_OpenBalanceMisMatchesPreviousCloseBalance

	FETCH NEXT FROM cursor_OpenBalanceMisMatchesPreviousCloseBalance
	INTO @AccountNumber, @FileOpeningBalance, @SystemClosingBalance -- System Closing Balance is actualy the previous Opening Balance in DB/

	-- If some records here have failed validation we need to set this flag appropriately.
	IF @@FETCH_STATUS = 0 AND @ValidationSucceeded = 1
		SET @ValidationSucceeded = 0
	
	-- Check @@FETCH_STATUS to see IF there are any more rows to fetch.
	WHILE @@FETCH_STATUS = 0
	BEGIN
		-- Write a log entry for every failed validation.
		SET @ValidationMessage = ''Integrity Validation failed. Account No: '' + CAST(@AccountNumber AS VARCHAR(20)) 
			+ '' Expected Opening Balance: '' + CAST(@SystemClosingBalance AS VARCHAR(20)) 
			+ '' Actual Opening Balance On File: '' + CAST(@FileOpeningBalance AS VARCHAR(20))
		EXEC Log_Insert @ReceiveLocationSysId, @FileNameAndPath, ''Orchestrated'', @ValidationMessage, ''Warning'', '''', @RunId

		INSERT INTO #FailedAccounts (AccountNumber) 
		VALUES (@AccountNumber)

		FETCH NEXT FROM cursor_OpenBalanceMisMatchesPreviousCloseBalance
		INTO @AccountNumber, @FileOpeningBalance, @SystemClosingBalance

	END
		
	CLOSE cursor_OpenBalanceMisMatchesPreviousCloseBalance
	DEALLOCATE cursor_OpenBalanceMisMatchesPreviousCloseBalance
	-------------------------------------------------

	-- 2. This is easy, just do a grouping
	--------------------------

	DECLARE @PeopleSoft_ValidationForLoad TABLE 
	(
		AccountNumber VARCHAR(35),
		ExpectedClosingBalance DECIMAL(20,6),
		FileClosingBalance DECIMAL(20,6)
	)

	INSERT INTO @PeopleSoft_ValidationForLoad
	(
		AccountNumber,
		ExpectedClosingBalance,
		FileClosingBalance
	)
	SELECT	pplSoft.AccountNumber AS AccountNumber, 
			MIN(pplSoft.OpeningBalance) + SUM(pplSoft.ReceiptAmount) - SUM(pplSoft.PaymentAmount) AS ExpectedClosingBalance, 
			MIN(pplSoft.ClosingBalance) AS FileClosingBalance
	FROM (
		SELECT	AccountNumber, 
				OpeningBalance, 
				CASE WHEN LEN(ReceiptAmount) > 0 THEN
					CAST(ReceiptAmount AS decimal(20,6))
				ELSE
					0
				END AS ReceiptAmount,
				CASE WHEN LEN(PaymentAmount)  > 0 THEN
					CAST(PaymentAmount AS decimal(20,6))
				ELSE
					0
				END AS PaymentAmount, 
				ClosingBalance
		FROM dbo.PeopleSoft
		WHERE LoadState = @InitialLoadState
		  AND [FileName] = @FileNameAndPath
		) pplSoft
	GROUP BY pplSoft.AccountNumber

	DECLARE pos_cursor CURSOR FOR
	SELECT	AccountNumber,
			ExpectedClosingBalance,
			FileClosingBalance
	FROM	@PeopleSoft_ValidationForLoad
	WHERE ExpectedClosingBalance <> FileClosingBalance

	-- Declare CURSOR Variables
	DECLARE	@ExpectedClosingBalance	DECIMAL(20,6)
	DECLARE	@FileClosingBalance	DECIMAL(20,6)

	OPEN pos_cursor

	FETCH NEXT FROM pos_cursor
	INTO @AccountNumber, @ExpectedClosingBalance, @FileClosingBalance

	-- If some records here have failed validation we need to set this flag appropriately.
	IF @@FETCH_STATUS = 0 AND @ValidationSucceeded = 1
		SET @ValidationSucceeded = 0

	-- Check @@FETCH_STATUS to see IF there are any more rows to fetch.
	WHILE @@FETCH_STATUS = 0
	BEGIN
		-- Write a log entry for every failed validation.
		SET @ValidationMessage = ''Integrity Validation failed. Account No: '' + @AccountNumber + '' Expected Closing Balance: '' + CAST(@ExpectedClosingBalance AS VARCHAR(20))+ '' Actual Closing Balance On File: '' + CAST(@FileClosingBalance AS VARCHAR(20))
		EXEC Log_Insert @ReceiveLocationSysId, @FileNameAndPath, ''Orchestrated'', @ValidationMessage, ''Warning'', '''', @RunId

		INSERT INTO #FailedAccounts (AccountNumber) 
		VALUES (@AccountNumber)

		FETCH NEXT FROM pos_cursor
		INTO @AccountNumber, @ExpectedClosingBalance, @FileClosingBalance

	END
		
	CLOSE pos_cursor
	DEALLOCATE pos_cursor

	--------------------------------------------------------------
	-- 3. Mark failed accounts as state 0 so they don''t get loaded
	--------------------------------------------------------------

	UPDATE Peoplesoft
	WITH (ROWLOCK)
	SET LoadState = 3
	WHERE AccountNumber IN (SELECT AccountNumber FROM #FailedAccounts)
		AND Filename = @FileNameAndPath
		AND LoadState = 1

	DROP TABLE #FailedAccounts

	----end block 3.----------------------------------------------

	EXEC Log_Insert @ReceiveLocationSysId, @FileNameAndPath, ''Orchestrated'', ''Integrity Validation Ended.'', ''Success'', '''', @RunId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_NostroBalanceAddOrUpdate]''
');

GO
EXECUTE ('-- =============================================
-- Author:		Petru Konrad Bercea
-- Create date: 02/26/2009
-- Description:	Updates the ib_NostroBalance based on the ib_Nostro record
--
-- Revision History
--
-- 27.02.09 Konrad Modified the NostroBalance Balances update from previous existing Balances values for the same MatchCode
-- 01.05.09 Konrad UpdateDate set when updating a record on the table ib_NostroBalance
-- 29.09.09 amk    Take in username too
-- 07.10.09 amk	   Allow for another thread to have inserted causing this insert to abend
--                 Switch to update in that case
-- =============================================
CREATE PROCEDURE [dbo].[ib_NostroBalanceAddOrUpdate] 
	(
		@NostroId				int output,
		@DataSourceId			int,
		@Amount				    decimal(18, 4),
		@AccountId				int,
		@CurrencyId				int,
		@Username				varchar(50) = null
		
	)
AS
SET NOCOUNT ON
BEGIN
	IF @Username IS NULL
		SET @Username = suser_sname()

	DECLARE @TemplateId int
	DECLARE @MatchCodeId int
	DECLARE @OutPut int
	DECLARE @InternalExternalCode char(1)
	DECLARE @MatchCode varchar(100)
	DECLARE @BalanceDate datetime
		
	SET @BalanceDate = cast(floor(cast(getdate() as float)) as datetime)

	SET @OutPut = NULL

	SET @TemplateId = NULL

			SELECT @MatchCode = tg.Description, @TemplateId = tg.TemplateId
			FROM [ib_TemplateGroup] tg
			WHERE tg.AccountId = @AccountId AND
				  tg.CurrencyId = @CurrencyId
	
			IF @TemplateId IS NOT NULL 
			BEGIN
				
				DECLARE @InternalBalance decimal(18,4)
				DECLARE @ExternalBalance decimal(18,4)

				DECLARE @InternalBalanceAdjustment decimal(18,4)
				DECLARE @ExternalBalanceAdjustment decimal(18,4)
				
				SET @InternalBalance = 0.00
				SET @ExternalBalance = 0.00
				
				SET @InternalBalanceAdjustment = 0.00
				SET @ExternalBalanceAdjustment = 0.00

				SELECT @OutPut = a.FirmId
				FROM [ib_Account] a
				WHERE a.AccountId = @AccountId

				SELECT @InternalExternalCode = tc.InternalExternalCode
				FROM [ib_TemplateCompare] tc
				WHERE tc.DataSourceId = @DataSourceId AND
				tc.FirmId = @OutPut AND tc.TemplateId = @TemplateId

				IF @InternalExternalCode = ''I''
				BEGIN
					SET @InternalBalance = @InternalBalance + @Amount
					SET @InternalBalanceAdjustment = @Amount
				END 
				ELSE IF @InternalExternalCode = ''E'' 
				BEGIN
					SET @ExternalBalance = @ExternalBalance + @Amount
					SET @ExternalBalanceAdjustment = @Amount
				END 

				SELECT @MatchCodeId = mc.MatchCodeId
				FROM [ib_MatchCode] mc
				WHERE mc.MatchCode = @MatchCode AND mc.TemplateId = @TemplateId

				SET @OutPut = NULL
				SELECT @OutPut = nb.NostroBalanceId
				FROM [ib_NostroBalance] nb
				WHERE nb.MatchCodeId = @MatchCodeId AND nb.BalanceDate = @BalanceDate

				IF @OutPut IS NOT NULL 
					BEGIN
						UPDATE ib_NostroBalance
							SET InternalBalance = InternalBalance + @InternalBalance
								, ExternalBalance = ExternalBalance + @ExternalBalance
								, UpdateDate=getdate()
								, UpdateUsername = @Username
						WHERE NostroBalanceId = @OutPut
					END
				ELSE
					BEGIN

						DECLARE @PreviousInternalBalance decimal(18,4)
						DECLARE @PreviousExternalBalance decimal(18,4)
						
						SET @PreviousInternalBalance = 0.00
						SET @PreviousExternalBalance = 0.00

						SELECT @PreviousInternalBalance = ISNULL(nb.InternalBalance,0.00), @PreviousExternalBalance = ISNULL(nb.ExternalBalance,0.00)
						FROM [ib_NostroBalance] nb
						WHERE nb.MatchCodeId = @MatchCodeId 
						AND nb.BalanceDate = (SELECT MAX(BalanceDate) AS LatestBalanceDate FROM [ib_NostroBalance] nb1 WHERE nb1.MatchCodeId = @MatchCodeId)

						SET @InternalBalance = @InternalBalance + @PreviousInternalBalance
						SET @ExternalBalance = @ExternalBalance + @PreviousExternalBalance

						BEGIN TRY
							INSERT INTO [dbo].[ib_NostroBalance]
								(
								[MatchCodeId], 
								[BalanceDate], 
								[InternalBalance], 
								[ExternalBalance],
								[CreateUsername]
								)
							VALUES
								(
								@MatchCodeId, 
								@BalanceDate, 
								@InternalBalance, 
								@ExternalBalance,
								@Username
								) 
						END TRY
						BEGIN CATCH
							-- assume another thread already inserted same match code / balance date record
							-- so switch to update

							UPDATE ib_NostroBalance
								SET InternalBalance = InternalBalance + @InternalBalanceAdjustment
									, ExternalBalance = ExternalBalance + @ExternalBalanceAdjustment
									, UpdateDate=getdate()
									, UpdateUsername = @Username
							WHERE MatchCodeId = @MatchCodeId
								AND BalanceDate = @BalanceDate

							IF @@ROWCOUNT = 0
								EXEC [dbo].[sp_RethrowError]
						END CATCH
					END
			END
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Nostro_Add]''
');

GO
EXECUTE ('-- =============================================
-- Author:		Petru Konrad Bercea
-- Create date: 22.01.2009
-- Description:	This stored procedure is used by the ib_Nostro_Load stored procedures to load the SWIFT data from the temp tables into the Nostro table.
-- =============================================
CREATE PROCEDURE [dbo].[ib_Nostro_Add] 
	(
		@NostroId				int output,
		@DataSourceId			int,
		@ValueDate				datetime,
		@TransDate				datetime,
		@Amount				    decimal(18, 4),
		@TransactionType	 	varchar(4),
		@InternalReference		varchar(16),
		@ExternalReference		varchar(16),
		@Narrative				varchar(max),
		@AccountId				int,
		@CurrencyId				int,
		@TempTableRecordId		int
	)
AS
SET NOCOUNT ON

-- Extra data processing

INSERT INTO ib_Nostro
		(
			DataSourceId,
			ValueDate,
			TransDate,
			Amount,
			TransactionType,
			InternalReference,
			ExternalReference,
			Narrative,
			AccountId,
			CurrencyId,
			TempTableRecordId
		)
VALUES
        (
			@DataSourceId,
			@ValueDate,
			@TransDate,
			@Amount,
			@TransactionType,
			@InternalReference,
			@ExternalReference,
			@Narrative,
			@AccountId,
			@CurrencyId,
			@TempTableRecordId
		)

select @NostroId = scope_identity()
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Nostro_Load]''
');

GO
EXECUTE ('
-- =============================================
-- Author:		Petru Konrad Bercea
-- Create date: 21.01.2009
-- Description:	This stored procedure is used by the SWIFT Load stored procedures to load the SWIFT data from the temp tables into the Nostro table.
-- =============================================
-- History
-- 21 Aug 2009	AAJM	MBAL-12894 Added AccountId parameter to patch SWIFT UNDO MISS
-- 28 Oct 2009	AAJM	MBAL-13637 Return the new NostroId

CREATE PROCEDURE [dbo].[ib_Nostro_Load] 
	-- Add the parameters for the stored procedure here
	(
		@DataSourceCd			varchar(100),
		@ValueDate				datetime,
		@TransDate				datetime,
		@Amount					decimal(18, 4),
		@TransactionType		varchar(4),
		@InternalReference		varchar(16),
		@ExternalReference		varchar(16),
		@Narrative				varchar(max),
		@Account				varchar(35),
		@Currency				varchar(3),
		@Firm					varchar(25) = NULL,
		@TempTableRecordId		varchar(34),
		@AccountId				INT = NULL, -- 21 Aug 2009 AAJM	Added
		@NostroId				int output
	)
AS
SET NOCOUNT ON

	DECLARE @ReturnValue		int, @OutPut int, @OutPut2 int
	DECLARE @DataSourceId		int
	DECLARE @DefaultCurrencyId 	int
	DECLARE @Code 			varchar(100)

	-- DataSourceId, DefaultCurrencyId 
	SET  @Code = @DataSourceCd
	EXEC @ReturnValue= [_ib_DataSource_GetByCodeForOutput] @Code,@OutPut output,@Output2 output
	SET  @DataSourceId = @OutPut
	SET  @DefaultCurrencyId = @OutPut2

	SET  @Output = null

	IF @AccountId IS NULL -- 21 Aug 2009 AAJM	Added
	BEGIN 
		-- FirmId 
		DECLARE @FirmId int 
		SET  @Code = @Firm
		EXEC @ReturnValue= [ib_Firm_AddAsNeeded] @DataSourceId,@Code,@OutPut output
		SET  @FirmId = @OutPut
	
		SET  @Output = null

	
		-- AccountId 
		SET  @Code = @Account
	   EXEC @ReturnValue= [ib_Account_AddAsNeeded] @Code,@FirmId,@OutPut output
	   SET  @AccountId = @OutPut

	   SET  @Output = null

	END

	-- CurrencyId 
	DECLARE @CurrencyId int
	EXEC @ReturnValue = [ib_Currency_AddAsNeeded] @DataSourceId, @Currency, @Output output
	SET  @CurrencyId = @Output
	

	IF @CurrencyId is null
		BEGIN
			
			SET  @CurrencyId = @DefaultCurrencyId	
			
		END
 
    -- Inserting values in the ib_Nostro table.
	SET @Output = null

	EXEC ib_Nostro_Add @Output output,@DataSourceId, @ValueDate, @TransDate, @Amount, @TransactionType, @InternalReference, @ExternalReference, @Narrative, @AccountId, @CurrencyId, @TempTableRecordId
	SET @NostroId=@OutPut
		
	EXEC @ReturnValue=ib_NostroBalanceAddOrUpdate @NostroId,@DataSourceId,@Amount,@AccountId,@CurrencyId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Peoplesoft_Load]''
');

GO
EXECUTE ('
-- =============================================
-- Author:		Petru Konrad Bercea
-- Create date: 04.02.2009
-- Description:	This stored procedure pulls data from the Peoplesoft temp
-- table and inserts it into ?
-- Whilst iterating through the records in Peoplesoft, all 
-- of these inserts are wrapped in a transaction so that any failure causes
-- the changes to not commit.
-- Revision History
--
-- 19 Feb 2009		Konrad		Removed ISDATE function calls as this function 
--								doesn''t recognise all the date format styles.
--
-- 03 Jul 2009      Konrad      The transactions that don''t have the OpenBalance matching with the ClosingBalance on a certain Account
--								are being moved from Peoplesoft temp table to a separate temp table named [Peoplesoft_UnMatching_OpenBalances]	
-- 16.07.2009       Konrad		Fixed bug in checking if the OpeningBalance matches the previous Closing Balance.
-- 26 Aug 2009		amk			1) Kevin''s pre val check now already moves out failed accts so process rest
--								2) Remove Konrad''s redundant integrity checks which also move records to second holding tank table
-- 16 Sep 2009		amk			1) Use transaction isolation level read committed to stop deadlock errors
--								2) Only pick up rows from the file just loaded (to allow multiple instances of this proc to run reliably)
-- 28 Oct 2009		AAJM		MBAL-13637 Add output NostroId parameter for ib_Nostro_Load
-- 09 Jan 2014		ED			EIB 25004 - remove importLog table and use Log table
-- =============================================
CREATE PROCEDURE [dbo].[ib_Peoplesoft_Load] 
	-- Add the parameters for the stored procedure here
	(
		@LocationPath	varchar(100) = NULL
		,@ReceiveLocationSysId INT
		,@RunId INT
	)
AS
SET NOCOUNT ON

	BEGIN TRANSACTION T1

	-- BizTalk''s SQL Adapter uses more restrictive read serializable
	-- so this is necessary to relax it to something that is default
	-- and perfectly acceptable!
	SET TRANSACTION ISOLATION LEVEL READ COMMITTED

	-- Do necessary Validation
	DECLARE @ValidationSucceeded BIT
	EXEC [dbo].[ib_Peoplesoft_Validate_Load] @LocationPath, @ValidationSucceeded OUTPUT, @ReceiveLocationSysId, @RunId
	
	DECLARE @DataSourceCd  AS VARCHAR(100)
	SET @DataSourceCd = ''Peoplesoft''
	DECLARE @DataSourceId INT
	DECLARE @DefaultCurrencyId INT
	EXEC [_ib_DataSource_GetByCodeForOutput] @DataSourceCd, @DataSourceId output, @DefaultCurrencyId output
	
	IF @ValidationSucceeded = 0
		EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', ''One or more accounts failed integrity validation.  Will load other accounts (if any).'', ''Success'', '''', @RunId
	ELSE
		EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', ''All accounts passed integrity validation.'', ''Success'', '''', @RunId
	
	-- Now proceed with load

	DECLARE @PeoplesoftID INT
	DECLARE	@AccountNumber VARCHAR(35)
	DECLARE	@OpeningBalance VARCHAR(50)
	DECLARE	@ClosingBalance VARCHAR(25)
	DECLARE	@CreateDate DATETIME
	DECLARE @Started BIT
	DECLARE	@Account VARCHAR(35)
	DECLARE @ReturnValue INT
	DECLARE @Output INT
	DECLARE @Output2 INT

	SET @Started = 0

	CREATE TABLE #temp1
	(
		PeoplesoftID					int,
		AccountNumber					varchar(35),
		TransactionDate					varchar(8),
		ValueDate						varchar(8),
		Narrative						varchar(34),
		InternalReference				varchar(16),
		ExternalReference				varchar(16),
		TrType							varchar(4),
		Currency						varchar(3),
		ReceiptAmount					varchar(20),
		PaymentAmount					varchar(20),
        BusinessUnit                    varchar(3),
		OpeningBalance					varchar(50),
		ClosingBalance					varchar(25),
        CreateDate						datetime
	)

	INSERT INTO #temp1
	(
		PeoplesoftID,	
		AccountNumber,
		TransactionDate,
		ValueDate,
		Narrative,
		InternalReference,
		ExternalReference,
		TrType,
		Currency,
		ReceiptAmount,
		PaymentAmount,
		BusinessUnit,
		OpeningBalance,
		ClosingBalance,
		CreateDate
	)
	SELECT 	
		PeoplesoftID,
		AccountNumber,
		TransactionDate,
		ValueDate,
		Narrative,
		InternalReference,
		ExternalReference,
		[Type],
		Currency,
		ReceiptAmount,
		PaymentAmount,
		BusinessUnit,
		OpeningBalance,
		ClosingBalance,
		CreateDate
	FROM	[dbo].[Peoplesoft]
	WHERE	LoadState = 1
		AND Filename = @LocationPath

			DECLARE	@TransactionDateStr				VARCHAR(8)
			DECLARE	@ValueDateStr					VARCHAR(8)
			DECLARE	@Narrative						VARCHAR(34)
			DECLARE	@InternalReference				VARCHAR(16)
			DECLARE	@ExternalReference				VARCHAR(16)
			DECLARE	@TrType							VARCHAR(4)
			DECLARE	@Currency						VARCHAR(3)
			DECLARE	@ReceiptAmount					VARCHAR(20)
			DECLARE	@PaymentAmount					VARCHAR(20)
			DECLARE	@BusinessUnit					VARCHAR(3)
			
			DECLARE pos_cursor CURSOR FOR
			SELECT	PeoplesoftID,	
					AccountNumber,
					TransactionDate,
					ValueDate,
					Narrative,
					InternalReference,
					ExternalReference,
					TrType,
					Currency,
					ReceiptAmount,
					PaymentAmount,
					BusinessUnit,
					OpeningBalance,
					ClosingBalance
			FROM	#temp1

			OPEN pos_cursor

			FETCH NEXT FROM pos_cursor
			INTO 
					@PeoplesoftID,	
					@AccountNumber,	
					@TransactionDateStr,
					@ValueDateStr,
					@Narrative,
					@InternalReference,
					@ExternalReference,
					@TrType,
					@Currency,
					@ReceiptAmount,
					@PaymentAmount,
					@BusinessUnit,
					@OpeningBalance,
					@ClosingBalance

				-- Check @@FETCH_STATUS to see IF there are any more rows to fetch.
				WHILE @@FETCH_STATUS = 0
				BEGIN
					DECLARE		@ValueDate				datetime
					DECLARE		@TransDate				datetime
					DECLARE		@ReceiptAmountDec		decimal(20, 6)
					DECLARE		@PaymentAmountDec		decimal(20, 6)
					DECLARE		@Amount					decimal(18, 4)
					DECLARE		@TransactionType		varchar(4)
					DECLARE     @FirmCd                 varchar(3)
					DECLARE 	@Code varchar(100), @Code2 varchar(100)
					DECLARE     @Continue    bit
					
				IF @Started = 0
				BEGIN
					-- COMMENT: specify datasource in proc.
					SET @DataSourceCd = ''Peoplesoft''
					IF @LocationPath IS NULL SET @LocationPath = @DataSourceCd
					
					EXEC @ReturnValue= [_ib_DataSource_GetByCodeForOutput] @DataSourceCd,@OutPut output, @Output2 output
					
					SET @DataSourceId = @Output
										
					SET @Started = 1
				END
	
			SET @Output = null
		  
			-- Remove the FirmCode and the CurrencyCode from the AccountNumber 
			SET @Account = SUBSTRING(@AccountNumber,1,8)

			-- FirmCd
			SET @FirmCd = @BusinessUnit		

			-- ValueDate
			SET @Code = null
            			
			SET @ValueDate = CONVERT(datetime, @ValueDateStr, 3) 
            			
			-- TransDate
			SET @TransDate = CONVERT(datetime, @TransactionDateStr, 3)
					  
			SET @ReceiptAmountDec = 0
			SET	@PaymentAmountDec = 0

			IF ISNUMERIC(@ReceiptAmount) = 1 SET @ReceiptAmountDec = CONVERT(decimal(20,6), @ReceiptAmount)
			IF ISNUMERIC(@PaymentAmount) = 1 SET @PaymentAmountDec = CONVERT(decimal(20,6), @PaymentAmount)

			SET @Amount = @ReceiptAmountDec - @PaymentAmountDec
  
            -- TransactionType
			SET @TransactionType = @TrType 

			EXEC [ib_PeoplesoftBalancesLog_AddAsNeeded]
				 @Account,
				 @Currency,
                 @FirmCd,	
				 @OpeningBalance,
				 @ClosingBalance,
            	 @LocationPath

			DECLARE @NewNostroId int
			
			EXEC [ib_Nostro_Load]
				@DataSourceCd,
				@ValueDate,
				@TransDate,
				@Amount,
				@TransactionType,
				@InternalReference,
				@ExternalReference,
				@Narrative,
				@Account,
				@Currency,
				@FirmCd,
				@PeoplesoftID,
				@NostroId = @NewNostroId output
			
			--flip processed flag in source table.
			UPDATE [Peoplesoft]
			WITH (ROWLOCK)
			SET [LoadState] = 2
			WHERE [PeoplesoftID] = @PeoplesoftID
				AND [LoadState] = 1

			FETCH NEXT FROM pos_cursor
			INTO 
					@PeoplesoftID,	
					@AccountNumber,	
					@TransactionDateStr,
					@ValueDateStr,
					@Narrative,
					@InternalReference,
					@ExternalReference,
					@TrType,
					@Currency,
					@ReceiptAmount,
					@PaymentAmount,
					@BusinessUnit,
					@OpeningBalance,
					@ClosingBalance
		END
			
			CLOSE pos_cursor
			DEALLOCATE pos_cursor
	
		DROP TABLE #temp1
	
	COMMIT TRANSACTION T1

    BEGIN TRANSACTION T_PostLoad

		-- BizTalk''s SQL Adapter uses more restrictive read serializable
		-- so this is necessary to relax it to something that is default
		-- and perfectly acceptable!
		SET TRANSACTION ISOLATION LEVEL READ COMMITTED

		SET @Started = 0

		DECLARE @AccountId		int
		DECLARE @CurrencyId		int

		DECLARE cursor_PeopleSoftLog CURSOR FOR
		SELECT	[AccountId],
				[CurrencyId],
				[ClosingBalance]
		FROM	dbo.[ib_PeoplesoftBalancesLog]	
		WHERE   [FileName] = @LocationPath

		OPEN cursor_PeopleSoftLog

		FETCH NEXT FROM cursor_PeopleSoftLog
		INTO 
					@AccountId,
					@CurrencyId,
					@ClosingBalance

				-- Check @@FETCH_STATUS to see IF there are any more rows to fetch.
				WHILE @@FETCH_STATUS = 0
				BEGIN	

					IF @Started = 0
					BEGIN
					-- COMMENT: specify datasource in proc.
						SET @DataSourceCd = ''Peoplesoft''
						IF @LocationPath IS NULL SET @LocationPath = @DataSourceCd
					
						EXEC @ReturnValue= [_ib_DataSource_GetByCodeForOutput] @DataSourceCd,@OutPut output, @Output2 output
					
						SET @DataSourceId = @Output
										
						EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', ''PostLoader started'', ''Success'', '''', @RunId
						SET @Started = 1
					END

					EXEC dbo.[ib_PeoplesoftLog_StoreNostroBalance]
						@AccountId,
						@CurrencyId,
						@ClosingBalance,
						@LocationPath

					FETCH NEXT FROM cursor_PeopleSoftLog
					INTO 
						@AccountId,
						@CurrencyId,
						@ClosingBalance
				END

		CLOSE cursor_PeopleSoftLog
		DEALLOCATE cursor_PeopleSoftLog	

		EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', ''PostLoader ended'', ''Success'', '''', @RunId

	COMMIT TRANSACTION T_PostLoad
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_ImbalanceReportSummary_InsertAdjustment]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_ImbalanceReportSummary_InsertAdjustment]
(
	@ImbalanceReportSummaryId1 int
	,@ImbalanceReportSummaryId2 int
	,@CreateUsername varchar(50)
)
AS
SET NOCOUNT ON
/*
<details>
	<summary> Insert new values for adjustments</summary>
	<created author="ED" Date="05 May 2010" />
</details>
  -- 28 May 2010 ED Set Also datasourceid
  -- 16 Jun 2010 ED Set quantity short/long
*/
BEGIN TRY
BEGIN TRAN

DECLARE @TemplateId int
DECLARE @MatchCodeId1 int
DECLARE @MatchCodeId2 int
DECLARE @Today DATETIME
DECLARE @RegenId int
DECLARE @AdjustmentTypeId int
DECLARE @AdjustmentHeaderId int
SELECT @TemplateId = TemplateId, @Today = Today FROM ib_ImbalanceReport 
	WHERE ImbalanceReportId = (SELECT DISTINCT ImbalanceReportId FROM ib_ImbalanceReportSummary
				WHERE ImbalanceReportSummaryId = @ImbalanceReportSummaryId1)
SELECT @MatchCodeId1 = MatchCodeId FROM 
	ib_MatchCode WHERE TemplateId=@TemplateId AND MatchCode IN (SELECT Description FROM ib_ImbalanceReportSummary
				WHERE ImbalanceReportSummaryId = @ImbalanceReportSummaryId1)

SELECT @MatchCodeId2 = MatchCodeId FROM 
	ib_MatchCode WHERE TemplateId=@TemplateId AND MatchCode IN (SELECT Description FROM ib_ImbalanceReportSummary
				WHERE ImbalanceReportSummaryId = @ImbalanceReportSummaryId2)

DECLARE @DataSourceId1 INT

SELECT @DataSourceId1 = [dbo].[GetDataSourceIdForTradeAdjustments]( @TemplateId,InstrumentId,ExchangeId ,Description,''I'')
	FROM ib_ImbalanceReportSummary irs WHERE  ImbalanceReportSummaryId = @ImbalanceReportSummaryId1

DECLARE @DataSourceId2 INT

SELECT @DataSourceId2 = [dbo].[GetDataSourceIdForTradeAdjustments]( @TemplateId,InstrumentId,ExchangeId ,Description,''I'')
	FROM ib_ImbalanceReportSummary irs WHERE  ImbalanceReportSummaryId = @ImbalanceReportSummaryId2

	--try to get firm id
DECLARE @FirmId1 INT
SELECT @FirmId1 = [dbo].[GetFirmIdForTradeAdjustments] (@TemplateId, Description, ExchangeId, @DataSourceId1)
	FROM ib_ImbalanceReportSummary irs WHERE  ImbalanceReportSummaryId = @ImbalanceReportSummaryId1
IF @FirmId1 < 0  SET @FirmId1 = NULL

	--try to get firm id
DECLARE @FirmId2 INT
SELECT @FirmId2 = [dbo].[GetFirmIdForTradeAdjustments] (@TemplateId, Description, ExchangeId, @DataSourceId2)
	FROM ib_ImbalanceReportSummary irs WHERE  ImbalanceReportSummaryId = @ImbalanceReportSummaryId2
IF @FirmId2 < 0  SET @FirmId2 = NULL

SELECT @AdjustmentTypeId = AdjustmentTypeId FROM ib_AdjustmentType WHERE Code = ''CT''

INSERT INTO [dbo].[ib_AdjustmentHeader] ([AdjustmentTypeId], [CreateDate], [CreateUsername])
	SELECT @AdjustmentTypeId, getdate(), @CreateUsername
SET @AdjustmentHeaderId = SCOPE_IDENTITY()

UPDATE ib_ImbalanceReportSummary
SET [Internal_TAdjOTE] = - [Variation]
WHERE ImbalanceReportSummaryId = @ImbalanceReportSummaryId1

INSERT INTO ib_Adjustment
           ([TemplateId]
           ,[ExchangeId]
           ,[InstrumentId]
           ,[InternalExternalCode]
           ,[TradeDate]
           ,[AdjustmentDate]
           ,[Quantity]
           ,[QuantityLong]
           ,[QuantityShort]
           ,[CurrencyId]
           ,[ExpiryYear]
           ,[ExpiryMonth]
           ,[ExpiryDay]
           ,[StrikePrice]
           ,[TradePrice]
           ,[SettlementPrice]
           ,[OptionTypeCode]
           ,[Value]
           ,[MatchCodeId] 
           ,[AdjustmentHeaderId]
           ,[CreateUsername]
           ,[IsBuy]
           ,[DataSourceId]
           ,FirmId)
     SELECT @TemplateId, ExchangeId, InstrumentId, ''I'' 
			,@Today
			, @Today
           ,0
           ,0
           ,0
           ,CurrencyId
           ,ExpiryYear
           ,ExpiryMonth
           ,ExpiryDay
           ,StrikePrice
           ,0--TradePrice, decimal(24,10),>
           ,0--<SettlementPrice, decimal(24,10),>
           ,OptionTypeCode
           ,-Variation
           ,@MatchCodeId1
           ,@AdjustmentHeaderId
           ,@CreateUsername
           ,1--<IsBuy, bit,>
           ,@DataSourceId1
           ,@FirmId1
        FROM ib_ImbalanceReportSummary
        WHERE ImbalanceReportSummaryId = @ImbalanceReportSummaryId1

UPDATE ib_ImbalanceReportSummary
SET [Variation] = 0
WHERE ImbalanceReportSummaryId = @ImbalanceReportSummaryId1

UPDATE ib_ImbalanceReportSummary
SET [Internal_TAdjOTE] = - [Variation]
WHERE ImbalanceReportSummaryId = @ImbalanceReportSummaryId2

INSERT INTO ib_Adjustment
           ([TemplateId]
           ,[ExchangeId]
           ,[InstrumentId]
           ,[InternalExternalCode]
           ,[TradeDate]
           ,[AdjustmentDate]
           ,[Quantity]
           ,[QuantityLong]
           ,[QuantityShort]
           ,[CurrencyId]
           ,[ExpiryYear]
           ,[ExpiryMonth]
           ,[ExpiryDay]
           ,[StrikePrice]
           ,[TradePrice]
           ,[SettlementPrice]
           ,[OptionTypeCode]
           ,[Value]
           ,[MatchCodeId]
           ,[AdjustmentHeaderId]
           ,[CreateUsername]
           ,[IsBuy] 
           ,[DataSourceId]
           ,FirmId)
     SELECT @TemplateId, ExchangeId, InstrumentId, ''I'' 
			,@Today
			,@Today
           ,0
           ,0
           ,0
           ,CurrencyId
           ,ExpiryYear
           ,ExpiryMonth
           ,ExpiryDay
           ,StrikePrice
           ,0--TradePrice, decimal(24,10),>
           ,0--<SettlementPrice, decimal(24,10),>
           ,OptionTypeCode
           ,-Variation
           ,@MatchCodeId2
           ,@AdjustmentHeaderId
           ,@CreateUsername
           ,1--<IsBuy, bit,>
           ,@DataSourceId2
           ,@FirmId2
        FROM ib_ImbalanceReportSummary
        WHERE ImbalanceReportSummaryId = @ImbalanceReportSummaryId2

UPDATE ib_ImbalanceReportSummary
SET [Variation] = 0
WHERE ImbalanceReportSummaryId = @ImbalanceReportSummaryId2

COMMIT TRAN
END TRY
BEGIN CATCH
ROLLBACK TRAN
EXEC [dbo].[sp_RethrowError]
END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[CreditSuisse_Transaction_Purge]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[CreditSuisse_Transaction_Purge] 
	(
		@LoadState		TINYINT = 0,
		@FileName       VARCHAR (512)= NULL
	)
AS

-- =============================================
-- Author:		Alister McLeod
-- Create date: 06 Apr 2011
-- Description:	Deletes from CreditSuisse_Transaction table all the records where the LoadState is 0
-- =============================================

BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
		DELETE FROM [dbo].[CreditSuisse_Transaction] WHERE LoadState= @LoadState AND [FileName] = Coalesce(@FileName, [FileName])

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[Log_GetSummaryByDate]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[Log_GetSummaryByDate]
	@Date DATETIME
	,@Type INT = 0
AS
-- =============================================
-- Author:		damiane
-- Create date: 07 Oct 2013
-- Description:	EIB 24392 - get details for logging
-- 16 Oct 2013   ED   EIB 24504 - get also step name
-- 02 Jan 2014   ED   EIB 24946 - get only active receive locations
-- 20 Jan 2014   ED   EIB 25063 - READPAST on Log table so it does not lock Monitor page on loading
-- 14 Apr 2014   ED   EIB 25491 - get only some types: 0 - All, 1 - Cash, 2 - Pos/Trade
-- 02 Jun 2014   ED   EIB 25667 - set DS as Misc
-- 03 Jul 2014   ED   EIB 25792 - Add IsComplete
-- 07 Jul 2014   ED   EIB 25804 - Get only top 100 errors/warnings per file
-- =============================================
BEGIN
	SET NOCOUNT ON;
	DECLARE @WarningLogStatusSysId INT, @ErrorLogStatusSysId INT
	SET @WarningLogStatusSysId = (SELECT LogStatusSysId FROM LogStatus WHERE LogStatusName = ''Warning'')
	SET @ErrorLogStatusSysId = (SELECT LogStatusSysId FROM LogStatus WHERE LogStatusName = ''Error'')
	SELECT  CASE WHEN p.IsMisc = 1 THEN ''Misc'' ELSE ds.Name END AS DataSourceName
		   ,ISNULL(l.[FileName], rl.FileMask) AS ''FileName''
	       ,l.[Message]
		   ,l.Exception
		   ,l.CreateDateTimeUtc
		   ,ls.LogStatusName
		   ,rl.IsRunning
		   ,l.RunId
		   ,rl.ReceiveLocationSysId
		   ,s.StepName
		   ,l.IsComplete
		FROM dbo.ib_DataSource ds 
			INNER JOIN dbo.ReceiveLocation rl ON rl.DataSourceId = ds.DataSourceId
			INNER JOIN dbo.Package p ON p.PackageSysId = rl.PackageSysId
			LEFT JOIN (
			
			SELECT [Filename], [MESSAGE], [EXCEPTION], CreateDateTimeUtc, RunId, ReceiveLocationSysId, LogStatusSysId, StepSysId, IsComplete
						FROM dbo.[Log] l1 (READPAST)
						WHERE DATEADD(dd, 0, DATEDIFF(dd, 0, l1.CreateDateTimeUtc)) = DATEADD(dd, 0, DATEDIFF(dd, 0, @Date)) AND LogStatusSysId != @WarningLogStatusSysId
						AND LogStatusSysId != @ErrorLogStatusSysId
			UNION ALL SELECT [Filename], [MESSAGE], [EXCEPTION], CreateDateTimeUtc, RunId, ReceiveLocationSysId, LogStatusSysId, StepSysId, IsComplete
			FROM(SELECT [Filename], [MESSAGE], [EXCEPTION], CreateDateTimeUtc, RunId, ReceiveLocationSysId, LogStatusSysId, StepSysId, IsComplete,ROW_NUMBER() OVER (PARTITION BY Filename,RunId ORDER BY LogSysId) AS Number
						FROM dbo.[Log] l1 (READPAST)
						WHERE DATEADD(dd, 0, DATEDIFF(dd, 0, l1.CreateDateTimeUtc)) = DATEADD(dd, 0, DATEDIFF(dd, 0, @Date)) 
						AND (LogStatusSysId = @WarningLogStatusSysId OR LogStatusSysId = @ErrorLogStatusSysId)
						) t1 WHERE t1.Number <= 100) l
				ON l.ReceiveLocationSysId = rl.ReceiveLocationSysId
			LEFT JOIN dbo.LogStatus ls ON ls.LogStatusSysId = l.LogStatusSysId
			LEFT JOIN dbo.Step s ON s.StepSysId = l.StepSysId
			WHERE (rl.IsActive = 1 OR l.Filename IS NOT NULL)
			AND (@Type = 0 OR (@Type = 1 AND p.PackageCode IN (''PS'', ''SWIFT'')) OR (@Type = 2 AND p.PackageCode NOT IN (''PS'', ''SWIFT'')))
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_ScheduledTask_GetQueueStatuses]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_ScheduledTask_GetQueueStatuses]
AS
SET NOCOUNT ON
	SELECT	
		*
	FROM
		ib_QueueStatus
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_InstrumentTypeDataSource_GetInstrumentTypeDataSourceById]''
');

GO
EXECUTE ('    /*
<details>
 <summary> Selectes an instrument type data source from the ib_InstrumentTypeDataSource table by its id</summary>
 <created author="Laurentiu Macovei" Date="Tuesday, 12 September 2006 9:34PM GMT" /> 
</details>
*/
create PROCEDURE [dbo].[ib_InstrumentTypeDataSource_GetInstrumentTypeDataSourceById]
(
	@InstrumentTypeDataSourceId int
)
AS 
SET NOCOUNT ON


SELECT itds.[InstrumentTypeDataSourceId]
      ,itds.[InstrumentTypeId]
	  ,it.[Name] as InstrumentTypeName
      ,itds.[DataSourceId]
	  ,ds.[Name] as DataSourceName
      ,itds.[DataSourceInstrumentTypeCode]
      ,itds.[CreateDate]
      ,itds.[CreateUsername]
      ,itds.[UpdateDate]
      ,itds.[UpdateUsername]
  FROM [dbo].[ib_InstrumentTypeDataSource] itds
INNER JOIN [dbo].[ib_InstrumentType] it ON it.[InstrumentTypeId] = itds.[InstrumentTypeId]
INNER JOIN [dbo].[DataSource] ds ON ds.[DataSourceId] = itds.[DataSourceId]
WHERE InstrumentTypeDataSourceId = @InstrumentTypeDataSourceId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_SWIFT_UNDO_Missing_Messages]''
');

GO
EXECUTE ('-- =============================================
-- Author:		Alister McLeod
-- Create date: 28.10.2009
-- Description:	Checks and inserts UNDOs for MISSED SWIFT messages
--				Created based on previous ib_SWIFT_MT940_UNDO_Missing_Messages
--				and in response to MBAL-13637, removing reliance on temp tables for misses.
-- =============================================
-- History

CREATE PROCEDURE [dbo].[ib_SWIFT_UNDO_Missing_Messages] 
	
	@FileName varchar(100)

AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	 
	BEGIN TRANSACTION

	-- BizTalk''s SQL Adapter uses more restrictive read serializable
	-- so this is necessary to relax it to something that is default
	-- and perfectly acceptable!
	SET TRANSACTION ISOLATION LEVEL READ COMMITTED

	CREATE TABLE #temp_Messages_With_Balances
              ( 
				[AccountId] [int] NOT NULL,
				[StatementNumber] int,
				[StatementSequenceNumber] int,
				[GapNostroId] int,
				[CurrencyId] int			
			  )

	insert into #temp_Messages_With_Balances
	   		  ( 
				[AccountId],
				[StatementNumber],
				[StatementSequenceNumber],
				[GapNostroId],
				[CurrencyId]				
			  )
	select  
		      swft.[AccountId],
			  swft.[StatementNumber],
			  swft.[StatementSequenceNumber],
			  swft.[GapNostroId],
			  swft.[CurrencyId]				
				
	from ib_SwiftStatement swft
	where swft.[FileName] = @FileName
		AND swft.IsMissReplacement = 1	

	-- process the table

	CREATE TABLE #temp_Existing_Miss_Balances
              ( 
				[AccountId] [int] NOT NULL,
				[Amount] decimal(18, 4) NOT NULL,
				[StatementNumber] [varchar](5)  COLLATE Latin1_General_CI_AS,
				[StatementSequenceNumber] [varchar](5)  COLLATE Latin1_General_CI_AS,
                [CurrencyId] int,
				[DataSourceId] int
			  )

	insert into #temp_Existing_Miss_Balances
              (
				[AccountId],
				[Amount],
				[StatementNumber],
				[StatementSequenceNumber],
                [CurrencyId],
				[DataSourceId]
              )
	select        
				nos.[AccountId],
				(nos.[Amount]*(-1)), -- We only need the Amount from ib_Nostro
				tmp.[StatementNumber],
                tmp.[StatementSequenceNumber],
				nos.[CurrencyId],
				nos.[DataSourceId]

	from #temp_Messages_With_Balances tmp
    INNER JOIN dbo.[ib_Nostro] nos ON nos.[NostroId] = tmp.[GapNostroId]
			   		
	DECLARE	@AccountId int 
	DECLARE	@CurrencyId int 
	DECLARE	@Amount decimal(18, 4) 
	DECLARE	@NewRecord_TempTableRecordId int
	DECLARE @CreateUsername varchar(50) 
	DECLARE	@StatementNumber varchar(5)
	DECLARE	@StatementSequenceNumber varchar(5)
	DECLARE @CurrencyCd varchar(3)
	DECLARE @DataSourceCd varchar(100)
	DECLARE @ValueDate	datetime
	DECLARE @TransDate	datetime
	DECLARE @FirmCode   varchar(12)	
	DECLARE @ConcatStatementSequence VARCHAR(16)
	
	SET @ValueDate = getdate()
	SET @TransDate = getdate() 
	
	SET @CreateUsername = (suser_sname())

	DECLARE pos_cursor CURSOR FOR
    SELECT  [AccountId],
			[Amount],
			[StatementNumber],
			[StatementSequenceNumber],
            [CurrencyId]

	FROM #temp_Existing_Miss_Balances

	OPEN pos_cursor

	FETCH NEXT FROM pos_cursor
	INTO 
			@AccountId,
			@Amount,
			@StatementNumber,
			@StatementSequenceNumber,
			@CurrencyId

	WHILE @@FETCH_STATUS = 0
	BEGIN
   			
						SET @CurrencyCd = null
						SET @CurrencyCd = (SELECT Code FROM ib_Currency where CurrencyId = @CurrencyId)
		
						SET @DataSourceCd = ''SWIFT''
										
						SET @ConcatStatementSequence = CONVERT(VARCHAR(5),@StatementNumber) + ''/'' + CONVERT(VARCHAR(5),@StatementSequenceNumber)
						
						SET @FirmCode = NULL -- This has always been NULL for a miss
						
						SET @NewRecord_TempTableRecordId = -1 -- This is now true for all misses
						
						DECLARE @NewNostroId int
						
                        -- add to nostro
						EXEC [ib_Nostro_Load]
							@DataSourceCd,
							@ValueDate,
							@TransDate,
							@Amount,
							''UNDO MISS'', -- TransactionType
							''Gap Record'', -- InternalReference
                            @ConcatStatementSequence , -- ExternalReference
							''Missing Statement loaded'', -- Narrative
							null, -- 21 Aug 2009 AAJM Changed from @AccountCode,
							@CurrencyCd,
							@FirmCode,
							@NewRecord_TempTableRecordId,
							@AccountId = @AccountId, -- 21 Aug 2009 AAJM	Added
							@NostroId = @NewNostroId output
							
			FETCH NEXT FROM pos_cursor
			INTO 
 			@AccountId,
			@Amount,
			@StatementNumber,
			@StatementSequenceNumber,
			@CurrencyId
	END

	CLOSE pos_cursor
	DEALLOCATE pos_cursor

	DROP TABLE #temp_Existing_Miss_Balances
	DROP TABLE #temp_Messages_With_Balances

	COMMIT TRANSACTION

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_SWIFT_StoreNostroBalance]''
');

GO
EXECUTE ('-- =============================================
-- Author:        Konrad      
-- Create date: 07.07.2009
-- Description:   Stores the Nostro Balance for a certain Account and Currency in the ib_SwiftStatement table for SWIFT statements
-- =============================================
-- History
-- 19 Aug 2009    AAJM  Updated select statement to retrieve Nostro Closing Balance to ensure
--                      it retrieves the Nostro Balance "opening balance" for the following day
--                      which should equal the closing balance for the SWIFT Statement on
--						BalanceDate
-- 24 Aug 2009	  AAJM	Rollback previous change back to 07.07.2009 state but include 
--						updateusername and improve query features of 19 Aug 2009
-- 05.06.2012	  ED	MBAL 20952 move change load state to load file and adding (nolock) to avoid deadlocks
CREATE PROCEDURE [dbo].[ib_SWIFT_StoreNostroBalance]
	@FileName	    varchar(100)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	CREATE TABLE #temp_SwiftStatement_Distinct
	(
		[AccountId] int,
		[CurrencyId]  int
		
	)

	INSERT INTO #temp_SwiftStatement_Distinct
		(		
		[AccountId],
		[CurrencyId]
		)

	SELECT DISTINCT swf_stm.[AccountId] as Account, swf_stm.[CurrencyId] as Currency
			FROM ib_SwiftStatement swf_stm (NOLOCK) 
			WHERE swf_stm.[FileName] = @FileName


    CREATE TABLE #temp_SwiftStatement
	(
		[SwiftStatementId] int NOT NULL,
		[AccountId] int,
		[CurrencyId]  int
		
	)
	
	INSERT INTO #temp_SwiftStatement
		(
		[SwiftStatementId],
		[AccountId],
		[CurrencyId]
		
		)

	SELECT
		(Select [SwiftStatementId] from ib_SwiftStatement tmp_swf
        where tmp_swf.[AccountId] = dstct.[AccountId] AND tmp_swf.[CurrencyId] = dstct.[CurrencyId] AND 
			  tmp_swf.[StatementNumber] = 
              (
							SELECT max([StatementNumber]) from ib_SwiftStatement temp_swf1 
							WHERE  temp_swf1.[AccountId] = dstct.[AccountId] AND temp_swf1.[CurrencyId] = dstct.[CurrencyId] AND temp_swf1.[FileName] = @FileName
			  ) AND
			  tmp_swf.[StatementSequenceNumber] = 
              (
				SELECT max([StatementSequenceNumber]) from ib_SwiftStatement temp_swf1 
				WHERE  temp_swf1.[AccountId] = dstct.[AccountId] AND temp_swf1.[CurrencyId] = dstct.[CurrencyId] AND temp_swf1.[FileName] = @FileName
					   AND 	temp_swf1.[StatementNumber] =
                       (
							SELECT max([StatementNumber]) from ib_SwiftStatement temp_swf2 
							WHERE  temp_swf2.[AccountId] = dstct.[AccountId] AND temp_swf2.[CurrencyId] = dstct.[CurrencyId] AND temp_swf2.[FileName] = @FileName
						)
              ) 
        ) as SwiftStatement_ID,
		dstct.[AccountId],
		dstct.[CurrencyId]
		
		
	FROM #temp_SwiftStatement_Distinct dstct


	DECLARE				@SwiftStatementId			int
	DECLARE				@AccountId					int
	DECLARE				@CurrencyId					int
	


	DECLARE pos_cursor CURSOR FOR
	SELECT	[SwiftStatementId],
			[AccountId],
			[CurrencyId]
			
			
	
	FROM	#temp_SwiftStatement


	OPEN pos_cursor

	FETCH NEXT FROM pos_cursor
			INTO 
					@SwiftStatementId,
					@AccountId,
					@CurrencyId
					
				-- Check @@FETCH_STATUS to see IF there are any more rows to fetch.
				WHILE @@FETCH_STATUS = 0
				BEGIN

			DECLARE @MatchCode		varchar(100)
			DECLARE	@TemplateId		int 
			DECLARE	@OutPut			int, @ReturnValue int, @Output2 int
			

			SELECT @MatchCode = tg.Description, @TemplateId = tg.TemplateId
			FROM [ib_TemplateGroup] tg
			WHERE tg.AccountId = @AccountId AND
				  tg.CurrencyId = @CurrencyId
	
			IF @TemplateId IS NOT NULL 
			BEGIN
				
				DECLARE @InternalExternalCode	char(1)
				DECLARE @NostroBalance			money
				DECLARE @DataSourceId			int	
				DECLARE @MatchCodeId			int
				DECLARE @BalanceDate			DATETIME

				SELECT @OutPut = a.FirmId
				FROM [ib_Account] a
				WHERE a.AccountId = @AccountId

				EXEC @ReturnValue= [_ib_DataSource_GetByCodeForOutput] ''SWIFT'',@OutPut output,@Output2 output
				SET  @DataSourceId = @OutPut

				SELECT @InternalExternalCode = tc.InternalExternalCode
				FROM [ib_TemplateCompare] tc
				WHERE tc.DataSourceId = @DataSourceId AND
				tc.FirmId = @OutPut AND tc.TemplateId = @TemplateId

				SELECT @MatchCodeId = mc.MatchCodeId
				FROM [ib_MatchCode] mc
				WHERE mc.MatchCode = @MatchCode AND mc.TemplateId = @TemplateId

                        SELECT @BalanceDate = ss.BalanceDate
                        FROM [dbo].[ib_SwiftStatement] ss
                        WHERE ss.SwiftStatementId = @SwiftStatementId
                  
                        SELECT      @NostroBalance = 
                              (CASE 
                                    WHEN @InternalExternalCode = ''I'' THEN convert(money,InternalBalance)
                                    ELSE convert(money,ExternalBalance) 
                                END)            
                FROM (
                              SELECT TOP(1) InternalBalance, ExternalBalance 
                              FROM ib_NostroBalance
                              WHERE  MatchCodeId = @MatchCodeId
                              ORDER BY BalanceDate DESC ) bal
                        

                UPDATE [dbo].[ib_SwiftStatement] 
                        SET    NostroClosingBalance = @NostroBalance, UpdateDate = GETDATE(), UpdateUsername = SUSER_SNAME()
                        WHERE  [SwiftStatementId] = @SwiftStatementId

			END	
		
			FETCH NEXT FROM pos_cursor
			INTO 
					@SwiftStatementId,
					@AccountId,
					@CurrencyId
					
			END
			
			CLOSE pos_cursor
			DEALLOCATE pos_cursor

			DROP  TABLE #temp_SwiftStatement_Distinct
			DROP  TABLE #temp_SwiftStatement
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_SWIFT_Check_Insert_Missing_Messages]''
');

GO
EXECUTE ('-- =============================================
-- Author:		Alister McLeod
-- Create date: 28.10.2009
-- Description:	Checks and inserts missing SWIFT messages
--				Created based on previous ib_SWIFT_MT940_Check_Insert_Missing_Messages
--				and in response to MBAL-13637, removing reliance on temp tables for misses.
-- Revision History
-- 05.06.2012		ED			MBAL 20952 move change load state to load file and adding (nolock) to avoid deadlocks
-- =============================================
CREATE PROCEDURE [dbo].[ib_SWIFT_Check_Insert_Missing_Messages] 
	
	@FileName varchar(100)

AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	 
	BEGIN TRANSACTION 

	-- BizTalk''s SQL Adapter uses more restrictive read serializable
	-- so this is necessary to relax it to something that is default
	-- and perfectly acceptable!
	SET TRANSACTION ISOLATION LEVEL READ COMMITTED

	CREATE TABLE #temp_Swift_Statement_Distinct
              ( 
				[SwiftStatementId] int, 
				[AccountId] int NOT NULL,
				[StatmtNo_28C] int,
				[StatmtNoSeqNo_28C] int
			  )	

	insert into #temp_Swift_Statement_Distinct
	   		(	
	   			[SwiftStatementId],
				[AccountId],
				[StatmtNo_28C],
				[StatmtNoSeqNo_28C]
			)
	select distinct 
				swft.SwiftStatementId,
				swft.[AccountId], 
				swft.StatementNumber, 
				swft.StatementSequenceNumber   
			
	from ib_SwiftStatement swft (NOLOCK) 
	where swft.[FileName] = @FileName


	CREATE TABLE #temp_Missing_Balances
              ( 
				[AccountId] [int] NOT NULL,
				[OpenBalance_Amount] money,
				[ClosingBalance_Amount] money,
				[StatmtNo_28C] int,
				[StatmtNoSeqNo_28C] int,
				[CurrencyId] int,
				[BalanceDate] datetime NOT NULL
			  )
	
	-- get missing statement seq numb
	insert into #temp_Missing_Balances
              (
				[AccountId],
				[OpenBalance_Amount],
				[ClosingBalance_Amount],
				[StatmtNo_28C],
				[StatmtNoSeqNo_28C],
				[CurrencyId],
				[BalanceDate]
              )
	select        
				tmp_swft_stm.[AccountId],
				(
                  Select top 1 [ClosingBalance]  from ib_SwiftStatement swf_stm 
                          where swf_stm.[AccountId]=tmp_swft_stm.[AccountId] and swf_stm.[StatementNumber]=tmp_swft_stm.[StatmtNo_28C] 
                                and swf_stm.[StatementSequenceNumber] = 
                                    (
                           SELECT TOP 1 MAX(swf_stm1.[StatementSequenceNumber]) from ib_SwiftStatement swf_stm1 where swf_stm1.[StatementSequenceNumber] < tmp_swft_stm.[StatmtNoSeqNo_28C] and swf_stm1.[AccountId] = tmp_swft_stm.[AccountId] and swf_stm1.[StatementNumber] = tmp_swft_stm.[StatmtNo_28C] 
                        )
                ),      

   				(select top 1 [OpenBalance] from ib_SwiftStatement tmp_b where tmp_b.[AccountId]=tmp_swft_stm.[AccountId] and tmp_b.[StatementSequenceNumber]=tmp_swft_stm.[StatmtNoSeqNo_28C] and tmp_b.[StatementNumber]=tmp_swft_stm.[StatmtNo_28C]),
				tmp_swft_stm.[StatmtNo_28C],
                tmp_swft_stm.[StatmtNoSeqNo_28C]-1,
				(select top 1 [CurrencyId] from ib_SwiftStatement tmp_b where tmp_b.[AccountId]=tmp_swft_stm.[AccountId] and tmp_b.[StatementSequenceNumber]=tmp_swft_stm.[StatmtNoSeqNo_28C] and tmp_b.[StatementNumber]=tmp_swft_stm.[StatmtNo_28C]),
				(select top 1 [BalanceDate] from ib_SwiftStatement tmp_b where tmp_b.[AccountId]=tmp_swft_stm.[AccountId] and tmp_b.[StatementSequenceNumber]=tmp_swft_stm.[StatmtNoSeqNo_28C] and tmp_b.[StatementNumber]=tmp_swft_stm.[StatmtNo_28C])

	from #temp_Swift_Statement_Distinct tmp_swft_stm
	where (tmp_swft_stm.[StatmtNoSeqNo_28C] > 1) and
		   (EXISTS (
					SELECT TOP 1 MAX(swf_stm.[StatementSequenceNumber]) 
					from ib_SwiftStatement swf_stm 
					where swf_stm.[AccountId] = tmp_swft_stm.[AccountId] and swf_stm.[StatementNumber] = tmp_swft_stm.[StatmtNo_28C] 
					and swf_stm.[StatementSequenceNumber] < tmp_swft_stm.[StatmtNoSeqNo_28C]
				  )) AND
	(tmp_swft_stm.[StatmtNoSeqNo_28C]-1) 
	<> 
	(
		SELECT TOP 1 MAX(swf_stm.[StatementSequenceNumber]) 
		from ib_SwiftStatement swf_stm
		where swf_stm.[StatementSequenceNumber] < tmp_swft_stm.[StatmtNoSeqNo_28C] and 
				swf_stm.[AccountId] = tmp_swft_stm.[AccountId] 
				and swf_stm.[StatementNumber] = tmp_swft_stm.[StatmtNo_28C]
	)

-- Fix for not inserting MISS when Stmt Seq = 2

	INSERT INTO #temp_Missing_Balances
              (
                        [AccountId],
                        [OpenBalance_Amount],
                        [ClosingBalance_Amount],
                        [StatmtNo_28C],
                        [StatmtNoSeqNo_28C],
                        [CurrencyId],
                        [BalanceDate]
              )
      SELECT       
                        tmp_swft_stm.[AccountId],
                        (
						  SELECT TOP 1 [ClosingBalance] 
                          FROM ib_SwiftStatement swft_stm 
                          WHERE swft_stm.[AccountId]=tmp_swft_stm.[AccountId] 
                              AND swft_stm.[StatementNumber]=
                              (
                                   SELECT MAX(swft_stm1.[StatementNumber]) 
                                   FROM ib_SwiftStatement swft_stm1 
								   WHERE swft_stm1.[StatementNumber] < tmp_swft_stm.[StatmtNo_28C]
										AND swft_stm1.[AccountId] = tmp_swft_stm.[AccountId]  
							  )
                              AND swft_stm.[StatementSequenceNumber]=
                              (
									SELECT TOP 1 MAX(swft_stm1.[StatementSequenceNumber])
									FROM ib_SwiftStatement swft_stm1 
                                    WHERE swft_stm1.[AccountId] = tmp_swft_stm.[AccountId]
							  AND swft_stm1.[StatementNumber] = 
							  (
                                    SELECT MAX(swft_stm2.[StatementNumber])
                                    FROM ib_SwiftStatement swft_stm2 
                                    WHERE swft_stm2.[StatementNumber] < tmp_swft_stm.[StatmtNo_28C]
										AND swft_stm2.[AccountId] = tmp_swft_stm.[AccountId] 
                              )
                          )
                ),      
                        (select top 1 [OpenBalance] from ib_SwiftStatement tmp where tmp.[AccountId]=tmp_swft_stm.[AccountId] and tmp.[StatementSequenceNumber]=tmp_swft_stm.[StatmtNoSeqNo_28C] and tmp.[StatementNumber]=tmp_swft_stm.[StatmtNo_28C]),
                        tmp_swft_stm.[StatmtNo_28C],
                1,
                        (select top 1 [CurrencyId] from ib_SwiftStatement tmp where tmp.[AccountId]=tmp_swft_stm.[AccountId] and tmp.[StatementSequenceNumber]=tmp_swft_stm.[StatmtNoSeqNo_28C] and tmp.[StatementNumber]=tmp_swft_stm.[StatmtNo_28C]),
                        (select top 1 [BalanceDate] from ib_SwiftStatement tmp where tmp.[AccountId]=tmp_swft_stm.[AccountId] and tmp.[StatementSequenceNumber]=tmp_swft_stm.[StatmtNoSeqNo_28C] and tmp.[StatementNumber]=tmp_swft_stm.[StatmtNo_28C])

      FROM #temp_Swift_Statement_Distinct tmp_swft_stm
      WHERE 
      (tmp_swft_stm.[StatmtNoSeqNo_28C] = 2) 
		 AND (NOT EXISTS 
				(SELECT 1 FROM ib_SwiftStatement tmp 
				 WHERE tmp.[AccountId] = tmp_swft_stm.[AccountId] 
					AND tmp.[StatementNumber] = tmp_swft_stm.[StatmtNo_28C] 
					AND tmp.[StatementSequenceNumber] = 1
				 ) 
		 AND(EXISTS 
				( -- Is there a smaller statement number
					SELECT TOP 1 MAX(tmp.[StatementNumber]) 
					FROM ib_SwiftStatement tmp 
					WHERE tmp.[AccountId] = tmp_swft_stm.[AccountId] 
						AND tmp.[StatementNumber] < tmp_swft_stm.[StatmtNo_28C]
                 )
		   )
    )

	-- get missing Statement Numbers 
    insert into #temp_Missing_Balances
              (
				[AccountId],
				[OpenBalance_Amount],
				[ClosingBalance_Amount],
				[StatmtNo_28C],
				[StatmtNoSeqNo_28C],
				[CurrencyId],
				[BalanceDate]
              )
	select        
				tmp_swft_stm.[AccountId],
				(
                  Select top 1 [ClosingBalance] from ib_SwiftStatement swft_stm 
                           WHERE swft_stm.[AccountId]=tmp_swft_stm.[AccountId] 
                              and swft_stm.[StatementNumber]=
                                     (
                           SELECT MAX(swft_stm1.[StatementNumber]) from ib_SwiftStatement swft_stm1 
                                       where swft_stm1.[StatementNumber] < tmp_swft_stm.[StatmtNo_28C] and swft_stm1.[AccountId] = tmp_swft_stm.[AccountId]  
                          )
                              and swft_stm.[StatementSequenceNumber]=
                                    (
                                       SELECT TOP 1 MAX(swft_stm1.[StatementSequenceNumber]) from ib_SwiftStatement swft_stm1 
                                       where swft_stm1.[AccountId] = tmp_swft_stm.[AccountId]
                                                 AND swft_stm1.[StatementNumber] = 
                             (
                                                  SELECT MAX(swft_stm2.[StatementNumber]) from ib_SwiftStatement swft_stm2 
                                       where swft_stm2.[StatementNumber] < tmp_swft_stm.[StatmtNo_28C] and swft_stm2.[AccountId] = tmp_swft_stm.[AccountId] 
                                          )
                                    )
                ),      
   				(select top 1 [OpenBalance] from ib_SwiftStatement tmp where tmp.[AccountId]=tmp_swft_stm.[AccountId] and tmp.[StatementSequenceNumber]=tmp_swft_stm.[StatmtNoSeqNo_28C] and tmp.[StatementNumber]=tmp_swft_stm.[StatmtNo_28C]),
				tmp_swft_stm.[StatmtNo_28C]-1,
                1,
				(select top 1 [CurrencyId] from ib_SwiftStatement tmp where tmp.[AccountId]=tmp_swft_stm.[AccountId] and tmp.[StatementSequenceNumber]=tmp_swft_stm.[StatmtNoSeqNo_28C] and tmp.[StatementNumber]=tmp_swft_stm.[StatmtNo_28C]),
				(select top 1 [BalanceDate] from ib_SwiftStatement tmp where tmp.[AccountId]=tmp_swft_stm.[AccountId] and tmp.[StatementSequenceNumber]=tmp_swft_stm.[StatmtNoSeqNo_28C] and tmp.[StatementNumber]=tmp_swft_stm.[StatmtNo_28C])

	from #temp_Swift_Statement_Distinct tmp_swft_stm
	where (EXISTS (
		SELECT TOP 1 MAX(tmp.[StatementNumber]) 
		from ib_SwiftStatement tmp 
		where tmp.[AccountId] = tmp_swft_stm.[AccountId] and tmp.[StatementNumber] < tmp_swft_stm.[StatmtNo_28C]
			
	)) and 
	(tmp_swft_stm.[StatmtNo_28C]-1) 
	<> 
	(
		SELECT TOP 1 MAX(tmp.[StatementNumber]) 
		from ib_SwiftStatement tmp 
		where tmp.[AccountId] = tmp_swft_stm.[AccountId] 
				and tmp.[StatementNumber] < tmp_swft_stm.[StatmtNo_28C]
	)
	AND (tmp_swft_stm.[StatmtNoSeqNo_28C] = 1)
	
	
	-- Insert MISS for missing last page of previous statement

  insert into #temp_Missing_Balances
              (
				[AccountId],
				[OpenBalance_Amount],
				[ClosingBalance_Amount],
				[StatmtNo_28C],
				[StatmtNoSeqNo_28C],
				[CurrencyId],
				[BalanceDate]
              )
	select        
				tmp_swft_stm.[AccountId],
				(
                  Select top 1 [ClosingBalance] from ib_SwiftStatement swft_stm 
                           WHERE swft_stm.[AccountId]=tmp_swft_stm.[AccountId] 
                              and swft_stm.[StatementNumber]=
                                     (
                           SELECT MAX(swft_stm1.[StatementNumber]) from ib_SwiftStatement swft_stm1 
                                       where swft_stm1.[StatementNumber] < tmp_swft_stm.[StatmtNo_28C] and swft_stm1.[AccountId] = tmp_swft_stm.[AccountId]  
                          )
                              and swft_stm.[StatementSequenceNumber]=
                                    (
                                       SELECT TOP 1 MAX(swft_stm1.[StatementSequenceNumber]) from ib_SwiftStatement swft_stm1 
                                       where swft_stm1.[AccountId] = tmp_swft_stm.[AccountId]
                                                 AND swft_stm1.[StatementNumber] = 
                             (
                                                  SELECT MAX(swft_stm2.[StatementNumber]) from ib_SwiftStatement swft_stm2 
                                       where swft_stm2.[StatementNumber] < tmp_swft_stm.[StatmtNo_28C] and swft_stm2.[AccountId] = tmp_swft_stm.[AccountId] 
                                          )
                                    )
                ),      

   				(SELECT TOP(1) [OpenBalance] from ib_SwiftStatement tmp where tmp.[AccountId]=tmp_swft_stm.[AccountId] and tmp.[StatementSequenceNumber]=tmp_swft_stm.[StatmtNoSeqNo_28C] and tmp.[StatementNumber]=tmp_swft_stm.[StatmtNo_28C]),
				tmp_swft_stm.[StatmtNo_28C]-1,
                (SELECT TOP(1) MAX(swft_stm1.[StatementSequenceNumber]) from ib_SwiftStatement swft_stm1 
					where swft_stm1.[AccountId] = tmp_swft_stm.[AccountId]
							AND swft_stm1.[StatementNumber] = tmp_swft_stm.[StatmtNo_28C]-1) + 1,  
				(SELECT TOP(1) [CurrencyId] from ib_SwiftStatement tmp where tmp.[AccountId]=tmp_swft_stm.[AccountId] and tmp.[StatementSequenceNumber]=tmp_swft_stm.[StatmtNoSeqNo_28C] and tmp.[StatementNumber]=tmp_swft_stm.[StatmtNo_28C]),
				(SELECT TOP(1)[BalanceDate] from ib_SwiftStatement tmp where tmp.[AccountId]=tmp_swft_stm.[AccountId] and tmp.[StatementSequenceNumber]=tmp_swft_stm.[StatmtNoSeqNo_28C] and tmp.[StatementNumber]=tmp_swft_stm.[StatmtNo_28C])

	from #temp_Swift_Statement_Distinct tmp_swft_stm
	where (EXISTS (
		SELECT TOP 1 MAX(tmp.[StatementNumber]) 
		from ib_SwiftStatement tmp 
		where tmp.[AccountId] = tmp_swft_stm.[AccountId] and tmp.[StatementNumber] < tmp_swft_stm.[StatmtNo_28C]
			
	)) -- There is a previous statement
	AND tmp_swft_stm.[StatmtNoSeqNo_28C] = 1 -- This statement is the first page
	AND -- Check that the previous statement is not the final
	(
                  SELECT TOP(1) [IsLastInSequence] from ib_SwiftStatement swft_stm 
                           WHERE swft_stm.[AccountId]=tmp_swft_stm.[AccountId] 
                              and swft_stm.[StatementNumber]=
                                     (
                           SELECT MAX(swft_stm1.[StatementNumber]) from ib_SwiftStatement swft_stm1 
                                       where swft_stm1.[StatementNumber] < tmp_swft_stm.[StatmtNo_28C] and swft_stm1.[AccountId] = tmp_swft_stm.[AccountId]  
                          )
                              and swft_stm.[StatementSequenceNumber]=
                                    (
                                       SELECT TOP 1 MAX(swft_stm1.[StatementSequenceNumber]) from ib_SwiftStatement swft_stm1 
                                       where swft_stm1.[AccountId] = tmp_swft_stm.[AccountId]
                                                 AND swft_stm1.[StatementNumber] = 
                             (
                                                  SELECT MAX(swft_stm2.[StatementNumber]) from ib_SwiftStatement swft_stm2 
                                       where swft_stm2.[StatementNumber] < tmp_swft_stm.[StatmtNo_28C] and swft_stm2.[AccountId] = tmp_swft_stm.[AccountId] 
                                          )
                                    )
                ) = 0
	AND -- Check that the previous final page isn''t a miss	
	(
                  SELECT TOP(1) [Filename] from ib_SwiftStatement swft_stm 
                           WHERE swft_stm.[AccountId]=tmp_swft_stm.[AccountId] 
                              and swft_stm.[StatementNumber]=
                                     (
                           SELECT MAX(swft_stm1.[StatementNumber]) from ib_SwiftStatement swft_stm1 
                                       where swft_stm1.[StatementNumber] < tmp_swft_stm.[StatmtNo_28C] and swft_stm1.[AccountId] = tmp_swft_stm.[AccountId]  
                          )
                              and swft_stm.[StatementSequenceNumber]=
                                    (
                                       SELECT TOP 1 MAX(swft_stm1.[StatementSequenceNumber]) from ib_SwiftStatement swft_stm1 
                                       where swft_stm1.[AccountId] = tmp_swft_stm.[AccountId]
                                                 AND swft_stm1.[StatementNumber] = 
                             (
                                                  SELECT MAX(swft_stm2.[StatementNumber]) from ib_SwiftStatement swft_stm2 
                                       where swft_stm2.[StatementNumber] < tmp_swft_stm.[StatmtNo_28C] and swft_stm2.[AccountId] = tmp_swft_stm.[AccountId] 
                                          )
                                    )
                ) <> ''MISS''

-- Insert MISS record for subsequent statement pages where a statement page has come in
-- and replaced a MISS and where the statement page is not the last in the sequence
-- and therefore this page has not fully accounted for all missing amounts, hence
-- the balances are not aligned.

INSERT INTO #temp_Missing_Balances
              (
				[AccountId],
				[OpenBalance_Amount],
				[ClosingBalance_Amount],
				[StatmtNo_28C],
				[StatmtNoSeqNo_28C],
				[CurrencyId],
				[BalanceDate]
              )
SELECT  
		tmp_swft_stm.[AccountId],
		(SELECT TOP(1) [ClosingBalance] from ib_SwiftStatement tmp where tmp.[AccountId]=tmp_swft_stm.[AccountId] and tmp.[StatementSequenceNumber]=tmp_swft_stm.[StatmtNoSeqNo_28C] and tmp.[StatementNumber]=tmp_swft_stm.[StatmtNo_28C]),
		(
			SELECT TOP(1) [OpenBalance] 
            FROM ib_SwiftStatement swft_stm 
            WHERE swft_stm.[AccountId]=tmp_swft_stm.[AccountId] 
				AND swft_stm.[StatementNumber]=
					(
						SELECT MIN(swft_stm1.[StatementNumber]) 
                        FROM ib_SwiftStatement swft_stm1 
                        WHERE -- StatementNumber is same but higher Sequence Number
							(
							swft_stm1.[StatementNumber] = tmp_swft_stm.[StatmtNo_28C] 
							AND swft_stm1.[StatementSequenceNumber] > tmp_swft_stm.[StatmtNoSeqNo_28C] 
							AND swft_stm1.[AccountId] = tmp_swft_stm.[AccountId] 
							)               
                         OR -- StatementNumber is higher 
                            (
                            swft_stm1.[StatementNumber] > tmp_swft_stm.[StatmtNo_28C]
                            )
                     )
                 AND swft_stm.[StatementSequenceNumber] =
                     (
						SELECT MIN(swft_stm2.[StatementSequenceNumber])
						FROM ib_SwiftStatement swft_stm2
						WHERE swft_stm2.[AccountId] = tmp_swft_stm.[AccountId]
							AND swft_stm2.[StatementNumber] =
							    (
									SELECT MIN(swft_stm3.[StatementNumber]) 
									FROM ib_SwiftStatement swft_stm3 
									WHERE -- StatementNumber is same but higher Sequence Number
										(
											swft_stm3.[StatementNumber] = tmp_swft_stm.[StatmtNo_28C] 
											AND swft_stm3.[StatementSequenceNumber] > tmp_swft_stm.[StatmtNoSeqNo_28C] 
											AND swft_stm3.[AccountId] = tmp_swft_stm.[AccountId] 
										)               
										OR -- StatementNumber is higher 
										(
											swft_stm3.[StatementNumber] > tmp_swft_stm.[StatmtNo_28C]
										 )
								  )
							AND 
								  (
										(
												swft_stm2.[StatementNumber] = tmp_swft_stm.[StatmtNo_28C]
												AND swft_stm2.[StatementSequenceNumber] > tmp_swft_stm.[StatmtNoSeqNo_28C]
										)
										OR 
										(
													swft_stm2.[StatementNumber] > tmp_swft_stm.[StatmtNo_28C]
										)
											
									)					
					    )
						
						
                ),  -- The opening balance from the next Statement in order
				tmp_swft_stm.[StatmtNo_28C],
                tmp_swft_stm.[StatmtNoSeqNo_28C] + 1,
				(select top 1 [CurrencyId] from ib_SwiftStatement tmp where tmp.[AccountId]=tmp_swft_stm.[AccountId] and tmp.[StatementSequenceNumber]=tmp_swft_stm.[StatmtNoSeqNo_28C] and tmp.[StatementNumber]=tmp_swft_stm.[StatmtNo_28C]),
				(select top 1 [BalanceDate] from ib_SwiftStatement tmp where tmp.[AccountId]=tmp_swft_stm.[AccountId] and tmp.[StatementSequenceNumber]=tmp_swft_stm.[StatmtNoSeqNo_28C] and tmp.[StatementNumber]=tmp_swft_stm.[StatmtNo_28C])

	FROM #temp_Swift_Statement_Distinct tmp_swft_stm
	WHERE	(SELECT TOP(1) [IsLastInSequence] 
			FROM ib_SwiftStatement tmp 
			WHERE tmp.[AccountId] = tmp_swft_stm.[AccountId] 
				AND tmp.[StatementNumber] = tmp_swft_stm.[StatmtNo_28C]
				AND tmp.[StatementSequenceNumber] = tmp_swft_stm.[StatmtNoSeqNo_28C]) 
			 = 0 -- It is not the final page
		AND -- this was replacing a MISS
			(SELECT TOP (1) [IsMissReplacement] 
			FROM ib_SwiftStatement tmp_swft_stm3 
			WHERE tmp_swft_stm3.[AccountId] = tmp_swft_stm.[AccountId]
				AND tmp_swft_stm3.[StatementNumber] = tmp_swft_stm.[StatmtNo_28C]
				AND tmp_swft_stm3.[StatementSequenceNumber] = tmp_swft_stm.[StatmtNoSeqNo_28C])
			 = 1 
		AND -- this next page does not already exist in SwiftStatement
			NOT EXISTS 
			( SELECT 1 FROM ib_SwiftStatement tmp_swft_stm4
				WHERE tmp_swft_stm4.[AccountId] = tmp_swft_stm.[AccountId]
				AND tmp_swft_stm4.[StatementNumber] = tmp_swft_stm.[StatmtNo_28C]
				AND tmp_swft_stm4.[StatementSequenceNumber] = tmp_swft_stm.[StatmtNoSeqNo_28C] + 1
			)		

	DECLARE	@AccountId int
	DECLARE @AccountCode varchar(35) 
	DECLARE @CurrencyCd varchar(3)
	DECLARE @DataSourceCd varchar(100)
	DECLARE	@CurrencyId int 
	DECLARE	@DataSourceId int 
	DECLARE	@Amount decimal(18, 4) 
	DECLARE	@NewRecord_TempTableRecordId int
	DECLARE @CreateUsername varchar(50)
	DECLARE @Miss_OpenBal money
	DECLARE @Miss_CloseBal money
	DECLARE	@StatmtNo_28C int 
	DECLARE	@StatmtNoSeqNo_28C int
	DECLARE @ValueDate	datetime
	DECLARE @TransDate	datetime
	DECLARE @FirmCode   varchar(12)
	DECLARE @BalanceDate datetime
	DECLARE @ConcatStatementSequence VARCHAR(16)

	SET @ValueDate = getdate()
	SET @TransDate = getdate()
	SET @CreateUsername = (suser_sname())

	DECLARE pos_cursor CURSOR FOR
    SELECT  [AccountId],
			[OpenBalance_Amount],
			[ClosingBalance_Amount],
			[StatmtNo_28C],
			[StatmtNoSeqNo_28C],
			[CurrencyId],
			[BalanceDate]
	
	FROM #temp_Missing_Balances

	OPEN pos_cursor

	FETCH NEXT FROM pos_cursor
	INTO 
			@AccountId,
			@Miss_OpenBal,
			@Miss_CloseBal,
			@StatmtNo_28C,
			@StatmtNoSeqNo_28C,
			@CurrencyId,
			@BalanceDate


	WHILE @@FETCH_STATUS = 0
	BEGIN
   						SET @AccountCode = null
						SET @AccountCode = (SELECT Code FROM ib_Account where AccountId = @AccountId)
                        SET @CurrencyCd = null
						SET @CurrencyCd = (SELECT Code FROM ib_Currency where CurrencyId = @CurrencyId)
						SET @DataSourceCd = ''SWIFT''
						SET @FirmCode = 
                                (
									SELECT TOP 1 f.[Code]
									FROM ib_Account a
									INNER JOIN ib_Firm f on f.[FirmId] = a.[FirmId]
									where a.[AccountId] = @AccountId
                                 )
                        
                        -- MBAL-13637 No longer adding to temp table                         
						SET @NewRecord_TempTableRecordId = -1 

						SET @Amount = convert(decimal(18, 4),REPLACE(@Miss_CloseBal,'','',''.'')) - convert(decimal(18, 4),REPLACE(@Miss_OpenBal,'','',''.''))
						

						SET @ConcatStatementSequence = RIGHT(REPLICATE(''0'', 5)
+ CAST(@StatmtNo_28C AS VARCHAR(5)), 5)	+ ''/'' + RIGHT(REPLICATE(''0'', 3)
+ CAST(@StatmtNoSeqNo_28C AS VARCHAR(3)), 3) -- Format the Statement Number padded with zeros on the left to ensure 5 digits, and pad the Statement Sequence Number to ensure 3 digits e.g. 000350/001
						
						DECLARE @NewNostroId int
												
						-- add to nostro
                        EXEC [ib_Nostro_Load]
							@DataSourceCd,
							@ValueDate,
							@TransDate,
							@Amount,
							''MISS'', -- TransactionType
                            ''Gap Record'', -- InternalReference
                            @ConcatStatementSequence , -- ExternalReference
                            ''Missing Statement'', -- Narrative
                            @AccountCode,
                            @CurrencyCd,
                            @FirmCode,
                            @NewRecord_TempTableRecordId,
                            @NostroId = @NewNostroId output

						INSERT INTO [dbo].[ib_SwiftStatement] 
						(
							[AccountId],
							[StatementNumber],
							[StatementSequenceNumber],
							[BalanceDate],
							[CurrencyId],
							[OpenBalance],
							[TotalOfLineItemAmounts],
							[ClosingBalance],
							[Filename],
							[GapNostroId]
						)
						VALUES 
						(
							@AccountId,
							@StatmtNo_28C,
							@StatmtNoSeqNo_28C,
							@BalanceDate,
							@CurrencyId,
							@Miss_OpenBal,
							@Amount,
							@Miss_CloseBal,
							''MISS'',
							@NewNostroId
						)

			FETCH NEXT FROM pos_cursor
			INTO 
			@AccountId,
			@Miss_OpenBal,
			@Miss_CloseBal,
			@StatmtNo_28C,
			@StatmtNoSeqNo_28C,
			@CurrencyId,
			@BalanceDate
 
	END

	CLOSE pos_cursor
	DEALLOCATE pos_cursor

	DROP TABLE #temp_Swift_Statement_Distinct
	DROP TABLE #temp_Missing_Balances

	COMMIT TRANSACTION

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_SWIFT_PostLoad]''
');

GO
EXECUTE ('-- =============================================
-- Author:		Konrad	
-- Create date: 24.06.2009
-- Description:	Post Load Processing
--
-- 07.07.2009	Konrad Added NostroClosingBalance to SwiftStatement
-- 15.09.2009	amk    Set transaction isolation level
-- 28.10.2009	AAJM   MBAL-13637 Update calls to MISS stored procedures
-- 09Jan2014    ED     EIB 25004 - remove importLog table and use Log table
-- =============================================
CREATE PROCEDURE [dbo].[ib_SWIFT_PostLoad] 
(	
	@LocationPath varchar(100)
	,@ReceiveLocationSysId INT
	,@RunId INT
)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	 
	DECLARE 	@Output int, @Output2 int
	DECLARE 	@DataSourceCd			varchar(100)
	DECLARE		@Started						bit
	DECLARE 	@DataSourceId int

	BEGIN TRANSACTION T_Undo_Loaded_Missed_Messages

	-- BizTalk''s SQL Adapter uses more restrictive read serializable
	-- so this is necessary to relax it to something that is default
	-- and perfectly acceptable!
	SET TRANSACTION ISOLATION LEVEL READ COMMITTED

	SET @Started = 0

	IF @Started = 0
				BEGIN
					-- COMMENT: specify datasource in proc.
					SET @DataSourceCd = ''SWIFT''
					IF @LocationPath IS NULL SET @LocationPath = @DataSourceCd
					
					EXEC [_ib_DataSource_GetByCodeForOutput] @DataSourceCd,@OutPut output, @OutPut2 output
					
					SET @DataSourceId = @Output
										
					EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', ''Post Load UNDO started'', ''Success'', '''', @RunId
					SET @Started = 1
				END

	EXEC ib_SWIFT_UNDO_Missing_Messages @LocationPath

	EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', ''Post Load UNDO ended'', ''Success'', '''', @RunId

	COMMIT TRAN T_Undo_Loaded_Missed_Messages

	BEGIN TRAN T_Load_Missed_Messages
	
	-- BizTalk''s SQL Adapter uses more restrictive read serializable
	-- so this is necessary to relax it to something that is default
	-- and perfectly acceptable!
	SET TRANSACTION ISOLATION LEVEL READ COMMITTED

	SET @Started = 0

	IF @Started = 0
				BEGIN
					-- COMMENT: specify datasource in proc.
					SET @DataSourceCd = ''SWIFT''
					IF @LocationPath IS NULL SET @LocationPath = @DataSourceCd
					
					EXEC [_ib_DataSource_GetByCodeForOutput] @DataSourceCd,@OutPut output, @OutPut2 output
					
					SET @DataSourceId = @Output
										
					EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', ''Post Load MISS started'', ''Success'', '''', @RunId

					SET @Started = 1
				END

	EXEC ib_SWIFT_StoreNostroBalance @LocationPath

	EXEC ib_SWIFT_Check_Insert_Missing_Messages @LocationPath

	EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', ''Post Load MISS ended'', ''Success'', '''', @RunId

	COMMIT TRANSACTION T_Load_Missed_Messages

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_DataSource_GetCodeAndIdForAllDataSources]''
');

GO
EXECUTE ('  /*
<details>
 <summary>Returns code and id columns for all the dataSources</summary>
 <created author="Laurentiu Macovei" Date="Wednesday, 13 September 2006 02:06AM GMT" /> 
</details>
*/
create PROCEDURE [dbo].[ib_DataSource_GetCodeAndIdForAllDataSources]
AS
SET NOCOUNT ON
SELECT Code, DataSourceId 
	FROM ib_DataSource
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_ImbalanceReportSummary_InsertCheckAmountAdjustment]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_ImbalanceReportSummary_InsertCheckAmountAdjustment]
(
	@ImbalanceReportSummaryId INT
	,@AdjustmentValue DECIMAL(24,10)
	,@Notes VARCHAR(255)
	,@CreateUsername VARCHAR(50)
)
AS
SET NOCOUNT ON
/*
<details>
	<summary> Insert new check amount adjustments</summary>
	<created author="ED" Date="10 May 2010" />
</details>
-- 28 May 2010 ED Set Also datasourceid
-- 16 Jun 2010 ED Set quantity short/long
*/
BEGIN TRY
BEGIN TRAN

DECLARE @TemplateId INT
DECLARE @MatchCodeId INT
DECLARE @Today DATETIME

DECLARE @AdjustmentTypeId INT
DECLARE @AdjustmentHeaderId INT
SELECT @TemplateId = TemplateId, @Today = Today FROM ib_ImbalanceReport ir
	INNER JOIN ib_ImbalanceReportSummary irs ON irs.ImbalanceReportId=ir.ImbalanceReportId
	WHERE ImbalanceReportSummaryId = @ImbalanceReportSummaryId
	
SELECT @MatchCodeId = MatchCodeId 
	FROM ib_MatchCode mc
	INNER JOIN ib_ImbalanceReportSummary irs ON mc.MatchCode = irs.Description
	WHERE TemplateId=@TemplateId AND ImbalanceReportSummaryId = @ImbalanceReportSummaryId

SELECT @AdjustmentTypeId = AdjustmentTypeId FROM ib_AdjustmentType WHERE Code = ''CQ''

INSERT INTO [dbo].[ib_AdjustmentHeader] ([AdjustmentTypeId], [CreateDate], [CreateUsername])
	SELECT @AdjustmentTypeId, GETDATE(), @CreateUsername
SET @AdjustmentHeaderId = SCOPE_IDENTITY()

UPDATE ib_ImbalanceReportSummary
SET [Internal_TAdjOTE] = [Internal_TAdjOTE] + @AdjustmentValue
WHERE ImbalanceReportSummaryId = @ImbalanceReportSummaryId

DECLARE @DataSourceId INT

SELECT @DataSourceId = [dbo].[GetDataSourceIdForTradeAdjustments]( @TemplateId,InstrumentId,ExchangeId ,Description,''I'')
	FROM ib_ImbalanceReportSummary irs WHERE  ImbalanceReportSummaryId = @ImbalanceReportSummaryId
	
	--try to get firm id
DECLARE @FirmId INT
SELECT @FirmId = [dbo].[GetFirmIdForTradeAdjustments] (@TemplateId, Description, ExchangeId, @DataSourceId)
	FROM ib_ImbalanceReportSummary irs WHERE  ImbalanceReportSummaryId = @ImbalanceReportSummaryId
IF @FirmId < 0  SET @FirmId = NULL
	
INSERT INTO ib_Adjustment
           ([TemplateId]
           ,[ExchangeId]
           ,[InstrumentId]
           ,[InternalExternalCode]
           ,[TradeDate]
           ,[AdjustmentDate]
           ,[Quantity]
           ,[QuantityLong]
           ,[QuantityShort]
           ,[CurrencyId]
           ,[ExpiryYear]
           ,[ExpiryMonth]
           ,[ExpiryDay]
           ,[StrikePrice]
           ,[TradePrice]
           ,[SettlementPrice]
           ,[OptionTypeCode]
           ,[VALUE]
           ,[MatchCodeId] 
           ,[AdjustmentHeaderId]
           ,[CreateUsername]
           ,[IsBuy]
           ,[Description]
           ,DataSourceId
           ,FirmId)
     SELECT @TemplateId, ExchangeId, InstrumentId, ''I'' 
			,@Today
			,@Today
           ,0
           ,0
           ,0
           ,CurrencyId
           ,ExpiryYear
           ,ExpiryMonth
           ,ExpiryDay
           ,StrikePrice
           ,0--TradePrice, decimal(24,10),>
           ,0--<SettlementPrice, decimal(24,10),>
           ,OptionTypeCode
           ,@AdjustmentValue
           ,@MatchCodeId
           ,@AdjustmentHeaderId
           ,@CreateUsername
           ,1--<IsBuy, bit,>
           ,@Notes
           ,@DataSourceId
           ,@FirmId
        FROM ib_ImbalanceReportSummary
        WHERE ImbalanceReportSummaryId = @ImbalanceReportSummaryId

UPDATE ib_ImbalanceReportSummary
SET [Variation] = Variation+@AdjustmentValue
WHERE ImbalanceReportSummaryId = @ImbalanceReportSummaryId

COMMIT TRAN
END TRY
BEGIN CATCH
ROLLBACK TRAN
EXEC [dbo].[sp_RethrowError]
END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[DGCX_Position_Add]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[DGCX_Position_Add]
	(
		@FileName						VARCHAR (512)	= NULL
		, @Date							VARCHAR (11)	= NULL
		, @ClearingMemberCode			VARCHAR (64)	= NULL
		, @TradingMemberCode			VARCHAR (64)	= NULL
		, @AccountType					VARCHAR (1)		= NULL
		, @ClientCode					VARCHAR (64)	= NULL
		, @InstrumentType				VARCHAR (15)	= NULL
		, @ContractCode					VARCHAR (255)	= NULL
		, @ExpiryDate					VARCHAR (11)	= NULL
		, @StrikePrice					VARCHAR (28)	= NULL
		, @OptionType					VARCHAR (2)		= NULL
		, @BroughtForwardLongQty		VARCHAR (12)	= NULL
		, @BroughtForwardLongValue		VARCHAR (25)	= NULL
		, @BroughtForwardShortQty		VARCHAR (12)	= NULL
		, @BroughtForwardShortValue		VARCHAR (25)	= NULL
		, @DayBuyQty					VARCHAR (11)	= NULL
		, @DayBuyValue					VARCHAR (25)	= NULL
		, @DaySellQty					VARCHAR (12)	= NULL
		, @DaySellValue					VARCHAR (25)	= NULL
		, @PreDelExAssignLongQty		VARCHAR (12)	= NULL
		, @PreDelExAssignLongValue		VARCHAR (25)	= NULL
		, @PreDelExAssignShortQty		VARCHAR (12)	= NULL
		, @PreDelExAssignShortValue		VARCHAR (25)	= NULL
		, @BuyDelMarkedExerQty			VARCHAR (12)	= NULL
		, @SellDelMarkedAssignQty		VARCHAR (12)	= NULL
		, @PostDelExerAssignLongQty		VARCHAR (12)	= NULL
		, @PostDelExerAssignLongValue	VARCHAR (25)	= NULL    
		, @PostDelExerAssignShortQty	VARCHAR (12)	= NULL
		, @PostDelExerAssignShortValue	VARCHAR (25)	= NULL
		, @SettlementPrice				VARCHAR (12)	= NULL
		, @NetPremium					VARCHAR (25)	= NULL
		, @DailyMTMSettlementValue		VARCHAR (25)	= NULL
		, @DelMarkedExAssignValue		VARCHAR (25)	= NULL 
    )
AS
-- Description: Add temporary DGCX Position Data to DGCX_Position table

-- 13 Apr 2012	AAJM	Creation

-- History:

BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

  INSERT INTO [dbo].[DGCX_Position]
			( 
				[FileName]
				, [Date]						
				, [ClearingMemberCode]			
				, [TradingMemberCode]	
				, [AccountType]		
				, [ClientCode]			
				, [InstrumentType]		
				, [ContractCode]		
				, [ExpiryDate]		
				, [StrikePrice]		
				, [OptionType]		
				, [BroughtForwardLongQty]	
				, [BroughtForwardLongValue]		
				, [BroughtForwardShortQty]	
				, [BroughtForwardShortValue]
				, [DayBuyQty]				
				, [DayBuyValue]					
				, [DaySellQty]					
				, [DaySellValue]			
				, [PreDelExAssignLongQty]		
				, [PreDelExAssignLongValue]	
				, [PreDelExAssignShortQty]		
				, [PreDelExAssignShortValue]	
				, [BuyDelMarkedExerQty]			
				, [SellDelMarkedAssignQty]		
				, [PostDelExerAssignLongQty]	
				, [PostDelExerAssignLongValue] 
				, [PostDelExerAssignShortQty]
				, [PostDelExerAssignShortValue]	
				, [SettlementPrice]			
				, [NetPremium]				
				, [DailyMTMSettlementValue]	
				, [DelMarkedExAssignValue]	
			)
    VALUES
			( 
				@FileName							
				, @Date								
				, @ClearingMemberCode				
				, @TradingMemberCode				
				, @AccountType							
				, @ClientCode						
				, @InstrumentType					
				, @ContractCode						
				, @ExpiryDate							
				, @StrikePrice						
				, @OptionType							
				, @BroughtForwardLongQty			
				, @BroughtForwardLongValue			
				, @BroughtForwardShortQty			
				, @BroughtForwardShortValue			
				, @DayBuyQty						
				, @DayBuyValue						
				, @DaySellQty						
				, @DaySellValue						
				, @PreDelExAssignLongQty			
				, @PreDelExAssignLongValue			
				, @PreDelExAssignShortQty			
				, @PreDelExAssignShortValue			
				, @BuyDelMarkedExerQty				
				, @SellDelMarkedAssignQty			
				, @PostDelExerAssignLongQty			
				, @PostDelExerAssignLongValue				    
				, @PostDelExerAssignShortQty		
				, @PostDelExerAssignShortValue		
				, @SettlementPrice					
				, @NetPremium						
				, @DailyMTMSettlementValue			
				, @DelMarkedExAssignValue			 
			)
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_ScheduledTask_GetScheduledTaskById]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_ScheduledTask_GetScheduledTaskById]
	@scheduledTaskId int
AS
SET NOCOUNT ON
	SELECT 
		ST.ScheduledTaskId,
		ST.Name,
		ST.Description,
		ST.TaskTypeId,
		ST.RunAtSpecificDay,
		ST.Frequency,
		ST.NextRun,
		ST.LastRun,
		ST.IsActive,
		ST.CreateUsername,
		ST.SiteId,
		ST.TemplateId,
		ST.CreateDate,
		ST.UpdateDate,
		CONVERT(NVARCHAR(5),ST.RunAtTime, 8) AS RunAtTime,
		ST.UpdateUsername,
		CASE WHEN T.TemplateId IS NULL THEN ''All Templates'' ELSE T.Description END AS TemplateName,
		S.Name AS SiteName,
		TT.Name AS TaskTypeName,
		CASE ST.Frequency WHEN 0 THEN ''Daily'' WHEN 2 THEN ''Weekly'' WHEN 1 THEN ''Monthly'' WHEN 3 THEN ''Every Hour'' 
		END AS FrequencyName,
		CASE ST.Frequency
			WHEN 0 THEN NULL
			WHEN 1 THEN CAST(ST.RunAtSpecificDay AS NVARCHAR(20))
			WHEN 2 THEN
				(CASE ST.RunAtSpecificDay 
					WHEN 0 THEN ''Sunday'' 
					WHEN 1 THEN ''Monday'' 
					WHEN 2 THEN ''Tuesday'' 
					WHEN 3 THEN ''Wednesday'' 
					WHEN 4 THEN ''Thursday'' 
					WHEN 5 THEN ''Friday'' 
					WHEN 6 THEN ''Saturday'' 
				END)
		END AS RunAtSpecificDayName
	FROM
		ib_ScheduledTask ST
	INNER JOIN
		ib_TaskType TT ON TT.TaskTypeId = ST.TaskTypeId
	LEFT OUTER JOIN
		ib_Site S ON S.SiteId = ST.SiteId
	LEFT OUTER JOIN
		ib_Template T ON T.TemplateId = ST.TemplateId
	WHERE
		ScheduledTaskId = @scheduledTaskId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_InstrumentTypeDataSource_Update]''
');

GO
EXECUTE (' /*
<details>
 <summary>Updates a instrument type data source from the ib_InstrumentTypeDataSource table by its id</summary>
 <created author="Laurentiu Macovei" Date=" Sunday, 10 September 2006 2:26PM GMT" /> 
</details>
*/
create PROCEDURE [dbo].[ib_InstrumentTypeDataSource_Update]
(
	@InstrumentTypeDataSourceId int,
	@InstrumentTypeId int,
    @DataSourceId int,
    @DataSourceInstrumentTypeCode varchar(100),
    @UpdateUsername varchar(50)
)
AS 
SET NOCOUNT ON


UPDATE [dbo].[ib_InstrumentTypeDataSource]
   SET [InstrumentTypeId] = @InstrumentTypeId,
       [DataSourceId] = @DataSourceId,
       [DataSourceInstrumentTypeCode] = @DataSourceInstrumentTypeCode,
       [UpdateUsername] = @UpdateUsername
 WHERE InstrumentTypeDataSourceId = @InstrumentTypeDataSourceId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_SwiftStatement_CheckIfExists]''
');

GO
EXECUTE ('


-- =============================================
-- Author:		Petru Konrad Bercea
-- Create date: 15.07.09
-- Description:	Check if the statement (Account,StatmNo and StatmSeqNo) already exists
-- =============================================
CREATE PROCEDURE [dbo].[ib_SwiftStatement_CheckIfExists] 
	-- Add the parameters for the stored procedure here
	(
		@AccountCode varchar(35),
		@Firm		 varchar(25),
		@DataSourceId		int,	
		@StatementNumber int,
		@StatementSequenceNumber int,
		@Exists			 bit = 0 output
	)
AS
SET NOCOUNT ON

	DECLARE @NeedsUpdate		int
	DECLARE @Code 				varchar(100)
	DECLARE @ReturnValue		int, @OutPut int

	DECLARE @FirmId int 
	SET  @Code = @Firm
	EXEC @ReturnValue= [ib_Firm_AddAsNeeded] @DataSourceId,@Code,@OutPut output
	SET  @FirmId = @OutPut

	SET  @Output = null 

	-- AccountId 
	DECLARE @AccountId int
	SET  @Code = @AccountCode
    EXEC @ReturnValue= [ib_Account_AddAsNeeded] @Code,@FirmId,@OutPut output
    SET  @AccountId = @OutPut

	SET @Exists = 0

	SET @NeedsUpdate = ( 
							SELECT count(*) FROM ib_SwiftStatement swst
							WHERE  swst.[AccountId] = @AccountId 
									and swst.[StatementNumber] = @StatementNumber 
									and swst.[StatementSequenceNumber] = @StatementSequenceNumber
						)
    IF @NeedsUpdate > 0 SET @Exists = 1
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_SwiftStatement_Add]''
');

GO
EXECUTE ('


-- =============================================
-- Author:		Petru Konrad Bercea
-- Create date: 16.04.2009
-- Description:	Adds new lines to the ib_SwiftStatement
--
-- Revision History
--
-- 17.04.09		Konrad Fixed the BalanceDate persisting into the ib_SwiftStatement table.
-- 15.07.09		Konrad For already existing statements (Account,StatmNo and StatmSeqNo) the duplicate doesn''t get added but it gets logged in ImportLog
-- 09.09.09		AAJM	Store IsLastInSequence
-- 10.09.09		AAJM	Store IsMissReplacement
-- 09Jan2014    ED      EIB 25004 - remove importLog table and use Log table
-- =============================================
CREATE PROCEDURE [dbo].[ib_SwiftStatement_Add] 
	-- Add the parameters for the stored procedure here
	(
		@AccountCode varchar(35),
		@StatementNumber int,
		@StatementSequenceNumber int,
		@BalanceDate datetime,
		@CurrencyCode	varchar(3),
		@OpenBalance money,
		@TotalOfLineItemAmounts money,
		@ClosingBalance money,
		@FileName varchar(512),
		@DataSourceCd varchar(100),
		@Firm	varchar(25) = NULL,
		@IsLastInSequence BIT = NULL,
		@IsMissReplacement BIT = NULL,
		@ReceiveLocationSysId INT,
		@RunId INT
	)
AS
SET NOCOUNT ON

	DECLARE @ReturnValue		int, @OutPut int, @OutPut2 int
	DECLARE @DataSourceId		int
	DECLARE @DefaultCurrencyId 	int
	DECLARE @Code 				varchar(100)
    DECLARE @Exists				bit
	DECLARE @Message			varchar(1024)
	
	-- DataSourceId, DefaultCurrencyId 
	SET  @Code = @DataSourceCd
	EXEC @ReturnValue= [_ib_DataSource_GetByCodeForOutput] @Code,@OutPut output,@Output2 output
	SET  @DataSourceId = @OutPut
	SET  @DefaultCurrencyId = @OutPut2
	
	SET  @Output = null

	-- FirmId 
	DECLARE @FirmId int 
	SET  @Code = @Firm
	EXEC @ReturnValue= [ib_Firm_AddAsNeeded] @DataSourceId,@Code,@OutPut output
	SET  @FirmId = @OutPut

	SET  @Output = null 

	-- AccountId 
	DECLARE @AccountId int
	SET  @Code = @AccountCode
    EXEC @ReturnValue= [ib_Account_AddAsNeeded] @Code,@FirmId,@OutPut output
    SET  @AccountId = @OutPut

    SET  @Output = null

	-- CurrencyId 
	DECLARE @CurrencyId int
	EXEC @ReturnValue = [ib_Currency_AddAsNeeded] @DataSourceId, @CurrencyCode, @Output output
	SET  @CurrencyId = @Output
	

	IF @CurrencyId is null
		BEGIN
			
			SET  @CurrencyId = @DefaultCurrencyId	
			
		END	

	EXEC dbo.[ib_SwiftStatement_CheckIfExists] @AccountCode, @Firm, @DataSourceId, @StatementNumber, @StatementSequenceNumber, @Exists output 
	
    IF @Exists > 0
	BEGIN
			SET @Message = ''Duplicated Acc:''+@AccountCode+'';StatmNo:''+cast(@StatementNumber as varchar(15))+'';StatmSeq:''+cast(@StatementSequenceNumber as varchar(15))
			EXEC Log_Insert @ReceiveLocationSysId, @FileName, ''Orchestrated'', @Message, ''Success'', '''', @RunId
            
    END
    
	IF @Exists = 0
	BEGIN

		INSERT INTO ib_SwiftStatement
		(
			[AccountId],
			[StatementNumber],
			[StatementSequenceNumber],
			[BalanceDate],
			[CurrencyId],
			[OpenBalance],
			[TotalOfLineItemAmounts],
			[ClosingBalance],
			[Filename],
			[IsLastInSequence],
			[IsMissReplacement]
		)
		VALUES
        (
			@AccountId,
			@StatementNumber,
			@StatementSequenceNumber,
			@BalanceDate,
			@CurrencyId,
			@OpenBalance,
			@TotalOfLineItemAmounts,
			@ClosingBalance,
			@FileName,
			@IsLastInSequence,
			@IsMissReplacement
		)
	END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_DataSource_GetDataSourceById]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_DataSource_GetDataSourceById] ( @DataSourceId INT )
AS 
SET NOCOUNT ON

SELECT
    ds.[DataSourceId]
   ,ds.[Code]
   ,ds.[Name]
   ,ds.[DefaultCurrencyId]
   ,c.Code AS CurrencyCode
   ,c.[Description] AS CurrencyDescription
   ,ds.[ProvidesVariation]
   ,ds.[CreateDate]
   ,ds.[CreateUsername]
   ,ds.[UpdateDate]
   ,ds.[UpdateUsername]
   ,ds.[ProvidesVariation]
   ,ds.[IncludeDetailAccountInTradeReconciliation]
   ,ds.[UseTrxsForTradedOnDay]
FROM
    [dbo].[ib_DataSource] ds
INNER JOIN [dbo].[ib_Currency] c
ON  ds.[DefaultCurrencyId] = c.[CurrencyId]
WHERE
    DataSourceId = @DataSourceId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[DGCX_Position_LoadStateChange]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[DGCX_Position_LoadStateChange] 
	(
		@OldLoadState	TINYINT,
		@NewLoadState	TINYINT
	)
AS

-- Description: Changes the LoadState of the DGCX_Position type table

-- 13 Apr 2012	AAJM	Creation

BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

		UPDATE [dbo].[DGCX_Position] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[Peoplesoft_Add]''
');

GO
EXECUTE ('-- =============================================
-- Author:		Petru Konrad Bercea
-- Create date: 04.02.2009
-- Description:	Insert into Peoplesoft table
--
-- Revision History
--
-- Konrad 08.04.2009 Added SourceFileName field to the Peoplesoft Temp Table.
-- 16 Sep 2009		amk		set transaction isolation level
--
-- =============================================
CREATE PROCEDURE [dbo].[Peoplesoft_Add]
	-- Add the parameters for the stored procedure here
	(
	@FileName					varchar(512) = NULL,
	@OpeningBalance				varchar(50) = NULL,
	@AccountNumber				varchar(35) = NULL,
	@TransactionDate			varchar(12) = NULL,
	@ValueDate					varchar(12) = NULL,
	@Narrative					varchar(34) = NULL,
	@InternalReference			varchar(16) = NULL,
	@ExternalReference			varchar(16) = NULL,
	@Type						varchar(4) = NULL,
	@Department					varchar(50) = NULL,
	@UserField1					varchar(10) = NULL,
	@UserField2					varchar(10) = NULL,
	@UserField3					varchar(10) = NULL,
	@BusinessUnit				varchar(10) = NULL,
	@UserField5					varchar(19) = NULL,
	@UserField6					varchar(10) = NULL,
	@Currency					varchar(3) = NULL,
	@OriginalAmount				varchar(20) = NULL,
	@ReceiptAmount				varchar(20) = NULL,
	@PaymentAmount				varchar(20) = NULL,
	@Quantity					varchar(12) = NULL,
	@Percent					varchar(3) = NULL,
	@UnitPrice					varchar(20) = NULL,
	@UserDateA					varchar(50) = NULL,
	@UserDateB					varchar(50) = NULL,
	@UserId						varchar(50) = NULL,
	@UserField8					varchar(50) = NULL,
	@FlagA						varchar(1) = NULL,
	@FlagB						varchar(1) = NULL,
	@FlagC						varchar(1) = NULL,
	@FlagD						varchar(1) = NULL,
	@FlagE						varchar(1) = NULL,
	@FlagF						varchar(1) = NULL,
	@FlagG						varchar(1) = NULL,
	@FlagH						varchar(1) = NULL,
	@IsStatement				varchar(1) = NULL,
	@IsHolding					varchar(1) = NULL,
	@wf_Ref						varchar(20) = NULL,
	@Period						varchar(25) = NULL,
	@UserField9					varchar(25) = NULL,
	@UserField10				varchar(25) = NULL,
	@FiscalYear					varchar(4) = NULL,
	@AccountingPeriodOfFiscalYear varchar(2) = NULL,
	@UserField13				varchar(25) = NULL,
	@UserField14				varchar(25) = NULL,
	@UserField15				varchar(25) = NULL,
	@UserField16				varchar(25) = NULL,
	@UserDateC					varchar(12) = NULL,
	@UserDateD					varchar(12) = NULL,
	@UserDecimalB				varchar(25) = NULL,
	@UserDecimalC				varchar(25) = NULL,
	@UserDecimalD				varchar(25) = NULL,
	@ClosingBalance				varchar(25) = NULL
    )
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	BEGIN TRANSACTION 

	-- BizTalk''s SQL Adapter uses more restrictive read serializable
	-- so this is necessary to relax it to something that is default
	-- and perfectly acceptable!
	SET TRANSACTION ISOLATION LEVEL READ COMMITTED

  INSERT INTO [dbo].[Peoplesoft]
			( 
			[OpeningBalance]
			,[AccountNumber]
			,[TransactionDate]
			,[ValueDate]
			,[Narrative]
			,[InternalReference]
			,[ExternalReference]
			,[Type]
			,[Department]
			,[UserField1]
			,[UserField2]
			,[UserField3]
			,[BusinessUnit]
			,[UserField5]
			,[UserField6]
			,[Currency]
			,[OriginalAmount]
			,[ReceiptAmount]
			,[PaymentAmount]
			,[Quantity]
			,[Percent]
			,[UnitPrice]
			,[UserDateA]
			,[UserDateB]
			,[UserId]
			,[UserField8]
			,[FlagA]
			,[FlagB]
			,[FlagC]
			,[FlagD]
			,[FlagE]
			,[FlagF]
			,[FlagG]
			,[FlagH]
			,[IsStatement]
			,[IsHolding]
			,[wf_Ref]
			,[Period]
			,[UserField9]
			,[UserField10]
			,[FiscalYear]
			,[AccountingPeriodOfFiscalYear]
			,[UserField13]
			,[UserField14]
			,[UserField15]
			,[UserField16]
			,[UserDateC]
			,[UserDateD]
			,[UserDecimalB]
			,[UserDecimalC]
			,[UserDecimalD]
			,[ClosingBalance]
			,[FileName]
			)
    VALUES
			( 
			@OpeningBalance,
			@AccountNumber,
			@TransactionDate,
			@ValueDate,
			@Narrative,
			@InternalReference,
			@ExternalReference,
			@Type,
			@Department,
			@UserField1,
			@UserField2,
			@UserField3,
			@BusinessUnit,
			@UserField5,
			@UserField6,
			@Currency,
			@OriginalAmount,
			@ReceiptAmount,
			@PaymentAmount,
			@Quantity,
			@Percent,
			@UnitPrice,
			@UserDateA,
			@UserDateB,
			@UserId,
			@UserField8,
			@FlagA,
			@FlagB,
			@FlagC,
			@FlagD,
			@FlagE,
			@FlagF,
			@FlagG,
			@FlagH,
			@IsStatement,
			@IsHolding,
			@wf_Ref,
			@Period,
			@UserField9,
			@UserField10,
			@FiscalYear,
			@AccountingPeriodOfFiscalYear,
			@UserField13,
			@UserField14,
			@UserField15,
			@UserField16,
			@UserDateC,
			@UserDateD,
			@UserDecimalB,
			@UserDecimalC,
			@UserDecimalD,
			@ClosingBalance,
			@FileName
			)

	COMMIT TRANSACTION
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_InstumentType_GetInstumentTypeCodes]''
');

GO
EXECUTE ('/*
<details>
 <summary> Returns the InstumentTypeCodes hint for a specific code /summary>
 <created author="Laurentiu Macovei" Date="Thursday, 16 August 2006 23:02 GMT" /> 
 <tasks>
 </tasks>
</details>
*/
CREATE PROCEDURE [dbo].[ib_InstumentType_GetInstumentTypeCodes]
AS
SET NOCOUNT ON

	SELECT [Code], [InstrumentTypeId]
		FROM [dbo].[ib_InstrumentType]
		ORDER BY [Code]
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TradeReconciliationSummary_InsertGroupTradeAdjustments]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_TradeReconciliationSummary_InsertGroupTradeAdjustments]
(
	@TradeReconciliationSummaryId INT
	,@IsAddTrade BIT
	,@CreateUsername VARCHAR(50)
	,@ErrorMessage VARCHAR(MAX) OUTPUT
)
AS
SET NOCOUNT ON
/*
--	Insert group trade rec adjustment
--	Created 18 May 2010 ED

*/
BEGIN TRY
BEGIN TRAN TranEXT

DECLARE @ExchangeId INT
DECLARE @MatchCode VARCHAR(100)
DECLARE @CurrencyId INT
DECLARE @TradeReconciliationId INT
DECLARE @RepTradRecSummaryId INT
--get all needed data
SELECT @ExchangeId = ExchangeId, @MatchCode = MatchCode, @CurrencyId=CurrencyId, @TradeReconciliationId = TradeReconciliationId
	FROM ib_TradeReconciliationSummary 
	WHERE TradeReconciliationSummaryId = @TradeReconciliationSummaryId

	DECLARE group_cursor CURSOR FOR
	SELECT TradeReconciliationSummaryId FROM ib_TradeReconciliationSummary
		WHERE 
			ExchangeId = @ExchangeId 
			AND MatchCode = @MatchCode 
			AND CurrencyId=@CurrencyId 
			AND TradeReconciliationId = @TradeReconciliationId
			AND (DifferenceLong != 0 OR DifferenceShort != 0)
	
	OPEN group_cursor
	
	FETCH NEXT FROM group_cursor
	INTO @RepTradRecSummaryId
		
	-- Check @@FETCH_STATUS to see IF there are any more rows to fetch.
	WHILE @@FETCH_STATUS = 0
	BEGIN
		 
		EXEC [dbo].[ib_TradeReconciliationSummary_InsertTradeAdjustments] @RepTradRecSummaryId, @IsAddTrade, @CreateUsername, @ErrorMessage OUTPUT
		IF LEN(@ErrorMessage) > 0
		BEGIN
			IF(@@TRANCOUNT = 1) ROLLBACK TRAN
				ELSE IF(@@TRANCOUNT > 1) COMMIT TRAN TranEXT
			RETURN -1
		END
	FETCH NEXT FROM group_cursor
	INTO @RepTradRecSummaryId
	END
						
	CLOSE group_cursor
	DEALLOCATE group_cursor


COMMIT TRAN TranEXT
END TRY
BEGIN CATCH
ROLLBACK TRAN TranEXT
EXEC [dbo].[sp_RethrowError]
END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_DataSource_GetDataSourcesForFuturesAndOptions]''
');

GO
EXECUTE ('--KevinP	23 Feb 2010		Added.
CREATE PROCEDURE [dbo].[ib_DataSource_GetDataSourcesForFuturesAndOptions]
AS
SET NOCOUNT ON
BEGIN

SELECT * FROM ib_Datasource
WHERE [Code] NOT IN (''SWIFT'',''Peoplesoft'',''i-Star'',''HKFE'',''IDEM'',''SFE'',''NZFOE'',''Eurfut'',''USAfut'',''Ausfut'',''Asafut'')
ORDER BY [Name]
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_ImportSettings_Get]''
');

GO
EXECUTE ('


-- =============================================
-- Author:		Lee Manifold
-- Create date: 10 Jan 2007
-- Description:	Gets column values from table ImportSettings.
--				
-- =============================================
CREATE PROCEDURE [dbo].[ib_ImportSettings_Get]
	(
	@FileType			varchar(100),
	@DataSourceId		int,
	@StartFromDate		datetime	output,
	@StartFromDaysBack	int			output,
	@ImportSettingsId	int			output,
	@LastUpdateImported datetime	output
	)
AS
SET NOCOUNT ON

	BEGIN TRY
		SELECT	@ImportSettingsId	= [ImportSettingsId],
				@StartFromDate		= [StartFromDate],
				@StartFromDaysBack	= [StartFromDaysBack],
				@LastUpdateImported = [LastUpdateImported]

		FROM	[dbo].[ib_ImportSettings]
		WHERE	[FileType]		= @FileType
		AND		[DataSourceId]	= @DataSourceId

	END TRY
	BEGIN CATCH
		EXEC [dbo].[sp_RethrowError]
	END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[DGCX_Position_Purge]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[DGCX_Position_Purge] 
	(
		@LoadState		TINYINT = 0,
		@FileName       VARCHAR (512)= NULL
	)
AS
-- Description: Deletes from DGCX_Position table all the records where the LoadState is 0

-- 13 Apr 2012	AAJM	Creation

-- History:

BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
		DELETE FROM [dbo].[DGCX_Position] WHERE LoadState= @LoadState AND [FileName] = Coalesce(@FileName, [FileName])

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[Peoplesoft_LoadStateChange]''
');

GO
EXECUTE ('-- =============================================
-- Author:		Petru Konrad Bercea
-- Create date: 04.02.2009
-- Description:	Changes the LoadState of the Peoplesoft type tables
-- 16 Sep 2009	amk		Set transaction isolation level
-- =============================================
CREATE PROCEDURE [dbo].[Peoplesoft_LoadStateChange] 
	-- Add the parameters for the stored procedure here
	(
		@OldLoadState	TINYINT,
		@NewLoadState	TINYINT,
		@RecordDate		DATETIME = NULL
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	BEGIN TRANSACTION 

	-- BizTalk''s SQL Adapter uses more restrictive read serializable
	-- so this is necessary to relax it to something that is default
	-- and perfectly acceptable!
	SET TRANSACTION ISOLATION LEVEL READ COMMITTED

	UPDATE [dbo].[Peoplesoft] 
	SET LoadState = @NewLoadState   
	WHERE LoadState= @OldLoadState

	COMMIT TRANSACTION

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[SWIFT_MT950]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[SWIFT_MT950]
(
[SWIFT_MT950ID] [int] NOT NULL IDENTITY(1, 1),
[AppId] [varchar] (1) NULL,
[ServiceId] [tinyint] NULL,
[LTAdrs] [varchar] (12) NULL,
[SessionNo] [varchar] (4) NULL,
[SequenceNo] [varchar] (6) NULL,
[AppHBlckInpMsgType] [varchar] (3) NULL,
[AppHBlckInpDestAdrs] [varchar] (12) NULL,
[AppHBlckInpMsgPriority] [varchar] (1) NULL,
[AppHBlckInpDelivMonitoring] [varchar] (1) NULL,
[AppHBlckInpObslscPeriod] [varchar] (3) NULL,
[AppHBlckOutpMsgType] [varchar] (3) NULL,
[AppHBlckOutInpTime] [varchar] (4) NULL,
[AppHBlckOutMsgRefInpDate] [varchar] (6) NULL,
[AppHBlckOutMsgRefLTAdrs] [varchar] (12) NULL,
[AppHBlckOutMsgRefSessionNo] [varchar] (4) NULL,
[AppHBlckOutMsgRefSeqNo] [varchar] (6) NULL,
[AppHBlckOutMsgRefOutpDate] [varchar] (6) NULL,
[AppHBlckOutMsgRefOutpTime] [varchar] (4) NULL,
[AppHBlckOutMsgRefMsgPriority] [varchar] (1) NULL,
[FINServiceId_103] [varchar] (3) NULL,
[BankingPriority_113] [varchar] (4) NULL,
[MsgUserRef_108] [varchar] (16) NULL,
[ValidationFlag_119] [varchar] (8) NULL,
[AddresseeInfo_115] [varchar] (32) NULL,
[Swift_HTextBlock] [varchar] (max) NULL,
[TrxRefNo_20] [varchar] (16) NULL,
[AccountId_25] [varchar] (35) NULL,
[StatmtNo_28C] [varchar] (5) NULL,
[StatmtNoSeqNo_28C] [varchar] (5) NULL,
[OpenBalance_60F_DCMark] [char] (1) NULL,
[OpenBalance_60F_Date] [varchar] (6) NULL,
[OpenBalance_60F_CurrencyCode] [varchar] (3) NULL,
[OpenBalance_60F_Amount] [varchar] (15) NULL,
[OpenBalance_60M_DCMark] [char] (1) NULL,
[OpenBalance_60M_Date] [varchar] (6) NULL,
[OpenBalance_60M_CurrencyCode] [varchar] (3) NULL,
[OpenBalance_60M_Amount] [varchar] (15) NULL,
[StatmtLine_61] [varchar] (66) NULL,
[StatmtLine_61_SupplemDetails] [varchar] (34) NULL,
[ClosingBalance_62F_DCMark] [char] (1) NULL,
[ClosingBalance_62F_Date] [varchar] (6) NULL,
[ClosingBalance_62F_CurrencyCode] [varchar] (3) NULL,
[ClosingBalance_62F_Amount] [varchar] (15) NULL,
[ClosingBalance_62M_DCMark] [char] (1) NULL,
[ClosingBalance_62M_Date] [varchar] (6) NULL,
[ClosingBalance_62M_CurrencyCode] [varchar] (3) NULL,
[ClosingBalance_62M_Amount] [varchar] (15) NULL,
[ClosingAvailBalance_64_DCMark] [char] (1) NULL,
[ClosingAvailBalance_64_Date] [varchar] (6) NULL,
[ClosingAvailBalance_64_CurrencyCode] [varchar] (3) NULL,
[ClosingAvailBalance_64_Amount] [varchar] (15) NULL,
[EndTextBlock] [varchar] (max) NULL,
[MAC] [varchar] (8) NULL,
[PAC] [varchar] (8) NULL,
[CHK] [varchar] (12) NULL,
[SYS] [varchar] (max) NULL,
[TNG] [varchar] (max) NULL,
[PDE] [varchar] (max) NULL,
[DLM] [varchar] (max) NULL,
[PDM] [varchar] (max) NULL,
[MRF] [varchar] (max) NULL,
[RTV] [varchar] (max) NULL,
[AllianceTrailerData] [varchar] (max) NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_SWIFT_MT950_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_SWIFT_MT950_CreateDate] DEFAULT (getdate()),
[FileName] [varchar] (512) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_SWIFT_MT950] on [dbo].[SWIFT_MT950]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[SWIFT_MT950] ADD CONSTRAINT [PK_SWIFT_MT950] PRIMARY KEY CLUSTERED  ([SWIFT_MT950ID])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[SWIFT_MT940]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[SWIFT_MT940]
(
[SWIFT_MT940ID] [int] NOT NULL IDENTITY(1, 1),
[AppId] [varchar] (1) NULL,
[ServiceId] [tinyint] NULL,
[LTAdrs] [varchar] (12) NULL,
[SessionNo] [varchar] (4) NULL,
[SequenceNo] [varchar] (6) NULL,
[AppHBlckInpMsgType] [varchar] (3) NULL,
[AppHBlckInpDestAdrs] [varchar] (12) NULL,
[AppHBlckInpMsgPriority] [varchar] (1) NULL,
[AppHBlckInpDelivMonitoring] [varchar] (1) NULL,
[AppHBlckInpObslscPeriod] [varchar] (3) NULL,
[AppHBlckOutpMsgType] [varchar] (3) NULL,
[AppHBlckOutInpTime] [varchar] (4) NULL,
[AppHBlckOutMsgRefInpDate] [varchar] (6) NULL,
[AppHBlckOutMsgRefLTAdrs] [varchar] (12) NULL,
[AppHBlckOutMsgRefSessionNo] [varchar] (4) NULL,
[AppHBlckOutMsgRefSeqNo] [varchar] (6) NULL,
[AppHBlckOutMsgRefOutpDate] [varchar] (6) NULL,
[AppHBlckOutMsgRefOutpTime] [varchar] (4) NULL,
[AppHBlckOutMsgRefMsgPriority] [varchar] (1) NULL,
[FINServiceId_103] [varchar] (3) NULL,
[BankingPriority_113] [varchar] (4) NULL,
[MsgUserRef_108] [varchar] (16) NULL,
[ValidationFlag_119] [varchar] (8) NULL,
[AddresseeInfo_115] [varchar] (32) NULL,
[Swift_HTextBlock] [varchar] (max) NULL,
[TrxRefNo_20] [varchar] (16) NULL,
[RelatedRef_21] [varchar] (16) NULL,
[AccountId_25] [varchar] (35) NULL,
[StatmtNo_28C] [varchar] (5) NULL,
[StatmtNoSeqNo_28C] [varchar] (5) NULL,
[OpenBalance_60F_DCMark] [char] (1) NULL,
[OpenBalance_60F_Date] [varchar] (6) NULL,
[OpenBalance_60F_CurrencyCode] [varchar] (3) NULL,
[OpenBalance_60F_Amount] [varchar] (15) NULL,
[OpenBalance_60M_DCMark] [char] (1) NULL,
[OpenBalance_60M_Date] [varchar] (6) NULL,
[OpenBalance_60M_CurrencyCode] [varchar] (3) NULL,
[OpenBalance_60M_Amount] [varchar] (15) NULL,
[StatmtLine_61] [varchar] (66) NULL,
[StatmtLine_61_SupplemDetails] [varchar] (34) NULL,
[InfoToAccOwn_1_86_line1] [varchar] (65) NULL,
[InfoToAccOwn_1_86_line2] [varchar] (65) NULL,
[InfoToAccOwn_1_86_line3] [varchar] (65) NULL,
[InfoToAccOwn_1_86_line4] [varchar] (65) NULL,
[InfoToAccOwn_1_86_line5] [varchar] (65) NULL,
[InfoToAccOwn_1_86_line6] [varchar] (65) NULL,
[ClosingBalance_62F_DCMark] [char] (1) NULL,
[ClosingBalance_62F_Date] [varchar] (6) NULL,
[ClosingBalance_62F_CurrencyCode] [varchar] (3) NULL,
[ClosingBalance_62F_Amount] [varchar] (15) NULL,
[ClosingBalance_62M_DCMark] [char] (1) NULL,
[ClosingBalance_62M_Date] [varchar] (6) NULL,
[ClosingBalance_62M_CurrencyCode] [varchar] (3) NULL,
[ClosingBalance_62M_Amount] [varchar] (15) NULL,
[ClosingAvailBalance_64_DCMark] [char] (1) NULL,
[ClosingAvailBalance_64_Date] [varchar] (6) NULL,
[ClosingAvailBalance_64_CurrencyCode] [varchar] (3) NULL,
[ClosingAvailBalance_64_Amount] [varchar] (15) NULL,
[ForwardAvailBalance_65_DCMark] [char] (1) NULL,
[ForwardAvailBalance_65_Date] [varchar] (6) NULL,
[ForwardAvailBalance_65_CurrencyCode] [varchar] (3) NULL,
[ForwardAvailBalance_65_Amount] [varchar] (15) NULL,
[InfoToAccOwn_2_86_line1] [varchar] (65) NULL,
[InfoToAccOwn_2_86_line2] [varchar] (65) NULL,
[InfoToAccOwn_2_86_line3] [varchar] (65) NULL,
[InfoToAccOwn_2_86_line4] [varchar] (65) NULL,
[InfoToAccOwn_2_86_line5] [varchar] (65) NULL,
[InfoToAccOwn_2_86_line6] [varchar] (65) NULL,
[EndTextBlock] [varchar] (max) NULL,
[MAC] [varchar] (8) NULL,
[PAC] [varchar] (8) NULL,
[CHK] [varchar] (12) NULL,
[SYS] [varchar] (max) NULL,
[TNG] [varchar] (max) NULL,
[PDE] [varchar] (max) NULL,
[DLM] [varchar] (max) NULL,
[PDM] [varchar] (max) NULL,
[MRF] [varchar] (max) NULL,
[RTV] [varchar] (max) NULL,
[AllianceTrailerData] [varchar] (max) NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_SWIFT_MT940_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_SWIFT_MT940_CreateDate] DEFAULT (getdate()),
[FileName] [varchar] (512) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_SWIFT_MT940] on [dbo].[SWIFT_MT940]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[SWIFT_MT940] ADD CONSTRAINT [PK_SWIFT_MT940] PRIMARY KEY CLUSTERED  ([SWIFT_MT940ID])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_SwiftStatement_UpdateIfExists]''
');

GO
EXECUTE ('
-- =============================================
-- Author:		Alister McLeod
-- Create date: 28 Oct 2009
-- Description:	Update an existing Swift Statement record
--
-- Revision History
--
-- 19 May 2010	amk		Stamp updatedate
-- =============================================
CREATE PROCEDURE [dbo].[ib_SwiftStatement_UpdateIfExists] 

	(
		@AccountCode varchar(35),
		@StatementNumber int,
		@StatementSequenceNumber int,
		@BalanceDate datetime,
		@CurrencyCode	varchar(3),
		@OpenBalance money,
		@TotalOfLineItemAmounts money,
		@ClosingBalance money,
		@FileName varchar(512),
		@DataSourceCd varchar(100),
		@Firm	varchar(25) = NULL,
		@IsLastInSequence BIT = NULL,
		@IsMissReplacement BIT = NULL
	)
AS
SET NOCOUNT ON

BEGIN
	DECLARE @ReturnValue		int, @OutPut int, @OutPut2 int
	DECLARE @DataSourceId		int
	DECLARE @DefaultCurrencyId 	int
	DECLARE @Code 				varchar(100)
    DECLARE @Exists				bit
	DECLARE @Message			varchar(1024)
	
	-- DataSourceId, DefaultCurrencyId 
	SET  @Code = @DataSourceCd
	EXEC @ReturnValue= [_ib_DataSource_GetByCodeForOutput] @Code,@OutPut output,@Output2 output
	SET  @DataSourceId = @OutPut
	SET  @DefaultCurrencyId = @OutPut2
	
	SET  @Output = null

	-- FirmId 
	DECLARE @FirmId int 
	SET  @Code = @Firm
	EXEC @ReturnValue= [ib_Firm_AddAsNeeded] @DataSourceId,@Code,@OutPut output
	SET  @FirmId = @OutPut

	SET  @Output = null 

	-- AccountId 
	DECLARE @AccountId int
	SET  @Code = @AccountCode
    EXEC @ReturnValue= [ib_Account_AddAsNeeded] @Code,@FirmId,@OutPut output
    SET  @AccountId = @OutPut

    SET  @Output = null

	-- CurrencyId 
	DECLARE @CurrencyId int
	EXEC @ReturnValue = [ib_Currency_AddAsNeeded] @DataSourceId, @CurrencyCode, @Output output
	SET  @CurrencyId = @Output
	
	IF @CurrencyId is null
		SET  @CurrencyId = @DefaultCurrencyId	

	EXEC dbo.[ib_SwiftStatement_CheckIfExists] @AccountCode, @Firm, @DataSourceId, @StatementNumber, @StatementSequenceNumber, @Exists output 
	
	IF @Exists = 1
	BEGIN

		UPDATE ib_SwiftStatement
		SET [BalanceDate] = @BalanceDate,
			[CurrencyId] = @CurrencyId,
			[OpenBalance] = @OpenBalance,
			[Filename]= @Filename, -- Note, we want to update the filename
			[TotalOfLineItemAmounts] = @TotalOfLineItemAmounts,
			[ClosingBalance] = @ClosingBalance,
			[IsLastInSequence] = @IsLastInSequence,
			[IsMissReplacement] = @IsMissReplacement
			, UpdateDate = GETDATE()
			, UpdateUsername = SUSER_SNAME()
		WHERE  [AccountId] = @AccountId 
			AND [StatementNumber] = @StatementNumber 
			AND [StatementSequenceNumber] = @StatementSequenceNumber
		
		-- Note, this doesn''t update the GapNostroId
	END
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_SwiftStatement_CheckIfExistsExcludeMisses]''
');

GO
EXECUTE ('
CREATE PROCEDURE [dbo].[ib_SwiftStatement_CheckIfExistsExcludeMisses] 
	(
		@AccountCode VARCHAR(35),
		@Firm VARCHAR(25),
		@DataSourceId INT,	
		@StatementNumber INT,
		@StatementSequenceNumber INT,
		@Exists BIT = 0 OUTPUT
	)
AS
SET NOCOUNT ON

-- Description: Check if a SwiftStatement record exists but don''t include ''MISS'' 
--				records

-- 24 Aug 2009	AAJM	Creation (based on ib_SwiftStatement_CheckIfExists)
-- 10 May 2010	amk		MBAL-15484 earlier statements should be ignored too
-- 19 May 2010	amk		MBAL-15484 Fix bug I introduced (allow MISS to be handled correctly)
-- 20 May 2010	amk		MBAL-15484 Undo this bug fix since there isn''t a MISS logged for every point in GAP 
--						Marc agreed to scrap the bug fix and let the ''seed'' enhancement handle the need

BEGIN

	DECLARE @Code VARCHAR(100)
	DECLARE @ReturnValue INT
	DECLARE @OutPut INT

	DECLARE @FirmId INT 
	SET @Code = @Firm
	EXEC @ReturnValue= [ib_Firm_AddAsNeeded] @DataSourceId, @Code, @OutPut OUTPUT
	SET @FirmId = @OutPut

	SET @Output = NULL

	-- AccountId 
	DECLARE @AccountId INT
	SET @Code = @AccountCode
    EXEC @ReturnValue= [ib_Account_AddAsNeeded] @Code, @FirmId, @OutPut OUTPUT
    SET @AccountId = @OutPut

	SET @Exists = 0

	IF EXISTS (
			SELECT *
			FROM ib_SwiftStatement swst
			WHERE swst.[AccountId] = @AccountId 
				AND swst.[FileName] <> ''MISS''	
				AND swst.[StatementNumber] = @StatementNumber 
				AND swst.[StatementSequenceNumber] = @StatementSequenceNumber
		)
		SET @Exists = 1

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[SWIFT_EmptyStatement_Add]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[SWIFT_EmptyStatement_Add]
	(
	@FileName								VARCHAR(512) = NULL,
	@AppId									VARCHAR(1) = NULL ,
	@ServiceId								TINYINT = NULL ,
	@LTAdrs									VARCHAR(12) = NULL ,
    @SessionNo								VARCHAR(4) = NULL ,
	@SequenceNo								VARCHAR(6) = NULL ,
	@AppHBlckInpMsgType						VARCHAR(3) = NULL ,
	@AppHBlckInpDestAdrs					VARCHAR(12) = NULL ,
	@AppHBlckInpMsgPriority					VARCHAR(1) = NULL ,
	@AppHBlckInpDelivMonitoring				VARCHAR(1) = NULL ,
	@AppHBlckInpObslscPeriod				VARCHAR(3) = NULL ,
	@AppHBlckOutpMsgType					VARCHAR(3) = NULL ,
	@AppHBlckOutInpTime						VARCHAR(4) = NULL ,
	@AppHBlckOutMsgRefInpDate				VARCHAR(6) = NULL ,
	@AppHBlckOutMsgRefLTAdrs				VARCHAR(12) = NULL ,
	@AppHBlckOutMsgRefSessionNo				VARCHAR(4) = NULL ,
	@AppHBlckOutMsgRefSeqNo					VARCHAR(6) = NULL ,
	@AppHBlckOutMsgRefOutpDate				VARCHAR(6) = NULL ,
	@AppHBlckOutMsgRefOutpTime				VARCHAR(4) = NULL ,
	@AppHBlckOutMsgRefMsgPriority			VARCHAR(1) = NULL ,
	@FINServiceId_103						VARCHAR(3) = NULL ,
	@BankingPriority_113					VARCHAR(4) = NULL ,
	@MsgUserRef_108							VARCHAR(16) = NULL ,
	@ValidationFlag_119						VARCHAR(8) = NULL ,
	@AddresseeInfo_115						VARCHAR(32) = NULL ,
	@Swift_HTextBlock						VARCHAR(MAX) = NULL ,
	@TrxRefNo_20							VARCHAR(16) = NULL ,
	@RelatedRef_21							VARCHAR(16) = NULL ,
	@AccountId_25							VARCHAR(35) = NULL ,
	@StatmtNo_28C							VARCHAR(5) = NULL ,
	@StatmtNoSeqNo_28C						VARCHAR(5) = NULL ,
	@OpenBalance_60F_DCMark					CHAR(1) = NULL ,
	@OpenBalance_60F_Date					VARCHAR(6) = NULL ,
	@OpenBalance_60F_CurrencyCode			VARCHAR(3) = NULL ,
	@OpenBalance_60F_Amount					VARCHAR(15) = NULL ,
	@OpenBalance_60M_DCMark					CHAR(1) = NULL ,
	@OpenBalance_60M_Date					VARCHAR(6) = NULL ,
	@OpenBalance_60M_CurrencyCode			VARCHAR(3) = NULL ,
	@OpenBalance_60M_Amount					VARCHAR(15) = NULL ,
	@InfoToAccOwn_1_86_line1				VARCHAR(65) = NULL ,
	@InfoToAccOwn_1_86_line2				VARCHAR(65) = NULL ,
	@InfoToAccOwn_1_86_line3				VARCHAR(65) = NULL ,
	@InfoToAccOwn_1_86_line4				VARCHAR(65) = NULL ,
	@InfoToAccOwn_1_86_line5				VARCHAR(65) = NULL ,
    @InfoToAccOwn_1_86_line6				VARCHAR(65) = NULL ,
    @ClosingBalance_62F_DCMark				CHAR(1) = NULL ,
	@ClosingBalance_62F_Date				VARCHAR(6) = NULL ,
	@ClosingBalance_62F_CurrencyCode		VARCHAR(3) = NULL ,
	@ClosingBalance_62F_Amount				VARCHAR(15) = NULL ,
	@ClosingBalance_62M_DCMark				CHAR(1) = NULL ,
	@ClosingBalance_62M_Date				VARCHAR(6) = NULL ,
	@ClosingBalance_62M_CurrencyCode		VARCHAR(3) = NULL ,
	@ClosingBalance_62M_Amount				VARCHAR(15) = NULL ,
    @ClosingAvailBalance_64_DCMark			CHAR(1) = NULL ,
	@ClosingAvailBalance_64_Date			VARCHAR(6) = NULL ,
	@ClosingAvailBalance_64_CurrencyCode	VARCHAR(3) = NULL ,
	@ClosingAvailBalance_64_Amount			VARCHAR(15) = NULL , 
	@ForwardAvailBalance_65_DCMark			CHAR(1) = NULL ,
	@ForwardAvailBalance_65_Date			VARCHAR(6) = NULL ,
	@ForwardAvailBalance_65_CurrencyCode	VARCHAR(3) = NULL ,
	@ForwardAvailBalance_65_Amount			VARCHAR(15) = NULL , 
    @InfoToAccOwn_2_86_line1				VARCHAR(65) = NULL ,
	@InfoToAccOwn_2_86_line2				VARCHAR(65) = NULL ,
	@InfoToAccOwn_2_86_line3				VARCHAR(65) = NULL ,
	@InfoToAccOwn_2_86_line4				VARCHAR(65) = NULL ,
	@InfoToAccOwn_2_86_line5				VARCHAR(65) = NULL ,
    @InfoToAccOwn_2_86_line6				VARCHAR(65) = NULL ,
    @EndTextBlock							VARCHAR(MAX) = NULL ,
    @MAC									VARCHAR(8) = NULL ,
	@PAC									VARCHAR(8) = NULL ,
	@CHK									VARCHAR(12) = NULL ,
	@SYS									VARCHAR(MAX) = NULL ,
	@TNG									VARCHAR(MAX) = NULL ,
    @PDE									VARCHAR(MAX) = NULL ,
	@DLM									VARCHAR(MAX) = NULL ,
	@PDM									VARCHAR(MAX) = NULL ,
	@MRF									VARCHAR(MAX) = NULL ,
	@RTV									VARCHAR(MAX) = NULL ,
    @AllianceTrailerData					VARCHAR(MAX) = NULL 
	,@ReceiveLocationSysId INT
	,@RunId INT 
    )
AS
-- =============================================
-- Author:		Petru Konrad Bercea
-- Create date: 20.04.2009
-- Description:	Insert into ib_SwiftStatement table
--
-- Revision History
--
-- 15 July 2009 Konrad Added the empty statement records to the Swift_MT950 and Swift_MT940 temp tables.
--
-- 09 Sep 2009	AAJM	Calculate IsLastInSequence to add to ib_SwiftStatement to support
--						MISS gap record logic
-- 14 Sep 2009	AAJM	MBAL-13024 Add in logic for deleting a related MISS before trying
--						to add to ib_SwiftStatement
-- 15 Sep 2009	amk	    Set transaction isolation level
-- 29 Oct 2009	AAJM	Updated section to not delete MISSES but rather update or add
-- 17 May 2010	amk		MBAL-15484 Don''t load statements with EARLIER statement no/seq no
-- 17 May 2101  evd     MBAL-15488 Use Statement Seed
-- 09 Jan 2014  ED      EIB 25004 - remove importLog table and use Log table
-- =============================================
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	BEGIN TRANSACTION

	-- BizTalk''s SQL Adapter uses more restrictive read serializable
	-- so this is necessary to relax it to something that is default
	-- and perfectly acceptable!
	SET TRANSACTION ISOLATION LEVEL READ COMMITTED

	IF @AppHBlckOutpMsgType = ''940''
    BEGIN
			INSERT INTO [dbo].[SWIFT_MT940]
			( 
			[AppId]
			,[ServiceId]
			,[LTAdrs]
			,[SessionNo]
			,[SequenceNo]
			,[AppHBlckInpMsgType]
			,[AppHBlckInpDestAdrs]
			,[AppHBlckInpMsgPriority]
			,[AppHBlckInpDelivMonitoring]
			,[AppHBlckInpObslscPeriod]
			,[AppHBlckOutpMsgType]
			,[AppHBlckOutInpTime]
			,[AppHBlckOutMsgRefInpDate]
			,[AppHBlckOutMsgRefLTAdrs]
			,[AppHBlckOutMsgRefSessionNo]
			,[AppHBlckOutMsgRefSeqNo]
			,[AppHBlckOutMsgRefOutpDate]
			,[AppHBlckOutMsgRefOutpTime]
			,[AppHBlckOutMsgRefMsgPriority]
			,[FINServiceId_103]
			,[BankingPriority_113]
			,[MsgUserRef_108]
			,[ValidationFlag_119]
			,[AddresseeInfo_115]
			,[Swift_HTextBlock]
			,[TrxRefNo_20]
			,[RelatedRef_21]
			,[AccountId_25]
			,[StatmtNo_28C]
			,[StatmtNoSeqNo_28C]
			,[OpenBalance_60F_DCMark]
			,[OpenBalance_60F_Date]
			,[OpenBalance_60F_CurrencyCode]
			,[OpenBalance_60F_Amount]
			,[OpenBalance_60M_DCMark]
			,[OpenBalance_60M_Date]
			,[OpenBalance_60M_CurrencyCode]
			,[OpenBalance_60M_Amount]
			,[InfoToAccOwn_1_86_line1]
			,[InfoToAccOwn_1_86_line2]
			,[InfoToAccOwn_1_86_line3]
			,[InfoToAccOwn_1_86_line4]
			,[InfoToAccOwn_1_86_line5]
			,[InfoToAccOwn_1_86_line6]
			,[ClosingBalance_62F_DCMark]
			,[ClosingBalance_62F_Date]
			,[ClosingBalance_62F_CurrencyCode]
			,[ClosingBalance_62F_Amount]
			,[ClosingBalance_62M_DCMark]
			,[ClosingBalance_62M_Date]
			,[ClosingBalance_62M_CurrencyCode]
			,[ClosingBalance_62M_Amount]
			,[ClosingAvailBalance_64_DCMark]
			,[ClosingAvailBalance_64_Date]
			,[ClosingAvailBalance_64_CurrencyCode]
			,[ClosingAvailBalance_64_Amount] 
			,[ForwardAvailBalance_65_DCMark]
			,[ForwardAvailBalance_65_Date]
			,[ForwardAvailBalance_65_CurrencyCode]
			,[ForwardAvailBalance_65_Amount]
			,[InfoToAccOwn_2_86_line1]
			,[InfoToAccOwn_2_86_line2]
			,[InfoToAccOwn_2_86_line3]
			,[InfoToAccOwn_2_86_line4]
			,[InfoToAccOwn_2_86_line5]
			,[InfoToAccOwn_2_86_line6]
			,[EndTextBlock] 
			,[MAC]
			,[PAC]
			,[CHK]
			,[SYS]
			,[TNG]
			,[PDE]
			,[DLM]
			,[PDM]
			,[MRF]
			,[RTV]
			,[AllianceTrailerData]
			,[FileName]
			,[LoadState]
			)
			VALUES
			( 
			@AppId,
			@ServiceId,
			@LTAdrs,
			@SessionNo,
			@SequenceNo,
			@AppHBlckInpMsgType,
			@AppHBlckInpDestAdrs,
			@AppHBlckInpMsgPriority,
			@AppHBlckInpDelivMonitoring,
			@AppHBlckInpObslscPeriod,
			@AppHBlckOutpMsgType,
			@AppHBlckOutInpTime,
			@AppHBlckOutMsgRefInpDate,
			@AppHBlckOutMsgRefLTAdrs,
			@AppHBlckOutMsgRefSessionNo,
			@AppHBlckOutMsgRefSeqNo,
			@AppHBlckOutMsgRefOutpDate,
			@AppHBlckOutMsgRefOutpTime,
			@AppHBlckOutMsgRefMsgPriority,
			@FINServiceId_103,
			@BankingPriority_113,
			@MsgUserRef_108,
			@ValidationFlag_119,
			@AddresseeInfo_115,
			@Swift_HTextBlock,
			@TrxRefNo_20,
			@RelatedRef_21,
			@AccountId_25,
			[dbo].[GetFixedSwiftStatementNumber](@AccountId_25, @StatmtNo_28C),
			@StatmtNoSeqNo_28C,
			@OpenBalance_60F_DCMark,
			@OpenBalance_60F_Date,
			@OpenBalance_60F_CurrencyCode,
			@OpenBalance_60F_Amount,
			@OpenBalance_60M_DCMark,
			@OpenBalance_60M_Date,
			@OpenBalance_60M_CurrencyCode,
			@OpenBalance_60M_Amount,
			@InfoToAccOwn_1_86_line1,
			@InfoToAccOwn_1_86_line2,
			@InfoToAccOwn_1_86_line3,
			@InfoToAccOwn_1_86_line4,
			@InfoToAccOwn_1_86_line5,
			@InfoToAccOwn_1_86_line6,
			@ClosingBalance_62F_DCMark,
			@ClosingBalance_62F_Date,
			@ClosingBalance_62F_CurrencyCode,
			@ClosingBalance_62F_Amount,
			@ClosingBalance_62M_DCMark,
			@ClosingBalance_62M_Date,
			@ClosingBalance_62M_CurrencyCode,
			@ClosingBalance_62M_Amount,
			@ClosingAvailBalance_64_DCMark,
			@ClosingAvailBalance_64_Date,
			@ClosingAvailBalance_64_CurrencyCode,
			@ClosingAvailBalance_64_Amount, 
			@ForwardAvailBalance_65_DCMark,
			@ForwardAvailBalance_65_Date,
			@ForwardAvailBalance_65_CurrencyCode,
			@ForwardAvailBalance_65_Amount, 
			@InfoToAccOwn_2_86_line1,
			@InfoToAccOwn_2_86_line2,
			@InfoToAccOwn_2_86_line3,
			@InfoToAccOwn_2_86_line4,
			@InfoToAccOwn_2_86_line5,
			@InfoToAccOwn_2_86_line6,
			@EndTextBlock,
			@MAC,
			@PAC,
			@CHK,
			@SYS,
			@TNG,
			@PDE,
			@DLM,
			@PDM,
			@MRF,
			@RTV,
			@AllianceTrailerData,
			@FileName,
			2 
			)
    END
			
	IF @AppHBlckOutpMsgType = ''950''
    BEGIN
    			
			INSERT INTO [dbo].[SWIFT_MT950]
			( 
			[AppId]
			,[ServiceId]
			,[LTAdrs]
			,[SessionNo]
			,[SequenceNo]
			,[AppHBlckInpMsgType]
			,[AppHBlckInpDestAdrs]
			,[AppHBlckInpMsgPriority]
			,[AppHBlckInpDelivMonitoring]
			,[AppHBlckInpObslscPeriod]
			,[AppHBlckOutpMsgType]
			,[AppHBlckOutInpTime]
			,[AppHBlckOutMsgRefInpDate]
			,[AppHBlckOutMsgRefLTAdrs]
			,[AppHBlckOutMsgRefSessionNo]
			,[AppHBlckOutMsgRefSeqNo]
			,[AppHBlckOutMsgRefOutpDate]
			,[AppHBlckOutMsgRefOutpTime]
			,[AppHBlckOutMsgRefMsgPriority]
			,[FINServiceId_103]
			,[BankingPriority_113]
			,[MsgUserRef_108]
			,[ValidationFlag_119]
			,[AddresseeInfo_115]
			,[Swift_HTextBlock]
			,[TrxRefNo_20]
			,[AccountId_25]
			,[StatmtNo_28C]
			,[StatmtNoSeqNo_28C]
			,[OpenBalance_60F_DCMark]
			,[OpenBalance_60F_Date]
			,[OpenBalance_60F_CurrencyCode]
			,[OpenBalance_60F_Amount]
			,[OpenBalance_60M_DCMark]
			,[OpenBalance_60M_Date]
			,[OpenBalance_60M_CurrencyCode]
			,[OpenBalance_60M_Amount]
			,[ClosingBalance_62F_DCMark]
			,[ClosingBalance_62F_Date]
			,[ClosingBalance_62F_CurrencyCode]
			,[ClosingBalance_62F_Amount]
			,[ClosingBalance_62M_DCMark]
			,[ClosingBalance_62M_Date]
			,[ClosingBalance_62M_CurrencyCode]
			,[ClosingBalance_62M_Amount]
			,[ClosingAvailBalance_64_DCMark]
			,[ClosingAvailBalance_64_Date]
			,[ClosingAvailBalance_64_CurrencyCode]
			,[ClosingAvailBalance_64_Amount] 
			,[EndTextBlock] 
			,[MAC]
			,[PAC]
			,[CHK]
			,[SYS]
			,[TNG]
			,[PDE]
			,[DLM]
			,[PDM]
			,[MRF]
			,[RTV]
			,[AllianceTrailerData]
			,[FileName]
			,[LoadState]
			)
			VALUES
			( 
			@AppId,
			@ServiceId,
			@LTAdrs,
			@SessionNo,
			@SequenceNo,
			@AppHBlckInpMsgType,
			@AppHBlckInpDestAdrs,
			@AppHBlckInpMsgPriority,
			@AppHBlckInpDelivMonitoring,
			@AppHBlckInpObslscPeriod,
			@AppHBlckOutpMsgType,
			@AppHBlckOutInpTime,
			@AppHBlckOutMsgRefInpDate,
			@AppHBlckOutMsgRefLTAdrs,
			@AppHBlckOutMsgRefSessionNo,
			@AppHBlckOutMsgRefSeqNo,
			@AppHBlckOutMsgRefOutpDate,
			@AppHBlckOutMsgRefOutpTime,
			@AppHBlckOutMsgRefMsgPriority,
			@FINServiceId_103,
			@BankingPriority_113,
			@MsgUserRef_108,
			@ValidationFlag_119,
			@AddresseeInfo_115,
			@Swift_HTextBlock,
			@TrxRefNo_20,
			@AccountId_25,
			[dbo].[GetFixedSwiftStatementNumber](@AccountId_25, @StatmtNo_28C),
			@StatmtNoSeqNo_28C,
			@OpenBalance_60F_DCMark,
			@OpenBalance_60F_Date,
			@OpenBalance_60F_CurrencyCode,
			@OpenBalance_60F_Amount,
			@OpenBalance_60M_DCMark,
			@OpenBalance_60M_Date,
			@OpenBalance_60M_CurrencyCode,
			@OpenBalance_60M_Amount,
			@ClosingBalance_62F_DCMark,
			@ClosingBalance_62F_Date,
			@ClosingBalance_62F_CurrencyCode,
			@ClosingBalance_62F_Amount,
			@ClosingBalance_62M_DCMark,
			@ClosingBalance_62M_Date,
			@ClosingBalance_62M_CurrencyCode,
			@ClosingBalance_62M_Amount,
			@ClosingAvailBalance_64_DCMark,
			@ClosingAvailBalance_64_Date,
			@ClosingAvailBalance_64_CurrencyCode,
			@ClosingAvailBalance_64_Amount, 
			@EndTextBlock,
			@MAC,
			@PAC,
			@CHK,
			@SYS,
			@TNG,
			@PDE,
			@DLM,
			@PDM,
			@MRF,
			@RTV,
			@AllianceTrailerData, 
			@FileName,
			2
			)
							
	END

	DECLARE     @StatementNumber			INT
	DECLARE     @StatementSequenceNumber	INT 
	DECLARE     @OpenBalance				MONEY
	DECLARE     @ClosingBalance				MONEY	
	DECLARE		@BalanceDate				DATETIME
	DECLARE		@CurrencyCode				VARCHAR(3)
	DECLARE 	@DataSourceCd				VARCHAR(100)
	DECLARE		@OpenBalance_DCMark			CHAR(1)
	DECLARE		@ClosingBalance_DCMark		CHAR(1)
	DECLARE 	@ReturnValue INT, @Output INT, @Output2 INT
	DECLARE 	@DataSourceId INT
	DECLARE		@IsMissed					INT
	DECLARE		@IsMissReplacement			BIT

	SET @DataSourceCd = ''SWIFT''

	IF @FileName IS NULL SET @FileName = @DataSourceCd
					
	EXEC @ReturnValue= [_ib_DataSource_GetByCodeForOutput] @DataSourceCd,@OutPut OUTPUT, @Output2 OUTPUT
					
	SET @DataSourceId = @Output
										
	SET @CurrencyCode = @OpenBalance_60M_CurrencyCode
			IF @OpenBalance_60F_CurrencyCode IS NOT NULL
                  IF LEN(@OpenBalance_60F_CurrencyCode) > 2  
					SET @CurrencyCode = @OpenBalance_60F_CurrencyCode

	SET @StatementNumber = CONVERT(INT,[dbo].[GetFixedSwiftStatementNumber](@AccountId_25, @StatmtNo_28C))
	SET @StatementSequenceNumber = CONVERT(INT, @StatmtNoSeqNo_28C)  					

	IF ISNUMERIC(@OpenBalance_60F_Amount) = 1 
                SET @OpenBalance = CONVERT(MONEY,REPLACE(@OpenBalance_60F_Amount,'','',''.''))
	ELSE SET @OpenBalance = CONVERT(MONEY,REPLACE(@OpenBalance_60M_Amount,'','',''.''))

	IF LEN(@OpenBalance_60F_DCMark)  > 0
			SET @OpenBalance_DCMark = @OpenBalance_60F_DCMark
	ELSE SET @OpenBalance_DCMark = @OpenBalance_60M_DCMark

	IF @OpenBalance_DCMark <> ''C'' SET @OpenBalance = @OpenBalance * (-1)

	IF ISNUMERIC(@ClosingBalance_62F_Amount) = 1
				SET @ClosingBalance = CONVERT(MONEY,REPLACE(@ClosingBalance_62F_Amount,'','',''.''))
	ELSE SET @ClosingBalance = CONVERT(MONEY,REPLACE(@ClosingBalance_62M_Amount,'','',''.''))

	IF LEN(@ClosingBalance_62F_DCMark)  > 0
			SET @ClosingBalance_DCMark = @ClosingBalance_62F_DCMark
	ELSE SET @ClosingBalance_DCMark = @ClosingBalance_62M_DCMark

	IF @ClosingBalance_DCMark <> ''C'' SET @ClosingBalance = @ClosingBalance * (-1)

	IF LEN(@OpenBalance_60F_Date) > 0
              SET @BalanceDate = CONVERT(DATETIME,@OpenBalance_60F_Date,12)
	ELSE SET @BalanceDate = CONVERT(DATETIME,@OpenBalance_60M_Date,12)

	DECLARE @IsLastInSequence BIT
	SET @IsLastInSequence = CASE WHEN (@ClosingBalance_62F_Amount IS NULL OR @ClosingBalance_62F_Amount = '''') THEN 0 ELSE 1 END
		
	SET @IsMissed = ( SELECT COUNT(*)
						FROM dbo.[ib_SwiftStatement] stm	
							INNER JOIN ib_Account a ON a.AccountId = stm.AccountId	
						WHERE a.Code = @AccountId_25 
							AND stm.StatementNumber = @StatementNumber 
							AND stm.StatementSequenceNumber = @StatementSequenceNumber
							AND stm.[FileName] = ''MISS''
					) 
									
	IF @IsMissed >= 1 -- then update it instead
		BEGIN
			SET @IsMissReplacement = 1
			
			EXEC [ib_SwiftStatement_UpdateIfExists]
				@AccountId_25,
				@StatementNumber,
				@StatementSequenceNumber,
				@BalanceDate,
				@CurrencyCode,
				@OpenBalance,
				0,
				@ClosingBalance,
		        @FileName,
				@DataSourceCd,
				@LTAdrs,
				@IsLastInSequence,
				@IsMissReplacement
		END													
	ELSE -- @IsMissed < 1
		BEGIN
			DECLARE @Exists BIT
			EXEC dbo.[ib_SwiftStatement_CheckIfExistsExcludeMisses] @AccountId_25, @LTAdrs, @DataSourceId
				, @StatementNumber, @StatementSequenceNumber, @Exists OUTPUT
			IF @Exists <> 0
			BEGIN
				DECLARE @message VARCHAR(255)
				SET @message = ''Skipping statement since already have equivalent; account  '' 
						+ @AccountId_25 + '', '' 
						+ CONVERT(VARCHAR(25), @StatementNumber) 
						+ ''/'' + CONVERT(VARCHAR(25), @StatementSequenceNumber)
				EXEC Log_Insert @ReceiveLocationSysId, @FileName, ''Orchestrated'', @Message, ''Warning'', '''', @RunId
			END
			ELSE
			BEGIN
				SET @IsMissReplacement = 0
				EXEC [ib_SwiftStatement_Add]
						@AccountId_25,
						@StatementNumber,
						@StatementSequenceNumber,
						@BalanceDate,
						@CurrencyCode,
						@OpenBalance,
						0,
						@ClosingBalance,
						@FileName,
						@DataSourceCd,
						@LTAdrs,
						@IsLastInSequence,
						@IsMissReplacement,
						@ReceiveLocationSysId,
						@RunId

			END
		END					
	
	COMMIT TRANSACTION

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_ImportSettings_Update]''
');

GO
EXECUTE ('-- =============================================
-- Author:		Lee Manifold
-- Create date: 10 Jan 2007
-- Description: Updates column values in ImportSettings.
--				
-- =============================================
CREATE PROCEDURE [dbo].[ib_ImportSettings_Update]
	(
	@ImportSettingsId	int,
	@StartFromDate		datetime,
	@LastUpdateImported datetime	
	)
AS
SET NOCOUNT ON

	BEGIN TRY
		UPDATE [dbo].[ib_ImportSettings]

		SET		[StartFromDate]		 =	@StartFromDate,
				[LastUpdateImported] =	@LastUpdateImported
		WHERE	[ImportSettingsId]	 =	@ImportSettingsId

	END TRY
	BEGIN CATCH
		EXEC [dbo].[sp_RethrowError]
	END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[DGCX_Transaction_Add]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[DGCX_Transaction_Add]
	(
		@FileName				VARCHAR (512) = NULL
		, @TradeNumber			VARCHAR (32)  = NULL
		, @TradeStatus			VARCHAR (20)  = NULL
		, @InstrumentId			VARCHAR (2)   = NULL
		, @InstrumentName		VARCHAR (15)  = NULL
		, @ContractCode			VARCHAR (64)  = NULL
		, @ExpiryDate			VARCHAR (11)  = NULL
		, @StrikePrice			VARCHAR (28)  = NULL
		, @OptionType			VARCHAR (2)   = NULL
		, @ContractDesc			VARCHAR (255) = NULL
		, @BookType				VARCHAR (2)   = NULL
		, @BookTypeName			VARCHAR (3)   = NULL
		, @MarketType			VARCHAR (50)  = NULL
		, @TradingMemberId		VARCHAR (64)  = NULL
		, @UserId				VARCHAR (64)  = NULL
		, @BuySellInd			VARCHAR (1)   = NULL
		, @TradeQty				VARCHAR (16)  = NULL
		, @Price				VARCHAR (28)  = NULL
		, @ProClientInst		VARCHAR (1)   = NULL
		, @Account				VARCHAR (64)  = NULL
		, @ClearingMemberId		VARCHAR (64)  = NULL
		, @OpenCloseFlag		VARCHAR (5)   = NULL
		, @SpreadPrice			VARCHAR (28)  = NULL
		, @CoverUncoverFlag		VARCHAR (7)   = NULL
		, @TradedTime			VARCHAR (20)  = NULL
		, @OrderNumber			VARCHAR (32)  = NULL
		, @UserRemarks			VARCHAR (255) = NULL

    )
AS
-- Description:		Add Temporary DGCX Transaction Data

-- 13 Apr 2012	AAJM	Creation

-- History:

BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

  INSERT INTO [dbo].[DGCX_Transaction]
			( 
				[FileName]
				, [TradeNumber]      
				, [TradeStatus]      
				, [InstrumentId]      
				, [InstrumentName]      
				, [ContractCode]     
				, [ExpiryDate]		
				, [StrikePrice]
				, [OptionType]      
				, [ContractDesc]    
				, [BookType]     
				, [BookTypeName] 
				, [MarketType]      
				, [TradingMemberId]    
				, [UserId]            
				, [BuySellInd]         
				, [TradeQty]			  
				, [Price]				
				, [ProClientInst]    
				, [Account]           
				, [ClearingMemberId]   
				, [OpenCloseFlag]    
				, [SpreadPrice]       
				, [CoverUncoverFlag]   
				, [TradedTime]		
				, [OrderNumber]       
				, [UserRemarks]       
			)
    VALUES
			( 
				@FileName			
				, @TradeNumber		
				, @TradeStatus	
				, @InstrumentId
				, @InstrumentName	
				, @ContractCode	
				, @ExpiryDate		
				, @StrikePrice		
				, @OptionType		
				, @ContractDesc	
				, @BookType	
				, @BookTypeName	
				, @MarketType		
				, @TradingMemberId	
				, @UserId		
				, @BuySellInd	
				, @TradeQty		
				, @Price			
				, @ProClientInst     
				, @Account          
				, @ClearingMemberId 
				, @OpenCloseFlag     
				, @SpreadPrice       
				, @CoverUncoverFlag  
				, @TradedTime		
				, @OrderNumber       
				, @UserRemarks         

			)
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_ScheduledTask_RestartQueueItem]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_ScheduledTask_RestartQueueItem]
	@queueItemId int ,
	@updateUsername nvarchar(50)
AS
SET NOCOUNT ON
	DECLARE @code nvarchar(10)
	DECLARE @statusId INT
	
	SELECT	
		@statusId = StatusId,
		@code = S.Code
	FROM 
		ib_QueueItem I
	INNER JOIN
		ib_QueueStatus S ON S.QueueStatusId = I.StatusId
	WHERE
		QueueItemId = @queueItemId
		
	
	
	IF (ISNULL(@statusId,-1) <> -1)
	BEGIN
		IF (@code <> ''Failed'' AND @code <> ''Cancelled'')
		BEGIN
			RAISERROR (''Queue Item cannot be restarted. Only items with status "Failed" or "Cancelled" can be run repeatedly'', 16, 2)
		END
		ELSE
		BEGIN
			SELECT @statusId = QueueStatusId FROM ib_QueueStatus WHERE Code = ''StandBy''
			
			UPDATE
				ib_QueueItem
			SET
				ScheduledStart = getdate(),
				StatusId = @statusId,
				DisplayMessage = ''Standing by'',
				ErrorMessage = null,
				UpdateDate = getdate(),
				UpdateUsername = @updateUsername
				
			WHERE
				QueueItemId = @queueItemId
		END
	END
');

GO
EXECUTE ('PRINT N''Creating [stage].[CME_TrdCaptRpt_Load]''
');

GO
EXECUTE ('CREATE PROCEDURE [stage].[CME_TrdCaptRpt_Load]
(
	@LocationPath		VARCHAR(100)
	,@ReceiveLocationSysId INT
	,@RunId INT
)
AS

-- Description: Load Transactions for CME TrdCaptRpt

-- History:
-- 29 Jul 2014	ED		EIB 25635 Creation
-- 02 Oct 2014	ED		EIB 26049 Fix MMY format to allow week(ymw)
-- 20 Oct 2014	ED		EIB 26119 Fix LongExpiryDay for yyyyMM format
-- 22 Oct 2014	ED		EIB 26124 Use InstrumentExchange, MarginingAccount and Settlement Currency
-- 08 Dec 2014	ED      EIB 26286 - Change StrikePrice decimals from 4 to 6
SET NOCOUNT ON

DECLARE @DataSourceCode		VARCHAR(100)
DECLARE @DataSourceId		INT
DECLARE @Code				VARCHAR(100)
DECLARE @ReturnValue		INT
DECLARE @Output				INT
DECLARE @Output2			INT
DECLARE @DefaultCurrencyId	INT
DECLARE @Message			VARCHAR(1024)

DECLARE @AddCount			INT
SET @AddCount = 0

DECLARE @ProcessedCount		INT
SET @ProcessedCount = 0

--specify datasource in proc.
SET @DataSourceCode = (SELECT d.Code FROM ib_DataSource d INNER JOIN ReceiveLocation rl ON rl.DataSourceId = d.DataSourceId WHERE ReceiveLocationSysId = @ReceiveLocationSysId)
IF @LocationPath IS NULL SET @LocationPath = @DataSourceCode

SET @Code = @DataSourceCode
EXEC @ReturnValue= [_ib_DataSource_GetByCodeForOutput] @Code,@OutPut output,@Output2 output	
SET @DataSourceId = @Output
SET @DefaultCurrencyId = @Output2	
			
SET @Message = @DataSourceCode + '' Trade Capture Report loader started'' 		
EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @Message, ''Success'', '''', @RunId

--Gets the defaultStrikePriceDivisor
DECLARE	@DefaultStrikePriceDivisor	DECIMAL(19,6)
SET @DefaultStrikePriceDivisor = [dbo].[udf_GetDefaultStrikePriceDivisor](@DataSourceId, NULL)

-- There really isn''t any need for orchestration to call a LoadStateChange anymore
-- since we only process rows for single file now
-- but to keep consistent with other loaders - we''ll update to LoadState 1 at 
-- start of this Load stored procedure
UPDATE [stage].[CME_TrdCaptRpt]
SET LoadState = 1
WHERE LoadState = 0
	AND Filename = @LocationPath

	-- Creating Temp Table just for use in this process
	-- for iterating through the records.
	CREATE TABLE #temp1
		(
		CME_TrdCaptRptID		INT				NOT NULL
		, Exchange				VARCHAR(25)		NOT NULL
		, OriginatingMemberName VARCHAR(3)		NOT NULL
		, AccountCode			VARCHAR(5)		NOT NULL
		, DetailAccountCode		VARCHAR(14)		NULL
		, PhysicalCommodity		VARCHAR(6)		NOT NULL
		, ContractType			VARCHAR(3)		NOT NULL
		, PutCall				BIT				NULL
		, LongExpiryDate		VARCHAR(8)		NOT NULL
		, ExercisePrice			DECIMAL(19,6)	NULL
		, Volume				INT				NOT NULL
		, BuyOrSell				TINYINT			NOT NULL
		, TradeType				TINYINT			NOT NULL
		, TradeSubType			TINYINT			NULL
		, TradeDate				NVARCHAR(10)	NULL -- MBAL-16775 Missing TrdDt Causing File Failure
		, Price					DECIMAL(24,10)	NOT NULL
		, BizDate				NVARCHAR(10)	NOT NULL
		, TransferReason		NVARCHAR(4)		NULL
		, MarginingAccount		INT				NULL
		, SettlementCurrency    VARCHAR(3)		NULL
		)
	
	INSERT INTO #temp1
		(
		CME_TrdCaptRptID
		, Exchange
		, OriginatingMemberName
		, AccountCode
		, DetailAccountCode
		, PhysicalCommodity
		, ContractType
		, PutCall
		, LongExpiryDate
		, ExercisePrice
		, Volume
		, BuyOrSell
		, TradeType
		, TradeSubType
		, TradeDate
		, Price
		, BizDate
		, TransferReason
		, MarginingAccount
		, SettlementCurrency
		)
	SELECT 
		CME_TrdCaptRptID
		, InstrExchange
		, TradingMember	
		, PositionAccount
		, CustomerAccount	
		, CommodityId
		, InstrumentType		-- ContractType
								-- If ContractType was F or M or D then "FUT"
								-- If ContractType was P or C then "OOF"
		, PutCall				-- 0 = Put,  1 = Call
		, MaturityMonthYear	
		, StrikePrice
		, LastQty	
		, SideBuySellFlag		-- 1 = Buy (was ''B''), 2 = Sell (was ''S'')
		, TradeType		
		, TradeSubType
		, TradeDate
		, LastPx
		, BizDt
		, TransferReason
		, MarginingAccount
		, SettlementCurrency
	FROM [stage].[CME_TrdCaptRpt]
	WHERE LoadState = 1
	  AND [FileName] = @LocationPath

	--rd - make sure the As Of Date is not older than acceptable	
	DECLARE @CheckAsOfDate DATETIME

	SET @CheckAsOfDate = (SELECT MIN([dbo].[GetDateFromIceBizDt](BizDate)) AS CheckRunDate FROM #temp1)
	IF (@CheckAsOfDate IS NOT NULL)
	BEGIN		
		DECLARE @IsAcceptable bit
		EXECUTE [dbo].[Load_IsFileTooOld] @DataSourceId,@LocationPath,@CheckAsOfDate,@IsAcceptable OUTPUT, @ReceiveLocationSysId, @RunId
		IF (@IsAcceptable = 0)
		BEGIN
			DROP TABLE #temp1
			UPDATE stage.CME_TrdCaptRpt SET [LoadState] = 3 WHERE [Filename] = @LocationPath
			RAISERROR (''File is too old.'', 18, 0)
			RETURN 0
		END
	END
SET XACT_ABORT ON 
			
BEGIN TRANSACTION T1
	
-- BizTalk''s SQL Adapter uses more restrictive read serializable
-- so this is necessary to relax it to something that is default
-- and perfectly acceptable!

SET TRANSACTION ISOLATION LEVEL READ COMMITTED

BEGIN TRY
  
	DECLARE 
		@CME_TrdCaptRptID			INT
		, @Exchange					VARCHAR(25)
		, @OriginatingMemberName	VARCHAR(3)
		, @AccountCode				VARCHAR(5) 
		, @DetailAccountCode		VARCHAR(14) 
		, @PhysicalCommodity		VARCHAR(6)
		, @ContractType				VARCHAR(3)
		, @PutCall					BIT
		, @LongExpiryDate			VARCHAR(8)
		, @ExercisePrice			DECIMAL(19,6)
		, @Volume					INT 
		, @BuyOrSell				TINYINT
		, @TradeType				TINYINT 
		, @TradeSubType				TINYINT
		, @TradeDate				NVARCHAR(10)
		, @Price					DECIMAL(24,10) 
		, @BizDate					NVARCHAR(10)
		, @TransferReason			NVARCHAR(4)
		, @MarginingAccount			INT
		, @SettlementCurrency       VARCHAR(3)

	DECLARE @MarexFirmId INT
	SET @MarexFirmId = [dbo].[udf_GetMarexFirmId]()	

	DECLARE trx_cursor CURSOR FOR
	SELECT CME_TrdCaptRptID
		, Exchange	
		, OriginatingMemberName
		, AccountCode
		, DetailAccountCode
		, PhysicalCommodity
		, ContractType
		, PutCall	
		, LongExpiryDate
		, ExercisePrice
		, Volume
		, BuyOrSell
		, TradeType
		, TradeSubType
		, TradeDate
		, Price
		, BizDate
		, TransferReason
		, MarginingAccount
		, SettlementCurrency
	FROM #temp1

	OPEN trx_cursor

	-- Perform the first fetch and store the values in variables.
	-- Note: The variables are in the same order as the columns
	-- in the SELECT statement. 
	
	FETCH NEXT FROM trx_cursor
	INTO @CME_TrdCaptRptID 
		, @Exchange 
		, @OriginatingMemberName
		, @AccountCode 
		, @DetailAccountCode 
		, @PhysicalCommodity 
		, @ContractType 
		, @PutCall 
		, @LongExpiryDate 
		, @ExercisePrice 
		, @Volume 
		, @BuyOrSell 
		, @TradeType 
		, @TradeSubType
		, @TradeDate
		, @Price
		, @BizDate
		, @TransferReason
		, @MarginingAccount
		, @SettlementCurrency
		-- Check @@FETCH_STATUS to see if there are any more rows to fetch.
		WHILE @@FETCH_STATUS = 0
		BEGIN
	
		DECLARE @ExchangeCd			VARCHAR(25)
		DECLARE @FirmCd				VARCHAR(100)
		DECLARE @AccountCd			VARCHAR(100)
		DECLARE @DetailAccountCd	VARCHAR(14)
		DECLARE @InstrumentCd		VARCHAR(100)
		DECLARE @InstrumentTypeCd	VARCHAR(100)
		DECLARE @ExpYr				SMALLINT
		DECLARE @ExpMth				SMALLINT
		DECLARE @ExpDay				SMALLINT
		DECLARE @StrikePrice		DECIMAL(19,6)
		DECLARE @TrxTypeCd			VARCHAR(25)
		DECLARE @OptionTypeCd		VARCHAR(25)
		DECLARE @Quantity			DECIMAL(18,10)
		DECLARE	@QuantityLong		INT
		DECLARE @QuantityShort		INT
		DECLARE @TrxDate			DATETIME
		DECLARE @PriceDec			DECIMAL(24,10)
		DECLARE @AsOfDate			DATETIME
		DECLARE @CurrencyId			INT
		DECLARE @InstrumentId		INT
		DECLARE @TickSize			INT		
		DECLARE @StrikePriceDivisor DECIMAL(19,4)	
		DECLARE @PriceDivisor		DECIMAL(19,4)
		DECLARE @GenericContractType VARCHAR(1)
		
		SET @ExchangeCd = @Exchange
	
		SET @Output = NULL
		DECLARE @InstrumentTypeId INT
		
		SET @InstrumentTypeCd = 
			CASE @ContractType
				WHEN ''FUT'' THEN ''F''
				WHEN ''OOF'' THEN ''O''
				WHEN ''OPT'' THEN ''O''
				WHEN ''OOC'' THEN ''O''
			END
		
		EXEC @ReturnValue = ib_Instrumenttype_AddAsNeeded @DataSourceId, @InstrumentTypeCd, @OutPut OUTPUT
		SET @InstrumentTypeId = @Output
		
		SET @CurrencyId = NULL
		if @SettlementCurrency IS NOT NULL
			BEGIN
				EXEC @ReturnValue = [ib_Currency_AddAsNeeded] @DataSourceId, @SettlementCurrency, @Output output
				SET @CurrencyId = @Output
			END
		
		SET @Output = NULL
		SET @Output2 = NULL
		
		SET @InstrumentCd = @InstrumentTypeCd + ''_'' + @ExchangeCd + ''_'' + @PhysicalCommodity
				
		EXEC @ReturnValue= [ib_Instrument_AddAsNeeded] @DataSourceId,@InstrumentTypeId,@InstrumentCd,@CurrencyId,@OutPut output,@Output2 output	
		SET @InstrumentId = @Output
		SET @CurrencyId = @Output2
		IF @Output2 = NULL
			BEGIN
				SET @CurrencyId = @DefaultCurrencyId
			END

		SET @TickSize = NULL
		SELECT @TickSize = TickSize 
		FROM ib_Instrument 
		WHERE InstrumentId = @InstrumentId

		SET @FirmCd = @OriginatingMemberName
		SET @AccountCd = @AccountCode
		IF @MarginingAccount IS NOT NULL
			SET @AccountCd = @AccountCd + ''-'' + CAST(@MarginingAccount AS VARCHAR(1))
		SET @DetailAccountCd = @DetailAccountCode
		
		SET @StrikePriceDivisor = NULL
		SET @PriceDivisor = NULL

		SELECT @StrikePriceDivisor = StrikePriceDivisor
			, @PriceDivisor = PriceDivisor
		FROM [dbo].[ib_InstrumentDataSource]
		WHERE DataSourceId = @DataSourceId
			AND DataSourceInstrumentCode = @InstrumentCd 

		IF @PriceDivisor IS NULL 
			SET @PriceDivisor = 1
		SET @PriceDec = CONVERT(DECIMAL(24,10), @Price) / @PriceDivisor

		IF @StrikePriceDivisor IS NULL -- Then get the default
			BEGIN
				DECLARE @ExchangeId INT
				SELECT @ExchangeId = ExchangeId FROM ib_Exchange WHERE [Code] = @ExchangeCd
				
				SET @StrikePriceDivisor = [dbo].[udf_GetDefaultStrikePriceDivisor](@DataSourceId, @ExchangeId)
			END

		SET @StrikePrice = (@ExercisePrice/@StrikePriceDivisor)
		 
		SET @TrxTypeCd =
			CASE
				WHEN @TradeType = 0 AND @TradeSubType IS NULL
					THEN ''0''
				WHEN @TradeType = 0 AND @TradeSubType = 10
					THEN ''0-10''
				WHEN @TradeType = 0 AND @TradeSubType = 9
					THEN ''0-9''
				WHEN @TradeType = 3 AND @TradeSubType = 5
					THEN ''3-5''
				WHEN @TradeType = 3 AND @TradeSubType = 6
					THEN ''3-6''
				ELSE 
					ISNULL(CONVERT(VARCHAR(3), @TradeType), '''') + ISNULL(''-'' + CONVERT (VARCHAR(3), @TradeSubType), '''')
			END

		IF UPPER(@TransferReason) IN (''ADJ'', ''POS'', ''GU'', ''APT'', ''REV'')
		BEGIN
			-- file rollback requires non-numeric trx type to have a dash so add one if necessary
			IF CHARINDEX(''-'', @TrxTypeCd) = 0
				SET @TrxTypeCd = @TrxTypeCd + ''-''
			SET @TrxTypeCd = @TrxTypeCd + UPPER(@TransferReason)
		END
				
		-- Set Option Type Code
		SET @OptionTypeCd = 
			CASE @PutCall
				WHEN 0 THEN ''P''
				WHEN 1 THEN ''C''
			END 
			
		IF @TrxTypeCd IN (''3-5ADJ'', ''3-5POS'', ''3-5REV'')	-- MBAL-16417
			IF (@BuyOrSell = 1)		-- Buy
				SET @BuyOrSell = 0
			ELSE
				SET @BuyOrSell = 1

		IF (@BuyOrSell = 1) -- = B = Buy
			BEGIN
				SET @Quantity = @volume
				SET @QuantityLong = @volume
				SET @QuantityShort = 0
			END
		ELSE
			BEGIN
				SET @Quantity = @volume * -1
				SET @QuantityLong = 0
				SET @QuantityShort = @volume
			END

		IF @TrxTypeCd IN (''3-5ADJ'', ''3-5POS'', ''3-5REV'')
			BEGIN
				IF @Quantity > 0
					SET @Quantity = @Quantity * -1
				IF @QuantityLong > 0
					SET @QuantityLong = @QuantityLong * -1
				IF @QuantityShort > 0
					SET @QuantityShort = @QuantityShort * -1
			END
		
		SET @ExpYr = LEFT(@LongExpiryDate, 4)
		SET @ExpMth = SUBSTRING(@LongExpiryDate, 5, 2)
		SET @ExpDay = CASE WHEN RIGHT(@LongExpiryDate,2) LIKE ''w%'' THEN 0 ELSE SUBSTRING(@LongExpiryDate,7,2) + 0 END
		SET @ExpDay = dbo.udf_OnLoad_ExpiryDate_Get_Day(@ExpYr, @ExpMth, @ExpDay)

		-- Set AsOfDate	and TrxDate
		SET @AsofDate = [dbo].[GetDateFromIceBizDt] (@BizDate)	
		
		IF @TradeDate IS NULL
			SET @TrxDate = @AsOfDate
		ELSE
			SET @TrxDate = [dbo].[GetDateFromIceBizDt] (@TradeDate)
	
		-- Set Generic Contract Type
		IF (@ContractType IS NOT NULL AND @ContractType = ''FUT'')
			SET @GenericContractType = ''F''
		ELSE
			SET @GenericContractType = ''O''
		
		DECLARE @TrxId INT
		SET @TrxId = NULL

		EXEC [ib_Trx_Load]
			@DataSourceCode
			, @ExchangeCd
			, @FirmCd
			, @AccountCd
			, @DetailAccountCd
			, @InstrumentCd
			, @ExpYr
			, @ExpMth
			, @ExpDay
			, @StrikePrice
			, @TrxTypeCd
			, @OptionTypeCd
			, @Quantity
			, @TrxDate
			, @PriceDec
			, @CME_TrdCaptRptID
			, @GenericContractType
			, @AsOfDate
			, @LocationPath = @LocationPath
			, @CurrencyCd = @SettlementCurrency
			, @MarexFirmId = @MarexFirmId
			, @TrxId = @TrxId OUTPUT
			, @QuantityLong = @QuantityLong 
			, @QuantityShort = @QuantityShort
			, @ReceiveLocationSysId = @ReceiveLocationSysId
			, @RunId = @RunId
			
			
		--flip processed flag in source table.
		UPDATE stage.CME_TrdCaptRpt
		SET LoadState = 2
		WHERE CME_TrdCaptRptID = @CME_TrdCaptRptID
			AND LoadState = 1
		
		IF @TrxId IS NOT NULL AND @TrxId > 0
			SET @AddCount = @AddCount + 1
		
		SET @ProcessedCount = @ProcessedCount + 1

		FETCH NEXT FROM trx_cursor
		INTO @CME_TrdCaptRptID 
			, @Exchange 
			, @OriginatingMemberName
			, @AccountCode 
			, @DetailAccountCode 
			, @PhysicalCommodity 
			, @ContractType 
			, @PutCall 
			, @LongExpiryDate 
			, @ExercisePrice 
			, @Volume 
			, @BuyOrSell 
			, @TradeType 
			, @TradeSubType
			, @TradeDate
			, @Price
			, @BizDate
			, @TransferReason
			, @MarginingAccount
			, @SettlementCurrency
		END

	CLOSE trx_cursor
	DEALLOCATE trx_cursor

	SET @Message = @DataSourceCode + '' Trade Capture Report loader ended ('' + CONVERT(VARCHAR(10), @ProcessedCount) + '' processed, '' 
		+ CONVERT(VARCHAR(10), @AddCount) + '' added)'' 
		
	EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @Message, ''Success'', '''', @RunId
		
	COMMIT TRANSACTION
		
	IF OBJECT_ID(''tempdb..#temp1'') IS NOT NULL 
		DROP TABLE #temp1
		
END TRY

BEGIN CATCH 

	IF XACT_STATE() = -1 
		ROLLBACK TRANSACTION
	
	SET @Message = @DataSourceCode + '' Trade Capture Report loader failed'' 		
	EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @Message, ''Error'', '''', @RunId
	
	EXEC [dbo].[sp_RethrowError]
		
END CATCH 

SET XACT_ABORT OFF
	
RETURN 0
');

GO
EXECUTE ('PRINT N''Creating [stage].[CME_PosRpt_Load]''
');

GO
EXECUTE ('CREATE PROCEDURE [stage].[CME_PosRpt_Load]
(
	@LocationPath		VARCHAR(100)
	,@ReceiveLocationSysId INT
	,@RunId INT
)
AS

-- Description: Load Transactions for CME PosRpt

-- History:
-- 29 Jul 2014	ED		EIB 25635 Creation
-- 02 Oct 2014	ED		EIB 26049 Fix MMY format to allow week(ymw)
-- 10 Oct 2014	ED		EIB 26086 Use Margining Account too
-- 20 Oct 2014	ED		EIB 26119 Fix LongExpiryDay for yyyyMM format
-- 22 Oct 2014	ED		EIB 26124 Use InstrumentExchange, MarginingAccount and Settlement Currency
-- 08 Dec 2014	ED      EIB 26286 - Change StrikePrice decimals from 4 to 6
-- 17 Jul 2018	CH		EIB	42966 Commodityid increased from 3 to 6	
SET NOCOUNT ON

DECLARE @DataSourceCode		VARCHAR(100)
DECLARE @DataSourceId		INT
DECLARE @Code				VARCHAR(100)
DECLARE @ReturnValue		INT
DECLARE @Output				INT
DECLARE @Output2			INT
DECLARE @DefaultCurrencyId	INT
DECLARE @Message			VARCHAR(1024)

DECLARE @ProcessedCount INT
SET @ProcessedCount = 0

DECLARE @AddCount INT
SET @AddCount = 0

--specify datasource in proc.
SET @DataSourceCode = (SELECT d.Code FROM ib_DataSource d INNER JOIN ReceiveLocation rl ON rl.DataSourceId = d.DataSourceId WHERE ReceiveLocationSysId = @ReceiveLocationSysId)
IF @LocationPath IS NULL SET @LocationPath = @DataSourceCode

SET @Code = @DataSourceCode
EXEC @ReturnValue= [_ib_DataSource_GetByCodeForOutput] @Code, @OutPut output, @Output2 output	
SET @DataSourceId = @Output
SET @DefaultCurrencyId = @Output2	
			
SET @Message = @DataSourceCode + '' Position Report loader started'' 		
EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @Message, ''Success'', '''', @RunId

-- Store ImportFile record to be associated with Settlement Price load
DECLARE @ImportFileId INT
EXEC ib_ImportFile_Add @DataSourceId, @LocationPath, @ImportFileId output
DECLARE @SelectedAsOfDate DATETIME

--Gets the defaultStrikePriceDivisor
DECLARE	@DefaultStrikePriceDivisor	DECIMAL(19,6)
SET @DefaultStrikePriceDivisor = [dbo].[udf_GetDefaultStrikePriceDivisor](@DataSourceId, NULL)

-- There really isn''t any need for orchestration to call a LoadStateChange anymore
-- since we only process rows for single file now
-- but to keep consistent with other loaders - we''ll update to LoadState 1 at 
-- start of this Load stored procedure
UPDATE [stage].[CME_PosRpt]
SET LoadState = 1
WHERE LoadState = 0
	AND Filename = @LocationPath

-- Creating Temp Table just for use in this process
-- for iterating through the records.
CREATE TABLE #temp1
	(
	CME_PosRptID			INT				NOT NULL
	, Exchange				VARCHAR(25)		NOT NULL
	, OriginatingMemberName VARCHAR(3)		NOT NULL
	, AccountCode			VARCHAR(5)		NOT NULL
	, PhysicalCommodity		VARCHAR(6)		NOT NULL
	, ContractType			VARCHAR(3)		NOT NULL
	, PutCall				BIT				NULL
	, LongExpiryDate		VARCHAR(8)		NOT NULL
	, ExercisePrice			DECIMAL(19,6)	NULL
	, LongAccountVolme		INT				NOT NULL
	, ShortAccountVolume	INT				NOT NULL	
	, PayCollect			DECIMAL(19,10)	NULL
	, PremiumPayCollect		DECIMAL(19,10)	NULL
	, LongLotsTraded		INT				NULL	
	, ShortLotsTraded		INT				NULL
	, ValuationPrice		DECIMAL(24,10)	NOT NULL
	, BizDate				VARCHAR(10)
	, MarginingAccount		INT				NULL
	, SettlementCurrency    VARCHAR (3)     NULL
	)

INSERT INTO #temp1
	(
	CME_PosRptID	
	, Exchange	
	, OriginatingMemberName
	, AccountCode	
	, PhysicalCommodity	
	, ContractType	
	, PutCall	
	, LongExpiryDate
	, ExercisePrice	
	, LongAccountVolme	
	, ShortAccountVolume
	, PayCollect
	, PremiumPayCollect	
	, LongLotsTraded		
	, ShortLotsTraded
	, ValuationPrice
	, BizDate	
	, MarginingAccount
	, SettlementCurrency
	)
	
	SELECT 
		CME_PosRptID
		, InstrExchange
		, TradingMember
		, PositionAccount
		, CommodityId	
		, InstrumentType		-- ContractType
								-- If ContractType was F or M or D then "FUT"
								-- If ContractType was P or C then "OOF"
		, PutCall				-- PutCall: 0 = Put, 1 = Call
		, MaturityMonthYear	
		, StrikePrice
		, QtyLong	
		, QtyShort			
		, PayCollectAmt -- set as zero for now
		, PremPayCollectAmt	
		, TradedLongLots	
		, TradedShortLots
		, SettlementPrice
		, BizDt
		, MarginingAccount
		, SettlementCurrency
	FROM [stage].[CME_PosRpt]
	WHERE LoadState = 1
	  AND [FileName] = @LocationPath
	
	--rd - make sure the As Of Date is not older than acceptable	
	DECLARE @CheckAsOfDate DATETIME

	SET @CheckAsOfDate = (SELECT MIN([dbo].[GetDateFromIceBizDt](BizDate)) AS CheckRunDate FROM #temp1)
	IF (@CheckAsOfDate IS NOT NULL)
	BEGIN		
		DECLARE @IsAcceptable bit
		EXECUTE [dbo].[Load_IsFileTooOld] @DataSourceId,@LocationPath,@CheckAsOfDate,@IsAcceptable OUTPUT, @ReceiveLocationSysId, @RunId
		IF (@IsAcceptable = 0)
		BEGIN
			DROP TABLE #temp1
			UPDATE stage.CME_PosRpt SET [LoadState] = 3 WHERE [Filename] = @LocationPath
			RAISERROR (''File is too old.'', 18, 0)
			RETURN 0
		END
	END
	  
		
SET XACT_ABORT ON 
			
BEGIN TRANSACTION T1
	
-- BizTalk''s SQL Adapter uses more restrictive read serializable
-- so this is necessary to relax it to something that is default
-- and perfectly acceptable!

SET TRANSACTION ISOLATION LEVEL READ COMMITTED

BEGIN TRY

	DECLARE 
		@CME_PosRptID				INT				
		, @Exchange					VARCHAR(25)		
		, @OriginatingMemberName	VARCHAR(3)		
		, @AccountCode				VARCHAR(5)		
		, @PhysicalCommodity		VARCHAR(6)		
		, @ContractType				VARCHAR(3)		
		, @PutCall					BIT				
		, @LongExpiryDate			VARCHAR(8)		
		, @ExercisePrice			DECIMAL(19,6)		
		, @LongAccountVolume		INT				
		, @ShortAccountVolume		INT					
		, @PayCollect				DECIMAL(19,10)	
		, @PremiumPayCollect		DECIMAL(19,10)	
		, @LongLotsTraded			INT					
		, @ShortLotsTraded			INT				
		, @ValuationPrice			DECIMAL(24,10)	
		, @BizDate					VARCHAR(10)
		, @MarginingAccount			INT
		, @SettlementCurrency		VARCHAR(3)
	DECLARE pos_cursor CURSOR FOR
	SELECT CME_PosRptID	
		, Exchange	
		, OriginatingMemberName
		, AccountCode	
		, PhysicalCommodity	
		, ContractType	
		, PutCall	
		, LongExpiryDate
		, ExercisePrice	
		, LongAccountVolme	
		, ShortAccountVolume
		, PayCollect
		, PremiumPayCollect	
		, LongLotsTraded		
		, ShortLotsTraded
		, ValuationPrice
		, BizDate	
		, MarginingAccount
		, SettlementCurrency
	FROM #temp1

	OPEN pos_cursor

	-- Perform the first fetch and store the values in variables.
	-- Note: The variables are in the same order as the columns
	-- in the SELECT statement. 
	
	FETCH NEXT FROM pos_cursor
	INTO 
		@CME_PosRptID
		, @Exchange		
		, @OriginatingMemberName
		, @AccountCode	
		, @PhysicalCommodity	
		, @ContractType	
		, @PutCall	
		, @LongExpiryDate	
		, @ExercisePrice	
		, @LongAccountVolume	
		, @ShortAccountVolume	
		, @PayCollect
		, @PremiumPayCollect
		, @LongLotsTraded		
		, @ShortLotsTraded	
		, @ValuationPrice	
		, @BizDate	
		, @MarginingAccount
		, @SettlementCurrency
		-- Check @@FETCH_STATUS to see if there are any more rows to fetch.
		WHILE @@FETCH_STATUS = 0
		BEGIN

	
		DECLARE @ExchangeCode			VARCHAR(25)
		DECLARE @FirmCd					VARCHAR(100)
		DECLARE @AccountCd				VARCHAR(100)
		DECLARE @InstrumentCd			VARCHAR(100)
		DECLARE @InstrumentTypeCd		VARCHAR(100)
		DECLARE @QuantityPS				DECIMAL(18,10)
		DECLARE @MarketValuePS			DECIMAL(19,4)
		DECLARE @MarketValueTR			DECIMAL(19,4)
		DECLARE @ExpiryDate				DATETIME
		DECLARE @StrikePrice			DECIMAL(19,6)
		DECLARE @TrxTypeCdPS			VARCHAR(25)
		DECLARE @TrxTypeCdTR			VARCHAR(25)
		DECLARE @OptionTypeCd			VARCHAR(25)
		DECLARE @QuantityTR				DECIMAL(18,10)
		DECLARE @TrxDate				DATETIME
		DECLARE @ExpYr					SMALLINT
		DECLARE @ExpMth					SMALLINT
		DECLARE @ExpDay					SMALLINT
		DECLARE	@LongQuantity			DECIMAL(19,4)
		DECLARE @ShortQuantity			DECIMAL(19,4)
		DECLARE @TradedLongQuantity		DECIMAL(19,4)
		DECLARE @TradedShortQuantity	DECIMAL(19,4)
		DECLARE @AsOfDate				DATETIME
		DECLARE @InstrumentId			INT
		DECLARE @TickSize				INT
		DECLARE @MarketValueDivisor		DECIMAL(19,4)
		DECLARE	@StrikePriceDivisor		DECIMAL(19,4)
		DECLARE @PriceDivisor			DECIMAL(19,4)
		
		SET @ExchangeCode = @Exchange
	
		SET @Output = NULL
		DECLARE @InstrumentTypeId INT

		SET @InstrumentTypeCd = 
			CASE @ContractType
				WHEN ''FUT'' THEN ''F''
				WHEN ''OOF'' THEN ''O''
				WHEN ''OPT'' THEN ''O''
				WHEN ''OOC'' THEN ''O''
			END

		EXEC @ReturnValue = ib_Instrumenttype_AddAsNeeded @DataSourceId,@InstrumentTypeCd,@OutPut output
		SET @InstrumentTypeId = @Output

		DECLARE @CurrencyId INT
		SET @CurrencyId = NULL
		IF @SettlementCurrency IS NOT NULL
			BEGIN
				EXEC @ReturnValue = [ib_Currency_AddAsNeeded] @DataSourceId, @SettlementCurrency, @Output output
				SET @CurrencyId = @Output
			END
		SET @Output = NULL
		SET @Output2 = NULL
		
		SET @InstrumentCd = @InstrumentTypeCd + ''_'' + @ExchangeCode + ''_'' + @PhysicalCommodity
				
		EXEC @ReturnValue= [ib_Instrument_AddAsNeeded] @DataSourceId,@InstrumentTypeId,@InstrumentCd,@CurrencyId,@OutPut output,@Output2 output	
		SET @InstrumentId = @Output
		SET @CurrencyId = @Output2
		IF @Output2 = NULL
			BEGIN
				SET @CurrencyId = @DefaultCurrencyId
			END

		SET @TickSize = NULL
		SELECT @TickSize = TickSize FROM ib_Instrument WHERE InstrumentId = @InstrumentId

		SET @MarketValueDivisor = NULL
		SET @StrikePriceDivisor = NULL
		SET @PriceDivisor = NULL

		SELECT @MarketValueDivisor = MarketValueDivisor
				, @StrikePriceDivisor	= StrikePriceDivisor
				, @PriceDivisor = PriceDivisor
		FROM [dbo].[ib_InstrumentDataSource]
		WHERE DataSourceId = @DataSourceId
			AND DataSourceInstrumentCode = @InstrumentCd 
			
		IF @MarketValueDivisor IS NULL SET @MarketValueDivisor = 1

		SET @FirmCd = @OriginatingMemberName
		SET @AccountCd = @AccountCode
		IF @MarginingAccount IS NOT NULL
			SET @AccountCd = @AccountCd + ''-'' + CAST(@MarginingAccount AS VARCHAR(1))

		SET @QuantityPS = CAST(@LongAccountVolume AS DECIMAL(18,10)) - CAST(@ShortAccountVolume AS DECIMAL(18,10))
		SET @MarketValuePS = CASE WHEN @TickSize > 0 THEN (@PayCollect * @TickSize / @MarketValueDivisor) ELSE @PayCollect END
		SET @MarketValueTR = CASE WHEN @TickSize > 0 THEN @PremiumPayCollect * @TickSize / @MarketValueDivisor ELSE @PremiumPayCollect END
			
		IF @StrikePriceDivisor IS NULL -- Then get the default
			BEGIN
				DECLARE @ExchangeId INT
				SELECT @ExchangeId = ExchangeId FROM ib_Exchange WHERE [Code] = @ExchangeCode
				
				SET @StrikePriceDivisor = [dbo].[udf_GetDefaultStrikePriceDivisor](@DataSourceId, @ExchangeId)
			END

		SET @StrikePrice = (@ExercisePrice/@StrikePriceDivisor)
	
		-- Set Settlement Price
		IF @PriceDivisor IS NULL 
			SET @PriceDivisor = 1
					
		DECLARE @SettlementPrice DECIMAL(24,10)
		SET @SettlementPrice = CONVERT(DECIMAL(24,10), @ValuationPrice) / @PriceDivisor
			
		SET @TrxTypeCdPS = ''Position''
		SET @TrxTypeCdTR = ''Premium''

		-- Set Option Type Code
		SET @OptionTypeCd = 
			CASE @PutCall
				WHEN 0 THEN ''P''
				WHEN 1 THEN ''C''
			END 

		-- Set AsOfDate	
		SET @AsofDate = [dbo].[GetDateFromIceBizDt] (@BizDate)
					
		SET @TrxDate = @AsOfDate
		SET @SelectedAsOfDate = @AsOfDate

		-- MBAL 15856 - Set Quantity = 0 to Premium trx
		-- SET @QuantityTR = case when @TickSize > 0 then @premiumpaycollect/@TickSize else @premiumpaycollect END
		SET @QuantityTR = 0

		SET @ExpYr = LEFT(@LongExpiryDate,4)
		SET @ExpMth = SUBSTRING(@LongExpiryDate,5,2)
		SET @ExpDay = CASE WHEN RIGHT(@LongExpiryDate,2) LIKE ''w%'' THEN 0 ELSE SUBSTRING(@LongExpiryDate,7,2) + 0 END
		SET @ExpDay = dbo.udf_OnLoad_ExpiryDate_Get_Day(@ExpYr,@ExpMth,@ExpDay)
		
		SET @LongQuantity = @LongAccountVolume
		SET @ShortQuantity = @ShortAccountVolume
		SET @TradedLongQuantity = @LongLotsTraded 
		SET @TradedShortQuantity = @ShortLotsTraded
		
		DECLARE @PositionId INT
		SET @PositionId = NULL		
		
		EXEC [ib_Position_W_Trans_Load]
			@DataSourceCode
			, @ExchangeCode
			, @FirmCd
			, @AccountCd	
			, @AsOfDate
			, @InstrumentCd
			, @QuantityPS
			, @MarketValuePS
			, @MarketValueTR
			, @ExpYr
			, @ExpMth
			, @ExpDay
			, @StrikePrice
			, @TrxTypeCdPS
			, @TrxTypeCdTR
			, @OptionTypeCd
			, @QuantityTR
			, @TrxDate
			, NULL -- @Price is not used in LCH_TypePS_Load
			, @CME_PosRptID
			, @InstrumentTypeCd
			, @SettlementCurrency
			, @LongQuantity 
			, @ShortQuantity 
			, @TradedLongQuantity 
			, @TradedShortQuantity
			, @PositionId = @PositionId OUTPUT
			, @ReceiveLocationSysId = @ReceiveLocationSysId
			, @RunId = @RunId
			, @LocationPath = @LocationPath
						
			-- Add Settlement Price											
			EXEC ib_Price_AddFromPositionLoad
				@PositionId
				, @ImportFileId
				, @SettlementPrice 			
		
		
		--flip processed flag in source table.
		UPDATE stage.CME_PosRpt
		SET LoadState = 2
		WHERE CME_PosRptID = @CME_PosRptID
			AND LoadState = 1
		
		IF @PositionId IS NOT NULL AND @PositionId > 0
			SET @AddCount = @AddCount + 1

		SET @ProcessedCount	= @ProcessedCount + 1
		
		FETCH NEXT FROM pos_cursor
		INTO 		
			@CME_PosRptID
			, @Exchange		
			, @OriginatingMemberName
			, @AccountCode	
			, @PhysicalCommodity	
			, @ContractType	
			, @PutCall	
			, @LongExpiryDate	
			, @ExercisePrice	
			, @LongAccountVolume	
			, @ShortAccountVolume	
			, @PayCollect
			, @PremiumPayCollect
			, @LongLotsTraded		
			, @ShortLotsTraded	
			, @ValuationPrice	
			, @BizDate	
			, @MarginingAccount
			, @SettlementCurrency
		END

	CLOSE pos_cursor
	DEALLOCATE pos_cursor

	SET @Message = @DataSourceCode + '' Position Report loader ended ('' + CONVERT(VARCHAR(10), @ProcessedCount) + '' processed, '' 
		+ CONVERT(VARCHAR(10), @AddCount) + '' added)'' 
		
	EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @Message, ''Success'', '''', @RunId
		
	UPDATE ib_ImportFile 
	SET AsOfDate = @SelectedAsOfDate 
	WHERE ImportFileId = @ImportFileId

	COMMIT TRANSACTION
		
	IF OBJECT_ID(''tempdb..#temp1'') IS NOT NULL 
		DROP TABLE #temp1
		
END TRY


BEGIN CATCH 

	IF XACT_STATE() = -1 
		ROLLBACK TRANSACTION
	
	SET @Message = @DataSourceCode + '' Position Report Report loader failed'' 		
	EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @Message, ''Error'', '''', @RunId
	
	EXEC [dbo].[sp_RethrowError]
		
END CATCH 

SET XACT_ABORT OFF
	
RETURN 0
');

GO
EXECUTE ('PRINT N''Creating [stage].[CME_AsgnRpt_Load]''
');

GO
EXECUTE ('CREATE PROCEDURE [stage].[CME_AsgnRpt_Load]
(
	@LocationPath		VARCHAR(100)
	,@ReceiveLocationSysId INT
	,@RunId INT
)
AS

-- Description: Load Transactions for CME Assignment Report

-- History:
-- 29 Jul 2014	ED		EIB 25635 Creation
-- 02 Oct 2014	ED		EIB 26049 Fix MMY format to allow week(ymw)
-- 20 Oct 2014	ED		EIB 26119 Fix LongExpiryDay for yyyyMM format
-- 22 Oct 2014	ED		EIB 26124 Use InstrumentExchange, MarginingAccount and Settlement Currency
-- 08 Dec 2014	ED      EIB 26286 - Change StrikePrice decimals from 4 to 6
-- 17 Jul 2018	CH		EIB	42966 Commodityid increased from 3 to 6	
SET NOCOUNT ON

DECLARE @DataSourceCode		VARCHAR(100)
DECLARE @DataSourceId		INT
DECLARE @Code				VARCHAR(100)
DECLARE @ReturnValue		INT
DECLARE @Output				INT
DECLARE @Output2			INT
DECLARE @DefaultCurrencyId	INT
DECLARE @Message			VARCHAR(1024)

DECLARE @AddCount			INT
SET @AddCount = 0

DECLARE @ProcessedCount		INT
SET @ProcessedCount = 0

--specify datasource in proc.
SET @DataSourceCode = (SELECT d.Code FROM ib_DataSource d INNER JOIN ReceiveLocation rl ON rl.DataSourceId = d.DataSourceId WHERE ReceiveLocationSysId = @ReceiveLocationSysId)
IF @LocationPath IS NULL SET @LocationPath = @DataSourceCode

SET @Code = @DataSourceCode
EXEC @ReturnValue= [_ib_DataSource_GetByCodeForOutput] @Code,@OutPut output,@Output2 output	
SET @DataSourceId = @Output
SET @DefaultCurrencyId = @Output2	
			
SET @Message = @DataSourceCode + '' Assignment Report loader started'' 		
EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @Message, ''Success'', '''', @RunId

--Gets the defaultStrikePriceDivisor
DECLARE	@DefaultStrikePriceDivisor	DECIMAL(19,6)
SET @DefaultStrikePriceDivisor = [dbo].[udf_GetDefaultStrikePriceDivisor](@DataSourceId, NULL)

-- There really isn''t any need for orchestration to call a LoadStateChange anymore
-- since we only process rows for single file now
-- but to keep consistent with other loaders - we''ll update to LoadState 1 at 
-- start of this Load stored procedure
UPDATE [stage].[CME_AsgnRpt]
SET LoadState = 1
WHERE LoadState = 0
	AND Filename = @LocationPath

-- Creating Temp Table just for use in this process
-- for iterating through the records.
CREATE TABLE #temp1
	(
	CME_AsgnRptID		INT				NOT NULL
	, Exchange				VARCHAR(25)		NOT NULL
	, OriginatingMemberName VARCHAR(3)		NOT NULL
	, AccountCode			VARCHAR(5)		NOT NULL
	, PhysicalCommodity		VARCHAR(6)		NOT NULL
	, ContractType			VARCHAR(3)		NOT NULL
	, PutCall				BIT				NULL
	, LongExpiryDate		VARCHAR(8)		NOT NULL
	, ExercisePrice			DECIMAL(19,6)	NULL
	, QtyLong				INT				NOT NULL
	, QtyShort				INT				NOT NULL
	, Price					DECIMAL(24,10)	NOT NULL
	, DateOfTradeChr		NVARCHAR(10)    NULL
	, PositionType			NVARCHAR(3)		NOT NULL
	, BizDate				NVARCHAR(10)	NOT NULL
	, MarginingAccount		INT				NULL
	, SettlementCurrency    VARCHAR(3)      NULL
	)

INSERT INTO #temp1
	(
	CME_AsgnRptID
	, Exchange	
	, OriginatingMemberName
	, AccountCode
	, PhysicalCommodity
	, ContractType
	, PutCall
	, LongExpiryDate
	, ExercisePrice	
	, QtyLong
	, QtyShort
	, Price	
	, DateOfTradeChr
	, PositionType
	, BizDate
	, MarginingAccount
	, SettlementCurrency
	)
	
	SELECT 
		CME_AsgnRptID
		, InstrExchange
		, TradingMember	
		, PositionAccount
		, CommodityId
		, InstrumentType		-- ContractType
								-- If ContractType was F or M or D then "FUT"
								-- If ContractType was P or C then "OOF"
		, PutCall				-- 0 = Put,  1 = Call
		, MaturityMonthYear
		, StrikePrice
		, QtyLong				
		, QtyShort		
		, SettlementPrice
		, QtyDate
		, PosQtyType
		, BizDt
		, MarginingAccount
		, SettlementCurrency
	FROM [stage].[CME_AsgnRpt]
	WHERE LoadState = 1
	  AND [FileName] = @LocationPath
			AND (
			PosQtyType IN (''AS'',''DC'', ''EX'', ''FXP'')
			OR (PosQtyType IN (''OXP'') AND (QtyLong > 0 OR QtyShort > 0))		
			)
	-- If you add to the WHERE clause, make sure you update the 
	-- code at the end of the proc which updates non-processed records.

	--rd - make sure the As Of Date is not older than acceptable	
	DECLARE @CheckAsOfDate DATETIME

	SET @CheckAsOfDate = (SELECT MIN([dbo].[GetDateFromIceBizDt](BizDate)) AS CheckRunDate FROM #temp1)
	IF (@CheckAsOfDate IS NOT NULL)
	BEGIN		
		DECLARE @IsAcceptable bit
		EXECUTE [dbo].[Load_IsFileTooOld] @DataSourceId,@LocationPath,@CheckAsOfDate,@IsAcceptable OUTPUT, @ReceiveLocationSysId, @RunId
		IF (@IsAcceptable = 0)
		BEGIN
			DROP TABLE #temp1
			UPDATE stage.CME_AsgnRpt SET [LoadState] = 3 WHERE [Filename] = @LocationPath
			RAISERROR (''File is too old.'', 18, 0)
			RETURN 0
		END
	END	
		
SET XACT_ABORT ON 
			
BEGIN TRANSACTION T1
	
-- BizTalk''s SQL Adapter uses more restrictive read serializable
-- so this is necessary to relax it to something that is default
-- and perfectly acceptable!

SET TRANSACTION ISOLATION LEVEL READ COMMITTED

BEGIN TRY

	DECLARE
		@CME_AsgnRptID				INT
		, @Exchange					VARCHAR(25)
		, @OriginatingMemberName	VARCHAR(3)
		, @AccountCode				VARCHAR(5)
		, @PhysicalCommodity		VARCHAR(6)
		, @ContractType				VARCHAR(3)
		, @PutCall					BIT	
		, @LongExpiryDate			VARCHAR(8)
		, @ExercisePrice			DECIMAL(19,6)
		, @QtyLong					INT
		, @QtyShort					INT	
		, @Price					DECIMAL(24,10)
		, @DateOfTradeChr			NVARCHAR(10)
		, @PositionType				NVARCHAR(3)
		, @BizDate					NVARCHAR(10)
		, @MarginingAccount			INT
		, @SettlementCurrency		VARCHAR(3)
	DECLARE @MarexFirmId INT
	SET @MarexFirmId = [dbo].[udf_GetMarexFirmId]() 

	DECLARE trx_cursor CURSOR FOR
	SELECT	CME_AsgnRptID
		, Exchange	
		, OriginatingMemberName 
		, AccountCode
		, PhysicalCommodity
		, ContractType
		, PutCall
		, LongExpiryDate
		, ExercisePrice
		, QtyLong
		, QtyShort
		, Price
		, DateOfTradeChr
		, PositionType
		, BizDate
		, MarginingAccount
		, SettlementCurrency
	FROM #temp1

	OPEN trx_cursor

	-- Perform the first fetch and store the values in variables.
	-- Note: The variables are in the same order as the columns
	-- in the SELECT statement. 
	
	FETCH NEXT FROM trx_cursor
	INTO @CME_AsgnRptID
		, @Exchange	
		, @OriginatingMemberName
		, @AccountCode
		, @PhysicalCommodity
		, @ContractType
		, @PutCall
		, @LongExpiryDate
		, @ExercisePrice
		, @QtyLong
		, @QtyShort
		, @Price
		, @DateOfTradeChr
		, @PositionType
		, @BizDate
		, @MarginingAccount
		, @SettlementCurrency
		-- Check @@FETCH_STATUS to see if there are any more rows to fetch.
		WHILE @@FETCH_STATUS = 0
		BEGIN

	
		DECLARE @ExchangeCd			VARCHAR(25)
		DECLARE @FirmCd				VARCHAR(100)
		DECLARE @AccountCd			VARCHAR(100)
		DECLARE @InstrumentCd		VARCHAR(100)
		DECLARE @InstrumentTypeCd	VARCHAR(100)
		DECLARE @ExpYr				SMALLINT
		DECLARE @ExpMth				SMALLINT
		DECLARE @ExpDay				SMALLINT
		DECLARE @StrikePrice		DECIMAL(19,6)
		DECLARE @TrxTypeCd			VARCHAR(25)
		DECLARE @OptionTypeCd		VARCHAR(25)
		DECLARE @Quantity			DECIMAL(18,10)
		DECLARE	@QuantityLong		INT
		DECLARE @QuantityShort		INT
		DECLARE @AsOfDate			DATETIME
		DECLARE @DateOfTrade		DATETIME
		DECLARE @TrxDate			DATETIME
		DECLARE @PriceDec			DECIMAL(19,4)
		DECLARE @Volume				DECIMAL(18,10)
		DECLARE @CurrencyId			INT		
		DECLARE @InstrumentId		INT		
		DECLARE @TickSize			INT		
		DECLARE @GenericContractType VARCHAR(1)
		DECLARE @StrikePriceDivisor DECIMAL(19,4)
		DECLARE @PriceDivisor		DECIMAL(19,4)
		
		SET @ExchangeCd = @Exchange
	
		SET @Output = NULL
		DECLARE @InstrumentTypeId INT

		SET @InstrumentTypeCd = 
			CASE @ContractType
				WHEN ''FUT'' THEN ''F''
				WHEN ''OOF'' THEN ''O''
				WHEN ''OPT'' THEN ''O''
				WHEN ''OOC'' THEN ''O''
			END

		EXEC @ReturnValue = ib_Instrumenttype_AddAsNeeded @DataSourceId,@InstrumentTypeCd,@OutPut output
		SET @InstrumentTypeId = @Output
		SET @CurrencyId = NULL
		IF @SettlementCurrency IS NOT NULL
			BEGIN
				EXEC @ReturnValue = [ib_Currency_AddAsNeeded] @DataSourceId, @SettlementCurrency, @Output output
				SET @CurrencyId = @Output
			END
		SET @Output = NULL
		SET @Output2 = NULL
		
		SET @InstrumentCd = @InstrumentTypeCd + ''_'' + @ExchangeCd + ''_'' + @PhysicalCommodity
				
		EXEC @ReturnValue= [ib_Instrument_AddAsNeeded] @DataSourceId,@InstrumentTypeId,@InstrumentCd,@CurrencyId,@OutPut output,@Output2 output	
		SET @InstrumentId = @Output
		SET @CurrencyId = @Output2
		IF @Output2 = NULL
			BEGIN
				SET @CurrencyId = @DefaultCurrencyId
			END
		
		SET @TickSize = NULL
		SELECT @TickSize = TickSize FROM ib_Instrument WHERE InstrumentId = @InstrumentId

		SET @FirmCd = @OriginatingMemberName
		SET @AccountCd = @AccountCode
		IF @MarginingAccount IS NOT NULL
			SET @AccountCd = @AccountCd + ''-'' + CAST(@MarginingAccount AS VARCHAR(1))	
		SET @StrikePriceDivisor = NULL
		SET @PriceDivisor = NULL

		SELECT @StrikePriceDivisor = StrikePriceDivisor
			, @PriceDivisor = PriceDivisor
		FROM [dbo].[ib_InstrumentDataSource]
		WHERE DataSourceId = @DataSourceId
			AND DataSourceInstrumentCode = @InstrumentCd 

		IF @PriceDivisor IS NULL 
			SET @PriceDivisor = 1
			
		IF @StrikePriceDivisor IS NULL -- then get the default
			BEGIN
				DECLARE @ExchangeId INT
				SELECT @ExchangeId = ExchangeId FROM ib_Exchange WHERE [Code] = @ExchangeCd
				
				SET @StrikePriceDivisor = [dbo].[udf_GetDefaultStrikePriceDivisor](@DataSourceId, @ExchangeId)
			END

		SET @StrikePrice = (@ExercisePrice/@StrikePriceDivisor)
		
		SET @TrxTypeCd = @PositionType
		
		-- Set Option Type Code
		SET @OptionTypeCd = 
			CASE @PutCall
				WHEN 0 THEN ''P''
				WHEN 1 THEN ''C''
			END 
		
		SET @Volume = 0
		
		SET @Volume = 
			CASE 
				WHEN @QtyLong > 0 THEN @QtyLong
				WHEN @QtyShort > 0 THEN @QtyShort		
			END

		
		SET @ExpYr = LEFT(@LongExpiryDate,4)
		SET @ExpMth = SUBSTRING(@LongExpiryDate,5,2)
		SET @ExpDay = CASE WHEN RIGHT(@LongExpiryDate,2) LIKE ''w%'' THEN 0 ELSE SUBSTRING(@LongExpiryDate,7,2) + 0 END
		SET @ExpDay = dbo.udf_OnLoad_ExpiryDate_Get_Day(@ExpYr,@ExpMth,@ExpDay)

		-- Set AsOfDate	
		SET @AsOfDate = [dbo].[GetDateFromIceBizDt] (@BizDate)
		SET @DateOfTrade = [dbo].[GetDateFromIceBizDt] (@DateOfTradeChr)
		
		SET @TrxDate = DATEADD(d
			, (CONVERT(INT, @AsOfDate) - CONVERT(INT, @DateOfTrade)) * -1
			, @AsOfDate
			)

		IF @PositionType IN (''OXP'', ''AS'', ''FXP'', ''EX'', ''DC'')-- Was(''T'', ''J'', ''H'', ''R'', ''A'', ''E'', ''B'')
		BEGIN
			SET @Volume = @Volume * (-1)
			SET @QtyLong = @QtyLong * (-1)
			SET @QtyShort = @QtyShort * (-1)
		END
		
		IF @PositionType IN (''OXP'', ''AS'', ''EX'', ''FXP'') -- Was ''J'', ''A'', ''E''
			SET @PriceDec = 0
		ELSE
			SET @PriceDec = CONVERT(DECIMAL(24,10), @Price) / @PriceDivisor
			
		-- Set Generic Contract Type
		IF (@ContractType IS NOT NULL AND @ContractType = ''FUT'')
			SET @GenericContractType = ''F''
		ELSE
			SET @GenericContractType = ''O''
						
		SET @Quantity = @Volume
		SET @QuantityLong = @QtyLong
		SET @QuantityShort = @QtyShort
				
		DECLARE @TrxId INT
		SET @TrxId = NULL

		EXEC [ib_Trx_Load]
		@DataSourceCode
		, @ExchangeCd
		, @FirmCd
		, @AccountCd
		, NULL
		, @InstrumentCd
		, @ExpYr
		, @ExpMth
		, @ExpDay
		, @StrikePrice
		, @TrxTypeCd
		, @OptionTypeCd
		, @Quantity
		, @TrxDate
		, @PriceDec
		, @CME_AsgnRptID
		, @GenericContractType
		, @AsOfDate
		, @LocationPath = @LocationPath
		, @CurrencyCd = @SettlementCurrency
		, @MarexFirmId = @MarexFirmId
		, @TrxId = @TrxId OUTPUT
		, @QuantityLong = @QuantityLong 
		, @QuantityShort = @QuantityShort
		, @ReceiveLocationSysId = @ReceiveLocationSysId
		, @RunId = @RunId

		-- Flip processed flag in source table.
		UPDATE stage.CME_AsgnRpt
		SET LoadState = 2
		WHERE CME_AsgnRptID = @CME_AsgnRptID
		AND LoadState = 1
		
		IF @TrxId IS NOT NULL AND @TrxId > 0
			SET @AddCount = @AddCount + 1
		
		SET @ProcessedCount = @ProcessedCount + 1

		FETCH NEXT FROM trx_cursor
		INTO @CME_AsgnRptID
		, @Exchange	
		, @OriginatingMemberName
		, @AccountCode
		, @PhysicalCommodity
		, @ContractType
		, @PutCall
		, @LongExpiryDate
		, @ExercisePrice
		, @QtyLong
		, @QtyShort
		, @Price
		, @DateOfTradeChr
		, @PositionType
		, @BizDate
		, @MarginingAccount
		, @SettlementCurrency
		END

	CLOSE trx_cursor
	DEALLOCATE trx_cursor


		-- Now update Assignment Report Items not processed
		UPDATE stage.CME_AsgnRpt
		SET LoadState = 2
		WHERE LoadState = 1 AND [FileName] = @LocationPath
		AND NOT (
			PosQtyType IN (''AS'',''DC'', ''EX'', ''FXP'')
			OR (PosQtyType IN (''OXP'') AND (QtyLong > 0 OR QtyShort > 0))		
			)
		
		
	SET @Message = @DataSourceCode + '' Assignment Report loader ended ('' + CONVERT(VARCHAR(10), @ProcessedCount) + '' processed, '' 
		+ CONVERT(VARCHAR(10), @AddCount) + '' added)'' 
		
	EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @Message, ''Success'', '''', @RunId
		
	COMMIT TRANSACTION
		
	IF OBJECT_ID(''tempdb..#temp1'') IS NOT NULL 
	DROP TABLE #temp1
		
END TRY

BEGIN CATCH 

	IF XACT_STATE() = -1 
		ROLLBACK TRANSACTION
	
	SET @Message = @DataSourceCode + '' Assignment Report loader failed'' 		
	EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @Message, ''Error'', '''', @RunId
	
	EXEC [dbo].[sp_RethrowError]
		
END CATCH 

SET XACT_ABORT OFF
	
RETURN 0
');

GO
EXECUTE ('PRINT N''Creating [stage].[CME_Load]''
');

GO
EXECUTE ('CREATE PROCEDURE [stage].[CME_Load]
(
		@LocationPath VARCHAR(100)
		, @ReceiveLocationSysId INT
		, @RunId INT
)
AS
-- Description: Load rows for CME

-- History:
-- 29 Jul 2014	ED		EIB 25635 Creation

	SET NOCOUNT ON

	DECLARE @DataSourceCode VARCHAR(100)
	DECLARE @DataSourceId INT
	DECLARE @Code VARCHAR(100)
	DECLARE @ReturnValue INT
	DECLARE @Output INT
	DECLARE @Output2 INT
	DECLARE @DefaultCurrencyId INT
			
	--specify datasource in proc.
	SET @DataSourceCode = (SELECT d.Code FROM ib_DataSource d INNER JOIN ReceiveLocation rl ON rl.DataSourceId = d.DataSourceId WHERE ReceiveLocationSysId = @ReceiveLocationSysId)

	IF @LocationPath IS NULL SET @LocationPath = @DataSourceCode

	SET @Code = @DataSourceCode
	EXEC @ReturnValue= [_ib_DataSource_GetByCodeForOutput] @Code,@OutPut output,@Output2 output	
	SET @DataSourceId = @Output
	SET @DefaultCurrencyId = @Output2	
		
	DECLARE @Message VARCHAR(1024)
		
	-- Duplicate file check										
	DECLARE @IsFileAlreadyLoaded INT
	EXEC @IsFileALreadyLoaded = HasFileBeenLoaded @LocationPath, @DataSourceId

	IF @IsFileAlreadyLoaded = 1
	BEGIN
	
		UPDATE [stage].[CME_TrdCaptRpt]
		SET [LoadState] = 3
		WHERE [LoadState] = 1
		AND [Filename] = @LocationPath	
		
		UPDATE [stage].[CME_PosRpt]
		SET [LoadState] = 3
		WHERE [LoadState] = 1
		AND [Filename] = @LocationPath	
		
		UPDATE [stage].[CME_AsgnRpt]
		SET [LoadState] = 3
		WHERE [LoadState] = 1
		AND [Filename] = @LocationPath	

		RETURN
	END

	-- Now proceed with load
	EXEC stage.CME_TrdCaptRpt_Load @LocationPath, @ReceiveLocationSysId, @RunId
	EXEC stage.CME_PosRpt_Load @LocationPath, @ReceiveLocationSysId, @RunId
	EXEC stage.CME_AsgnRpt_Load @LocationPath, @ReceiveLocationSysId, @RunId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[DGCX_Transaction_LoadStateChange]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[DGCX_Transaction_LoadStateChange] 
	(
		@OldLoadState	TINYINT,
		@NewLoadState	TINYINT
	)
AS

-- Description: Changes the LoadState of the DGCX_Transaction type table

-- 13 Apr 2012	AAJM	Creation

BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

		UPDATE [dbo].[DGCX_Transaction] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[RBC_Position_Add]''
');

GO
EXECUTE ('

-- =============================================
-- 23 Apr 2014  ED  EIB 25559
-- Description:	Insert into RBC_Position table
--
-- Revision History
--

-- =============================================
CREATE PROCEDURE [dbo].[RBC_Position_Add]
	-- Add the parameters for the stored procedure here
	(
	@Filename				varchar(512)=NULL,	
	@Ledger					varchar(7)=NULL,
	@HostCurrency			varchar(21)=NULL,
	@BaseCurrency			varchar(3)=NULL,
	@Market					varchar(5)=NULL,
	@MarketCode				varchar(5)=NULL,
	@HostInstrument			varchar(21)=NULL,
	@PromptDate				varchar(8)=NULL,
	@TradeType				varchar(4)=NULL,
	@Series					varchar(6)=NULL,
	@Lots					varchar(21)=NULL,
	@PremiumRate			varchar(21)=NULL,
	@Price					varchar(21)=NULL,
	@MarketRate				varchar(21)=NULL,
	@Margin					varchar(21)=NULL,
	@Strike					VARCHAR(7)=NULL
    )
AS
BEGIN
	-- SET NOCOUNT ON added4 to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

  INSERT INTO [dbo].[RBC_Position]
			( 
			[Ledger]
			,[HostCurrency] 
			,[BaseCurrency]
			,[Market] 
			,[MarketCode]
			,[HostInstrument] 
			,[PromptDate]
			,[TradeType] 
			,[Series]
			,[Lots]
			,[PremiumRate]
			,[Price] 
			,[Filename]
			,[MarketRate]
			,[Margin]
			,[Strike]
			)
    VALUES
			( 
			@Ledger,
			@HostCurrency,
			@BaseCurrency,
			@Market,
			@MarketCode,
			@HostInstrument,
			@PromptDate,
			@TradeType,
			@Series,
			@Lots,
			@PremiumRate,
			@Price,
			@Filename,
			@MarketRate,
			@Margin,
			@Strike
			)
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Site_GetCodeAndIdForAllSites]''
');

GO
EXECUTE ('   /*
<details>
 <summary>Returns code and id columns for all the Sites</summary>
 <created author="laurentiu.macovei" date="Sat, 30 Sep 2006 05:03:50 GMT"/>
</details>
*/
create PROCEDURE [dbo].[ib_Site_GetCodeAndIdForAllSites]
AS
SET NOCOUNT ON
SELECT Code, SiteId 
	FROM ib_Site
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_GMI_EXTF1_Load]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_GMI_EXTF1_Load]
(
		@LocationPath VARCHAR(100)
		, @ReceiveLocationSysId INT
		, @RunId INT
)
AS
SET NOCOUNT ON
	--	08 Mar 2010		AAJM	Creation (MBAL-14813)
	--  09 Jan 2014		ED		EIB 25004 - remove importLog table and use Log table		
	-- There really isn''t any need for orchestration to call a LoadStateChange anymore
	-- since we only process rows for single file now
	-- but to keep consistent with other loaders - we''ll update to LoadState 1 at 
	-- start of this Load stored procedure
	UPDATE GMI_EXTF1
	SET LoadState = 1
	WHERE LoadState = 0
		AND Filename = @LocationPath
		
	DECLARE @Message VARCHAR(1024)
	DECLARE @DataSourceCode  AS VARCHAR(100)
	
	--Set the Datasource	
	EXEC [ib_GMI_GetDataSource] @LocationPath, @DataSourceCode Output

	DECLARE @DataSourceId INT
	DECLARE @DefaultCurrencyId INT
	EXEC [_ib_DataSource_GetByCodeForOutput] @DataSourceCode, @DataSourceId output, @DefaultCurrencyId output
	
	-- Duplicate file check										
	DECLARE @IsFileAlreadyLoaded INT
	EXEC @IsFileALreadyLoaded = HasFileBeenLoaded @LocationPath, @DataSourceId

	IF @IsFileAlreadyLoaded = 1
	BEGIN
	
		UPDATE [GMI_EXTF1]
		SET [LoadState] = 3
		WHERE [LoadState] = 1
		AND [Filename] = @LocationPath	
		
		RETURN
	END

	-- Now proceed with load
	EXEC ib_GMI_EXTF1_Trx_Load @LocationPath, @DataSourceId, @DataSourceCode, @ReceiveLocationSysId, @RunId
	EXEC ib_GMI_EXTF1_Position_Load @LocationPath, @DataSourceId, @DataSourceCode, @ReceiveLocationSysId, @RunId

	-- Set LoadState for all non-processed records
	UPDATE [GMI_EXTF1]
		SET [LoadState] = 2
		WHERE [LoadState] = 1
		AND [Filename] = @LocationPath
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_DataSource_GetDefaultStrikePriceDivisorById]''
');

GO
EXECUTE ('
/*
Developer:  Lee Manifold
Date:		02 Feb 2007
Version:	1.1
Revision History:
Version		Date			Author			Description
*/
CREATE PROCEDURE [dbo].[ib_DataSource_GetDefaultStrikePriceDivisorById]
(
	@DataSourceId				INT,
	@DefaultStrikePriceDivisor	DECIMAL(19,6) OUTPUT
)
AS 
SET NOCOUNT ON

	SELECT	@DefaultStrikePriceDivisor = [DefaultStrikePriceDivisor]

	FROM	[dbo].[ib_DataSource]

	WHERE	[DataSourceId] = @DataSourceId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Instrument_GetIsApprovedById]''
');

GO
EXECUTE ('/*
=============================================
Author:			Lee Manifold
Create date:	22 Dec 2006
Description:	Retrieves the IsApproved value for a particular 	
				instrumentId		
==============================================
*/
CREATE PROCEDURE [dbo].[ib_Instrument_GetIsApprovedById]
	(	
	@InstrumentId	int,
	@IsApproved		bit output			
 	)
AS
SET NOCOUNT ON

	BEGIN TRY
		SELECT	@IsApproved = [IsApproved]
		FROM	[dbo].[ib_Instrument]
		WHERE	[InstrumentId] = @InstrumentId
	END TRY
	BEGIN CATCH
		EXEC [dbo].[sp_RethrowError]
	END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[DGCX_Transaction_Purge]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[DGCX_Transaction_Purge] 
	(
		@LoadState		TINYINT = 0,
		@FileName       VARCHAR (512)= NULL
	)
AS
-- Description: Deletes from DGCX_Transaction table all the records where the LoadState is 0

-- 13 Apr 2012	AAJM	Creation

-- History:

BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
		DELETE FROM [dbo].[DGCX_Transaction] WHERE LoadState= @LoadState AND [FileName] = Coalesce(@FileName, [FileName])

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[RBC_Position_LoadStateChange]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[RBC_Position_LoadStateChange] 
	(
		@OldLoadState	TINYINT,
		@NewLoadState	TINYINT
	)
AS

-- Description: Changes the LoadState of the RBC_Position type table

-- 13 Apr 2012	AAJM	Creation

BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

		UPDATE [dbo].[RBC_Position] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Site_GetSites]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Site_GetSites]
AS
SET NOCOUNT ON
	SELECT
		SiteId,Code, Name
	FROM
		ib_Site
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_MatchCode_Delete]''
');

GO
EXECUTE ('
CREATE PROCEDURE [dbo].[ib_MatchCode_Delete]
(
	 @MatchCodeId int
)
AS
SET NOCOUNT ON
 /*
<details>
 <summary>Deletes a Match Code by its id from the ib_MatchCode table</summary>
 <created author="Alister McLeod" Date="Monday, 29 Mar 2010 14:57" /> 
</details>
*/

DELETE FROM [dbo].[ib_MatchCode]
      WHERE MatchCodeId = @MatchCodeId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_ICE_Load]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_ICE_Load]
(
		@LocationPath VARCHAR(100)
		, @ReceiveLocationSysId INT
		, @RunId INT
)
AS
SET NOCOUNT ON
	--	12 July 2010		AAJM	Creation (MBAL-14813)
	--  09 Jan 2014		    ED		EIB 25004 - remove importLog table and use Log table
	--  28 Jul 2014			ED		EIB 25628 - get DataSource from ReceiveLocation

	DECLARE @DataSourceCode VARCHAR(100)
	DECLARE @DataSourceId INT
	DECLARE @Code VARCHAR(100)
	DECLARE @ReturnValue INT
	DECLARE @Output INT
	DECLARE @Output2 INT
	DECLARE @DefaultCurrencyId INT
			
	--specify datasource in proc.
	SET @DataSourceCode = (SELECT d.Code FROM ib_DataSource d INNER JOIN ReceiveLocation rl ON rl.DataSourceId = d.DataSourceId WHERE ReceiveLocationSysId = @ReceiveLocationSysId)

	IF @LocationPath IS NULL SET @LocationPath = @DataSourceCode

	SET @Code = @DataSourceCode
	EXEC @ReturnValue= [_ib_DataSource_GetByCodeForOutput] @Code,@OutPut output,@Output2 output	
	SET @DataSourceId = @Output
	SET @DefaultCurrencyId = @Output2	
		
	DECLARE @Message VARCHAR(1024)
		
	-- Duplicate file check										
	DECLARE @IsFileAlreadyLoaded INT
	EXEC @IsFileALreadyLoaded = HasFileBeenLoaded @LocationPath, @DataSourceId

	IF @IsFileAlreadyLoaded = 1
	BEGIN
	
		UPDATE [dbo].[ICE_TrdCaptRpt]
		SET [LoadState] = 3
		WHERE [LoadState] = 1
		AND [Filename] = @LocationPath	
		
		UPDATE [dbo].[ICE_PosRpt]
		SET [LoadState] = 3
		WHERE [LoadState] = 1
		AND [Filename] = @LocationPath	
		
		UPDATE [dbo].[ICE_AsgnRpt]
		SET [LoadState] = 3
		WHERE [LoadState] = 1
		AND [Filename] = @LocationPath	

		RETURN
	END

	-- Now proceed with load
	EXEC ib_ICE_TrdCaptRpt_Load @LocationPath, @ReceiveLocationSysId, @RunId
	EXEC ib_ICE_PosRpt_Load @LocationPath, @ReceiveLocationSysId, @RunId
	EXEC ib_ICE_AsgnRpt_Load @LocationPath, @ReceiveLocationSysId, @RunId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_DataSource_GetFilesForRollbackByDataSource]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_DataSource_GetFilesForRollbackByDataSource]
	@DataSourceId INT 
AS
SET NOCOUNT ON
--  23 Feb 2010		KevinP	Added. This will only return a list of Files for F&O ONLY.
--	29 Apr 2010		Anilk	MBAL-13689: new NT file
--	16 Jul 2010		AAJM	MBAL-14903: Add ICE File
--  12 Aug 2010		AAJM	MBAL-16441: Rollback AsOfDate incorrect, conflicting temp table records
--	21 Dec 2010		amk		MBAL-17193: Support new US R&N data source
--	14 Jan 2011		amk		MBAL-17240: Support new datasources: ADM2, RNU2, RNG2
--	18 Jan 2011		amk		MBAL-17368: Speed up display particularly for R&N
--	02 Mar 2011		amk		MBAL-17728: BUG FIX - when joining ib_ImportFile can be multiple records 
--							for same filename/datasource since we don''t purge - only look at last one
--  07 Apr 2011		AAJM	MBAL-17385: Rollback for Credit Suisse
--  29 Apr 2012		AAJM	MBAL-20388: Rollback for DGCX
--	16 May 2012		ED		ADD new datasource - RNOT
--  08 Jun 2012		ED		MBAL 20978 - improve query for R&N
--	11 Jul 2012		ED		MBAL 21156 - add new datasource, RNIN and RNBB
--	13 Jul 2012		AAJM	MBAL 21156 - Change RNBB datasource to RNST

--	09 Sept 2012	ED		MBAL 21133 - ADD new datasource - BZ
--  10 Oct 2012		AAJM	MBAL-21845 - Update BZ datasource for new structure
--  15 Jan 2013		MJP		MBAL-22632 - Add new LIFFE datasource
--  18 Mar 2013		MJP		MBAL-22980 - Add NLX datasource
--  08 May 2013		MJP		MBAL-23171 - Add Eurex to adapter framework
--  23 Apr 2014		ED		EIB 25559 - add RBC
--  23 Jun 2014		ED		EIB 25762 - add LME
--  29 Jul 2014		ED		EIB 25855 - add ICE US and CME US
--  20 Aug 2014		ED		EIB 25894  - add OTCM
--  29 Oct 2014		ED		EIB 26162  - allow to rollback empty R&N files
--  30 Oct 2014		ED		EIB 26166  - fix ICE/ICEUS list
--  07 Jan 2015		ED		EIB 26360  - allow to rollback empty files
--  21 Jan 2019		KR		IBAL-12  - add Rosenthal Collins Group
--	31 Jan 2019		KR		IBAL-24 - update US environment to rollabck RCG files based on RNUS data source code
BEGIN

DECLARE @DateDiff INT
SET @DateDiff = DATEDIFF(HOUR, GETUTCDATE(), GETDATE())

DECLARE @DataSourceCode VARCHAR(25)

SELECT @DataSourceCode = [Code]
FROM ib_DataSource
WHERE DataSourceId = @DataSourceId

--Clearing21
IF @DataSourceCode = ''Clearing21''
BEGIN
	SELECT tmp.DataSourceId, tmp.[FileName] AS [FileName]
		, MIN(tmp.StartDateTime) AS StartDateTime, MAX(tmp.EndDateTime) AS EndDateTime
		, ISNULL(SUM(tmp.RecordCount), 0) AS RecordCount, MIN(tmp.AsOfDate) AS AsOfDate
	FROM (
		SELECT DISTINCT @DataSourceId AS DataSourceId, f.[FileName]
			, ISNULL(MIN(tmpPos.StartDateTime), MIN(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS StartDateTime, ISNULL(MAX(EndDateTime), MAX(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS EndDateTime
			, MIN(RecordCount) AS RecordCount, MIN(f.AsOfDate) AS AsOfDate
		FROM ib_ImportFile f
				INNER JOIN LOG l ON l.FileName = f.Filename
				LEFT JOIN (SELECT FileName, MIN(tmpPos.CreateDate) AS StartDateTime, MAX(tmpPos.CreateDate) AS EndDateTime , COUNT(*) AS RecordCount 
									FROM [dbo].[C21_ResumeLine] tmpPos 
								GROUP BY Filename) tmpPos 
						ON f.Filename = tmpPos.Filename
				WHERE 
					f.ImportFileId = (SELECT TOP 1 ImportFileId FROM ib_ImportFile f2 WHERE f2.filename = f.filename AND f2.DataSourceId = @DataSourceId ORDER BY CreateDate DESC)
					AND l.RunId = (SELECT TOP 1 RunId FROM LOG l2 WHERE l2.FileName = l.FileName ORDER BY CreateDateTimeUtc DESC)
					AND f.DataSourceId = @DataSourceId
		GROUP BY f.[FileName]
		UNION
		SELECT DISTINCT @DataSourceId AS DataSourceId, f.[FileName]
			, ISNULL(MIN(tmpTrx1.StartDateTime), MIN(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS StartDateTime, ISNULL(MAX(EndDateTime), MAX(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS EndDateTime
			, MIN(RecordCount) AS RecordCount, MIN(f.AsOfDate) AS AsOfDate
		FROM ib_ImportFile f
			INNER JOIN LOG l ON l.FileName = f.Filename
			LEFT JOIN (SELECT FileName, MIN(tmpTrx1.CreateDate) AS StartDateTime, MAX(tmpTrx1.CreateDate) AS EndDateTime , COUNT(*) AS RecordCount
							FROM [dbo].[C21_DetailLine] tmpTrx1 
						GROUP BY Filename) tmpTrx1
				ON f.Filename = tmpTrx1.Filename
		WHERE f.ImportFileId = (SELECT TOP 1 ImportFileId FROM ib_ImportFile f2 WHERE f2.filename = f.filename AND f2.DataSourceId = @DataSourceId ORDER BY CreateDate DESC)
				AND l.RunId = (SELECT TOP 1 RunId FROM LOG l2 WHERE l2.FileName = l.FileName ORDER BY CreateDateTimeUtc DESC)
				AND  f.DataSourceId = @DataSourceId
		GROUP BY f.[FileName]
	--DO NOT TRY TO GET DATA FROM PreviousDayLine!! ITS ALL BOGUS, AND IS NEVER USED.
	) tmp 
	GROUP BY tmp.DataSourceId, tmp.[FileName]
END

-- Hong Kong Futures Exchange
IF @DataSourceCode = ''HKFE''
BEGIN
	SELECT tmp.DataSourceId, tmp.[FileName] AS [FileName]
		, MIN(tmp.StartDateTime) AS StartDateTime, MAX(tmp.EndDateTime) AS EndDateTime
		, ISNULL(SUM(tmp.RecordCount), 0) AS RecordCount, MIN(tmp.AsOfDate) AS AsOfDate
	FROM (
		SELECT DISTINCT @DataSourceId AS DataSourceId, f.[FileName]
			, ISNULL(MIN(tmpPos.StartDateTime), MIN(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS StartDateTime, ISNULL(MAX(EndDateTime), MAX(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS EndDateTime
			, MIN(RecordCount) AS RecordCount, MIN(f.AsOfDate) AS AsOfDate
		FROM ib_ImportFile f
				INNER JOIN LOG l ON l.FileName = f.Filename
				LEFT JOIN (SELECT FileName, MIN(tmpPos.CreateDate) AS StartDateTime, MAX(tmpPos.CreateDate) AS EndDateTime , COUNT(*) AS RecordCount 
									FROM [dbo].[HKFE_TP001_Type01] tmpPos 
								GROUP BY Filename) tmpPos 
						ON f.Filename = tmpPos.Filename
				WHERE 
					f.ImportFileId = (SELECT TOP 1 ImportFileId FROM ib_ImportFile f2 WHERE f2.filename = f.filename AND f2.DataSourceId = @DataSourceId ORDER BY CreateDate DESC)
					AND l.RunId = (SELECT TOP 1 RunId FROM LOG l2 WHERE l2.FileName = l.FileName ORDER BY CreateDateTimeUtc DESC)
					AND f.DataSourceId = @DataSourceId
		GROUP BY f.[FileName]
		UNION
		SELECT DISTINCT @DataSourceId AS DataSourceId, f.[FileName]
			, ISNULL(MIN(tmpTrx1.StartDateTime), MIN(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS StartDateTime, ISNULL(MAX(EndDateTime), MAX(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS EndDateTime
			, MIN(RecordCount) AS RecordCount, MIN(f.AsOfDate) AS AsOfDate
		FROM ib_ImportFile f
			INNER JOIN LOG l ON l.FileName = f.Filename
			LEFT JOIN (SELECT FileName, MIN(tmpTrx1.CreateDate) AS StartDateTime, MAX(tmpTrx1.CreateDate) AS EndDateTime , COUNT(*) AS RecordCount
							FROM [dbo].[HKFE_TP001_Type02] tmpTrx1 
						GROUP BY Filename) tmpTrx1
				ON f.Filename = tmpTrx1.Filename
		WHERE f.ImportFileId = (SELECT TOP 1 ImportFileId FROM ib_ImportFile f2 WHERE f2.filename = f.filename AND f2.DataSourceId = @DataSourceId ORDER BY CreateDate DESC)
				AND l.RunId = (SELECT TOP 1 RunId FROM LOG l2 WHERE l2.FileName = l.FileName ORDER BY CreateDateTimeUtc DESC)
				AND  f.DataSourceId = @DataSourceId
		GROUP BY f.[FileName]
	) tmp 
	GROUP BY tmp.DataSourceId, tmp.[FileName]
END

-- LCH aka Liffe

	-- IMPORTANT NOTE 
	-- re. Recognition of Temp Records where Transactions are sourced from multiple temp				-- tables for a single datasource.
	-- Only way to differential TR trx''s against NT trx''s is to assume TrxTypeCode is 
	-- exactly one character for NT and longer for TR. 
	-- Otherwise might delete other one''s rows since TempTableRecordId''s may overlap
	-- and same target table (ib_Trx)
		
IF @DataSourceCode = ''LCH''
BEGIN
	SELECT tmp.DataSourceId, tmp.[FileName] AS [FileName]
		, MIN(tmp.StartDateTime) AS StartDateTime, MAX(tmp.EndDateTime) AS EndDateTime
		, ISNULL(SUM(tmp.RecordCount), 0) AS RecordCount, MIN(tmp.AsOfDate) AS AsOfDate
	FROM (
		SELECT DISTINCT @DataSourceId AS DataSourceId, f.[FileName]
			, ISNULL(MIN(tmpPos.StartDateTime), MIN(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS StartDateTime, ISNULL(MAX(EndDateTime), MAX(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS EndDateTime
			, MIN(RecordCount) AS RecordCount, MIN(f.AsOfDate) AS AsOfDate
		FROM ib_ImportFile f
				INNER JOIN LOG l ON l.FileName = f.Filename
				LEFT JOIN (SELECT FileName, MIN(tmpPos.CreateDate) AS StartDateTime, MAX(tmpPos.CreateDate) AS EndDateTime , COUNT(*) AS RecordCount 
									FROM [dbo].[LCH_TypePS_0101] tmpPos 
									LEFT JOIN [dbo].[ib_Position] pos ON tmpPos.LCH_TypePS_0101_ID = pos.[TempTableRecordId] 
											AND pos.DataSourceId = @DataSourceId	
								GROUP BY Filename) tmpPos 
						ON f.Filename = tmpPos.Filename
				WHERE 
					f.ImportFileId = (SELECT TOP 1 ImportFileId FROM ib_ImportFile f2 WHERE f2.filename = f.filename AND f2.DataSourceId = @DataSourceId ORDER BY CreateDate DESC)
					AND l.RunId = (SELECT TOP 1 RunId FROM LOG l2 WHERE l2.FileName = l.FileName ORDER BY CreateDateTimeUtc DESC)
					AND f.DataSourceId = @DataSourceId
		GROUP BY f.[FileName]
	UNION
		SELECT DISTINCT @DataSourceId AS DataSourceId, f.[FileName]
			, ISNULL(MIN(tmpTrx1.StartDateTime), MIN(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS StartDateTime, ISNULL(MAX(EndDateTime), MAX(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS EndDateTime
			, MIN(RecordCount) AS RecordCount, MIN(f.AsOfDate) AS AsOfDate
		FROM ib_ImportFile f
			INNER JOIN LOG l ON l.FileName = f.Filename
			LEFT JOIN (SELECT FileName, MIN(tmpTrx1.CreateDate) AS StartDateTime, MAX(tmpTrx1.CreateDate) AS EndDateTime , COUNT(*) AS RecordCount
							FROM dbo.[LCH_TypeTR]  tmpTrx1 
							LEFT JOIN [dbo].[ib_Trx] trx1 ON tmpTrx1.LIFFE_TRID = trx1.[TempTableRecordId] 
								AND trx1.DataSourceId = @DataSourceId
								AND LEN(trx1.TrxTypeCode) > 1
							GROUP BY Filename) tmpTrx1
				ON f.Filename = tmpTrx1.Filename
		WHERE f.ImportFileId = (SELECT TOP 1 ImportFileId FROM ib_ImportFile f2 WHERE f2.filename = f.filename AND f2.DataSourceId = @DataSourceId ORDER BY CreateDate DESC)
				AND l.RunId = (SELECT TOP 1 RunId FROM LOG l2 WHERE l2.FileName = l.FileName ORDER BY CreateDateTimeUtc DESC)
				AND  f.DataSourceId = @DataSourceId
		GROUP BY f.[FileName]
	UNION
		SELECT DISTINCT @DataSourceId AS DataSourceId, f.[FileName]
			, ISNULL(MIN(tmpTrx1.StartDateTime), MIN(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS StartDateTime, ISNULL(MAX(EndDateTime), MAX(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS EndDateTime
			, MIN(RecordCount) AS RecordCount, MIN(f.AsOfDate) AS AsOfDate
		FROM ib_ImportFile f
			INNER JOIN LOG l ON l.FileName = f.Filename
			LEFT JOIN (SELECT FileName, MIN(tmpTrx1.CreateDate) AS StartDateTime, MAX(tmpTrx1.CreateDate) AS EndDateTime , COUNT(*) AS RecordCount
							FROM dbo.[LCH_TypeNT]  tmpTrx1 
							LEFT JOIN [dbo].[ib_Trx] trx1 ON tmpTrx1.lch_typentID = trx1.[TempTableRecordId] 
								AND trx1.DataSourceId = @DataSourceId
								AND LEN(trx1.TrxTypeCode) = 1
							GROUP BY Filename) tmpTrx1
				ON f.Filename = tmpTrx1.Filename
		WHERE f.ImportFileId = (SELECT TOP 1 ImportFileId FROM ib_ImportFile f2 WHERE f2.filename = f.filename AND f2.DataSourceId = @DataSourceId ORDER BY CreateDate DESC)
				AND l.RunId = (SELECT TOP 1 RunId FROM LOG l2 WHERE l2.FileName = l.FileName ORDER BY CreateDateTimeUtc DESC)
				AND  f.DataSourceId = @DataSourceId
		GROUP BY f.[FileName]
	) tmp 
	GROUP BY tmp.DataSourceId, tmp.[FileName]
END

-- Liffe
IF @DataSourceCode = ''LIFFE''
BEGIN
	SELECT tmp.DataSourceId, tmp.[FileName] AS [FileName]
		, MIN(tmp.StartDateTime) AS StartDateTime, MAX(tmp.EndDateTime) AS EndDateTime
		, ISNULL(SUM(tmp.RecordCount), 0) AS RecordCount, MIN(tmp.AsOfDate) AS AsOfDate
	FROM (
		SELECT DISTINCT @DataSourceId AS DataSourceId, f.[FileName]
			, ISNULL(MIN(tmpPos.StartDateTime), MIN(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS StartDateTime, ISNULL(MAX(EndDateTime), MAX(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS EndDateTime
			, MIN(RecordCount) AS RecordCount, MIN(f.AsOfDate) AS AsOfDate
		FROM ib_ImportFile f
				INNER JOIN LOG l ON l.FileName = f.Filename
				LEFT JOIN (SELECT FileName, MIN(tmpPos.CreateDate) AS StartDateTime, MAX(tmpPos.CreateDate) AS EndDateTime , COUNT(*) AS RecordCount 
									FROM [dbo].[Liffe_Position] tmpPos 
									LEFT JOIN [dbo].[ib_Position] pos ON tmpPos.Liffe_PositionId = pos.[TempTableRecordId] 
											AND pos.DataSourceId = @DataSourceId	
								GROUP BY Filename) tmpPos 
						ON f.Filename = tmpPos.Filename
				WHERE 
					f.ImportFileId = (SELECT TOP 1 ImportFileId FROM ib_ImportFile f2 WHERE f2.filename = f.filename AND f2.DataSourceId = @DataSourceId ORDER BY CreateDate DESC)
					AND l.RunId = (SELECT TOP 1 RunId FROM LOG l2 WHERE l2.FileName = l.FileName ORDER BY CreateDateTimeUtc DESC)
					AND f.DataSourceId = @DataSourceId
		GROUP BY f.[FileName]
	UNION
		SELECT DISTINCT @DataSourceId AS DataSourceId, f.[FileName]
			, ISNULL(MIN(tmpTrx1.StartDateTime), MIN(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS StartDateTime, ISNULL(MAX(EndDateTime), MAX(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS EndDateTime
			, MIN(RecordCount) AS RecordCount, MIN(f.AsOfDate) AS AsOfDate
		FROM ib_ImportFile f
			INNER JOIN LOG l ON l.FileName = f.Filename
			LEFT JOIN (SELECT FileName, MIN(tmpTrx1.CreateDate) AS StartDateTime, MAX(tmpTrx1.CreateDate) AS EndDateTime , COUNT(*) AS RecordCount
							FROM dbo.[Liffe_TradeReport]  tmpTrx1 
							LEFT JOIN [dbo].[ib_Trx] trx1 ON tmpTrx1.Liffe_TradeReportId = trx1.[TempTableRecordId] 
								AND trx1.DataSourceId = @DataSourceId
								AND LEN(trx1.TrxTypeCode) > 1
							GROUP BY Filename) tmpTrx1
				ON f.Filename = tmpTrx1.Filename
		WHERE f.ImportFileId = (SELECT TOP 1 ImportFileId FROM ib_ImportFile f2 WHERE f2.filename = f.filename AND f2.DataSourceId = @DataSourceId ORDER BY CreateDate DESC)
				AND l.RunId = (SELECT TOP 1 RunId FROM LOG l2 WHERE l2.FileName = l.FileName ORDER BY CreateDateTimeUtc DESC)
				AND  f.DataSourceId = @DataSourceId
		GROUP BY f.[FileName]
	UNION
		SELECT DISTINCT @DataSourceId AS DataSourceId, f.[FileName]
			, ISNULL(MIN(tmpTrx1.StartDateTime), MIN(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS StartDateTime, ISNULL(MAX(EndDateTime), MAX(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS EndDateTime
			, MIN(RecordCount) AS RecordCount, MIN(f.AsOfDate) AS AsOfDate
		FROM ib_ImportFile f
			INNER JOIN LOG l ON l.FileName = f.Filename
			LEFT JOIN (SELECT FileName, MIN(tmpTrx1.CreateDate) AS StartDateTime, MAX(tmpTrx1.CreateDate) AS EndDateTime , COUNT(*) AS RecordCount
							FROM dbo.[Liffe_Notification]  tmpTrx1 
							LEFT JOIN [dbo].[ib_Trx] trx1 ON tmpTrx1.Liffe_NotificationId = trx1.[TempTableRecordId] 
								AND trx1.DataSourceId = @DataSourceId
								AND LEN(trx1.TrxTypeCode) = 1
							GROUP BY Filename) tmpTrx1
				ON f.Filename = tmpTrx1.Filename
		WHERE f.ImportFileId = (SELECT TOP 1 ImportFileId FROM ib_ImportFile f2 WHERE f2.filename = f.filename AND f2.DataSourceId = @DataSourceId ORDER BY CreateDate DESC)
				AND l.RunId = (SELECT TOP 1 RunId FROM LOG l2 WHERE l2.FileName = l.FileName ORDER BY CreateDateTimeUtc DESC)
				AND  f.DataSourceId = @DataSourceId
		GROUP BY f.[FileName]
	) tmp 
	GROUP BY tmp.DataSourceId, tmp.[FileName]
END

-- Eurex :- NB: There is NO Join to ib_Position or ib_Trx because it takes a Dogs age to return. Derive AsOfDate some other way
--NB2: Eurex has 1 table for both Transaction and Positions
IF @DataSourceCode = ''Eurex''
BEGIN
	SELECT DISTINCT @DataSourceId AS DataSourceId, tmp.[FileName]
		, MIN(tmp.CreateDate) AS StartDateTime, Max(tmp.CreateDate) AS EndDateTime
		, COUNT(*) AS RecordCount, MIN(rptPrntEffDat) AS AsOfDate
	FROM [dbo].[EU_CB010GRP] tmp
	WHERE tmp.[FileName] IS NOT NULL
	GROUP BY tmp.[FileName]
	UNION
	SELECT
		@DataSourceId AS DataSourceId,
		eib_StagingFile.[Path] AS [FileName],
		eib_StagingFile.CreateDate AS StartDateTime,
		eib_StagingFile.LoadDate AS EndDateTime,
		eib_StagingFile.RecordCount,
		eib_StagingFile.AsOfDate
	FROM
		eib_StagingFile
	WHERE
		eib_StagingFile.DataSourceID = @DataSourceID AND
		eib_StagingFile.[Status] IN (3 /* StagingFileStatus.Loaded */, 4 /* StagingFileStatus.Error */)
END

-- Broker aka Barclays
IF @DataSourceCode = ''Barclays''
BEGIN
	SELECT tmp.DataSourceId, tmp.[FileName] AS [FileName]
		, MIN(tmp.StartDateTime) AS StartDateTime, MAX(tmp.EndDateTime) AS EndDateTime
		, ISNULL(SUM(tmp.RecordCount), 0) AS RecordCount, MIN(tmp.AsOfDate) AS AsOfDate
	FROM (
		SELECT DISTINCT @DataSourceId AS DataSourceId, f.[FileName]
			, ISNULL(MIN(tmpPos.StartDateTime), MIN(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS StartDateTime, ISNULL(MAX(EndDateTime), MAX(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS EndDateTime
			, MIN(RecordCount) AS RecordCount, MIN(f.AsOfDate) AS AsOfDate
		FROM ib_ImportFile f
				INNER JOIN LOG l ON l.FileName = f.Filename
				LEFT JOIN (SELECT FileName, MIN(tmpPos.CreateDate) AS StartDateTime, MAX(tmpPos.CreateDate) AS EndDateTime , COUNT(*) AS RecordCount 
									FROM [dbo].[Broker_Position] tmpPos 
								GROUP BY Filename) tmpPos 
						ON f.Filename = tmpPos.Filename
				WHERE 
					f.ImportFileId = (SELECT TOP 1 ImportFileId FROM ib_ImportFile f2 WHERE f2.filename = f.filename AND f2.DataSourceId = @DataSourceId ORDER BY CreateDate DESC)
					AND l.RunId = (SELECT TOP 1 RunId FROM LOG l2 WHERE l2.FileName = l.FileName ORDER BY CreateDateTimeUtc DESC)
					AND f.DataSourceId = @DataSourceId
		GROUP BY f.[FileName]
		UNION
		SELECT DISTINCT @DataSourceId AS DataSourceId, f.[FileName]
			, ISNULL(MIN(tmpTrx1.StartDateTime), MIN(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS StartDateTime, ISNULL(MAX(EndDateTime), MAX(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS EndDateTime
			, MIN(RecordCount) AS RecordCount, MIN(f.AsOfDate) AS AsOfDate
		FROM ib_ImportFile f
			INNER JOIN LOG l ON l.FileName = f.Filename
			LEFT JOIN (SELECT FileName, MIN(tmpTrx1.CreateDate) AS StartDateTime, MAX(tmpTrx1.CreateDate) AS EndDateTime , COUNT(*) AS RecordCount
							FROM [dbo].[Broker_Transaction] tmpTrx1 
						GROUP BY Filename) tmpTrx1
				ON f.Filename = tmpTrx1.Filename
		WHERE f.ImportFileId = (SELECT TOP 1 ImportFileId FROM ib_ImportFile f2 WHERE f2.filename = f.filename AND f2.DataSourceId = @DataSourceId ORDER BY CreateDate DESC)
				AND l.RunId = (SELECT TOP 1 RunId FROM LOG l2 WHERE l2.FileName = l.FileName ORDER BY CreateDateTimeUtc DESC)
				AND  f.DataSourceId = @DataSourceId
		GROUP BY f.[FileName]
	) tmp 
	GROUP BY tmp.DataSourceId, tmp.[FileName]
END

-- CSA aka Credit Suisse
IF @DataSourceCode = ''CSA'' OR @DataSourceCode = ''CSNA''
BEGIN
	SELECT tmp.DataSourceId, tmp.[FileName] AS [FileName]
		, MIN(tmp.StartDateTime) AS StartDateTime, MAX(tmp.EndDateTime) AS EndDateTime
		, ISNULL(SUM(tmp.RecordCount), 0) AS RecordCount, MIN(tmp.AsOfDate) AS AsOfDate
	FROM (
		SELECT DISTINCT @DataSourceId AS DataSourceId, f.[FileName]
			, ISNULL(MIN(tmpPos.StartDateTime), MIN(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS StartDateTime, ISNULL(MAX(EndDateTime), MAX(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS EndDateTime
			, MIN(RecordCount) AS RecordCount, MIN(f.AsOfDate) AS AsOfDate
		FROM ib_ImportFile f
				INNER JOIN LOG l ON l.FileName = f.Filename
				LEFT JOIN (SELECT FileName, MIN(tmpPos.CreateDate) AS StartDateTime, MAX(tmpPos.CreateDate) AS EndDateTime , COUNT(*) AS RecordCount 
									FROM [dbo].[CreditSuisse_Position] tmpPos 
								GROUP BY Filename) tmpPos 
						ON f.Filename = tmpPos.Filename
				WHERE 
					f.ImportFileId = (SELECT TOP 1 ImportFileId FROM ib_ImportFile f2 WHERE f2.filename = f.filename AND f2.DataSourceId = @DataSourceId ORDER BY CreateDate DESC)
					AND l.RunId = (SELECT TOP 1 RunId FROM LOG l2 WHERE l2.FileName = l.FileName ORDER BY CreateDateTimeUtc DESC)
					AND f.DataSourceId = @DataSourceId
		GROUP BY f.[FileName]
		UNION
		SELECT DISTINCT @DataSourceId AS DataSourceId, f.[FileName]
			, ISNULL(MIN(tmpTrx1.StartDateTime), MIN(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS StartDateTime, ISNULL(MAX(EndDateTime), MAX(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS EndDateTime
			, MIN(RecordCount) AS RecordCount, MIN(f.AsOfDate) AS AsOfDate
		FROM ib_ImportFile f
			INNER JOIN LOG l ON l.FileName = f.Filename
			LEFT JOIN (SELECT FileName, MIN(tmpTrx1.CreateDate) AS StartDateTime, MAX(tmpTrx1.CreateDate) AS EndDateTime , COUNT(*) AS RecordCount
							FROM [dbo].[CreditSuisse_Transaction] tmpTrx1 
						GROUP BY Filename) tmpTrx1
				ON f.Filename = tmpTrx1.Filename
		WHERE f.ImportFileId = (SELECT TOP 1 ImportFileId FROM ib_ImportFile f2 WHERE f2.filename = f.filename AND f2.DataSourceId = @DataSourceId ORDER BY CreateDate DESC)
				AND l.RunId = (SELECT TOP 1 RunId FROM LOG l2 WHERE l2.FileName = l.FileName ORDER BY CreateDateTimeUtc DESC)
				AND  f.DataSourceId = @DataSourceId
		GROUP BY f.[FileName]
	) tmp 
	GROUP BY tmp.DataSourceId, tmp.[FileName]
END

-- RolfeNolan
IF @DataSourceCode = ''RolfeNolan'' OR @DataSourceCode = ''RNUS''  
	OR @DataSourceCode = ''RNU2'' OR @DataSourceCode = ''RNG2'' OR @DataSourceCode=''RNOT''
	OR @DataSourceCode=''RNIN'' OR @DataSourceCode=''RNST'' OR @DataSourceCode=''OTCM''
BEGIN

SELECT tmp.DataSourceId, tmp.[FileName] AS [FileName]
		, MIN(tmp.StartDateTime) AS StartDateTime, MAX(tmp.EndDateTime) AS EndDateTime
		, ISNULL(SUM(tmp.RecordCount), 0) AS RecordCount, MIN(tmp.AsOfDate) AS AsOfDate
	FROM (
		SELECT DISTINCT @DataSourceId AS DataSourceId, f.FileName
			, ISNULL(MIN(tmpPos.StartDateTime), MIN(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS StartDateTime, ISNULL(MAX(EndDateTime), MAX(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS EndDateTime
		    , MIN(RecordCount) AS RecordCount, MIN(f.AsOfDate) AS AsOfDate
		FROM ib_ImportFile f
		INNER JOIN LOG l ON l.FileName = f.Filename
		LEFT JOIN (SELECT FileName, MIN(tmpPos.CreateDate) AS StartDateTime, MAX(tmpPos.CreateDate) AS EndDateTime
					, COUNT(*) AS RecordCount
					FROM [dbo].[RolfeNolan_HOSTOPN] tmpPos GROUP BY Filename) tmpPos
				ON f.Filename = tmpPos.Filename
				WHERE
				f.ImportFileId = (SELECT TOP 1 ImportFileId FROM ib_ImportFile f2 WHERE f2.filename = f.filename AND f2.DataSourceId = @DataSourceId ORDER BY CreateDate DESC)
				 AND l.RunId = (SELECT TOP 1 RunId FROM LOG l2 WHERE l2.FileName = l.FileName ORDER BY CreateDateTimeUtc DESC)
				AND f.DataSourceId = @datasourceid
		GROUP BY f.Filename
	UNION
		SELECT DISTINCT @DataSourceId AS DataSourceId, f.[FileName]
			, ISNULL(MIN(tmpTrx1.StartDateTime), MIN(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS StartDateTime, ISNULL(MAX(EndDateTime), MAX(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS EndDateTime
			, MIN(RecordCount) AS RecordCount, MIN(f.AsOfDate) AS AsOfDate
		FROM ib_ImportFile f
		INNER JOIN LOG l ON l.FileName = f.Filename
		LEFT JOIN (SELECT FileName, MIN(tmpTrx1.CreateDate) AS StartDateTime, MAX(tmpTrx1.CreateDate) AS EndDateTime
					, COUNT(*) AS RecordCount
					FROM [dbo].[RolfeNolan_HOSTTRN] tmpTrx1 GROUP BY Filename) tmpTrx1
				ON f.Filename = tmpTrx1.Filename
				WHERE f.ImportFileId = (SELECT TOP 1 ImportFileId FROM ib_ImportFile f2 WHERE f2.filename = f.filename AND f2.DataSourceId = @DataSourceId ORDER BY CreateDate DESC)
				AND l.RunId = (SELECT TOP 1 RunId FROM LOG l2 WHERE l2.FileName = l.FileName ORDER BY CreateDateTimeUtc DESC)
				AND f.DataSourceId = @datasourceid
				
		GROUP BY f.Filename
	) tmp 
	GROUP BY tmp.DataSourceId, tmp.FileName
END

--Citibank and ADM (GMI Imports)
IF @DataSourceCode = ''Citibank'' OR @DataSourceCode = ''ADM'' OR @DataSourceCode = ''ADM2''
BEGIN
	SELECT tmp.DataSourceId, tmp.[FileName] AS [FileName]
		, MIN(tmp.StartDateTime) AS StartDateTime, MAX(tmp.EndDateTime) AS EndDateTime
		, ISNULL(SUM(tmp.RecordCount), 0) AS RecordCount, MIN(tmp.AsOfDate) AS AsOfDate
	FROM (
		SELECT DISTINCT @DataSourceId AS DataSourceId, f.[FileName]
			, ISNULL(MIN(tmpPos.StartDateTime), MIN(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS StartDateTime, ISNULL(MAX(EndDateTime), MAX(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS EndDateTime
			, MIN(RecordCount) AS RecordCount, MIN(f.AsOfDate) AS AsOfDate
		FROM ib_ImportFile f
				INNER JOIN LOG l ON l.FileName = f.Filename
				LEFT JOIN (SELECT FileName, MIN(tmpPos.CreateDate) AS StartDateTime, MAX(tmpPos.CreateDate) AS EndDateTime , COUNT(*) AS RecordCount 
									FROM [dbo].[GMI_EXTF1] tmpPos 
								GROUP BY Filename) tmpPos 
						ON f.Filename = tmpPos.Filename
				WHERE 
					f.ImportFileId = (SELECT TOP 1 ImportFileId FROM ib_ImportFile f2 WHERE f2.filename = f.filename AND f2.DataSourceId = @DataSourceId ORDER BY CreateDate DESC)
					AND l.RunId = (SELECT TOP 1 RunId FROM LOG l2 WHERE l2.FileName = l.FileName ORDER BY CreateDateTimeUtc DESC)
					AND f.DataSourceId = @DataSourceId
					AND l.[FileName] LIKE ''%'' + @DataSourceCode + ''\%''
		GROUP BY f.[FileName]
		UNION
		SELECT DISTINCT @DataSourceId AS DataSourceId, f.[FileName]
			, ISNULL(MIN(tmpTrx1.StartDateTime), MIN(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS StartDateTime, ISNULL(MAX(EndDateTime), MAX(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS EndDateTime
			, MIN(RecordCount) AS RecordCount, MIN(f.AsOfDate) AS AsOfDate
		FROM ib_ImportFile f
			INNER JOIN LOG l ON l.FileName = f.Filename
			LEFT JOIN (SELECT FileName, MIN(tmpTrx1.CreateDate) AS StartDateTime, MAX(tmpTrx1.CreateDate) AS EndDateTime , COUNT(*) AS RecordCount
							FROM [dbo].[GMI_EXTF1] tmpTrx1 
						GROUP BY Filename) tmpTrx1
				ON f.Filename = tmpTrx1.Filename
		WHERE f.ImportFileId = (SELECT TOP 1 ImportFileId FROM ib_ImportFile f2 WHERE f2.filename = f.filename AND f2.DataSourceId = @DataSourceId ORDER BY CreateDate DESC)
				AND l.RunId = (SELECT TOP 1 RunId FROM LOG l2 WHERE l2.FileName = l.FileName ORDER BY CreateDateTimeUtc DESC)
				AND  f.DataSourceId = @DataSourceId
				AND l.[FileName] LIKE ''%'' + @DataSourceCode + ''\%''
		GROUP BY f.[FileName]
	) tmp 
	GROUP BY tmp.DataSourceId, tmp.[FileName]
END

-- ICE

	-- IMPORTANT NOTE 
	-- re. Recognition of Temp Records where Transactions are sourced from multiple temp		
	-- tables for a single datasource.
	-- only way to differential TrdCaptRpt trx''s against AsgnRpt trx''s is to assume		
	-- TrxTypeCode is numeric, or contains a hyphen, for TrdCaptRpt. 
	-- Or transaction types in AsgnRpt will be letters and won''t contain a hyphen.  
	-- Otherwise might delete other one''s rows since TempTableRecordId''s may overlap
	-- and same target table (ib_Trx)
		
IF @DataSourceCode = ''ICE'' OR @DataSourceCode = ''ICEUS''
BEGIN
	SELECT tmp.DataSourceId, tmp.[FileName] AS [FileName]
		, MIN(tmp.StartDateTime) AS StartDateTime, MAX(tmp.EndDateTime) AS EndDateTime
		, ISNULL(SUM(tmp.RecordCount), 0) AS RecordCount, MIN(tmp.AsOfDate) AS AsOfDate
	FROM (
		SELECT DISTINCT @DataSourceId AS DataSourceId, f.[FileName]
			, ISNULL(MIN(tmpPos.StartDateTime), MIN(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS StartDateTime, ISNULL(MAX(EndDateTime), MAX(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS EndDateTime
			, MIN(RecordCount) AS RecordCount, MIN(f.AsOfDate) AS AsOfDate
		FROM ib_ImportFile f
				INNER JOIN LOG l ON l.FileName = f.Filename
				LEFT JOIN (SELECT FileName, MIN(tmpPos.CreateDate) AS StartDateTime, MAX(tmpPos.CreateDate) AS EndDateTime , COUNT(*) AS RecordCount 
									FROM [dbo].[ICE_PosRpt] tmpPos 
								GROUP BY Filename) tmpPos 
						ON f.Filename = tmpPos.Filename
				WHERE 
					f.ImportFileId = (SELECT TOP 1 ImportFileId FROM ib_ImportFile f2 WHERE f2.filename = f.filename AND f2.DataSourceId = @DataSourceId ORDER BY CreateDate DESC)
					AND l.RunId = (SELECT TOP 1 RunId FROM LOG l2 WHERE l2.FileName = l.FileName ORDER BY CreateDateTimeUtc DESC)
					AND f.DataSourceId = @DataSourceId
		GROUP BY f.[FileName]
		UNION
		SELECT DISTINCT @DataSourceId AS DataSourceId, f.[FileName]
			, ISNULL(MIN(tmpTrx1.StartDateTime), MIN(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS StartDateTime, ISNULL(MAX(EndDateTime), MAX(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS EndDateTime
			, MIN(RecordCount) AS RecordCount, MIN(f.AsOfDate) AS AsOfDate
		FROM ib_ImportFile f
			INNER JOIN LOG l ON l.FileName = f.Filename
			LEFT JOIN (SELECT FileName, MIN(tmpTrx1.CreateDate) AS StartDateTime, MAX(tmpTrx1.CreateDate) AS EndDateTime , COUNT(*) AS RecordCount
							FROM [dbo].[ICE_TrdCaptRpt] tmpTrx1 
							LEFT JOIN [dbo].[ib_Trx] trx1 ON tmpTrx1.[ICE_TrdCaptRptID] = trx1.[TempTableRecordId] 
								AND trx1.DataSourceId = @DataSourceId
								AND (ISNUMERIC(trx1.TrxTypeCode) = 1 OR trx1.TrxTypeCode LIKE ''%-%'')
						GROUP BY Filename) tmpTrx1
				ON f.Filename = tmpTrx1.Filename
		WHERE f.ImportFileId = (SELECT TOP 1 ImportFileId FROM ib_ImportFile f2 WHERE f2.filename = f.filename AND f2.DataSourceId = @DataSourceId ORDER BY CreateDate DESC)
				AND l.RunId = (SELECT TOP 1 RunId FROM LOG l2 WHERE l2.FileName = l.FileName ORDER BY CreateDateTimeUtc DESC)
				AND  f.DataSourceId = @DataSourceId
		GROUP BY f.[FileName]
		UNION
		SELECT DISTINCT @DataSourceId AS DataSourceId, f.[FileName]
			, ISNULL(MIN(tmpAsgn1.StartDateTime), MIN(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS StartDateTime, ISNULL(MAX(EndDateTime), MAX(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS EndDateTime
			, MIN(RecordCount) AS RecordCount, MIN(f.AsOfDate) AS AsOfDate
		FROM ib_ImportFile f
			INNER JOIN LOG l ON l.FileName = f.Filename
			LEFT JOIN (SELECT FileName, MIN(tmpAsgn1.CreateDate) AS StartDateTime, MAX(tmpAsgn1.CreateDate) AS EndDateTime , COUNT(*) AS RecordCount
							FROM [dbo].[ICE_AsgnRpt] tmpAsgn1 
							LEFT JOIN [dbo].[ib_Trx] trx2 ON tmpAsgn1.[ICE_AsgnRptID] = trx2.[TempTableRecordId] 
								AND trx2.DataSourceId = @DataSourceId
								AND (ISNUMERIC(trx2.TrxTypeCode) <> 1 OR trx2.TrxTypeCode LIKE ''%-%'')
						GROUP BY Filename) tmpAsgn1
				ON f.Filename = tmpAsgn1.Filename
		WHERE f.ImportFileId = (SELECT TOP 1 ImportFileId FROM ib_ImportFile f2 WHERE f2.filename = f.filename AND f2.DataSourceId = @DataSourceId ORDER BY CreateDate DESC)
				AND l.RunId = (SELECT TOP 1 RunId FROM LOG l2 WHERE l2.FileName = l.FileName ORDER BY CreateDateTimeUtc DESC)
				AND  f.DataSourceId = @DataSourceId
		GROUP BY f.[FileName]
	) tmp 
	GROUP BY tmp.DataSourceId, tmp.[FileName]
END

-- CMEUS

-- IMPORTANT NOTE 
-- re. Recognition of Temp Records where Transactions are sourced from multiple temp		
-- tables for a single datasource.
-- only way to differential TrdCaptRpt trx''s against AsgnRpt trx''s is to assume		
-- TrxTypeCode is numeric, or contains a hyphen, for TrdCaptRpt. 
-- Or transaction types in AsgnRpt will be letters and won''t contain a hyphen.  
-- Otherwise might delete other one''s rows since TempTableRecordId''s may overlap
-- and same target table (ib_Trx)
		
IF @DataSourceCode = ''CMEUS''
BEGIN
	SELECT tmp.DataSourceId, tmp.[FileName] AS [FileName]
		, MIN(tmp.StartDateTime) AS StartDateTime, MAX(tmp.EndDateTime) AS EndDateTime
		, ISNULL(SUM(tmp.RecordCount), 0) AS RecordCount, MIN(tmp.AsOfDate) AS AsOfDate
	FROM (
		SELECT DISTINCT @DataSourceId AS DataSourceId, f.[FileName]
			, ISNULL(MIN(tmpPos.StartDateTime), MIN(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS StartDateTime, ISNULL(MAX(EndDateTime), MAX(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS EndDateTime
			, MIN(RecordCount) AS RecordCount, MIN(f.AsOfDate) AS AsOfDate
		FROM ib_ImportFile f
				INNER JOIN LOG l ON l.FileName = f.Filename
				LEFT JOIN (SELECT FileName, MIN(tmpPos.CreateDate) AS StartDateTime, MAX(tmpPos.CreateDate) AS EndDateTime , COUNT(*) AS RecordCount 
									FROM stage.[CME_PosRpt] tmpPos 
								GROUP BY Filename) tmpPos 
						ON f.Filename = tmpPos.Filename
				WHERE 
					f.ImportFileId = (SELECT TOP 1 ImportFileId FROM ib_ImportFile f2 WHERE f2.filename = f.filename AND f2.DataSourceId = @DataSourceId ORDER BY CreateDate DESC)
					AND l.RunId = (SELECT TOP 1 RunId FROM LOG l2 WHERE l2.FileName = l.FileName ORDER BY CreateDateTimeUtc DESC)
					AND f.DataSourceId = @DataSourceId
					AND f.[FileName] LIKE ''%'' + @DataSourceCode + ''%''
		GROUP BY f.[FileName]
		UNION
		SELECT DISTINCT @DataSourceId AS DataSourceId, f.[FileName]
			, ISNULL(MIN(tmpTrx1.StartDateTime), MIN(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS StartDateTime, ISNULL(MAX(EndDateTime), MAX(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS EndDateTime
			, MIN(RecordCount) AS RecordCount, MIN(f.AsOfDate) AS AsOfDate
		FROM ib_ImportFile f
			INNER JOIN LOG l ON l.FileName = f.Filename
			LEFT JOIN (SELECT FileName, MIN(tmpTrx1.CreateDate) AS StartDateTime, MAX(tmpTrx1.CreateDate) AS EndDateTime , COUNT(*) AS RecordCount
							FROM stage.[CME_TrdCaptRpt] tmpTrx1 
							LEFT JOIN [dbo].[ib_Trx] trx1 ON tmpTrx1.[CME_TrdCaptRptID] = trx1.[TempTableRecordId] 
								AND trx1.DataSourceId = @DataSourceId
								AND (ISNUMERIC(trx1.TrxTypeCode) = 1 OR trx1.TrxTypeCode LIKE ''%-%'')
						GROUP BY Filename) tmpTrx1
				ON f.Filename = tmpTrx1.Filename
		WHERE f.ImportFileId = (SELECT TOP 1 ImportFileId FROM ib_ImportFile f2 WHERE f2.filename = f.filename AND f2.DataSourceId = @DataSourceId ORDER BY CreateDate DESC)
				AND l.RunId = (SELECT TOP 1 RunId FROM LOG l2 WHERE l2.FileName = l.FileName ORDER BY CreateDateTimeUtc DESC)
				AND  f.DataSourceId = @DataSourceId
				AND f.[FileName] LIKE ''%'' + @DataSourceCode + ''%''
		GROUP BY f.[FileName]
		UNION
		SELECT DISTINCT @DataSourceId AS DataSourceId, f.[FileName]
			, ISNULL(MIN(tmpAsgn1.StartDateTime), MIN(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS StartDateTime, ISNULL(MAX(EndDateTime), MAX(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS EndDateTime
			, MIN(RecordCount) AS RecordCount, MIN(f.AsOfDate) AS AsOfDate
		FROM ib_ImportFile f
			INNER JOIN LOG l ON l.FileName = f.Filename
			LEFT JOIN (SELECT FileName, MIN(tmpAsgn1.CreateDate) AS StartDateTime, MAX(tmpAsgn1.CreateDate) AS EndDateTime , COUNT(*) AS RecordCount
							FROM [stage].[CME_AsgnRpt] tmpAsgn1 
							LEFT JOIN [dbo].[ib_Trx] trx2 ON tmpAsgn1.[CME_AsgnRptID] = trx2.[TempTableRecordId] 
								AND trx2.DataSourceId = @DataSourceId
								AND (ISNUMERIC(trx2.TrxTypeCode) <> 1 OR trx2.TrxTypeCode LIKE ''%-%'')
						GROUP BY Filename) tmpAsgn1
				ON f.Filename = tmpAsgn1.Filename
		WHERE f.ImportFileId = (SELECT TOP 1 ImportFileId FROM ib_ImportFile f2 WHERE f2.filename = f.filename AND f2.DataSourceId = @DataSourceId ORDER BY CreateDate DESC)
				AND l.RunId = (SELECT TOP 1 RunId FROM LOG l2 WHERE l2.FileName = l.FileName ORDER BY CreateDateTimeUtc DESC)
				AND  f.DataSourceId = @DataSourceId
				AND f.[FileName] LIKE ''%'' + @DataSourceCode + ''%''
		GROUP BY f.[FileName]
	) tmp 
	GROUP BY tmp.DataSourceId, tmp.[FileName]
END

-- DGCX

IF @DataSourceCode = ''DGCX''
BEGIN
	SELECT tmp.DataSourceId, tmp.[FileName] AS [FileName]
		, MIN(tmp.StartDateTime) AS StartDateTime, MAX(tmp.EndDateTime) AS EndDateTime
		, ISNULL(SUM(tmp.RecordCount), 0) AS RecordCount, MIN(tmp.AsOfDate) AS AsOfDate
	FROM (
		SELECT DISTINCT @DataSourceId AS DataSourceId, f.[FileName]
			, ISNULL(MIN(tmpPos.StartDateTime), MIN(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS StartDateTime, ISNULL(MAX(EndDateTime), MAX(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS EndDateTime
			, MIN(RecordCount) AS RecordCount, MIN(f.AsOfDate) AS AsOfDate
		FROM ib_ImportFile f
				INNER JOIN LOG l ON l.FileName = f.Filename
				LEFT JOIN (SELECT FileName, MIN(tmpPos.CreateDate) AS StartDateTime, MAX(tmpPos.CreateDate) AS EndDateTime , COUNT(*) AS RecordCount 
									FROM [dbo].[DGCX_Position] tmpPos 
								GROUP BY Filename) tmpPos 
						ON f.Filename = tmpPos.Filename
				WHERE 
					f.ImportFileId = (SELECT TOP 1 ImportFileId FROM ib_ImportFile f2 WHERE f2.filename = f.filename AND f2.DataSourceId = @DataSourceId ORDER BY CreateDate DESC)
					AND l.RunId = (SELECT TOP 1 RunId FROM LOG l2 WHERE l2.FileName = l.FileName ORDER BY CreateDateTimeUtc DESC)
					AND f.DataSourceId = @DataSourceId
		GROUP BY f.[FileName]
		UNION
		SELECT DISTINCT @DataSourceId AS DataSourceId, f.[FileName]
			, ISNULL(MIN(tmpTrx1.StartDateTime), MIN(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS StartDateTime, ISNULL(MAX(EndDateTime), MAX(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS EndDateTime
			, MIN(RecordCount) AS RecordCount, MIN(f.AsOfDate) AS AsOfDate
		FROM ib_ImportFile f
			INNER JOIN LOG l ON l.FileName = f.Filename
			LEFT JOIN (SELECT FileName, MIN(tmpTrx1.CreateDate) AS StartDateTime, MAX(tmpTrx1.CreateDate) AS EndDateTime , COUNT(*) AS RecordCount
							FROM [dbo].[DGCX_Transaction] tmpTrx1 
						GROUP BY Filename) tmpTrx1
				ON f.Filename = tmpTrx1.Filename
		WHERE f.ImportFileId = (SELECT TOP 1 ImportFileId FROM ib_ImportFile f2 WHERE f2.filename = f.filename AND f2.DataSourceId = @DataSourceId ORDER BY CreateDate DESC)
				AND l.RunId = (SELECT TOP 1 RunId FROM LOG l2 WHERE l2.FileName = l.FileName ORDER BY CreateDateTimeUtc DESC)
				AND  f.DataSourceId = @DataSourceId
		GROUP BY f.[FileName]
	) tmp 
	GROUP BY tmp.DataSourceId, tmp.[FileName]
END

-- NLX

IF @DataSourceCode = ''NLX''
BEGIN
	SELECT
		@DataSourceId AS DataSourceId,
		eib_StagingFile.[Path] AS [FileName],
		eib_StagingFile.CreateDate AS StartDateTime,
		eib_StagingFile.LoadDate AS EndDateTime,
		eib_StagingFile.RecordCount,
		eib_StagingFile.AsOfDate
	FROM
		eib_StagingFile
	WHERE
		eib_StagingFile.DataSourceID = @DataSourceID AND
		eib_StagingFile.[Status] IN (3 /* StagingFileStatus.Loaded */, 4 /* StagingFileStatus.Error */)
END

-- Banco Santander
IF  @DataSourceCode=''BZ''
BEGIN
	SELECT tmp.DataSourceId, tmp.[FileName] AS [FileName]
		, MIN(tmp.StartDateTime) AS StartDateTime, MAX(tmp.EndDateTime) AS EndDateTime
		, ISNULL(SUM(tmp.RecordCount), 0) AS RecordCount, MIN(tmp.AsOfDate) AS AsOfDate
	FROM (
		SELECT DISTINCT @DataSourceId AS DataSourceId, f.[FileName]
			, ISNULL(MIN(tmpPos.StartDateTime), MIN(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS StartDateTime, ISNULL(MAX(EndDateTime), MAX(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS EndDateTime
			, MIN(RecordCount) AS RecordCount, MIN(f.AsOfDate) AS AsOfDate
		FROM ib_ImportFile f
				INNER JOIN LOG l ON l.FileName = f.Filename
				LEFT JOIN (SELECT FileName, MIN(tmpPos.CreateDate) AS StartDateTime, MAX(tmpPos.CreateDate) AS EndDateTime , COUNT(*) AS RecordCount 
									FROM [dbo].[BancoSantander_HOSTOPN] tmpPos 
								GROUP BY Filename) tmpPos 
						ON f.Filename = tmpPos.Filename
				WHERE 
					f.ImportFileId = (SELECT TOP 1 ImportFileId FROM ib_ImportFile f2 WHERE f2.filename = f.filename AND f2.DataSourceId = @DataSourceId ORDER BY CreateDate DESC)
					AND l.RunId = (SELECT TOP 1 RunId FROM LOG l2 WHERE l2.FileName = l.FileName ORDER BY CreateDateTimeUtc DESC)
					AND f.DataSourceId = @DataSourceId
		GROUP BY f.[FileName]
		UNION
		SELECT DISTINCT @DataSourceId AS DataSourceId, f.[FileName]
			, ISNULL(MIN(tmpTrx1.StartDateTime), MIN(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS StartDateTime, ISNULL(MAX(EndDateTime), MAX(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS EndDateTime
			, MIN(RecordCount) AS RecordCount, MIN(f.AsOfDate) AS AsOfDate
		FROM ib_ImportFile f
			INNER JOIN LOG l ON l.FileName = f.Filename
			LEFT JOIN (SELECT FileName, MIN(tmpTrx1.CreateDate) AS StartDateTime, MAX(tmpTrx1.CreateDate) AS EndDateTime , COUNT(*) AS RecordCount
							FROM [dbo].[BancoSantander_HOSTTRN] tmpTrx1 
						GROUP BY Filename) tmpTrx1
				ON f.Filename = tmpTrx1.Filename
		WHERE f.ImportFileId = (SELECT TOP 1 ImportFileId FROM ib_ImportFile f2 WHERE f2.filename = f.filename AND f2.DataSourceId = @DataSourceId ORDER BY CreateDate DESC)
				AND l.RunId = (SELECT TOP 1 RunId FROM LOG l2 WHERE l2.FileName = l.FileName ORDER BY CreateDateTimeUtc DESC)
				AND  f.DataSourceId = @DataSourceId
		GROUP BY f.[FileName]
	) tmp 
	GROUP BY tmp.DataSourceId, tmp.[FileName]
END

-- RBC
IF @DataSourceCode = ''RBC''
BEGIN
	SELECT tmp.DataSourceId, tmp.[FileName] AS [FileName]
		, MIN(tmp.StartDateTime) AS StartDateTime, MAX(tmp.EndDateTime) AS EndDateTime
		, ISNULL(SUM(tmp.RecordCount), 0) AS RecordCount, MIN(tmp.AsOfDate) AS AsOfDate
	FROM (
		SELECT DISTINCT @DataSourceId AS DataSourceId, f.[FileName]
			, ISNULL(MIN(tmpPos.StartDateTime), MIN(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS StartDateTime, ISNULL(MAX(EndDateTime), MAX(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS EndDateTime
			, MIN(RecordCount) AS RecordCount, MIN(f.AsOfDate) AS AsOfDate
		FROM ib_ImportFile f
				INNER JOIN LOG l ON l.FileName = f.Filename
				LEFT JOIN (SELECT FileName, MIN(tmpPos.CreateDate) AS StartDateTime, MAX(tmpPos.CreateDate) AS EndDateTime , COUNT(*) AS RecordCount 
									FROM [dbo].[RBC_Position] tmpPos 
								GROUP BY Filename) tmpPos 
						ON f.Filename = tmpPos.Filename
				WHERE 
					f.ImportFileId = (SELECT TOP 1 ImportFileId FROM ib_ImportFile f2 WHERE f2.filename = f.filename AND f2.DataSourceId = @DataSourceId ORDER BY CreateDate DESC)
					AND l.RunId = (SELECT TOP 1 RunId FROM LOG l2 WHERE l2.FileName = l.FileName ORDER BY CreateDateTimeUtc DESC)
					AND f.DataSourceId = @DataSourceId
		GROUP BY f.[FileName]
		UNION
		SELECT DISTINCT @DataSourceId AS DataSourceId, f.[FileName]
			, ISNULL(MIN(tmpTrx1.StartDateTime), MIN(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS StartDateTime, ISNULL(MAX(EndDateTime), MAX(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS EndDateTime
			, MIN(RecordCount) AS RecordCount, MIN(f.AsOfDate) AS AsOfDate
		FROM ib_ImportFile f
			INNER JOIN LOG l ON l.FileName = f.Filename
			LEFT JOIN (SELECT FileName, MIN(tmpTrx1.CreateDate) AS StartDateTime, MAX(tmpTrx1.CreateDate) AS EndDateTime , COUNT(*) AS RecordCount
							FROM [dbo].[RBC_Transaction] tmpTrx1 
						GROUP BY Filename) tmpTrx1
				ON f.Filename = tmpTrx1.Filename
		WHERE f.ImportFileId = (SELECT TOP 1 ImportFileId FROM ib_ImportFile f2 WHERE f2.filename = f.filename AND f2.DataSourceId = @DataSourceId ORDER BY CreateDate DESC)
				AND l.RunId = (SELECT TOP 1 RunId FROM LOG l2 WHERE l2.FileName = l.FileName ORDER BY CreateDateTimeUtc DESC)
				AND  f.DataSourceId = @DataSourceId
		GROUP BY f.[FileName]
	) tmp 
	GROUP BY tmp.DataSourceId, tmp.[FileName]
END

-- LME
IF @DataSourceCode = ''LME''
BEGIN
	SELECT tmp.DataSourceId, tmp.[FileName] AS [FileName]
		, MIN(tmp.StartDateTime) AS StartDateTime, MAX(tmp.EndDateTime) AS EndDateTime
		, ISNULL(SUM(tmp.RecordCount), 0) AS RecordCount, MIN(tmp.AsOfDate) AS AsOfDate
	FROM (
		SELECT DISTINCT @DataSourceId AS DataSourceId, f.[FileName]
			, ISNULL(MIN(tmpPos.StartDateTime), MIN(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS StartDateTime, ISNULL(MAX(EndDateTime), MAX(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS EndDateTime
			, MIN(RecordCount) AS RecordCount, MIN(f.AsOfDate) AS AsOfDate
		FROM ib_ImportFile f
				INNER JOIN LOG l ON l.FileName = f.Filename
				LEFT JOIN (SELECT FileName, MIN(tmpPos.CreateDate) AS StartDateTime, MAX(tmpPos.CreateDate) AS EndDateTime , COUNT(*) AS RecordCount 
									FROM stage.LmePosition tmpPos 
								GROUP BY Filename) tmpPos 
						ON f.Filename = tmpPos.Filename
				WHERE 
					f.ImportFileId = (SELECT TOP 1 ImportFileId FROM ib_ImportFile f2 WHERE f2.filename = f.filename AND f2.DataSourceId = @DataSourceId ORDER BY CreateDate DESC)
					AND l.RunId = (SELECT TOP 1 RunId FROM LOG l2 WHERE l2.FileName = l.FileName ORDER BY CreateDateTimeUtc DESC)
					AND f.DataSourceId = @DataSourceId
		GROUP BY f.[FileName]
		UNION
		SELECT DISTINCT @DataSourceId AS DataSourceId, f.[FileName]
			, ISNULL(MIN(tmpTrx1.StartDateTime), MIN(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS StartDateTime, ISNULL(MAX(EndDateTime), MAX(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS EndDateTime
			, MIN(RecordCount) AS RecordCount, MIN(f.AsOfDate) AS AsOfDate
		FROM ib_ImportFile f
			INNER JOIN LOG l ON l.FileName = f.Filename
			LEFT JOIN (SELECT FileName, MIN(tmpTrx1.CreateDate) AS StartDateTime, MAX(tmpTrx1.CreateDate) AS EndDateTime , COUNT(*) AS RecordCount
							FROM stage.LmeTrade  tmpTrx1 
						GROUP BY Filename) tmpTrx1
				ON f.Filename = tmpTrx1.Filename
		WHERE f.ImportFileId = (SELECT TOP 1 ImportFileId FROM ib_ImportFile f2 WHERE f2.filename = f.filename AND f2.DataSourceId = @DataSourceId ORDER BY CreateDate DESC)
				AND l.RunId = (SELECT TOP 1 RunId FROM LOG l2 WHERE l2.FileName = l.FileName ORDER BY CreateDateTimeUtc DESC)
				AND  f.DataSourceId = @DataSourceId
		GROUP BY f.[FileName]
		UNION
		SELECT DISTINCT @DataSourceId AS DataSourceId, f.[FileName]
			, ISNULL(MIN(tmpPrc1.StartDateTime), MIN(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS StartDateTime, ISNULL(MAX(EndDateTime), MAX(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS EndDateTime
			, MIN(RecordCount) AS RecordCount, MIN(f.AsOfDate) AS AsOfDate
		FROM ib_ImportFile f
			INNER JOIN LOG l ON l.FileName = f.Filename
			LEFT JOIN (SELECT FileName, MIN(tmpPrc1.CreateDate) AS StartDateTime, MAX(tmpPrc1.CreateDate) AS EndDateTime , COUNT(*) AS RecordCount
							FROM stage.LmePositionsRealisedCash tmpPrc1 
						GROUP BY Filename) tmpPrc1
				ON f.Filename = tmpPrc1.Filename
		WHERE f.ImportFileId = (SELECT TOP 1 ImportFileId FROM ib_ImportFile f2 WHERE f2.filename = f.filename AND f2.DataSourceId = @DataSourceId ORDER BY CreateDate DESC)
				AND l.RunId = (SELECT TOP 1 RunId FROM LOG l2 WHERE l2.FileName = l.FileName ORDER BY CreateDateTimeUtc DESC)
				AND  f.DataSourceId = @DataSourceId
		GROUP BY f.[FileName]
	) tmp 
	GROUP BY tmp.DataSourceId, tmp.[FileName]
END


-- MAQ

IF @DataSourceCode = ''MAQ''
BEGIN
	SELECT tmp.DataSourceId, tmp.[FileName] AS [FileName]
		, MIN(tmp.StartDateTime) AS StartDateTime, MAX(tmp.EndDateTime) AS EndDateTime
		, ISNULL(SUM(tmp.RecordCount), 0) AS RecordCount, MIN(tmp.AsOfDate) AS AsOfDate
	FROM (
		SELECT DISTINCT @DataSourceId AS DataSourceId, f.[FileName]
			, ISNULL(MIN(tmpPos.StartDateTime), MIN(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS StartDateTime, ISNULL(MAX(EndDateTime), MAX(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS EndDateTime
			, MIN(RecordCount) AS RecordCount, MIN(f.AsOfDate) AS AsOfDate
		FROM ib_ImportFile f
				INNER JOIN LOG l ON l.FileName = f.Filename
				LEFT JOIN (SELECT FileName, MIN(tmpPos.CreateDate) AS StartDateTime, MAX(tmpPos.CreateDate) AS EndDateTime , COUNT(*) AS RecordCount 
									FROM [stage].[MacquariePosition] tmpPos 
								GROUP BY Filename) tmpPos 
						ON f.Filename = tmpPos.Filename
				WHERE 
					f.ImportFileId = (SELECT TOP 1 ImportFileId FROM ib_ImportFile f2 WHERE f2.filename = f.filename AND f2.DataSourceId = @DataSourceId ORDER BY CreateDate DESC)
					AND l.RunId = (SELECT TOP 1 RunId FROM LOG l2 WHERE l2.FileName = l.FileName ORDER BY CreateDateTimeUtc DESC)
					AND f.DataSourceId = @DataSourceId
		GROUP BY f.[FileName]
		UNION
		SELECT DISTINCT @DataSourceId AS DataSourceId, f.[FileName]
			, ISNULL(MIN(tmpTrx1.StartDateTime), MIN(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS StartDateTime, ISNULL(MAX(EndDateTime), MAX(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS EndDateTime
			, MIN(RecordCount) AS RecordCount, MIN(f.AsOfDate) AS AsOfDate
		FROM ib_ImportFile f
			INNER JOIN LOG l ON l.FileName = f.Filename
			LEFT JOIN (SELECT FileName, MIN(tmpTrx1.CreateDate) AS StartDateTime, MAX(tmpTrx1.CreateDate) AS EndDateTime , COUNT(*) AS RecordCount
							FROM [stage].[MacquarieTrade] tmpTrx1 
						GROUP BY Filename) tmpTrx1
				ON f.Filename = tmpTrx1.Filename
		WHERE f.ImportFileId = (SELECT TOP 1 ImportFileId FROM ib_ImportFile f2 WHERE f2.filename = f.filename AND f2.DataSourceId = @DataSourceId ORDER BY CreateDate DESC)
				AND l.RunId = (SELECT TOP 1 RunId FROM LOG l2 WHERE l2.FileName = l.FileName ORDER BY CreateDateTimeUtc DESC)
				AND  f.DataSourceId = @DataSourceId
		GROUP BY f.[FileName]
	) tmp 
	GROUP BY tmp.DataSourceId, tmp.[FileName]
END

-- BMF

IF @DataSourceCode = ''BMF''
BEGIN
	SELECT tmp.DataSourceId, tmp.[FileName] AS [FileName]
		, MIN(tmp.StartDateTime) AS StartDateTime, MAX(tmp.EndDateTime) AS EndDateTime
		, ISNULL(SUM(tmp.RecordCount), 0) AS RecordCount, MIN(tmp.AsOfDate) AS AsOfDate
	FROM (
		SELECT DISTINCT @DataSourceId AS DataSourceId, f.[FileName]
			, ISNULL(MIN(tmpPos.StartDateTime), MIN(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS StartDateTime, ISNULL(MAX(EndDateTime), MAX(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS EndDateTime
			, MIN(RecordCount) AS RecordCount, MIN(f.AsOfDate) AS AsOfDate
		FROM ib_ImportFile f
				INNER JOIN LOG l ON l.FileName = f.Filename
				LEFT JOIN (SELECT FileName, MIN(tmpPos.CreateDate) AS StartDateTime, MAX(tmpPos.CreateDate) AS EndDateTime , COUNT(*) AS RecordCount 
									FROM [stage].[BmfPosition] tmpPos 
								GROUP BY Filename) tmpPos 
						ON f.Filename = tmpPos.Filename
				WHERE 
					f.ImportFileId = (SELECT TOP 1 ImportFileId FROM ib_ImportFile f2 WHERE f2.filename = f.filename AND f2.DataSourceId = @DataSourceId ORDER BY CreateDate DESC)
					AND l.RunId = (SELECT TOP 1 RunId FROM LOG l2 WHERE l2.FileName = l.FileName ORDER BY CreateDateTimeUtc DESC)
					AND f.DataSourceId = @DataSourceId
		GROUP BY f.[FileName]
		UNION
		SELECT DISTINCT @DataSourceId AS DataSourceId, f.[FileName]
			, ISNULL(MIN(tmpTrx1.StartDateTime), MIN(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS StartDateTime, ISNULL(MAX(EndDateTime), MAX(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS EndDateTime
			, MIN(RecordCount) AS RecordCount, MIN(f.AsOfDate) AS AsOfDate
		FROM ib_ImportFile f
			INNER JOIN LOG l ON l.FileName = f.Filename
			LEFT JOIN (SELECT FileName, MIN(tmpTrx1.CreateDate) AS StartDateTime, MAX(tmpTrx1.CreateDate) AS EndDateTime , COUNT(*) AS RecordCount
							FROM [stage].[BmfTrade] tmpTrx1 
						GROUP BY Filename) tmpTrx1
				ON f.Filename = tmpTrx1.Filename
		WHERE f.ImportFileId = (SELECT TOP 1 ImportFileId FROM ib_ImportFile f2 WHERE f2.filename = f.filename AND f2.DataSourceId = @DataSourceId ORDER BY CreateDate DESC)
				AND l.RunId = (SELECT TOP 1 RunId FROM LOG l2 WHERE l2.FileName = l.FileName ORDER BY CreateDateTimeUtc DESC)
				AND  f.DataSourceId = @DataSourceId
		GROUP BY f.[FileName]
		UNION
		SELECT DISTINCT @DataSourceId AS DataSourceId, f.[FileName]
			, ISNULL(MIN(tmpPrc1.StartDateTime), MIN(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS StartDateTime, ISNULL(MAX(EndDateTime), MAX(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS EndDateTime
			, MIN(RecordCount) AS RecordCount, MIN(f.AsOfDate) AS AsOfDate
		FROM ib_ImportFile f
			INNER JOIN LOG l ON l.FileName = f.Filename
			LEFT JOIN (SELECT FileName, MIN(tmpPrc1.CreateDate) AS StartDateTime, MAX(tmpPrc1.CreateDate) AS EndDateTime , COUNT(*) AS RecordCount
							FROM stage.BmfPositionsRealisedCash tmpPrc1 
						GROUP BY Filename) tmpPrc1
				ON f.Filename = tmpPrc1.Filename
		WHERE f.ImportFileId = (SELECT TOP 1 ImportFileId FROM ib_ImportFile f2 WHERE f2.filename = f.filename AND f2.DataSourceId = @DataSourceId ORDER BY CreateDate DESC)
				AND l.RunId = (SELECT TOP 1 RunId FROM LOG l2 WHERE l2.FileName = l.FileName ORDER BY CreateDateTimeUtc DESC)
				AND  f.DataSourceId = @DataSourceId
		GROUP BY f.[FileName]
	) tmp 
	GROUP BY tmp.DataSourceId, tmp.[FileName]
END

-- Eurex :- NB: There is NO Join to ib_Position or ib_Trx because it takes a Dogs age to return. Derive AsOfDate some other way
--NB2: Eurex has 1 table for both Transaction and Positions
IF @DataSourceCode = ''EEX''
BEGIN
	SELECT DISTINCT @DataSourceId AS DataSourceId, tmp.[FileName]
		, MIN(tmp.CreateDate) AS StartDateTime, Max(tmp.CreateDate) AS EndDateTime
		, COUNT(*) AS RecordCount, MIN(rptPrntEffDat) AS AsOfDate
	FROM stage.Europower tmp
	INNER JOIN Log l ON l.FileName = tmp.FileName AND l.IsComplete = 1
	WHERE tmp.[FileName] IS NOT NULL
	GROUP BY tmp.[FileName]
	
END

-- Rosenthal Collins Group (aka GMI MNA - GMI File for Marex North America)
IF @DataSourceCode = ''GMI MNA''
BEGIN
	SELECT tmp.DataSourceId, tmp.[FileName] AS [FileName]
		, MIN(tmp.StartDateTime) AS StartDateTime, MAX(tmp.EndDateTime) AS EndDateTime
		, ISNULL(SUM(tmp.RecordCount), 0) AS RecordCount, MIN(tmp.AsOfDate) AS AsOfDate
	FROM (
		SELECT DISTINCT @DataSourceId AS DataSourceId, f.[FileName]
			, ISNULL(MIN(tmpPos.StartDateTime), MIN(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS StartDateTime, ISNULL(MAX(EndDateTime), MAX(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS EndDateTime
			, MIN(RecordCount) AS RecordCount, MIN(f.AsOfDate) AS AsOfDate
		FROM ib_ImportFile f
				INNER JOIN LOG l ON l.FileName = f.Filename
				LEFT JOIN (SELECT FileName, MIN(tmpPos.CreateDate) AS StartDateTime, MAX(tmpPos.CreateDate) AS EndDateTime , COUNT(*) AS RecordCount 
									FROM [stage].[RosenthalCollinsPosition] tmpPos 
								GROUP BY Filename) tmpPos 
						ON f.Filename = tmpPos.Filename
				WHERE 
					f.ImportFileId = (SELECT TOP 1 ImportFileId FROM ib_ImportFile f2 WHERE f2.filename = f.filename AND f2.DataSourceId = @DataSourceId ORDER BY CreateDate DESC)
					AND l.RunId = (SELECT TOP 1 RunId FROM LOG l2 WHERE l2.FileName = l.FileName ORDER BY CreateDateTimeUtc DESC)
					AND f.DataSourceId = @DataSourceId
		GROUP BY f.[FileName]
		UNION
		SELECT DISTINCT @DataSourceId AS DataSourceId, f.[FileName]
			, ISNULL(MIN(tmpTrx1.StartDateTime), MIN(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS StartDateTime, ISNULL(MAX(EndDateTime), MAX(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS EndDateTime
			, MIN(RecordCount) AS RecordCount, MIN(f.AsOfDate) AS AsOfDate
		FROM ib_ImportFile f
			INNER JOIN LOG l ON l.FileName = f.Filename
			LEFT JOIN (SELECT FileName, MIN(tmpTrx1.CreateDate) AS StartDateTime, MAX(tmpTrx1.CreateDate) AS EndDateTime , COUNT(*) AS RecordCount
							FROM [stage].[RosenthalCollinsTrade] tmpTrx1 
						GROUP BY Filename) tmpTrx1
				ON f.Filename = tmpTrx1.Filename
		WHERE f.ImportFileId = (SELECT TOP 1 ImportFileId FROM ib_ImportFile f2 WHERE f2.filename = f.filename AND f2.DataSourceId = @DataSourceId ORDER BY CreateDate DESC)
				AND l.RunId = (SELECT TOP 1 RunId FROM LOG l2 WHERE l2.FileName = l.FileName ORDER BY CreateDateTimeUtc DESC)
				AND  f.DataSourceId = @DataSourceId
		GROUP BY f.[FileName]
	) tmp 
	GROUP BY tmp.DataSourceId, tmp.[FileName]
END

-- Minneapolis Grain Exchange (aka MGEX)
IF @DataSourceCode = ''MGEX''
BEGIN
	SELECT tmp.DataSourceId, tmp.[FileName] AS [FileName]
		, MIN(tmp.StartDateTime) AS StartDateTime, MAX(tmp.EndDateTime) AS EndDateTime
		, ISNULL(SUM(tmp.RecordCount), 0) AS RecordCount, MIN(tmp.AsOfDate) AS AsOfDate
	FROM (
		SELECT DISTINCT @DataSourceId AS DataSourceId, f.[FileName]
			, ISNULL(MIN(tmpPos.StartDateTime), MIN(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS StartDateTime, ISNULL(MAX(EndDateTime), MAX(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS EndDateTime
			, MIN(RecordCount) AS RecordCount, MIN(f.AsOfDate) AS AsOfDate
		FROM ib_ImportFile f
				INNER JOIN LOG l ON l.FileName = f.Filename
				LEFT JOIN (SELECT FileName, MIN(tmpPos.CreateDate) AS StartDateTime, MAX(tmpPos.CreateDate) AS EndDateTime , COUNT(*) AS RecordCount 
									FROM [stage].[MGEPosition] tmpPos 
								GROUP BY Filename) tmpPos 
						ON f.Filename = tmpPos.Filename
				WHERE 
					f.ImportFileId = (SELECT TOP 1 ImportFileId FROM ib_ImportFile f2 WHERE f2.filename = f.filename AND f2.DataSourceId = @DataSourceId ORDER BY CreateDate DESC)
					AND l.RunId = (SELECT TOP 1 RunId FROM LOG l2 WHERE l2.FileName = l.FileName ORDER BY CreateDateTimeUtc DESC)
					AND f.DataSourceId = @DataSourceId
		GROUP BY f.[FileName]
		UNION
		SELECT DISTINCT @DataSourceId AS DataSourceId, f.[FileName]
			, ISNULL(MIN(tmpTrx1.StartDateTime), MIN(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS StartDateTime, ISNULL(MAX(EndDateTime), MAX(DATEADD(HOUR, @DateDiff, l.CreateDateTimeUtc)))  AS EndDateTime
			, MIN(RecordCount) AS RecordCount, MIN(f.AsOfDate) AS AsOfDate
		FROM ib_ImportFile f
			INNER JOIN LOG l ON l.FileName = f.Filename
			LEFT JOIN (SELECT FileName, MIN(tmpTrx1.CreateDate) AS StartDateTime, MAX(tmpTrx1.CreateDate) AS EndDateTime , COUNT(*) AS RecordCount
							FROM [stage].[MGETrade] tmpTrx1 
						GROUP BY Filename) tmpTrx1
				ON f.Filename = tmpTrx1.Filename
		WHERE f.ImportFileId = (SELECT TOP 1 ImportFileId FROM ib_ImportFile f2 WHERE f2.filename = f.filename AND f2.DataSourceId = @DataSourceId ORDER BY CreateDate DESC)
				AND l.RunId = (SELECT TOP 1 RunId FROM LOG l2 WHERE l2.FileName = l.FileName ORDER BY CreateDateTimeUtc DESC)
				AND  f.DataSourceId = @DataSourceId
		GROUP BY f.[FileName]
	) tmp 
	GROUP BY tmp.DataSourceId, tmp.[FileName]
END


END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Instrument_Update]''
');

GO
EXECUTE ('/*
<details>
 <summary>Updates an instrument from the ib_Instrument table by its id</summary>
 <created author="Laurentiu Macovei" Date=" Sunday, 10 September 2006 1:26PM GMT" /> 
</details>
Version		Date		Author			Description
1.1			30 Jan 2007	LM				Added ISNULL wrapper into the Update Statement and set the 
										default values of the parameters to NULL.
			16 Apr 2010	amk				MBAL-15170: bug fix: lotsize and ticksize now 24,10
*/
CREATE PROCEDURE [dbo].[ib_Instrument_Update]
	(
	@InstrumentId		int,
	@InstrumentTypeId	int = NULL,
	@Code				varchar(100) = NULL,
	@Name				varchar(100) = NULL,
	@IsApproved			bit = NULL,
	@LotSize			decimal(24,10) = NULL,
	@TickSize			decimal(24,10) = NULL,
	@BaseId				int = NULL,
	@UpdateUsername		varchar(50) = NULL
	)
AS
SET NOCOUNT ON

	BEGIN TRY
		--check for duplicates 
		EXEC [dbo].[ib_Instrument_CheckForDuplicate] @Code, @InstrumentId

		UPDATE [dbo].[ib_Instrument]
			SET		[InstrumentTypeId]	= ISNULL(@InstrumentTypeId,[InstrumentTypeId]),
					[Code]				= ISNULL(@Code,[Code]), 
					[Name]				= ISNULL(@Name,[Name]), 
					[IsApproved]		= ISNULL(@IsApproved,[IsApproved]), 
					[LotSize]			= ISNULL(@LotSize,[Lotsize]), 
					[TickSize]			= ISNULL(@TickSize,[Ticksize]),
					[BaseId]			= ISNULL(@BaseId, [BaseId]),
					[UpdateUsername]	= ISNULL(@UpdateUsername,[UpdateUsername])

			WHERE	[InstrumentId]	= @InstrumentId
	END TRY
	BEGIN CATCH
		EXEC [dbo].[sp_RethrowError]
	END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[eib_DataSource_GetByCode]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[eib_DataSource_GetByCode]
(
	@Code varchar(100)
)
AS

SET NOCOUNT ON

SELECT
	ib_DataSource.DataSourceId,
	ib_DataSource.Code,
	ib_DataSource.Name,
	ib_DataSource.DefaultCurrencyId,
	ib_DataSource.ProvidesVariation,
	ib_DataSource.DefaultStrikePriceDivisor,
	ib_DataSource.IncludeDetailAccountInTradeReconciliation,
	ib_DataSource.UseTrxsForTradedOnDay
FROM
	ib_DataSource
WHERE
	ib_DataSource.Code = @Code
');

GO
EXECUTE ('PRINT N''Creating [dbo].[RBC_Position_Purge]''
');

GO
EXECUTE ('-- =============================================
-- 23 Apr 2014  ED  EIB 25559
-- Description:	Deletes from RBC_Position table all the records where the LoadState is 0
-- =============================================
CREATE PROCEDURE [dbo].[RBC_Position_Purge] 
	(
		@LoadState		TINYINT = 0,
		@FileName       VARCHAR (512)= NULL
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
		DELETE FROM [dbo].[RBC_Position] WHERE LoadState= @LoadState AND [FileName] = Coalesce(@FileName, [FileName])

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_SiteTemplate_ByUserId]''
');

GO
EXECUTE ('




/*
<details>
	<summary>Lists which templates the user can access. </summary>
	<created author="McQuien" Date="Wednesday, 22 Nov 2006 09:37AM GMT" />
	<modification>McQuien added optional site name to query<modification>
</details>
*/
CREATE Proc [dbo].[ib_SiteTemplate_ByUserId]
@UserId uniqueidentifier,
@SiteName varchar(100)=null,
@TemplateId int


as
SET NOCOUNT ON

IF @SiteName is null
BEGIN
SELECT distinct a.TemplateId, b.Description
FROM ib_SiteTemplate a 
INNER JOIN ib_Template b on
a.TemplateId = b.TemplateId
AND b.TypeCode =''Equity Report''
and a.SiteId in (
SELECT s.[SiteId] 
	FROM [dbo].[ib_Site] s
		INNER JOIN [dbo].[ib_SiteUser] su ON 
			s.SiteId = su.SiteID 
			AND @UserId = su.UserId
			)
			--AND b.TemplateId = @TemplateId)
ORDER BY b.Description

END
ELSE
BEGIN
SELECT distinct a.TemplateId, b.Description
FROM ib_SiteTemplate a 
INNER JOIN ib_Template b on
a.TemplateId = b.TemplateId
AND b.TypeCode =''Equity Report''
and a.SiteId in (
SELECT s.[SiteId] 
	FROM [dbo].[ib_Site] s
		INNER JOIN [dbo].[ib_SiteUser] su ON 
			s.SiteId = su.SiteID 
			AND @UserId = su.UserId
			AND s.Name = @SiteName
			)
			--AND b.TemplateId = @TemplateId)
ORDER BY b.Description
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_SWIFT_MT940_Load]''
');

GO
EXECUTE ('
CREATE PROCEDURE [dbo].[ib_SWIFT_MT940_Load] 
	-- Add the parameters for the stored procedure here
	(
		@LocationPath	varchar(100) = NULL
		,@ReceiveLocationSysId INT
		,@RunId INT
	)
AS
SET NOCOUNT ON
-- =============================================
-- Author:		Petru Konrad Bercea
-- Create date: 21.01.2009
-- Description:	This stored procedure pulls data from the SWIFT_MT940
-- table and inserts it into the ib_Nostro.  
-- Whilst iterating through the records in SWIFT_MT940, all 
-- of these inserts are wrapped in a transaction so that any failure causes
-- the changes to not commit.
--
--
-- Revision History
--
-- 19 Feb 2009		Konrad		Removed ISDATE function calls as this function 
--								doesn''t recognise all the date format styles.
-- 19 Feb 2009		Konrad		Set the TransDate by default equal to the ValueDate  
-- 
-- 15.04.2009       Konrad      Added SwiftStatement Data Persist for Data Integrity Check of SWIFT Loading
-- 17.04.2009		Konrad		Fixed the BalanceDate persisting into the ib_SwiftStatement table.
-- 18.04.2009		Konrad      Fixed conversion of Open / Closing Balance and marking their Debit / Credit sign also. 	
-- 07.07.2009       Konrad      Missed statements are replaced if real ones are loaded
-- 15.07.2009       Konrad      Swift Statements are uniquely added and duplicates logged in ImportLog table
-- 21.08.2009		AAJM		Fix  Nostro Records Not Being Created from SWIFT Files - wrong 
--								"if exists" expression
-- 24.08.2009		AAJM		Fix Nostro records not being loaded because SwiftftStatement ''if exists''
--								returned MISS records.
-- 09.09.2009		AAJM		Calculate IsLastInSequence to add to ib_SwiftStatement to support
--								MISS gap record logic
-- 10.09.2009		AAJM		Mark SwiftStatement record as IsMissReplacement when new
--								statement added and MISS deleted
-- 15.09.2009		amk		    1. Set transaction isolation level
--								2. Move loader ended msg to postload so it only runs once
--								3. Move loader started msg to checkiffileexists so it only runs once
-- 18.09.2009		amk			Limit initial record selection to just ones for this file
-- 07.10.2009		amk			Bug Fix (from Live, ouch!): fix replacing of 00 in date
-- 28.10.2009		AAJM		MBAL-13637 Don''t delete Swift Statements but, rather, update. 
--								Add output NostroId parameter for ib_Nostro_Load
-- 23.11.2009		amk			MBAL-13605: Load field 86 into narrative too
-- 18.02.2010		AAJM		MBAL-14483 External Reference being copied down when empty
-- 10.05.2010		amk			MBAL-15484 Don''t load statements with EARLIER statement no/seq no
-- 11.05.2010       ED          MNAL 15488 Use Seed for StatementNumber
-- 19.05.2010		amk			MBAL-15484 Fix bug I introduced (allow MISS to be handled correctly)
-- 20.05.2010		amk			MBAL-15484 Undo this bug fix since there isn''t a MISS logged for every point in GAP 
--								Marc agreed to scrap the bug fix and let the ''seed'' enhancement handle the need
-- 01.03.2012		AAJM		MBAL-20190 Leap Year Fix
-- 05.06.2012		ED			MBAL 20952 move change load state to load file and adding (nolock) to avoid deadlocks
-- 08.01.2014		ED			EIB 24203 - fix the logic for IsLastInSequence
-- 09.01.2014	    ED			EIB 25004 - remove importLog table and use Log table
-- =============================================
BEGIN

BEGIN TRANSACTION T1

-- BizTalk''s SQL Adapter uses more restrictive read serializable
-- so this is necessary to relax it to something that is default
-- and perfectly acceptable!
SET TRANSACTION ISOLATION LEVEL READ COMMITTED

UPDATE [dbo].[SWIFT_MT940] SET LoadState = 1   WHERE LoadState= 0 AND Filename = @LocationPath

CREATE TABLE #temp1
	(
		SWIFT_MT940ID						int,
		LTAdrs								varchar(12) COLLATE Latin1_General_CI_AS,
		AccountId_25						varchar(35) COLLATE Latin1_General_CI_AS,
		OpenBalance_60F_CurrencyCode		varchar(3) COLLATE Latin1_General_CI_AS,
		OpenBalance_60M_CurrencyCode		varchar(3) COLLATE Latin1_General_CI_AS,
		StatmtLine_61						varchar(66) COLLATE Latin1_General_CI_AS,
		StatmtLine_61_SupplemDetails		varchar(34) COLLATE Latin1_General_CI_AS,
		StatmtNo_28C                        varchar(5) COLLATE Latin1_General_CI_AS,
		StatmtNoSeqNo_28C					varchar(5) COLLATE Latin1_General_CI_AS,
		OpenBalance_60F_Date				varchar(6) COLLATE Latin1_General_CI_AS,
		OpenBalance_60M_Date				varchar(6) COLLATE Latin1_General_CI_AS,
		OpenBalance_DCMark					char(1),
		OpenBalance_60F_Amount				varchar(15) COLLATE Latin1_General_CI_AS,
		OpenBalance_60M_Amount				varchar(15) COLLATE Latin1_General_CI_AS,
		ClosingBalance_DCMark				char(1),
		ClosingBalance_62F_Amount			varchar(15) COLLATE Latin1_General_CI_AS,
		ClosingBalance_62M_Amount			varchar(15) COLLATE Latin1_General_CI_AS,
		[FileName]							varchar(512)  COLLATE Latin1_General_CI_AS,
		InfoToAccOwn_1_86_lines_1_to_6		varchar(400) COLLATE Latin1_General_CI_AS
	)

	INSERT INTO #temp1
	(
		SWIFT_MT940ID,
		LTAdrs,	
		AccountId_25,	
		OpenBalance_60F_CurrencyCode,
		OpenBalance_60M_CurrencyCode,	
		StatmtLine_61,	
		StatmtLine_61_SupplemDetails,
		StatmtNo_28C,
		StatmtNoSeqNo_28C,
		OpenBalance_60F_Date,
		OpenBalance_60M_Date,
		OpenBalance_DCMark,				
		OpenBalance_60F_Amount,
		OpenBalance_60M_Amount,
		ClosingBalance_DCMark,
		ClosingBalance_62F_Amount,
		ClosingBalance_62M_Amount,
		[FileName],
		InfoToAccOwn_1_86_lines_1_to_6
	)
	SELECT 	
		SWIFT_MT940ID,
		LTAdrs,
		AccountId_25,	
		OpenBalance_60F_CurrencyCode,
		OpenBalance_60M_CurrencyCode,	
		StatmtLine_61,	
		StatmtLine_61_SupplemDetails,
		[dbo].[GetFixedSwiftStatementNumber](AccountId_25, StatmtNo_28C),
		StatmtNoSeqNo_28C,
		OpenBalance_60F_Date,
		OpenBalance_60M_Date,
		CASE WHEN (LEN(OpenBalance_60F_DCMark) > 0) THEN OpenBalance_60F_DCMark 
		ELSE OpenBalance_60M_DCMark END,	
		OpenBalance_60F_Amount,
		OpenBalance_60M_Amount,
		CASE WHEN (LEN(ClosingBalance_62F_DCMark) > 0) THEN ClosingBalance_62F_DCMark 
		ELSE ClosingBalance_62M_DCMark END,
		ClosingBalance_62F_Amount,
		ClosingBalance_62M_Amount,
		[FileName],
		ISNULL(RTRIM(LTRIM(InfoToAccOwn_1_86_line1)), '''')
			+ '' '' + ISNULL(RTRIM(LTRIM(InfoToAccOwn_1_86_line2)), '''')
			+ '' '' + ISNULL(RTRIM(LTRIM(InfoToAccOwn_1_86_line3)), '''')
			+ '' '' + ISNULL(RTRIM(LTRIM(InfoToAccOwn_1_86_line4)), '''')
			+ '' '' + ISNULL(RTRIM(LTRIM(InfoToAccOwn_1_86_line5)), '''')
			+ '' '' + ISNULL(RTRIM(LTRIM(InfoToAccOwn_1_86_line6)), '''')
	FROM [dbo].[SWIFT_MT940] (NOLOCK) 
	WHERE LoadState = 1
		AND [FileName] = @LocationPath

	CREATE TABLE #temp_SwiftStatement
	(
		[AccountCode] varchar(35),
		[StatementNumber] int,
		[StatementSequenceNumber] int,
		[BalanceDate] datetime,
		[CurrencyCode]	varchar(3),
		[OpenBalance] money,
		[TotalOfLineItemAmounts] money,
		[ClosingBalance] money,
		[FileName] varchar(512),
		[Firm] varchar(25),
		[DataSourceCd]	varchar(100),
		[IsLastInSequence] bit 
	)

	INSERT INTO #temp_SwiftStatement
	(
		[AccountCode],
		[StatementNumber],
		[StatementSequenceNumber],
		[TotalOfLineItemAmounts]
		
	)
	SELECT DISTINCT	
		AccountId_25,	
		convert(int,StatmtNo_28C),
		convert(int,StatmtNoSeqNo_28C),
		0
	FROM #temp1
	WHERE	
			NOT EXISTS (SELECT *
			  FROM dbo.[ib_SwiftStatement] stm	
				  INNER JOIN ib_Account a ON a.AccountId = stm.AccountId	
			  WHERE a.Code = #temp1.AccountId_25 
					AND stm.[FileName] <> ''MISS''
					AND stm.StatementNumber = CONVERT(INT, StatmtNo_28C) 
					AND stm.StatementSequenceNumber = CONVERT(INT, StatmtNoSeqNo_28C)
				) 

			DECLARE @SWIFT_MT940ID					int
			DECLARE	@LTAdrs						    varchar(12)
			DECLARE	@AccountId_25					varchar(35)
			DECLARE @OpenBalance_60F_CurrencyCode	varchar(3)
			DECLARE @OpenBalance_60M_CurrencyCode	varchar(3)
			DECLARE	@StatmtLine_61					varchar(66)
			DECLARE	@StatmtLine_61_SupplemDetails	varchar(34)
			DECLARE @Started						bit
			DECLARE	@StatmtNo_28C                   varchar(5)
			DECLARE	@StatmtNoSeqNo_28C				varchar(5)
			DECLARE	@OpenBalance_60F_Date			varchar(6)
			DECLARE	@OpenBalance_60M_Date			varchar(6)
			DECLARE @OpenBalance_DCMark				char(1)
			DECLARE	@OpenBalance_60F_Amount			varchar(15)
			DECLARE	@OpenBalance_60M_Amount			varchar(15)
			DECLARE @ClosingBalance_DCMark				char(1)
			DECLARE	@ClosingBalance_62F_Amount		varchar(15)
			DECLARE	@ClosingBalance_62M_Amount		varchar(15)
			DECLARE	@FileName						varchar(512)
			DECLARE @BalanceDate					datetime
			DECLARE @InfoToAccOwn_1_86_lines_1_to_6 VARCHAR(400)

			SET @Started = 0

			DECLARE pos_cursor CURSOR FOR
			SELECT	SWIFT_MT940ID,
					LTAdrs,	
					AccountId_25,	
					OpenBalance_60F_CurrencyCode,
					OpenBalance_60M_CurrencyCode,	
					StatmtLine_61,	
					StatmtLine_61_SupplemDetails,
					StatmtNo_28C,
					StatmtNoSeqNo_28C,
					OpenBalance_60F_Date,
					OpenBalance_60M_Date,
					OpenBalance_DCMark,				
					OpenBalance_60F_Amount,
					OpenBalance_60M_Amount,
					ClosingBalance_DCMark,
					ClosingBalance_62F_Amount,
					ClosingBalance_62M_Amount,
					[FileName],
					InfoToAccOwn_1_86_lines_1_to_6
			FROM	#temp1

			OPEN pos_cursor

			FETCH NEXT FROM pos_cursor
			INTO 
					@SWIFT_MT940ID,
                    @LTAdrs,	
					@AccountId_25,	
					@OpenBalance_60F_CurrencyCode,	
					@OpenBalance_60M_CurrencyCode,
					@StatmtLine_61,	
					@StatmtLine_61_SupplemDetails,
					@StatmtNo_28C,                   
					@StatmtNoSeqNo_28C,
					@OpenBalance_60F_Date,
					@OpenBalance_60M_Date,
					@OpenBalance_DCMark,
					@OpenBalance_60F_Amount,
					@OpenBalance_60M_Amount,
					@ClosingBalance_DCMark,
					@ClosingBalance_62F_Amount,
					@ClosingBalance_62M_Amount,
					@FileName,
					@InfoToAccOwn_1_86_lines_1_to_6

				-- Check @@FETCH_STATUS to see IF there are any more rows to fetch.
				WHILE @@FETCH_STATUS = 0
				BEGIN
					DECLARE 	@DataSourceCd			varchar(100)
					DECLARE		@ValueDate				datetime
					DECLARE		@TransDate				datetime
					DECLARE		@Amount					decimal(18, 4)
					DECLARE		@TransactionType		varchar(4)
					DECLARE		@InternalReference		varchar(16)
					DECLARE		@ExternalReference		varchar(16)
					DECLARE		@Narrative				varchar(max)
					DECLARE		@Account				varchar(35)
					DECLARE		@Currency				varchar(3)
					DECLARE 	@ReturnValue int, @Output int, @StringCursor int, @Output2 int
					DECLARE     @Continue    bit
					DECLARE 	@DataSourceId int
					DECLARE 	@Code varchar(100), @Code2 varchar(100)
					DECLARE     @StatementNumber          int
					DECLARE     @StatementSequenceNumber  int 
					DECLARE     @OpenBalance			  money
					DECLARE     @CloseBalance			  money						

				IF @Started = 0
				BEGIN
					-- COMMENT: specify datasource in proc.
					SET @DataSourceCd = ''SWIFT''
					IF @LocationPath IS NULL SET @LocationPath = @DataSourceCd
					
					EXEC @ReturnValue= [_ib_DataSource_GetByCodeForOutput] @DataSourceCd,@OutPut output, @Output2 output
					
					SET @DataSourceId = @Output
										
					SET @Started = 1
				END
	
			SET @Output = null
			SET @StringCursor = 0

			SET @Account = @AccountId_25
            					
			-- SET @ValueDate
			SET @Code = null
            SET @Code = SUBSTRING(@StatmtLine_61, 1, 6)
			
			SET @ValueDate = CONVERT(datetime, @Code, 12) 
            
            SET @Output = LEN(@StatmtLine_61) 
            SET @StatmtLine_61 = SUBSTRING(@StatmtLine_61,7, @Output - 6) 
			
			-- SET @TransDate
			SET @TransDate = @ValueDate
			SET @Code = null
			IF PATINDEX(''%[0-9]%'',@StatmtLine_61) = 1 
               BEGIN
                      SET @Code = SUBSTRING(@StatmtLine_61, 1, 4) 
					  SET @Code = ''00''+ @Code
						 
						BEGIN 
                          SET @TransDate = CONVERT(datetime, @Code, 12)
                          IF @ValueDate IS NOT null 
							BEGIN

                                -- Computing the year value of TransDate based on the year of ValueDate
                                -- There are 3 possible date values so we compare all of them and use the date closest to the ValueDate
								-- The date value is stored as a float value in the Sql Server system 
                                -- We convert the date values to float and compare the difference between each possible date and the ValueDate
								DECLARE @valueDateFloat float 
								DECLARE @equalYear float 
								DECLARE @equalYearStr varchar(8) 
                                
								SET @valueDateFloat = CAST(@ValueDate as float)
								SET @equalYearStr = @Code
								-- Replace the leading "00" with year
								SET @equalYearStr = CONVERT(varchar(4), YEAR(@ValueDate)) + RIGHT(@equalYearStr, 4)
								
								BEGIN 
									SET @equalYear = CAST(CONVERT(datetime, @equalYearStr, 112) as float)
									SET @equalYear = @equalYear - @valueDateFloat
									IF @equalYear < 0  SET @equalYear = @equalYear * -1

									SET @TransDate = CONVERT(datetime, @equalYearStr, 112)
								
									-- Based on the months of the ValueDate and TransDate we can reduce to 2 possible values
									IF MONTH(@ValueDate) < MONTH(@TransDate)
										BEGIN
											DECLARE @lowerYear float 
											DECLARE @lowerYearStr varchar(8) 
										           
											SET @lowerYearStr = @Code
											-- Replace the leading "00" with year
											SET @lowerYearStr = CONVERT(varchar(4), YEAR(@ValueDate) - 1) + RIGHT(@lowerYearStr, 4)
											 
											BEGIN    
											
												-- Quick Fix for Leap Year
												IF RIGHT(@lowerYearStr,4) = ''0229'' 
													SET @lowerYearStr = LEFT(@lowerYearStr, 4) + ''0301''   
													                         
												SET @lowerYear = CAST(CONVERT(datetime, @lowerYearStr, 112) as float)
												SET @lowerYear = @lowerYear - @valueDateFloat
												IF @lowerYear < 0 SET @lowerYear = @lowerYear * -1
								
												IF @lowerYear < @equalYear SET @TransDate = CONVERT(datetime, @lowerYearStr, 112)
											END
										END 

									ELSE
										BEGIN
                                								
											DECLARE @geaterYear float 
                                			DECLARE @geaterYearStr varchar(8) 
                                                
											SET @geaterYearStr = @Code              
											-- Replace the leading "00" with year
											SET @geaterYearStr = CONVERT(varchar(4), YEAR(@ValueDate) + 1) + RIGHT(@geaterYearStr, 4)
											 
											BEGIN  
											
												-- Quick Fix for Leap Year
												IF RIGHT(@geaterYearStr,4) = ''0229'' 
													SET @geaterYearStr = LEFT(@geaterYearStr, 4) + ''0301''

												SET @geaterYear = CAST(CONVERT(datetime, @geaterYearStr, 112) as float)
												SET @geaterYear = @geaterYear - @valueDateFloat
												IF @geaterYear < 0 SET @geaterYear = @geaterYear * -1

												IF @geaterYear < @equalYear SET @TransDate = CONVERT(datetime, @geaterYearStr, 112)
											END	
		                               	END
		                        END       	
							END
						END	
					  SET @Output = LEN(@StatmtLine_61) 
					  SET @StatmtLine_61 = SUBSTRING(@StatmtLine_61,5,@Output-4) 
			   END
            
            SET @StringCursor = PATINDEX(''%[0-9]%'',@StatmtLine_61) 
            SET @Code = SUBSTRING(@StatmtLine_61,1,1) 
			SET @Output = LEN(@StatmtLine_61) 
            SET @StatmtLine_61 = SUBSTRING(@StatmtLine_61,@StringCursor,@Output - @StringCursor +1) 
            
			SET @Amount = 1
            IF @Code <> ''C'' BEGIN SET @Amount = -1 END
			
            -- SET @Amount
            SET @StringCursor = PATINDEX(''%,%'',@StatmtLine_61)
            SET @Code = SUBSTRING(@StatmtLine_61,1,@StringCursor)
			SET @Code = REPLACE(@Code,'','',''.'')   
  
            SET @Output = LEN(@StatmtLine_61) 
            SET @StatmtLine_61 = SUBSTRING(@StatmtLine_61,@StringCursor+1,@Output - @StringCursor) 
            
            SET @StringCursor = PATINDEX(''%[^0-9]%'',@StatmtLine_61) 
            IF @StringCursor > 1 
               BEGIN
					 SET @Output = LEN(@StatmtLine_61) 
                     SET @Code2 = SUBSTRING(@StatmtLine_61,1,@StringCursor-1) 
                     SET @Code = @Code + @Code2
					 SET @StatmtLine_61 = SUBSTRING(@StatmtLine_61,@StringCursor,@Output - @StringCursor+1)
               END

            IF ISNUMERIC(@Code) = 1
                 SET @Amount = @Amount * CONVERT(decimal(18,4), @Code) 

            -- SET @TransactionType
			SET @TransactionType = SUBSTRING(@StatmtLine_61,1,4) 
            
			SET @Output = LEN(@StatmtLine_61) 
            SET @StatmtLine_61 = SUBSTRING(@StatmtLine_61,5,@Output - 4) 

			SET @ExternalReference = '''' -- Reset External Reference which could be empty
			
            -- SET @ExternalReference
            SET @StringCursor = PATINDEX(''%//%'',@StatmtLine_61) 
            IF @StringCursor > 0 
                 BEGIN
					   SET @Output = LEN(@StatmtLine_61) 
                       SET @ExternalReference = SUBSTRING(@StatmtLine_61,@StringCursor+2,@Output-@StringCursor-1) 
                       SET @StatmtLine_61 = SUBSTRING(@StatmtLine_61,1,@StringCursor-1) 
                 END

			-- SET @InternalReference
            SET @InternalReference = @StatmtLine_61         

			SET @Narrative = RTRIM(LTRIM(ISNULL(RTRIM(@StatmtLine_61_SupplemDetails), '''')
				+ '' '' + @InfoToAccOwn_1_86_lines_1_to_6))

			SET @Currency = @OpenBalance_60M_CurrencyCode
			IF @OpenBalance_60F_CurrencyCode IS NOT NULL
                  IF LEN(@OpenBalance_60F_CurrencyCode) > 2  
					SET @Currency = @OpenBalance_60F_CurrencyCode

			-- Updating the ib_SwiftStatement table	

			SET @StatementNumber = convert(int,@StatmtNo_28C)
			SET @StatementSequenceNumber = convert(int, @StatmtNoSeqNo_28C)  					

			UPDATE [dbo].[ib_SwiftStatement] 
			SET [TotalOfLineItemAmounts] = [TotalOfLineItemAmounts] + convert(MONEY, @Amount)
				, UpdateDate = GETDATE()
			WHERE ( SELECT TOP 1 Code 
                       FROM ib_Account a 
                       WHERE a.AccountId = [AccountId]
                   ) = @AccountId_25 
                   AND [StatementNumber] = @StatementNumber 
                   AND [StatementSequenceNumber] = @StatementSequenceNumber

			IF ISNUMERIC(@OpenBalance_60F_Amount) = 1 
                SET @OpenBalance = convert(money,REPLACE(@OpenBalance_60F_Amount,'','',''.''))
			ELSE SET @OpenBalance = convert(money,REPLACE(@OpenBalance_60M_Amount,'','',''.''))

			IF @OpenBalance_DCMark <> ''C'' SET @OpenBalance = @OpenBalance * (-1)

			IF ISNUMERIC(@ClosingBalance_62F_Amount) = 1
				SET @CloseBalance = convert(money,REPLACE(@ClosingBalance_62F_Amount,'','',''.''))
			ELSE SET @CloseBalance = convert(money,REPLACE(@ClosingBalance_62M_Amount,'','',''.''))

			IF @ClosingBalance_DCMark <> ''C'' SET @CloseBalance = @CloseBalance * (-1)

			IF LEN(@OpenBalance_60F_Date) > 0
                SET @BalanceDate = convert(datetime,@OpenBalance_60F_Date,12)
			ELSE SET @BalanceDate = convert(datetime,@OpenBalance_60M_Date,12)

			UPDATE #temp_SwiftStatement 
			SET 
                  [TotalOfLineItemAmounts] = [TotalOfLineItemAmounts] + convert(money,@Amount),
                  [CurrencyCode] = @Currency,
				  [BalanceDate]	= @BalanceDate,	
				  [OpenBalance] = @OpenBalance,
				  [ClosingBalance] = @CloseBalance,
				  [FileName] = @FileName,
				  [Firm] = @LTAdrs,
				  [DataSourceCd] = @DataSourceCd,
				  [IsLastInSequence] = CASE WHEN (@ClosingBalance_62F_Amount IS NULL OR @ClosingBalance_62F_Amount = '''') THEN 0 ELSE 1 END 
			WHERE [AccountCode] = @AccountId_25 
				AND [StatementNumber] = @StatementNumber 
				AND [StatementSequenceNumber] = @StatementSequenceNumber

            --------- End of Updating the ib_SwiftStatement

			DECLARE @Exists BIT

			EXEC dbo.[ib_SwiftStatement_CheckIfExistsExcludeMisses] @Account, @LTAdrs, @DataSourceId, @StatementNumber, @StatementSequenceNumber, @Exists output 
	
			DECLARE @NewNostroId INT
			
			IF @Exists = 0
				EXEC [ib_Nostro_Load]
							@DataSourceCd,
							@ValueDate,
							@TransDate,
							@Amount,
							@TransactionType,
							@InternalReference,
							@ExternalReference,
							@Narrative,
							@Account,
							@Currency,
							@LTAdrs,
							@SWIFT_MT940ID,
							@NostroId = @NewNostroId OUTPUT
			ELSE
			BEGIN
				DECLARE @message VARCHAR(255)
				SET @message = ''Skipping statement since already have equivalent; account  '' 
						+ @Account + '', '' 
						+ CONVERT(VARCHAR(25), @StatementNumber) 
						+ ''/'' + CONVERT(VARCHAR(25), @StatementSequenceNumber)
				EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @Message, ''Warning'', '''', @RunId
			END
			
			--flip processed flag in source table.
			UPDATE [SWIFT_MT940]
			SET [LoadState] = 2
			WHERE [SWIFT_MT940ID] = @SWIFT_MT940ID
				AND [LoadState] = 1

			FETCH NEXT FROM pos_cursor
			INTO 
					@SWIFT_MT940ID,	
					@LTAdrs,
					@AccountId_25,	
					@OpenBalance_60F_CurrencyCode,
					@OpenBalance_60M_CurrencyCode,	
					@StatmtLine_61,	
					@StatmtLine_61_SupplemDetails,
					@StatmtNo_28C,                   
					@StatmtNoSeqNo_28C,
					@OpenBalance_60F_Date,
					@OpenBalance_60M_Date,
					@OpenBalance_DCMark,
					@OpenBalance_60F_Amount,
					@OpenBalance_60M_Amount,
					@ClosingBalance_DCMark,
					@ClosingBalance_62F_Amount,
					@ClosingBalance_62M_Amount,
					@FileName,
					@InfoToAccOwn_1_86_lines_1_to_6

		END
			
			CLOSE pos_cursor
			DEALLOCATE pos_cursor

			DECLARE cursor_tempSwSt CURSOR FOR
			SELECT	[AccountCode],
					[StatementNumber],
					[StatementSequenceNumber],
					[BalanceDate],
					[CurrencyCode],
					[OpenBalance],
					[TotalOfLineItemAmounts],
					[ClosingBalance],
                    [FileName],
					[Firm],
					[DataSourceCd],
					[IsLastInSequence]
			FROM #temp_SwiftStatement

			OPEN cursor_tempSwSt

			DECLARE @AccountCode				varchar(35)
			DECLARE @CurrencyCode				varchar(3)	
			DECLARE @TotalOfLineItemAmounts		money
			DECLARE @ClosingBalance				money
			DECLARE @Firm						varchar(25)
			DECLARE @IsMissed					int
			DECLARE @IsMissReplacement			BIT
			DECLARE @IsLastInSequence			BIT

			FETCH NEXT FROM cursor_tempSwSt
			INTO 
					@AccountCode,
					@StatementNumber,
					@StatementSequenceNumber,
					@BalanceDate,
					@CurrencyCode,
					@OpenBalance,
					@TotalOfLineItemAmounts,
					@ClosingBalance,
                    @FileName,
					@Firm,
					@DataSourceCd,
					@IsLastInSequence	

				-- Check @@FETCH_STATUS to see IF there are any more rows to fetch.
				WHILE @@FETCH_STATUS = 0
				BEGIN		
			
					SET @IsMissed = ( SELECT COUNT(*)
									  FROM dbo.[ib_SwiftStatement] stm	
										INNER JOIN ib_Account a ON a.AccountId = stm.AccountId	
										WHERE a.Code = @AccountCode AND stm.StatementNumber = @StatementNumber AND stm.StatementSequenceNumber = @StatementSequenceNumber	
										AND stm.[FileName] = ''MISS''
									) 
									
					IF @IsMissed >= 1 -- then update it instead
						BEGIN
					
							SET @IsMissReplacement = 1
							
							EXEC [ib_SwiftStatement_UpdateIfExists]
								@AccountCode,
								@StatementNumber,
								@StatementSequenceNumber,
								@BalanceDate,
								@CurrencyCode,
								@OpenBalance,
								@TotalOfLineItemAmounts,
								@ClosingBalance,
						        @FileName,
								@DataSourceCd,
								@Firm,
								@IsLastInSequence,
								@IsMissReplacement
											
						END													
					ELSE -- @IsMissed < 1
						BEGIN
					
							SET @IsMissReplacement = 0
					
							EXEC [ib_SwiftStatement_Add]
									@AccountCode,
									@StatementNumber,
									@StatementSequenceNumber,
									@BalanceDate,
									@CurrencyCode,
									@OpenBalance,
									@TotalOfLineItemAmounts,
									@ClosingBalance,
							        @FileName,
									@DataSourceCd,
									@Firm,
									@IsLastInSequence,
									@IsMissReplacement,
									@ReceiveLocationSysId,
									@RunId
						END
								
					FETCH NEXT FROM cursor_tempSwSt
						INTO 
							@AccountCode,
							@StatementNumber,
							@StatementSequenceNumber,
							@BalanceDate,
							@CurrencyCode,
							@OpenBalance,
							@TotalOfLineItemAmounts,
							@ClosingBalance,
                            @FileName,
							@Firm,
							@DataSourceCd,
							@IsLastInSequence							
				END

			CLOSE cursor_tempSwSt
			DEALLOCATE cursor_tempSwSt

			DROP TABLE #temp1
			DROP TABLE #temp_SwiftStatement

	COMMIT TRANSACTION T1
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_DataSource_GetSummary]''
');

GO
EXECUTE ('-- =============================================
-- Author:		Anil Kripalani
-- Create date: 23 Oct 2006
-- Description:	For page to show Data Sources
-- =============================================
CREATE PROCEDURE [dbo].[ib_DataSource_GetSummary] 
	@StartDate	DATETIME = ''01 Jan 2000''
	, @EndDate	DATETIME = ''31 Dec 2100''
AS
BEGIN

	--	02 Nov 2006		amk		Also return last createdate''s of position and trx
	--	13 Nov 2006		amk		Group by asofdate (so row per day in range)
	--	14 Nov 2006		amk		Bug Fix: all for end date inclusive!

	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	SELECT ds.Code, COUNT(p.PositionId) AS [Position Rows]
		, p.AsOfDate
		, MAX(AsOfDate) AS [Last Position]
		, MAX(p.CreateDate) AS [Position Last Added On]
	INTO #pos
	FROM ib_DataSource ds
		LEFT OUTER JOIN ib_Position p ON p.DataSourceId = ds.DataSourceId
	WHERE p.[AsOfDate] >= @StartDate and p.[AsOfDate] <= @EndDate
	GROUP BY p.AsOfDate, ds.Code

	SELECT ds.Code, COUNT(t.trxid) AS [Trx Rows]
		, t.AsOfDate
		, MAX(AsOfDate) AS [Last Trx]
		, MAX(t.CreateDate) AS [Trx Last Added On]
	INTO #trx
	FROM ib_DataSource ds
		LEFT OUTER JOIN ib_Trx t ON t.DataSourceId = ds.DataSourceId
	WHERE t.[AsOfDate] >= @StartDate and t.[AsOfDate] <= @EndDate
	GROUP BY t.AsOfDate, ds.Code

	-- WATCH OUT: FULL OUTER JOIN AHEAD!

	SELECT ISNULL(p.Code, t.Code) AS [Data Source]
		, CONVERT(VARCHAR(10), ISNULL(p.AsOfDate, t.AsOfDate), 103) AS [As Of Date]
		, p.[Position Rows]
		, CONVERT(VARCHAR(10), p.[Last Position], 103) AS [Last Position]
		, p.[Position Last Added On]
		, NULL as ''|''
		, t.[Trx Rows]
		, CONVERT(VARCHAR(10), t.[Last Trx], 103) AS [Last Trx]
		, t.[Trx Last Added On]
	FROM #pos p
		FULL OUTER JOIN #trx t ON p.Code = t.Code AND p.AsOfDate = t.AsOfDate
	ORDER BY [Data Source], [As Of Date]

	DROP TABLE #pos

	DROP TABLE #trx
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[eib_DeleteStagingFile]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[eib_DeleteStagingFile]
(
	@StagingFileId int
)
AS

SET NOCOUNT ON

DELETE 
	eib_StagingFile
WHERE
	eib_StagingFile.StagingFileId = @StagingFileId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[RBC_Transaction_Add]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[RBC_Transaction_Add]
	@Filename				varchar(512)=NULL,
	@Type					varchar(3)=NULL,
	@Serial					varchar(5)=NULL,
	@Ledger					varchar(7)=NULL,
	@FASCurrency			varchar(3)=NULL,
	@Currency				varchar(3)=NULL,
	@BaseCurrency			varchar(3)=NULL,
	@Market					varchar(5)=NULL,
	@MarketCode				varchar(5)=NULL,
	@DummyField				varchar(3)=NULL,
	@RunDate				varchar(8)=NULL,
	@RecordType_Field1		VARCHAR(100)=NULL,
	@RecordType_Field2		VARCHAR(100)=NULL,
	@RecordType_Field3		VARCHAR(100)=NULL,
	@RecordType_Field4		VARCHAR(100)=NULL,
	@RecordType_Field5		VARCHAR(100)=NULL,
	@RecordType_Field6		VARCHAR(100)=NULL,
	@RecordType_Field7		VARCHAR(100)=NULL,
	@RecordType_Field8		VARCHAR(100)=NULL,
	@RecordType_Field9		varchar(100)=NULL,
	@RecordType_Field10		varchar(100)=NULL,
	@RecordType_Field11		varchar(100)=NULL,
	@RecordType_Field12		varchar(100)=NULL,
	@RecordType_Field13		varchar(100)=NULL, -- NOT used as @ 08 Mar 2010. Only here for possible expansion in the future.
	@RecordType_Field14		varchar(100)=NULL, -- NOT used as @ 08 Mar 2010. Only here for possible expansion in the future.
	@RecordType_Field15		varchar(100)=NULL  -- NOT used as @ 08 Mar 2010. Only here for possible expansion in the future.
AS
SET NOCOUNT ON;

/*
-- 23 Apr 2014  ED  EIB 25559
*/


--KevinP : TODO: Work out where to grab the fields for the table depending on the RecordType!
DECLARE @StrikeShort VARCHAR(21)
DECLARE @Strike VARCHAR(21)
DECLARE @PutCall VARCHAR(2)
DECLARE @Lots VARCHAR(21)
DECLARE @Price VARCHAR(21)
DECLARE @OpenClose VARCHAR(1)
DECLARE @PostingAmount VARCHAR(20)
DECLARE @IsMergedTrade CHAR(1)
DECLARE @Serial2 VARCHAR(10)
DECLARE @PromptDate VARCHAR(8)

--Used for 003, 004,020,093,006,007,012,013
DECLARE @Series VARCHAR(20)
DECLARE @FullSeries VARCHAR(20)
DECLARE @Premium VARCHAR(20)

--This is just to make sure that we dont add record types we don''t know about...
DECLARE @IsValidToInsertRecord BIT
SET @IsValidToInsertRecord = 0

-- Used for 005 only
DECLARE @IsCashSettlingOption CHAR(1)

IF	@Type = ''001'' OR 
	@Type = ''002'' OR
	@Type = ''014'' OR 
	@Type = ''018'' OR 
	@Type = ''019'' OR 
	@Type = ''091'' 
BEGIN
	SET @Serial2= @RecordType_Field1
	SET @PromptDate = @RecordType_Field2
	SET @Lots = @RecordType_Field3
	SET @Price = @RecordType_Field4
	SET @PostingAmount = @RecordType_Field5
	SET @OpenClose = @RecordType_Field6
	SET @IsMergedTrade = @RecordType_Field7
	SET @Strike = 0
	SET @StrikeShort = NULL
	SET @PutCall = NULL
	SET @IsValidToInsertRecord = 1
END


IF	@Type = ''003'' OR 
	@Type = ''004'' OR
	@Type = ''020'' OR 
	@Type = ''093'' 
BEGIN
	SET @Serial2= @RecordType_Field1
	SET @PromptDate = @RecordType_Field2
	SET @Series = @RecordType_Field3
	SET @PutCall = @RecordType_Field4
	SET @Lots = @RecordType_Field5
	SET @Price = @RecordType_Field6
	SET @Premium = @RecordType_Field7
	SET @Strike = @RecordType_Field3 -- We get this from Series Column because Price doesn''t hold anything...
	SET @PostingAmount = @RecordType_Field9
	SET @OpenClose = @RecordType_Field10
	SET @IsMergedTrade = @RecordType_Field11
	SET @FullSeries = @RecordType_Field12
	SET @IsValidToInsertRecord = 1
END

IF	@Type = ''005'' 
BEGIN
	SET @Serial2= @RecordType_Field1
	SET @Lots = @RecordType_Field2
	SET @PromptDate = @RecordType_Field3
	SET @PostingAmount = @RecordType_Field4
	SET @IsCashSettlingOption = @RecordType_Field5
	SET @PutCall = NULL -- N/A for 005 Record Types.
	SET @Price = NULL -- N/A
	SET @Strike = NULL -- N/A
	SET @StrikeShort = NULL --N/A
	SET @IsValidToInsertRecord = 1
END

IF	@Type = ''006'' 
BEGIN
	SET @Serial2= @RecordType_Field1
	SET @PromptDate = @RecordType_Field2
	SET @Series = @RecordType_Field3
	SET @PutCall = @RecordType_Field4
	SET @Lots = @RecordType_Field5
	SET @Price = @RecordType_Field6 -- NB:- Price will actuall hold the value in the Premium Rate Column
	SET @Premium = @RecordType_Field7
	SET @PostingAmount = @RecordType_Field8 
	SET @Strike = @RecordType_Field3 --NB:- We get this from Series Column because Price doesn''t hold anything...
	SET @OpenClose = @RecordType_Field10
	SET @FullSeries = @RecordType_Field10
	SET @StrikeShort = NULL --N/A
	SET @IsValidToInsertRecord = 1
END

IF	@Type = ''007'' 
BEGIN
	SET @Serial2= @RecordType_Field3
	SET @Lots = @RecordType_Field4
	SET @PromptDate = @RecordType_Field5
	SET @PostingAmount = @RecordType_Field6
	SET @Series = @RecordType_Field7
	SET @PutCall = @RecordType_Field8
	SET @FullSeries = @RecordType_Field10

	SET @Price = NULL
	SET @Premium = NULL
	SET @Strike = @RecordType_Field7
	SET @OpenClose = NULL
	SET @StrikeShort = NULL --N/A
	SET @IsValidToInsertRecord = 1
END

IF	@Type = ''012'' OR
	@Type = ''013''
BEGIN
	SET @Serial2= @RecordType_Field1
	SET @PromptDate = @RecordType_Field2
	SET @Series = @RecordType_Field3
	SET @PutCall = @RecordType_Field4
	SET @Lots = @RecordType_Field5
	SET @Price = @RecordType_Field6
	SET @Premium = @RecordType_Field7
	SET @PostingAmount = @RecordType_Field8
	SET @Strike = @RecordType_Field3 -- We get this from Series Column because Price doesn''t hold anything...
	SET @OpenClose = @RecordType_Field10
	SET @FullSeries = @RecordType_Field11	
	SET @StrikeShort = NULL --N/A
	SET @IsValidToInsertRecord = 1
END


IF @IsValidToInsertRecord = 1
BEGIN
	INSERT INTO [dbo].[RBC_Transaction]
				( 
					[Filename]
					,[Type]
					,[Serial]
					,[Ledger]
					,[FASCurrency]
					,[Currency]
					,[BaseCurrency]
					,[Market]
					,[MarketCode]
					,[DummyField]
					,[RunDate]
					,[Serial2]
					,[PromptDate]
					,[StrikeShort]
					,[Strike]
					,[PutCall]
					,[Lots]
					,[Price]
					,[OpenClose]
					,[PostingAmount]
					,[IsMergedTrade]
					,[Series]
					,[FullSeries]
					,[Premium]
					,[IsCashSettlingOption]
				)
		VALUES
				( 
					@Filename,
					@Type,
					@Serial,
					@Ledger,
					@FASCurrency,
					@Currency,
					@BaseCurrency,
					@Market,	
					@MarketCode,
					@DummyField,
					@RunDate,
					@Serial2,
					@PromptDate,
					@StrikeShort,
					@Strike,
					@PutCall,
					@Lots,
					@Price,
					@OpenClose,
					@PostingAmount,
					@IsMergedTrade,
					@Series,
					@FullSeries,
					@Premium,
					@IsCashSettlingOption
				)
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_SiteTemplate_CheckForDuplicate]''
');

GO
SET ANSI_NULLS OFF

GO
EXECUTE ('  /*
<details>
 <summary>
	Checks for the duplicate site templates with same fields. 
</summary>
   <created author="laurentiu.macovei" date="Fri, 29 Sep 2006 15:28:04 GMT"/>
</details>
*/
create PROCEDURE [dbo].[ib_SiteTemplate_CheckForDuplicate]
@SiteId varchar(100),
@TemplateId varchar(100),
@SiteTemplateId int
AS
SET NOCOUNT ON

DECLARE @Count int
DECLARE @SiteName varchar(100)
DECLARE @TemplateDescription varchar(100)

SET @Count=0

SELECT TOP 1 @Count = 1, @SiteName = s.[Name], @TemplateDescription = t.Description
	FROM [dbo].[ib_SiteTemplate] st
		INNER JOIN [dbo].[ib_Site] s ON s.SiteId = st.SiteId
		INNER JOIN [dbo].[ib_Template] t ON t.TemplateId = st.TemplateId
	WHERE st.SiteId = @SiteId
		AND st.TemplateId = @TemplateID
		AND st.SiteTemplateID <> @SiteTemplateId

IF @Count > 0
	RAISERROR (N''There is already another site template with same template (%s) and same site (%s). Please specify values!'', 11, 1, @SiteName, @TemplateDescription)
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_SWIFT_MT950_Load]''
');

GO
SET ANSI_NULLS ON

GO
EXECUTE ('
CREATE PROCEDURE [dbo].[ib_SWIFT_MT950_Load] 
	(
		@LocationPath	varchar(100) = NULL
		,@ReceiveLocationSysId INT
		,@RunId INT
	)
AS
SET NOCOUNT ON
-- =============================================
-- Author:		Petru Konrad Bercea
-- Create date: 21.01.2009
-- Description:	This stored procedure pulls data from the SWIFT_MT950
-- table and inserts it into the ib_Nostro.  
-- Whilst iterating through the records in SWIFT_MT950, all 
-- of these inserts are wrapped in a transaction so that any failure causes
-- the changes to not commit.
--
--
-- Revision History
--
-- 19 Feb 2009		Konrad		Removed ISDATE function calls as this function 
--								doesn''t recognise all the date format styles.
-- 19 Feb 2009		Konrad		Set the TransDate by default equal to the ValueDate  
--
-- 
-- 16.04.2009       Konrad      Added SwiftStatement Data Persist for Data Integrity Check of SWIFT Loading
-- 17.04.2009		Konrad		Fixed the BalanceDate persisting into the ib_SwiftStatement table.
-- 18.04.2009		Konrad      Fixed conversion of Open / Closing Balance and marking their Debit / Credit sign also.	
-- 07.07.2009       Konrad      Missed statements are replaced if real ones are loaded
-- 15.07.2009       Konrad      Swift Statements are uniquely added and duplicates logged in ImportLog table
-- 21.08.2009		AAJM		Fix  Nostro Records Not Being Created from SWIFT Files - wrong 
--								"if exists" expression
-- 24.08.2009		AAJM		Fix Nostro records not being loaded because SwiftftStatement ''if exists''
--								returned MISS records.
-- 09.09.2009		AAJM		Calculate IsLastInSequence to add to ib_SwiftStatement to support
--								MISS gap record logic
-- 10.09.2009		AAJM		Mark SwiftStatement record as IsMissReplacement when new
--								statement added and MISS deleted
-- 15.09.2009		amk		    1. Set transaction isolation level
--								2. Move loader ended msg to postload so it only runs once
--								3. Move loader started msg to checkiffileexists so it only runs once
-- 18.09.2009		amk			Limit initial record selection to just ones for this file
-- 07.10.2009		amk			Bug Fix (from Live, ouch!): fix replacing of 00 in date
-- 28.10.2009		AAJM		MBAL-13637 Don''t delete Swift Statements but, rather, update.
--								Add output NostroId parameter for ib_Nostro_Load
-- 18.02.2010		AAJM		MBAL-14483 External Reference being copied down when empty
-- 10.05.2010		amk			MBAL-15484 Don''t load statements with EARLIER statement no/seq no
-- 11.05.2010       ED          MNAL 15488 Use Seed for StatementNumber
-- 19.05.2010		amk			MBAL-15484 Fix bug I introduced (allow MISS to be handled correctly)
-- 20.05.2010		amk			MBAL-15484 Undo this bug fix since there isn''t a MISS logged for every point in GAP 
--								Marc agreed to scrap the bug fix and let the ''seed'' enhancement handle the need
-- 01.03.2012		AAJM		MBAL-20190 Leap Year Fix
-- 05.06.2012		ED			MBAL 20952 move change load state to load file and adding (nolock) to avoid deadlocks
-- 08.01.2014		ED			EIB 24203 - fix the logic for IsLastInSequence
-- 08.01.2014		ED			EIB 25004 - remove importLog table and use Log table
-- =============================================
BEGIN

BEGIN TRANSACTION T1

-- BizTalk''s SQL Adapter uses more restrictive read serializable
-- so this is necessary to relax it to something that is default
-- and perfectly acceptable!
SET TRANSACTION ISOLATION LEVEL READ COMMITTED

UPDATE [dbo].[SWIFT_MT950] SET LoadState = 1   WHERE LoadState= 0 AND Filename = @LocationPath

CREATE TABLE #temp1
	(
		SWIFT_MT950ID						int,
		LTAdrs								varchar(12) COLLATE Latin1_General_CI_AS,
		AccountId_25						varchar(35) COLLATE Latin1_General_CI_AS,
		OpenBalance_60F_CurrencyCode		varchar(3) COLLATE Latin1_General_CI_AS,
		OpenBalance_60M_CurrencyCode		varchar(3) COLLATE Latin1_General_CI_AS,
		StatmtLine_61						varchar(66) COLLATE Latin1_General_CI_AS,
		StatmtLine_61_SupplemDetails		varchar(34) COLLATE Latin1_General_CI_AS,
		StatmtNo_28C                        varchar(5) COLLATE Latin1_General_CI_AS,
		StatmtNoSeqNo_28C					varchar(5) COLLATE Latin1_General_CI_AS,
		OpenBalance_60F_Date				varchar(6) COLLATE Latin1_General_CI_AS,
		OpenBalance_60M_Date				varchar(6) COLLATE Latin1_General_CI_AS,
		OpenBalance_DCMark					char(1),
		OpenBalance_60F_Amount				varchar(15) COLLATE Latin1_General_CI_AS,
		OpenBalance_60M_Amount				varchar(15) COLLATE Latin1_General_CI_AS,
		ClosingBalance_DCMark				char(1),
		ClosingBalance_62F_Amount			varchar(15) COLLATE Latin1_General_CI_AS,
		ClosingBalance_62M_Amount			varchar(15) COLLATE Latin1_General_CI_AS,
		[FileName]							varchar(512) COLLATE Latin1_General_CI_AS,
	)

	INSERT INTO #temp1
	(
		SWIFT_MT950ID,	
		LTAdrs,
		AccountId_25,	
		OpenBalance_60F_CurrencyCode,
		OpenBalance_60M_CurrencyCode,	
		StatmtLine_61,	
		StatmtLine_61_SupplemDetails,
		StatmtNo_28C,
		StatmtNoSeqNo_28C,
		OpenBalance_60F_Date,
		OpenBalance_60M_Date,
		OpenBalance_DCMark,				
		OpenBalance_60F_Amount,
		OpenBalance_60M_Amount,
		ClosingBalance_DCMark,
		ClosingBalance_62F_Amount,
		ClosingBalance_62M_Amount,
		[FileName]
	)
	SELECT 	
		SWIFT_MT950ID,
		LTAdrs,
		AccountId_25,	
		OpenBalance_60F_CurrencyCode,
		OpenBalance_60M_CurrencyCode,	
		StatmtLine_61,	
		StatmtLine_61_SupplemDetails,
		[dbo].[GetFixedSwiftStatementNumber](AccountId_25, StatmtNo_28C),
		StatmtNoSeqNo_28C,
		OpenBalance_60F_Date,
		OpenBalance_60M_Date,
		CASE WHEN (LEN(OpenBalance_60F_DCMark) > 0) THEN OpenBalance_60F_DCMark 
		ELSE OpenBalance_60M_DCMark END,	
		OpenBalance_60F_Amount,
		OpenBalance_60M_Amount,
		CASE WHEN (LEN(ClosingBalance_62F_DCMark) > 0) THEN ClosingBalance_62F_DCMark 
		ELSE ClosingBalance_62M_DCMark END,
		ClosingBalance_62F_Amount,
		ClosingBalance_62M_Amount,
		[FileName]
	FROM [dbo].[SWIFT_MT950] (NOLOCK) 
	WHERE LoadState = 1
		AND [FileName] = @LocationPath

	CREATE TABLE #temp_SwiftStatement
	(
		[AccountCode] varchar(35)  COLLATE Latin1_General_CI_AS,
		[StatementNumber] int,
		[StatementSequenceNumber] int,
		[BalanceDate] datetime,
		[CurrencyCode]	varchar(3) COLLATE Latin1_General_CI_AS,
		[OpenBalance] money,
		[TotalOfLineItemAmounts] money,
		[ClosingBalance] money,
		[FileName] varchar(512)  COLLATE Latin1_General_CI_AS,
		[Firm] varchar(25)  COLLATE Latin1_General_CI_AS,
		[DataSourceCd]	varchar(100)  COLLATE Latin1_General_CI_AS,
		[IsLastInSequence] bit
	)

	INSERT INTO #temp_SwiftStatement
	(
		[AccountCode],
		[StatementNumber],
		[StatementSequenceNumber],
		[TotalOfLineItemAmounts]
		
	)
	SELECT DISTINCT	
		AccountId_25,	
		convert(int,StatmtNo_28C),
		convert(int,StatmtNoSeqNo_28C),
		0
	FROM #temp1
	WHERE	
			NOT EXISTS (SELECT *
			  FROM dbo.[ib_SwiftStatement] stm	
				  INNER JOIN ib_Account a ON a.AccountId = stm.AccountId	
			  WHERE a.Code = #temp1.AccountId_25 
					AND stm.[FileName] <> ''MISS''
					AND stm.StatementNumber = CONVERT(INT, StatmtNo_28C) 
					AND stm.StatementSequenceNumber = CONVERT(INT, StatmtNoSeqNo_28C)
				) 

			DECLARE @SWIFT_MT950ID					int
			DECLARE	@LTAdrs							varchar(12)
			DECLARE	@AccountId_25					varchar(35)
			DECLARE @OpenBalance_60F_CurrencyCode	varchar(3)
			DECLARE @OpenBalance_60M_CurrencyCode	varchar(3)
			DECLARE	@StatmtLine_61					varchar(66)
			DECLARE	@StatmtLine_61_SupplemDetails	varchar(34)
			DECLARE @Started						bit
			DECLARE	@StatmtNo_28C                   varchar(5)
			DECLARE	@StatmtNoSeqNo_28C				varchar(5)
			DECLARE	@OpenBalance_60F_Date			varchar(6)
			DECLARE	@OpenBalance_60M_Date			varchar(6)
			DECLARE @OpenBalance_DCMark				char(1)
			DECLARE	@OpenBalance_60F_Amount			varchar(15)
			DECLARE	@OpenBalance_60M_Amount			varchar(15)
			DECLARE @ClosingBalance_DCMark				char(1)
			DECLARE	@ClosingBalance_62F_Amount		varchar(15)
			DECLARE	@ClosingBalance_62M_Amount		varchar(15)
			DECLARE	@FileName						varchar(512)
			DECLARE @BalanceDate					datetime


			SET @Started = 0

			DECLARE pos_cursor CURSOR FOR
			SELECT	SWIFT_MT950ID,
					LTAdrs,	
					AccountId_25,	
					OpenBalance_60F_CurrencyCode,
					OpenBalance_60M_CurrencyCode,	
					StatmtLine_61,	
					StatmtLine_61_SupplemDetails,
					StatmtNo_28C,
					StatmtNoSeqNo_28C,
					OpenBalance_60F_Date,
					OpenBalance_60M_Date,
					OpenBalance_DCMark,				
					OpenBalance_60F_Amount,
					OpenBalance_60M_Amount,
					ClosingBalance_DCMark,
					ClosingBalance_62F_Amount,
					ClosingBalance_62M_Amount,
					[FileName]	
			FROM #temp1

			OPEN pos_cursor

			FETCH NEXT FROM pos_cursor
			INTO 
					@SWIFT_MT950ID,
					@LTAdrs,	
					@AccountId_25,	
					@OpenBalance_60F_CurrencyCode,
					@OpenBalance_60M_CurrencyCode,	
					@StatmtLine_61,	
					@StatmtLine_61_SupplemDetails,
					@StatmtNo_28C,                   
					@StatmtNoSeqNo_28C,
					@OpenBalance_60F_Date,
					@OpenBalance_60M_Date,
					@OpenBalance_DCMark,
					@OpenBalance_60F_Amount,
					@OpenBalance_60M_Amount,
					@ClosingBalance_DCMark,
					@ClosingBalance_62F_Amount,
					@ClosingBalance_62M_Amount,
					@FileName

				-- Check @@FETCH_STATUS to see IF there are any more rows to fetch.
				WHILE @@FETCH_STATUS = 0
				BEGIN
					DECLARE 	@DataSourceCd			varchar(100)
					DECLARE		@ValueDate				datetime
					DECLARE		@TransDate				datetime
					DECLARE		@Amount					decimal(18, 4)
					DECLARE		@TransactionType		varchar(4)
					DECLARE		@InternalReference		varchar(16)
					DECLARE		@ExternalReference		varchar(16)
					DECLARE		@Narrative				varchar(max)
					DECLARE		@Account				varchar(35)
					DECLARE		@Currency				varchar(3)
					DECLARE 	@ReturnValue int, @Output int, @StringCursor int, @Output2 int
					DECLARE     @Continue    bit
					DECLARE 	@DataSourceId int
					DECLARE 	@Code varchar(100), @Code2 varchar(100)
					DECLARE     @StatementNumber          int
					DECLARE     @StatementSequenceNumber  int 
					DECLARE     @OpenBalance			  money
					DECLARE     @CloseBalance			  money	
					
				IF @Started = 0
				BEGIN
					-- COMMENT: specify datasource in proc.
					SET @DataSourceCd = ''SWIFT''
					IF @LocationPath IS NULL SET @LocationPath = @DataSourceCd
					
					EXEC @ReturnValue= [_ib_DataSource_GetByCodeForOutput] @DataSourceCd,@OutPut output, @Output2 output
					
					SET @DataSourceId = @Output
										
					SET @Started = 1
				END
	

			SET @Output = null
			SET @StringCursor = 0

			SET @Account = @AccountId_25
		
			-- SET @ValueDate
			SET @Code = null
            SET @Code = SUBSTRING(@StatmtLine_61, 1, 6)
			
			SET @ValueDate = CONVERT(datetime, @Code, 12) 
			               
            SET @Output = LEN(@StatmtLine_61) 
            SET @StatmtLine_61 = SUBSTRING(@StatmtLine_61,7, @Output - 6) 
			
			-- SET @TransDate
			SET @TransDate = @ValueDate
			SET @Code = null
			IF PATINDEX(''%[0-9]%'',@StatmtLine_61) = 1 
               BEGIN
                      SET @Code = SUBSTRING(@StatmtLine_61, 1, 4) 
					  SET @Code = ''00''+ @Code
                      
						 
						BEGIN 
                          SET @TransDate = CONVERT(datetime, @Code, 12)
                          IF @ValueDate IS NOT null 
							BEGIN

                                -- Computing the year value of TransDate based on the year of ValueDate
                                -- There are 3 possible date values so we compare all of them and use the date closest to the ValueDate
								-- The date value is stored as a float value in the Sql Server system 
                               
                                -- We convert the date values to float and compare the difference between each possible date and the ValueDate
								DECLARE @valueDateFloat float 
								DECLARE @equalYear float 
								DECLARE @equalYearStr varchar(8) 
                                
								SET @valueDateFloat = CAST(@ValueDate as float)
								SET @equalYearStr = @Code
								-- Replace the leading "00" with year
								SET @equalYearStr = CONVERT(varchar(4), YEAR(@ValueDate)) + RIGHT(@equalYearStr, 4)
								
								BEGIN 
									SET @equalYear = CAST(CONVERT(datetime, @equalYearStr, 112) as float)
									SET @equalYear = @equalYear - @valueDateFloat
									IF @equalYear < 0  SET @equalYear = @equalYear * -1

									SET @TransDate = CONVERT(datetime, @equalYearStr, 112)
								
									-- Based on the months of the ValueDate and TransDate we can reduce to 2 possible values
									IF MONTH(@ValueDate) < MONTH(@TransDate)
										BEGIN
											DECLARE @lowerYear float 
											DECLARE @lowerYearStr varchar(8) 
										           
											SET @lowerYearStr = @Code
											-- Replace the leading "00" with year
											SET @lowerYearStr = CONVERT(varchar(4), YEAR(@ValueDate) - 1) + RIGHT(@lowerYearStr, 4)
											 
											BEGIN       
											                     											
												-- Quick Fix for Leap Year
												IF RIGHT(@lowerYearStr,4) = ''0229'' 
													SET @lowerYearStr = LEFT(@lowerYearStr, 4) + ''0301''   
													                             
												SET @lowerYear = CAST(CONVERT(datetime, @lowerYearStr, 112) as float)
												SET @lowerYear = @lowerYear - @valueDateFloat
												IF @lowerYear < 0 SET @lowerYear = @lowerYear * -1
								
												IF @lowerYear < @equalYear SET @TransDate = CONVERT(datetime, @lowerYearStr, 112)
											END
										END 

									ELSE
										BEGIN
                                								
											DECLARE @geaterYear float 
                                			DECLARE @geaterYearStr varchar(8) 
                                                
											SET @geaterYearStr = @Code              
											-- Replace the leading "00" with year
											SET @geaterYearStr = CONVERT(varchar(4), YEAR(@ValueDate) + 1) + RIGHT(@geaterYearStr, 4)
											 
											BEGIN  
																						
												-- Quick Fix for Leap Year
												IF RIGHT(@geaterYearStr,4) = ''0229'' 
													SET @geaterYearStr = LEFT(@geaterYearStr, 4) + ''0301''

												SET @geaterYear = CAST(CONVERT(datetime, @geaterYearStr, 112) as float)
												SET @geaterYear = @geaterYear - @valueDateFloat
												IF @geaterYear < 0 SET @geaterYear = @geaterYear * -1

												IF @geaterYear < @equalYear SET @TransDate = CONVERT(datetime, @geaterYearStr, 112)
											END	
		                               	END
		                        END       	
							END
						END	
					  SET @Output = LEN(@StatmtLine_61) 
					  SET @StatmtLine_61 = SUBSTRING(@StatmtLine_61,5,@Output-4) 
			   END
            
            SET @StringCursor = PATINDEX(''%[0-9]%'',@StatmtLine_61) 
            SET @Code = SUBSTRING(@StatmtLine_61,1,1) 
			SET @Output = LEN(@StatmtLine_61) 
            SET @StatmtLine_61 = SUBSTRING(@StatmtLine_61,@StringCursor,@Output - @StringCursor +1) 
            
			SET @Amount = 1
            IF  @Code <> ''C'' BEGIN SET @Amount = -1 END
			
            -- SET @Amount
            SET @StringCursor = PATINDEX(''%,%'',@StatmtLine_61)
            SET @Code = SUBSTRING(@StatmtLine_61,1,@StringCursor)
			SET @Code = REPLACE(@Code,'','',''.'')   
  
            SET @Output = LEN(@StatmtLine_61) 
            SET @StatmtLine_61 = SUBSTRING(@StatmtLine_61,@StringCursor+1,@Output - @StringCursor) 
            
            SET @StringCursor = PATINDEX(''%[^0-9]%'',@StatmtLine_61) 
            IF @StringCursor > 1 
               BEGIN
					 SET @Output = LEN(@StatmtLine_61) 
                     SET @Code2 = SUBSTRING(@StatmtLine_61,1,@StringCursor-1) 
                     SET @Code = @Code + @Code2
					 SET @StatmtLine_61 = SUBSTRING(@StatmtLine_61,@StringCursor,@Output - @StringCursor+1)
               END

            IF ISNUMERIC(@Code) = 1
                 SET @Amount = @Amount * CONVERT(decimal(18,4), @Code) 

            -- SET @TransactionType
			SET @TransactionType = SUBSTRING(@StatmtLine_61,1,4) 
            
			SET @Output = LEN(@StatmtLine_61) 
            SET @StatmtLine_61 = SUBSTRING(@StatmtLine_61,5,@Output - 4) 

			SET @ExternalReference = '''' -- Reset External Reference which could be empty
			
            -- SET @ExternalReference
            SET @StringCursor = PATINDEX(''%//%'',@StatmtLine_61) 
            IF @StringCursor > 0 
                 BEGIN
					   SET @Output = LEN(@StatmtLine_61) 
                       SET @ExternalReference = SUBSTRING(@StatmtLine_61,@StringCursor+2,@Output-@StringCursor-1) 
                       SET @StatmtLine_61 = SUBSTRING(@StatmtLine_61,1,@StringCursor-1) 
                 END

			-- SET @InternalReference
            SET @InternalReference = @StatmtLine_61         

			SET @Narrative = @StatmtLine_61_SupplemDetails
			
			SET @Currency = @OpenBalance_60M_CurrencyCode
			IF @OpenBalance_60F_CurrencyCode IS NOT NULL
                  IF LEN(@OpenBalance_60F_CurrencyCode) > 2  
					SET @Currency = @OpenBalance_60F_CurrencyCode
            
			-- Updating the ib_SwiftStatement table	

			SET @StatementNumber = convert(int,@StatmtNo_28C)
			SET @StatementSequenceNumber = convert(int, @StatmtNoSeqNo_28C)  					

			UPDATE [dbo].[ib_SwiftStatement] 
			SET [TotalOfLineItemAmounts] = [TotalOfLineItemAmounts] + convert(MONEY, @Amount)
				, UpdateDate = GETDATE()
			WHERE ( SELECT TOP 1 Code 
                       FROM ib_Account a 
                       WHERE a.AccountId = [AccountId]
                   ) = @AccountId_25 
                   AND [StatementNumber] = @StatementNumber 
                   AND [StatementSequenceNumber] = @StatementSequenceNumber

			IF ISNUMERIC(@OpenBalance_60F_Amount) = 1 
                SET @OpenBalance = convert(money,REPLACE(@OpenBalance_60F_Amount,'','',''.''))
			ELSE SET @OpenBalance = convert(money,REPLACE(@OpenBalance_60M_Amount,'','',''.''))

			IF @OpenBalance_DCMark <> ''C'' SET @OpenBalance = @OpenBalance * (-1)  

			IF ISNUMERIC(@ClosingBalance_62F_Amount) = 1
				SET @CloseBalance = convert(money,REPLACE(@ClosingBalance_62F_Amount,'','',''.''))
			ELSE SET @CloseBalance = convert(money,REPLACE(@ClosingBalance_62M_Amount,'','',''.''))

			IF @ClosingBalance_DCMark <> ''C'' SET @CloseBalance = @CloseBalance * (-1)

			IF LEN(@OpenBalance_60F_Date) > 0
                SET @BalanceDate = convert(datetime,@OpenBalance_60F_Date,12)
			ELSE SET @BalanceDate = convert(datetime,@OpenBalance_60M_Date,12)

			UPDATE #temp_SwiftStatement 
			SET 
                  [TotalOfLineItemAmounts] = [TotalOfLineItemAmounts] + convert(money,@Amount),
                  [CurrencyCode] = @Currency,
				  [BalanceDate]	= @BalanceDate, 
				  [OpenBalance] = @OpenBalance,
				  [ClosingBalance] = @CloseBalance,
				  [FileName] = @FileName,
				  [Firm] = @LTAdrs,
				  [DataSourceCd] = @DataSourceCd,
				  [IsLastInSequence] = CASE WHEN (@ClosingBalance_62F_Amount IS NULL OR @ClosingBalance_62F_Amount = '''') THEN 0 ELSE 1 END
			WHERE [AccountCode] = @AccountId_25 
				AND [StatementNumber] = @StatementNumber 
				AND [StatementSequenceNumber] = @StatementSequenceNumber

            --------- End of Updating the ib_SwiftStatement

			DECLARE @Exists BIT

			EXEC dbo.[ib_SwiftStatement_CheckIfExistsExcludeMisses] @Account, @LTAdrs, @DataSourceId, @StatementNumber, @StatementSequenceNumber, @Exists output 
	
			DECLARE @NewNostroId INT

			IF @Exists = 0	
				EXEC [ib_Nostro_Load]
					@DataSourceCd,
					@ValueDate,
					@TransDate,
					@Amount,
					@TransactionType,
					@InternalReference,
					@ExternalReference,
					@Narrative,
					@Account,
					@Currency,
					@LTAdrs,
					@SWIFT_MT950ID,
					@NostroId = @NewNostroId OUTPUT
			ELSE				
			BEGIN
				DECLARE @message VARCHAR(255)
				SET @message = ''Skipping statement since already have equivalent; account '' 
						+ @Account + '', '' 
						+ CONVERT(VARCHAR(25), @StatementNumber) 
						+ ''/'' + CONVERT(VARCHAR(25), @StatementSequenceNumber)
				EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @Message, ''Warning'', '''', @RunId
			END
			
			--flip processed flag in source table.
			UPDATE [SWIFT_MT950]
			SET [LoadState] = 2
			WHERE [SWIFT_MT950ID] = @SWIFT_MT950ID
				AND [LoadState] = 1

			FETCH NEXT FROM pos_cursor
			INTO 
					@SWIFT_MT950ID,	
					@LTAdrs,
					@AccountId_25,	
					@OpenBalance_60F_CurrencyCode,	
					@OpenBalance_60M_CurrencyCode,
					@StatmtLine_61,	
					@StatmtLine_61_SupplemDetails,
					@StatmtNo_28C,                   
					@StatmtNoSeqNo_28C,
					@OpenBalance_60F_Date,
					@OpenBalance_60M_Date,
					@OpenBalance_DCMark,
					@OpenBalance_60F_Amount,
					@OpenBalance_60M_Amount,
					@ClosingBalance_DCMark,
					@ClosingBalance_62F_Amount,
					@ClosingBalance_62M_Amount,
					@FileName

			END
			
			CLOSE pos_cursor
			DEALLOCATE pos_cursor

			DECLARE cursor_tempSwSt CURSOR FOR
			SELECT	[AccountCode],
					[StatementNumber],
					[StatementSequenceNumber],
					[BalanceDate],
					[CurrencyCode],
					[OpenBalance],
					[TotalOfLineItemAmounts],
					[ClosingBalance],
                    [FileName],
					[Firm],
					[DataSourceCd],
					[IsLastInSequence]
			FROM #temp_SwiftStatement

			OPEN cursor_tempSwSt

			DECLARE @AccountCode				varchar(35)
			DECLARE @CurrencyCode				varchar(3)	
			DECLARE @TotalOfLineItemAmounts		money
			DECLARE @ClosingBalance				money
			DECLARE @Firm						varchar(25)
			DECLARE @IsMissed					int
			DECLARE @IsMissReplacement			BIT
			DECLARE @IsLastInSequence			BIT

			FETCH NEXT FROM cursor_tempSwSt
			INTO 
					@AccountCode,
					@StatementNumber,
					@StatementSequenceNumber,
					@BalanceDate,
					@CurrencyCode,
					@OpenBalance,
					@TotalOfLineItemAmounts,
					@ClosingBalance,
                    @FileName,
					@Firm,
					@DataSourceCd,
					@IsLastInSequence		

				-- Check @@FETCH_STATUS to see IF there are any more rows to fetch.
				WHILE @@FETCH_STATUS = 0
				BEGIN		
			
				    SET @IsMissed = ( SELECT COUNT(*) 
									  FROM dbo.[ib_SwiftStatement] stm	
										INNER JOIN ib_Account a ON a.AccountId = stm.AccountId	
										WHERE a.Code = @AccountCode AND stm.StatementNumber = @StatementNumber AND stm.StatementSequenceNumber = @StatementSequenceNumber	
										AND stm.[FileName] = ''MISS''
									) 
									
					IF @IsMissed >= 1 -- then update it instead
						BEGIN

							SET @IsMissReplacement = 1

							EXEC [ib_SwiftStatement_UpdateIfExists]
								@AccountCode,
								@StatementNumber,
								@StatementSequenceNumber,
								@BalanceDate,
								@CurrencyCode,
								@OpenBalance,
								@TotalOfLineItemAmounts,
								@ClosingBalance,
						        @FileName,
								@DataSourceCd,
								@Firm,
								@IsLastInSequence,
								@IsMissReplacement
	
						END
					ELSE
						BEGIN
						
						SET @IsMissReplacement = 0
						
						EXEC [ib_SwiftStatement_Add]
								@AccountCode,
								@StatementNumber,
								@StatementSequenceNumber,
								@BalanceDate,
								@CurrencyCode,
								@OpenBalance,
								@TotalOfLineItemAmounts,
								@ClosingBalance,
						        @FileName,
								@DataSourceCd,
								@Firm,
								@IsLastInSequence,
								@IsMissReplacement,
								@ReceiveLocationSysId,
								@RunId
						END
						
					FETCH NEXT FROM cursor_tempSwSt
						INTO 
							@AccountCode,
							@StatementNumber,
							@StatementSequenceNumber,
							@BalanceDate,
							@CurrencyCode,
							@OpenBalance,
							@TotalOfLineItemAmounts,
							@ClosingBalance,
                            @FileName,
							@Firm,
							@DataSourceCd,
							@IsLastInSequence
							
				END

			CLOSE cursor_tempSwSt
			DEALLOCATE cursor_tempSwSt

			DROP TABLE #temp1
			DROP TABLE #temp_SwiftStatement

	COMMIT TRANSACTION T1
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[eib_Adapter]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[eib_Adapter]
(
[AdapterId] [int] NOT NULL IDENTITY(1, 1),
[AdapterCode] [nvarchar] (50) NOT NULL,
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_eib_Adapter_CreateDate] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_eib_Adapter] on [dbo].[eib_Adapter]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[eib_Adapter] ADD CONSTRAINT [PK_eib_Adapter] PRIMARY KEY CLUSTERED  ([AdapterId])
');

GO
EXECUTE ('PRINT N''Creating index [IX_eib_Adapter_AdapterCode] on [dbo].[eib_Adapter]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [IX_eib_Adapter_AdapterCode] ON [dbo].[eib_Adapter] ([AdapterCode])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[eib_GetNextStagingFileToLoad]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[eib_GetNextStagingFileToLoad]
(
	@ReadyToLoadStatus int
)
AS

SET NOCOUNT ON

SELECT TOP 1
	eib_StagingFile.StagingFileId,
	eib_StagingFile.[Path],
	eib_Adapter.AdapterCode
FROM
	eib_StagingFile
INNER JOIN
	eib_Adapter
ON
	eib_StagingFile.AdapterId = eib_Adapter.AdapterId
WHERE
	eib_StagingFile.[Status] = @ReadyToLoadStatus 
ORDER BY
	eib_StagingFile.StagingFileId ASC
');

GO
EXECUTE ('PRINT N''Creating [dbo].[RBC_Transaction_LoadStateChange]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[RBC_Transaction_LoadStateChange]
		@OldLoadState	TINYINT,
		@NewLoadState	TINYINT,
		@FileName VARCHAR(512) = NULL
AS
BEGIN
/*
-- 23 Apr 2014  ED  EIB 25559
*/


	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	UPDATE [dbo].[RBC_Transaction] SET LoadState = @NewLoadState   
	WHERE LoadState= @OldLoadState
	  AND [FileName] = COALESCE(@FileName, [FileName])
	
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_SiteTemplate_Delete]''
');

GO
EXECUTE (' /*
<details>
 <summary>Deletes a site template by its id from the ib_SiteTemplate table</summary>
 <created author="Laurentiu Macovei" Date=" Sunday 10 September 2006 12:20AM GMT" /> 
</details>
*/
 create PROCEDURE [dbo].[ib_SiteTemplate_Delete]
(
	@SiteTemplateId int
)
AS
SET NOCOUNT ON

DELETE FROM [dbo].[ib_SiteTemplate]
      WHERE SiteTemplateId = @SiteTemplateId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_MatchCode_GetMatchCodeAllFieldsByMatchCodeId]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_MatchCode_GetMatchCodeAllFieldsByMatchCodeId]
	@MatchCodeId int
AS
SET NOCOUNT ON
/*
<details>
	<summary>Returns all of the fields of a MatchCode by MatchCodeId</summary>
	<created author="Alister McLeod" Date="29 Mar 2010 15:09" /> 
</details>
*/
	SELECT ttc.[Code] AS [TemplateTypeClassCode], m.* , b.Code AS [BrokerCode]
	FROM ib_MatchCode m
	LEFT JOIN ib_TemplateTypeClass ttc ON m.TemplateTypeClassId = ttc.TemplateTypeClassId
	LEFT JOIN ib_Broker b ON m.BrokerId = b.BrokerId
	WHERE MatchCodeId = @MatchCodeId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[Package_Get_List]''
');

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Gets all records from the Package table
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[Package_Get_List]

AS


				
				SELECT
					[PackageSysId],
					[PackageCode],
					[PackageName],
					[SSISPackagePath],
					[ProjectName],
					[JobName],
					[IsActive],
					[CreateDateTimeUtc],
					[CreateUsername],
					[UpdateDateTimeUtc],
					[UpdateUsername],
					[DeleteDateTimeUtc],
					[DeleteUsername],
					[IsMisc]
				FROM
					[dbo].[Package]
					
				SELECT @@ROWCOUNT
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Trx_UpdateStrikePrice]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Trx_UpdateStrikePrice]
	(
	@DataSourceId			int
	, @InstrumentId			int
	, @DivisorDifferential	DECIMAL(38,19)
	, @UpdateUsername varchar(50)
	)
AS
SET NOCOUNT ON

-- =============================================
-- Author:		Lee Manifold
-- Create date: 02 Feb 2007
-- Description:	Updates StrikePrice in ib_Trx table

-- Revision History:
--	08 Mar 2010 AAJM	MBAL-14764 Ensure Username is updated correctly
--	29 Sep 2010	AAJM	MBAL-16706 Fix ''Division by Zero''
-- =============================================

	UPDATE	[dbo].[ib_Trx]
	SET		[StrikePrice] = (StrikePrice/@DivisorDifferential), UpdateUsername = @UpdateUsername
	WHERE	[DataSourceId] = @DataSourceId
	AND		[InstrumentId] = @InstrumentId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Trx_UpdatePrice]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Trx_UpdatePrice]
	(
	@DataSourceId INT
	, @InstrumentId INT
	, @DivisorDifferential DECIMAL(38,19)
	, @UpdateUsername varchar(50)
	)
AS
SET NOCOUNT ON

--	29 Oct 2009		amk		Creation

--	Revision History:
--	08 Mar 2010 AAJM	MBAL-14764 Ensure Username is updated correctly
--	29 Sep 2010	AAJM	MBAL-16706 Fix ''Division by Zero''

	UPDATE ib_Trx
	SET Price = (Price / @DivisorDifferential), UpdateUsername = @UpdateUsername
	WHERE DataSourceId = @DataSourceId
		AND InstrumentId = @InstrumentId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Trx_UpdateMarketValue]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Trx_UpdateMarketValue]
	(
	  @DataSourceId INT
	, @InstrumentId INT
	, @DivisorDifferential DECIMAL(38,19)
	, @UpdateUsername varchar(50)
	)
AS
SET NOCOUNT ON

--	23 Feb 2010	AAJM	Creation

--	Revision History:
--	08 Mar 2010 AAJM	MBAL-14764 Ensure Username is updated correctly
--	29 Sep 2010	AAJM	MBAL-16706 Fix ''Division by Zero''

	UPDATE ib_Trx
	SET MarketValue = (MarketValue / @DivisorDifferential), UpdateUsername = @UpdateUsername
	WHERE DataSourceId = @DataSourceId
		AND InstrumentId = @InstrumentId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Trx_UpdateCurrencyByInstrumentDataSource]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Trx_UpdateCurrencyByInstrumentDataSource]
	(
	  @DataSourceId INT
	, @InstrumentId INT
	, @CurrencyId INT = NULL
	, @UpdateUsername varchar(50)
	)
AS
SET NOCOUNT ON

--	23 Mar 2010	AAJM	Creation
--	Revision History:

IF (@CurrencyId IS NULL)
	BEGIN

	SELECT @CurrencyId =
		[DefaultCurrencyId]
		FROM [dbo].[ib_DataSource]
		WHERE [DataSourceId] = @DataSourceId

	END
	
UPDATE ib_Trx
SET CurrencyId = @CurrencyId, UpdateUsername = @UpdateUsername
WHERE DataSourceId = @DataSourceId
	AND InstrumentId = @InstrumentId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Position_UpdateStrikePrice]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Position_UpdateStrikePrice]
	(
	@DataSourceId			int
	, @InstrumentId			int
	, @DivisorDifferential	DECIMAL(38,19)
	, @UpdateUsername varchar(50)
	)
AS
SET NOCOUNT ON

-- =============================================
-- Author:		Lee Manifold
-- Create date: 02 Feb 2007
-- Description:	Updates StrikePrice in ib_Position table
--
-- Revision History:
--	08 Mar 2010 AAJM	MBAL-14764 Ensure Username is updated correctly
--	29 Sep 2010	AAJM	MBAL-16706 Fix ''Division by Zero''
-- =============================================

	UPDATE	[dbo].[ib_Position]
	SET		[StrikePrice] = (StrikePrice/@DivisorDifferential), UpdateUsername = @UpdateUsername
	WHERE	[DataSourceId] = @DataSourceId
	AND		[InstrumentId] = @InstrumentId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Position_UpdateMarketValue]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Position_UpdateMarketValue]
	(
	@DataSourceId			int
	, @InstrumentId			int
	, @DivisorDifferential	DECIMAL(38,19)
	, @UpdateUsername varchar(50)
	)
AS
SET NOCOUNT ON

--	23 Feb 2010	AAJM	Creation

--  Revision History
--	08 Mar 2010 AAJM	MBAL-14764 Ensure Username is updated correctly
--	29 Sep 2010	AAJM	MBAL-16706 Fix ''Division by Zero''

	UPDATE	[dbo].[ib_Position]
	SET		[MarketValue] = (MarketValue/@DivisorDifferential), UpdateUsername = @UpdateUsername
	WHERE	[DataSourceId] = @DataSourceId
	AND		[InstrumentId] = @InstrumentId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Position_UpdateCurrencyByInstrumentDataSource]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Position_UpdateCurrencyByInstrumentDataSource]
	(
	  @DataSourceId INT
	, @InstrumentId INT
	, @CurrencyId INT = NULL
	, @UpdateUsername varchar(50)
	)
AS
SET NOCOUNT ON

--	23 Mar 2010	AAJM	Creation
--	Revision History:

IF (@CurrencyId IS NULL)
	BEGIN

	SELECT @CurrencyId =
		[DefaultCurrencyId]
		FROM [dbo].[ib_DataSource]
		WHERE [DataSourceId] = @DataSourceId

	END
	
UPDATE ib_Position
SET CurrencyId = @CurrencyId, UpdateUsername = @UpdateUsername
WHERE DataSourceId = @DataSourceId
	AND InstrumentId = @InstrumentId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_InstrumentDataSource_Update]''
');

GO
EXECUTE ('
CREATE PROCEDURE [dbo].[ib_InstrumentDataSource_Update]
(
	@InstrumentDataSourceId		int ,
	@InstrumentId				int,
    @DataSourceId				int,
    @DataSourceInstrumentCode	varchar(100),
    @CurrencyId					int = NULL,
    @MarketValueDivisor			decimal(19,4),
    @StrikePriceDivisor			decimal(19,4),
    @UpdateUsername				varchar(50),
    @PriceDivisor				decimal(19,4),
    @BaseId						INT = NULL,
    @RunCloseOutReport          BIT = 0
)
AS 
SET NOCOUNT ON

	/*
<details>
 <summary>Updates an instrument data source from the ib_InstrumentDataSource table by its id</summary>
 <created author="Laurentiu Macovei" Date=" Sunday, 10 September 2006 1:26PM GMT" /> 
 <updated author="Anil Kripalani" Date="31 Jan 2007">
	Don''t allow zero for strike price divisor
 </updated>
</details>

Depends on

[ib_DataSource_GetDefaultStrikePriceDivisorById]
[ib_Position_UpdateStrikePrice]
[ib_Trx_UpdateStrikePrice]
[ib_InstrumentDataSource_CheckForDuplicate]


Version		Date			Author			Description
1.1			02 Feb 2007		LM				Added extra functionality to carry out a cascade
											update of the strike price in the ib_positions and
											ib_Trx tables.
1.2			02 Feb 2007		LM				Added Default value of NULL for CurrencyId
1.3			05 Feb 2007		LM				Took out @CurrencyId=-1
			22 Jul 2009		AAJM			MBAL-12377 use common source for default Strike Price Divisor		
			29 Oct 2009		amk				MBAL-13542 new price divisor field
			23 Feb 2010		AAJM			MBAL-14764 MarketValues should be updated in Trx and Position table
			08 Mar 2010		AAJM			MBAL-14764 Send @Username to ensure UpdateUsername correct in SPs called
			26 Apr 2010		AAJM			MBAL-15413 Add BaseId which will now be stored on InstrumentDataSource
			29 Sep 2010		AAJM			MBAL-16706 Fix ''Division by Zero''
*/

	BEGIN TRY

		DECLARE @DefaultStrikePriceDivisor	DECIMAL(19,4)
		DECLARE @DivisorDifferential		DECIMAL(38,19)
		DECLARE @OldStrikePriceDivisor		DECIMAL(19,4)
		DECLARE @OldPriceDivisor			DECIMAL(19,4)
		DECLARE @OldMarketValueDivisor		DECIMAL(19,4)
		DECLARE @OldCurrencyId				INT
		
		BEGIN TRAN T1

			IF @StrikePriceDivisor = 0
				SET @StrikePriceDivisor = NULL

			IF @PriceDivisor = 0
				SET @PriceDivisor = NULL
				
			IF @MarketValueDivisor = 0
				SET @MarketValueDivisor = NULL

			--Get the OldStrikePriceDivisor
			SELECT @OldStrikePriceDivisor = StrikePriceDivisor 
				, @OldPriceDivisor = PriceDivisor 
				, @OldMarketValueDivisor = MarketValueDivisor
				, @OldCurrencyId = CurrencyId
			FROM [dbo].[ib_InstrumentDataSource]  
			WHERE InstrumentDataSourceId = @InstrumentDataSourceId

			--Get the DefaultStrikePriceDivisor
			SET @DefaultStrikePriceDivisor = [dbo].[udf_GetDefaultStrikePriceDivisor](@DataSourceId, NULL)

			IF ISNUMERIC(@OldStrikePriceDivisor) <> 1 OR @OldStrikePriceDivisor = 0
				SET @OldStrikePriceDivisor = @DefaultStrikePriceDivisor

			IF ISNUMERIC(@StrikePriceDivisor) <> 1 OR @StrikePriceDivisor = 0
				SET @StrikePriceDivisor = @DefaultStrikePriceDivisor
			
			-- strike price
			IF @OldStrikePriceDivisor <> @StrikePriceDivisor
				BEGIN
					-- MBAL-16706 Ensure the Divisor Differential is very refined to avoid it being truncated to zero
					SET @DivisorDifferential = CONVERT(DECIMAL(38,19), @StrikePriceDivisor) / @OldStrikePriceDivisor
					EXEC [dbo].[ib_Position_UpdateStrikePrice] @DataSourceId, @InstrumentId, @DivisorDifferential, @UpdateUsername
					EXEC [dbo].[ib_Trx_UpdateStrikePrice] @DataSourceId, @InstrumentId, @DivisorDifferential, @UpdateUsername
				END

			-- price
			IF ISNULL(@OldPriceDivisor,1) <> ISNULL(@PriceDivisor, 1)
				BEGIN
					-- MBAL-16706 Ensure the Divisor Differential is very refined to avoid it being truncated to zero
					SET @DivisorDifferential = CONVERT(DECIMAL(38,19), ISNULL(@PriceDivisor,1)) / ISNULL(@OldPriceDivisor,1)
					EXEC [dbo].[ib_Trx_UpdatePrice] @DataSourceId, @InstrumentId, @DivisorDifferential, @UpdateUsername
				END
			
			-- market values
			IF ISNULL(@OldMarketValueDivisor,1) <> ISNULL(@MarketValueDivisor, 1)
				BEGIN
					-- MBAL-16706 Ensure the Divisor Differential is very refined to avoid it being truncated to zero
					SET @DivisorDifferential = CONVERT(DECIMAL(38,19), ISNULL(@MarketValueDivisor,1)) / ISNULL(@OldMarketValueDivisor,1)
					EXEC [dbo].[ib_Position_UpdateMarketValue] @DataSourceId, @InstrumentId, @DivisorDifferential, @UpdateUsername
					EXEC [dbo].[ib_Trx_UpdateMarketValue] @DataSourceId, @InstrumentId, @DivisorDifferential, @UpdateUsername
				END
			
			-- Update CurrencyId on related Transactions and Positions
			IF ISNULL(@OldCurrencyId,-1) <> ISNULL(@CurrencyId, -1)
				BEGIN
					EXEC [dbo].[ib_Position_UpdateCurrencyByInstrumentDataSource] @DataSourceId, @InstrumentId, @CurrencyId, @UpdateUsername
					EXEC [dbo].[ib_Trx_UpdateCurrencyByInstrumentDataSource] @DataSourceId, @InstrumentId, @CurrencyId, @UpdateUsername				
				END
				
			--check for duplicates 
			EXEC [dbo].[ib_InstrumentDataSource_CheckForDuplicate] @InstrumentId, @DataSourceId, @DataSourceInstrumentCode, @InstrumentDataSourceId

			UPDATE [dbo].[ib_InstrumentDataSource]
			   SET [InstrumentId] = @InstrumentId,
				   [DataSourceId] = @DataSourceId,
				   [DataSourceInstrumentCode] = @DataSourceInstrumentCode,
				   [CurrencyId] = @CurrencyId,
				   [MarketValueDivisor] = @MarketValueDivisor,
				   [StrikePriceDivisor] = @StrikePriceDivisor,
				   [PriceDivisor] = @PriceDivisor,
				   [BaseId] = @BaseId,
				   [UpdateUsername] = @UpdateUsername,
				   [RunCloseOutReport] = @RunCloseOutReport
			 WHERE InstrumentDataSourceId = @InstrumentDataSourceId

		COMMIT TRAN T1		

	END TRY
	BEGIN CATCH
		IF (@@TRANCOUNT >= 1) ROLLBACK TRAN
		EXEC [dbo].[sp_RethrowError]
	END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[eib_GetStagingFileMonitorDetails]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[eib_GetStagingFileMonitorDetails]
(
	@AdapterCode  nvarchar(50),
	@ErrorStatus  int,
	@LoadedStatus int
)
AS

SET NOCOUNT ON

SELECT TOP 1
	eib_StagingFile.CreateDate,
	eib_StagingFile.UpdateDate,
	eib_StagingFile.[Status]
FROM
	eib_StagingFile
INNER JOIN
	eib_Adapter
ON
	eib_StagingFile.AdapterId = eib_Adapter.AdapterId
WHERE
	eib_Adapter.AdapterCode = @AdapterCode AND
	eib_StagingFile.[Status] IN (@ErrorStatus, @LoadedStatus)
ORDER BY
	eib_StagingFile.StagingFileId DESC
');

GO
EXECUTE ('PRINT N''Creating [dbo].[RBC_Transaction_Purge]''
');

GO
EXECUTE ('

-- =============================================
-- 23 Apr 2014  ED  EIB 25559
-- Description:	Deletes from RBC_Transaction table all the records where the LoadState is 0
-- =============================================
CREATE PROCEDURE [dbo].[RBC_Transaction_Purge] 
	(
		@LoadState		TINYINT = 0,
		@FileName       VARCHAR (512)= NULL
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
		DELETE FROM [dbo].[RBC_Transaction] WHERE LoadState= @LoadState AND [FileName] = Coalesce(@FileName, [FileName])

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_MatchCode_GetMatchCodeById]''
');

GO
EXECUTE ('/*
----------------------------------------------------------------------------------------------------

-- 26 Feb 09 : ED created
-- Purpose: get matchCode

*/

CREATE PROCEDURE [dbo].[ib_MatchCode_GetMatchCodeById]
(
	@MatchCodeId int
)
AS
SET NOCOUNT ON
BEGIN
	DECLARE @MatchCode varchar(100)
	SELECT @MatchCode = MatchCode FROM ib_MatchCode
		WHERE MatchCodeId=@MatchCodeId
	IF (@MatchCode IS NULL)
		SET @MatchCode = ''''
	SELECT @MatchCode
	
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_InstrumentDataSource_Update_MoveToInstrument]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_InstrumentDataSource_Update_MoveToInstrument]
	-- Add the parameters for the stored procedure here
	(
		@InstrumentDataSourceId		INT,
        @OriginalInstrumentId		INT,
		@MoveToInstrumentId			INT,
		@UpdateUsername				VARCHAR(50)
    )
AS
SET NOCOUNT ON
-- =============================================
-- Author:		Petru Konrad Bercea
-- Create date: 28.04.2009
-- Description:	Moves the Instrument of an InstrumentDataSource
--
-- Revision History
--
-- 29.04.09 Added to WHERE conditions the DataSourceId for ib_Position and ib_Trx updating.
-- 17 May 2010 ED  move ib_price records, too
-- 11 Jun 2012 ED  MBAL 20985 - check for duplicates on moving instrumentdatasources
-- =============================================

   
	IF @MoveToInstrumentId > -1
	
	BEGIN TRY
	
	BEGIN TRAN T1

		DECLARE @DataSourceId INT
		DECLARE @DataSourceInstrumentCode VARCHAR(100)
		SET @DataSourceInstrumentCode = (SELECT DataSourceInstrumentCode FROM [ib_InstrumentDataSource] WHERE InstrumentDataSourceId = @InstrumentDataSourceId)		
		SET @DataSourceId = (SELECT DataSourceId FROM [ib_InstrumentDataSource] WHERE InstrumentDataSourceId = @InstrumentDataSourceId)

		EXEC [dbo].[ib_InstrumentDataSource_CheckForDuplicate] @MoveToInstrumentId, @DataSourceId, @DataSourceInstrumentCode, @InstrumentDataSourceId

		UPDATE [dbo].[ib_InstrumentDataSource]
			   SET [InstrumentId] = @MoveToInstrumentId,
				   [UpdateDate]	= GETDATE(),
				   [UpdateUsername] = @UpdateUsername
			 WHERE InstrumentDataSourceId = @InstrumentDataSourceId

		UPDATE [dbo].[ib_Position]
			   SET [InstrumentId] = @MoveToInstrumentId,
				   [UpdateDate]	= GETDATE(),
				   [UpdateUsername] = @UpdateUsername
			 WHERE InstrumentId = @OriginalInstrumentId AND DataSourceId = @DataSourceId

		UPDATE [dbo].[ib_Trx]
			   SET [InstrumentId] = @MoveToInstrumentId,
				   [UpdateDate]	= GETDATE(),
				   [UpdateUsername] = @UpdateUsername
			 WHERE InstrumentId = @OriginalInstrumentId AND DataSourceId = @DataSourceId
		
		UPDATE [dbo].[ib_Price]
			   SET [InstrumentId] = @MoveToInstrumentId,
				   [UpdateDate]	= GETDATE(),
				   [UpdateUsername] = @UpdateUsername
			 WHERE InstrumentId = @OriginalInstrumentId AND DataSourceId = @DataSourceId

    COMMIT TRAN T1
    
	END TRY
	BEGIN CATCH
		IF (@@TRANCOUNT >= 1) ROLLBACK TRAN
		EXEC [dbo].[sp_RethrowError]
	END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[eib_RegisterStagingFile]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[eib_RegisterStagingFile]
(
	@Path		      nvarchar(255),
	@AdapterCode	  nvarchar(50),
	@RegisteredStatus int,
	@LoadedStatus     int,
    @ErrorStatus      int
)

AS

SET NOCOUNT ON

-- Get adapter ID associated with adapter code
DECLARE @AdapterId int
SELECT @AdapterId = [a].[AdapterId] 
FROM [dbo].[eib_Adapter] a 
WHERE [a].[AdapterCode] = @AdapterCode

-- If adapter not found in adapters table, insert row and record allocated adapter ID	
IF (@AdapterId IS NULL)
BEGIN
	INSERT INTO [dbo].[eib_Adapter] (AdapterCode)
	VALUES (@AdapterCode)
	SET @AdapterId = SCOPE_IDENTITY()
END

-- Determine whether staging file already in queue
DECLARE @StagingFileId int
SELECT @StagingFileId = StagingFileId FROM eib_StagingFile WHERE [Path] = @Path

-- If staging file not found, insert row and record allocated staging file ID
IF (@StagingFileId IS NULL)
BEGIN
	INSERT INTO
		[dbo].[eib_StagingFile] ([Path], AdapterId, [Status], RecordCount, AsOfDate, DataSourceId, LoadDate)
	VALUES
		(@Path, @AdapterId, @RegisteredStatus, 0, ''1753-1-1'', 0, ''1753-1-1'')
	SET @StagingFileId = SCOPE_IDENTITY()
END
ELSE
BEGIN
	UPDATE eib_StagingFile
	SET [Status] = @RegisteredStatus
	WHERE StagingFileId = @StagingFileId AND [Status] IN (@LoadedStatus, @ErrorStatus)
END

-- Return results
SELECT
	eib_StagingFile.StagingFileId,
	eib_StagingFile.[Status]
FROM
	eib_StagingFile
WHERE
	eib_StagingFile.StagingFileID = @StagingFileID
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ReceiveLocation_Add]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ReceiveLocation_Add]
(
	@ReceiveLocationName VARCHAR(100)
	,@PackageSysId INT
	,@FileMask VARCHAR(50)
	,@InputFolder VARCHAR(255)
	,@OutputFolder VARCHAR(255)
	,@ErrorFolder VARCHAR(255)
	,@IsActive BIT
	,@DataSourceId INT
	,@CreateUsername VARCHAR(50)
	,@@ReceiveLocationSysId INT OUTPUT
)
AS
-- Revision History:
-- 20 May 2014  ED  EIB 25641 - created

	SET NOCOUNT ON
	
	INSERT INTO [ReceiveLocation]
           ([ReceiveLocationName]
           ,[PackageSysId]
           ,[FileMask]
           ,[InputFolder]
           ,[OutputFolder]
           ,[ErrorFolder]
		   ,[IsActive]
           ,[DataSourceId]
           ,[CreateDateTimeUtc]
           ,[CreateUsername])
     VALUES
           (@ReceiveLocationName
           ,@PackageSysId
           ,@FileMask
           ,@InputFolder
           ,@OutputFolder
           ,@ErrorFolder
		   ,@IsActive
           ,@DataSourceId
           ,GETUTCDATE()
           ,@CreateUsername)

		   SELECT
                @@ReceiveLocationSysId = SCOPE_IDENTITY()
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_SiteTemplate_GetSiteTemplateById]''
');

GO
EXECUTE ('/* 
<details>
 <summary> Selectes a site template  from the ib_SiteTemplate table by its id</summary>
 <created author="Laurentiu Macovei" Date="Tuesday, 12 September 2006 9:34PM GMT" /> 
 <updated author="laurentiu.macovei" date="Sat, 30 Sep 2006 05:03:50 GMT">
	Added the SiteCode to the output
 </updated>
</details>
*/
CREATE PROCEDURE [dbo].[ib_SiteTemplate_GetSiteTemplateById]
(
	@SiteTemplateId int
)
AS 
SET NOCOUNT ON


SELECT st.[SiteTemplateId]
      ,st.[SiteId]
	  ,s.[Name] as SiteName
	  ,s.[Code] as SiteCode
      ,st.[TemplateId]
	  ,t.[Description] as TemplateDescription
      ,st.[CreateDate]
      ,st.[CreateUsername]
      ,st.[UpdateDate]
      ,st.[UpdateUsername]
  FROM [dbo].[ib_SiteTemplate] st
INNER JOIN [dbo].[ib_Site] s ON s.[SiteId] = st.[SiteId]
INNER JOIN [dbo].[ib_Template] t ON t.[TemplateId] = st.[TemplateId]
WHERE SiteTemplateId = @SiteTemplateId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_MatchCode_GetMatchCodeHintByKeyword]''
');

GO
EXECUTE ('

/*
<details>
 <summary> Returns the MatchCodes hint for a specific MatchCode /summary>
 <created author="Petru Konrad Bercea" Date="02 Mar 2009" />  
 <tasks>
 </tasks>
</details>
*/
CREATE PROCEDURE [dbo].[ib_MatchCode_GetMatchCodeHintByKeyword]
@MatchCode varchar(100),
@HintByStartOnly bit = 0,
@HintLength int = 1
AS
SET NOCOUNT ON

DECLARE @len int
SET @len = LEN(@MatchCode)
IF @HintByStartOnly = 1
BEGIN
	SELECT DISTINCT SUBSTRING ([MatchCode], @len, @HintLength) x
		FROM [dbo].[ib_MatchCode]
		WHERE [MatchCode] LIKE @MatchCode+''%''
		ORDER BY x DESC

END
ELSE
BEGIN
	SELECT DISTINCT SUBSTRING ([MatchCode], PATINDEX(''%''+@MatchCode+''%'', [MatchCode]) + @len, @HintLength) x
		FROM [dbo].[ib_MatchCode]
		WHERE [MatchCode] LIKE ''%''+@MatchCode+''%''
		ORDER BY x DESC
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[Package_Insert]''
');

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Inserts a record into the Package table
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[Package_Insert]
(

	@PackageSysId tinyint    OUTPUT,

	@PackageCode varchar (10)  ,

	@PackageName nvarchar (100)  ,

	@SsisPackagePath varchar (300)  ,

	@ProjectName varchar (200)  ,

	@JobName varchar (100)  ,

	@IsActive bit   ,

	@CreateDateTimeUtc smalldatetime   ,

	@CreateUsername varchar (100)  ,

	@UpdateDateTimeUtc smalldatetime   ,

	@UpdateUsername varchar (100)  ,

	@DeleteDateTimeUtc smalldatetime   ,

	@DeleteUsername varchar (100)  ,

	@IsMisc bit   
)
AS


				
				INSERT INTO [dbo].[Package]
					(
					[PackageCode]
					,[PackageName]
					,[SSISPackagePath]
					,[ProjectName]
					,[JobName]
					,[IsActive]
					,[CreateDateTimeUtc]
					,[CreateUsername]
					,[UpdateDateTimeUtc]
					,[UpdateUsername]
					,[DeleteDateTimeUtc]
					,[DeleteUsername]
					,[IsMisc]
					)
				VALUES
					(
					@PackageCode
					,@PackageName
					,@SsisPackagePath
					,@ProjectName
					,@JobName
					,@IsActive
					,@CreateDateTimeUtc
					,@CreateUsername
					,@UpdateDateTimeUtc
					,@UpdateUsername
					,@DeleteDateTimeUtc
					,@DeleteUsername
					,@IsMisc
					)
				
				-- Get the identity value
				SET @PackageSysId = SCOPE_IDENTITY()
									
							
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_DataSourceExchange_GetDataSourceExchangeById]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_DataSourceExchange_GetDataSourceExchangeById]
(
	@DataSourceExchangeId INT
)
AS 
SET NOCOUNT ON

/*
--Description: get exchange by id
--17 May 2010 ED create
*/
SELECT	dse.[DataSourceExchangeId]
		,dse.[DataSourceExchangeCode]
		,dse.[DataSourceId]
		,ds.Code DataSourceCode
		,e.Code ExchangeCode
		,dse.[ExchangeId]
		,dse.[CreateDate]
		,dse.[CreateUsername]
		,dse.[UpdateDate]
		,dse.[UpdateUsername]
FROM [dbo].[ib_DataSourceExchange] dse
INNER JOIN ib_Exchange e ON e.ExchangeId=dse.ExchangeId
INNER JOIN [ib_DataSource] ds ON dse.DataSourceID = ds.DataSourceId
WHERE dse.DataSourceExchangeId = @DataSourceExchangeId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_InstrumentDataSource_UpdateAsNeeded]''
');

GO
EXECUTE ('/*
=============================================
Author:			Lee Manifold
Create date:	21 Dec 2006
Description:	Updates the Instrument table, with only fields	
				that you want, but keeps the original values.	
==============================================
*/
CREATE PROCEDURE [dbo].[ib_InstrumentDataSource_UpdateAsNeeded]
	(	
	@InstrumentDataSourceId_Add		int = NULL,
	@InstrumentId_Add				int = NULL,
    @DataSourceId_Add				int = NULL,
    @DataSourceInstrumentCode_Add	varchar(100) = NULL,
    @CurrencyId_Add					int = NULL,
    @MarketValueDivisor_Add			decimal(19,4) = NULL,
    @StrikePriceDivisor_Add			decimal(19,4) = NULL,
    @UpdateUsername_Add				varchar(50) = NULL
	)
AS
SET NOCOUNT ON

	DECLARE	@InstrumentDataSourceId		int
	DECLARE	@InstrumentId				int
    DECLARE	@DataSourceId				int
    DECLARE	@DataSourceInstrumentCode	varchar(100)
    DECLARE	@CurrencyId					int
    DECLARE	@MarketValueDivisor			decimal(19,4)
    DECLARE	@StrikePriceDivisor			decimal(19,4)
    DECLARE	@UpdateUsername				varchar(50)

	BEGIN TRY
		SELECT 	@InstrumentDataSourceId =[InstrumentDataSourceId] ,	
				@InstrumentId = [InstrumentId] ,
				@DataSourceId = [DataSourceId],
				@DataSourceInstrumentCode =[DataSourceInstrumentCode],
				@CurrencyId = [CurrencyId],	
				@MarketValueDivisor = [MarketValueDivisor],
				@StrikePriceDivisor = [StrikePriceDivisor],
				@UpdateUserName		= [UpdateUserName]

		FROM	[dbo].[Instrument] 
		WHERE	[InstrumentId]		=	@InstrumentId


		--Amend the fields here
		IF @InstrumentDataSourceId_Add IS NOT NULL
			SET @InstrumentDataSourceId = @InstrumentDataSourceId_Add
		IF @InstrumentId_Add IS NOT NULL
			SET @InstrumentId = @InstrumentId_Add
		IF @DataSourceId_Add IS NOT NULL
			SET @DataSourceId = @DataSourceId_Add
		IF @DataSourceInstrumentCode_Add IS NOT NULL
			SET @DataSourceInstrumentCode = @DataSourceInstrumentCode_Add
		IF @CurrencyId_Add IS NOT NULL	
			SET @CurrencyId = @CurrencyId_Add
		IF @MarketValueDivisor_Add IS NOT NULL
			SET @MarketValueDivisor = @MarketValueDivisor_Add
		IF @StrikePriceDivisor_Add IS NOT NULL
			SET @StrikePriceDivisor = @StrikePriceDivisor_Add
		IF @UpdateUsername_Add IS NOT NULL
			SET @UpdateUserName =	@UpdateUsername_Add 


		EXEC	[dbo].[ib_InstrumentDataSource_Update]
				@InstrumentDataSourceId,
				@InstrumentId,
				@DataSourceId,
				@DataSourceInstrumentCode,
				@CurrencyId,
				@MarketValueDivisor	,
				@StrikePriceDivisor,
				@UpdateUsername	

	END TRY
	BEGIN CATCH
		EXEC [dbo].[sp_RethrowError]
	END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[eib_StagingFile_Delete]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[eib_StagingFile_Delete]
(
	@EndDate datetime
)
AS

SET NOCOUNT ON

DELETE 
	eib_StagingFile
WHERE
	eib_StagingFile.CreateDate < @EndDate
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ReceiveLocation_GetByPackageCode]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ReceiveLocation_GetByPackageCode]
	@PackageCode VARCHAR(10)
AS
-- =============================================
-- Author:		damiane
-- Create date: 30 Sep 2013
-- Description:	get receive locations by package code
-- Modification History
--
-- 04/10/2013	Ruth	Changed to package sysid
-- 01/11/2012   campbellg Add OrderBy on Priority
-- 09/12/2013   ED EIB 24343 - fix the packagecode size
-- 02/01/2014   ED EIB 24946 - get only active Receive Locations
-- =============================================

BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	SELECT r1.ReceiveLocationSysId, r1.DataSourceId, r1.InputFolder, r1.FileMask, r1.OutputFolder, r1.ErrorFolder
	FROM [dbo].[ReceiveLocation] r1
	INNER JOIN [dbo].[Package] p on p.PackageSysId = r1.PackageSysId
	WHERE p.[PackageCode] = @PackageCode AND p.[IsActive] = 1 AND r1.[IsActive] = 1
	ORDER BY r1.[Priority] ASC

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[vw_aspnet_WebPartState_Paths]''
');

GO
SET QUOTED_IDENTIFIER OFF

GO
EXECUTE ('
  CREATE VIEW [dbo].[vw_aspnet_WebPartState_Paths]
  AS SELECT [dbo].[aspnet_Paths].[ApplicationId], [dbo].[aspnet_Paths].[PathId], [dbo].[aspnet_Paths].[Path], [dbo].[aspnet_Paths].[LoweredPath]
  FROM [dbo].[aspnet_Paths]
  
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_MatchCode_GetMatchCodeIdByMatchCode]''
');

GO
SET QUOTED_IDENTIFIER ON

GO
EXECUTE ('



/*
<details>
	<summary>Returns the MatchCode id for a specific MatchCode</summary>
	<created author="Petru Konrad Bercea" Date="02 Mar 2009" /> 	
</details>
*/
CREATE PROCEDURE [dbo].[ib_MatchCode_GetMatchCodeIdByMatchCode]
@MatchCode varchar(100)
AS
SET NOCOUNT ON
	SELECT MatchCodeId 
	FROM ib_MatchCode 
	WHERE MatchCode = @MatchCode
');

GO
EXECUTE ('PRINT N''Creating [dbo].[Package_Update]''
');

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Updates a record in the Package table
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[Package_Update]
(

	@PackageSysId tinyint   ,

	@PackageCode varchar (10)  ,

	@PackageName nvarchar (100)  ,

	@SsisPackagePath varchar (300)  ,

	@ProjectName varchar (200)  ,

	@JobName varchar (100)  ,

	@IsActive bit   ,

	@CreateDateTimeUtc smalldatetime   ,

	@CreateUsername varchar (100)  ,

	@UpdateDateTimeUtc smalldatetime   ,

	@UpdateUsername varchar (100)  ,

	@DeleteDateTimeUtc smalldatetime   ,

	@DeleteUsername varchar (100)  ,

	@IsMisc bit   
)
AS


				
				
				-- Modify the updatable columns
				UPDATE
					[dbo].[Package]
				SET
					[PackageCode] = @PackageCode
					,[PackageName] = @PackageName
					,[SSISPackagePath] = @SsisPackagePath
					,[ProjectName] = @ProjectName
					,[JobName] = @JobName
					,[IsActive] = @IsActive
					,[CreateDateTimeUtc] = @CreateDateTimeUtc
					,[CreateUsername] = @CreateUsername
					,[UpdateDateTimeUtc] = @UpdateDateTimeUtc
					,[UpdateUsername] = @UpdateUsername
					,[DeleteDateTimeUtc] = @DeleteDateTimeUtc
					,[DeleteUsername] = @DeleteUsername
					,[IsMisc] = @IsMisc
				WHERE
[PackageSysId] = @PackageSysId 
				
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_InstrumentDetail_Add]''
');

GO
EXECUTE ('
CREATE PROCEDURE  [dbo].[ib_InstrumentDetail_Add]
	(
	@InstrumentId		int,
	@ExpiryYear			smallint,
	@ExpiryMonth		smallint,
	@ExpiryDay			smallint,
	@StrikePrice		decimal(19,4),
	@OptionTypeCode		varchar(25),
	@AsOfDate			datetime,
	@CurrencyId			int,
	@SettlementPrice	decimal(24,10)
	)
AS
SET NOCOUNT ON
 /*
<details
 <summaryAdds a record into the ib_imbalanceDetail table</summary
 <created author="Lee Manifold" Date=" 17 October 2006 " / 
</details
23 Apr 2010		AAJM	MBAL-15416 Increase size of SettlementPrice
*/
BEGIN TRY

INSERT INTO [dbo].[ib_InstrumentDetail]
           (
			[InstrumentId],
			[ExpiryYear],
			[ExpiryMonth],
			[ExpiryDay],
			[StrikePrice],
			[OptionTypeCode],
			[AsOfDate],
			[SettlementPrice],
			[CurrencyId]
			)
     VALUES
           (
			@InstrumentId,
			@ExpiryYear,
			@ExpiryMonth,
			@ExpiryDay,
			@StrikePrice,
			@OptionTypeCode,
			@AsOfDate,
			@SettlementPrice,
			@CurrencyId
			)

END TRY

BEGIN CATCH
	EXEC [dbo].[sp_RethrowError]
END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[eib_TrxType_GetByDataSource]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[eib_TrxType_GetByDataSource]
(
	@DataSourceId int
)
AS

SET NOCOUNT ON

SELECT
	ib_TrxType.TrxTypeId,
	ib_TrxType.Code,
	ib_TrxType.[Description],
	ib_TrxType.IsPosition,
	ib_TrxType.IsPremium,
	ib_TrxType.IsPandS,
	ib_TrxType.IsPandL,
	ib_TrxType.IsTrade,
	ib_TrxType.ExcludeFromTradeRec,
	ib_TrxType.IsCancellation,
	ib_TrxType.IsOptionMarketValue,
	ib_TrxType.IsAutoMatched
FROM
	ib_TrxType
WHERE
	ib_TrxType.DataSourceId = @DataSourceId
ORDER BY
	ib_TrxType.Code
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ReceiveLocation_IsRunning_Update]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ReceiveLocation_IsRunning_Update]
	@ReceiveLocationSysId INT
	,@IsRunning BIT
AS
SET NOCOUNT ON
-- =============================================
-- Author:		damiane
-- Create date: 14 Oct 2013
-- Description:	update ReceiveLocation.IsRunning column.
-- =============================================

BEGIN
	
	UPDATE ReceiveLocation SET IsRunning = @IsRunning WHERE ReceiveLocationSysId = @ReceiveLocationSysId

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[vw_aspnet_WebPartState_Shared]''
');

GO
SET QUOTED_IDENTIFIER OFF

GO
EXECUTE ('
  CREATE VIEW [dbo].[vw_aspnet_WebPartState_Shared]
  AS SELECT [dbo].[aspnet_PersonalizationAllUsers].[PathId], [DataSize]=DATALENGTH([dbo].[aspnet_PersonalizationAllUsers].[PageSettings]), [dbo].[aspnet_PersonalizationAllUsers].[LastUpdatedDate]
  FROM [dbo].[aspnet_PersonalizationAllUsers]
  
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_MatchCode_GetMatchCodeIdByTemplateIdMatchCode]''
');

GO
SET QUOTED_IDENTIFIER ON

GO
SET ANSI_NULLS OFF

GO
EXECUTE ('
--	10 Sep 09	KevinP		Creation
-- 14 Sep 2009	KevinP		Removed unneccessary join to Template and restriction on "Nostro Rec" Type Code

CREATE PROCEDURE [dbo].[ib_MatchCode_GetMatchCodeIdByTemplateIdMatchCode]
(
	@TemplateId int,
	@MatchCode VARCHAR(100)
)
AS
SET NOCOUNT ON
BEGIN

	SELECT mc.MatchCodeId
	FROM ib_MatchCode mc
	WHERE mc.MatchCode = @MatchCode
	  AND mc.TemplateId = @TemplateId
	ORDER BY mc.MatchCode

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[Package_Delete]''
');

GO
SET ANSI_NULLS ON

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Deletes a record in the Package table
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[Package_Delete]
(

	@PackageSysId tinyint   
)
AS


				DELETE FROM [dbo].[Package] WITH (ROWLOCK) 
				WHERE
					[PackageSysId] = @PackageSysId
					
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_InstrumentDetail_AddAsNeeded]''
');

GO
EXECUTE ('CREATE proc [dbo].[ib_InstrumentDetail_AddAsNeeded]
	(
	@InstrumentId		int,
	@ExpiryYear			smallint,
	@ExpiryMonth		smallint,
	@ExpiryDay			smallint,
	@StrikePrice		decimal(19,4),
	@OptionTypeCode		varchar(25),
	@AsOfDate			datetime,
	@CurrencyId			int,
	@SettlementPrice	decimal(24,10)
	)
AS
SET NOCOUNT ON
/*
Programmer:  Lee Manifold
Date:        18 Oct 2006
Description: Inserts values into ib_Imbalance_Detail table if record does not exist.

History

Date			Author		Desc
23 Apr 2010		AAJM		MBAL-15416 Increase size of SettlementPrice
*/

	DECLARE @returnvalue	int 
	DECLARE @Exists			bit
		
	EXEC @returnvalue = [ib_InstrumentDetail_CheckforDuplicate]  @InstrumentId, @ExpiryYear, @ExpiryMonth, @ExpiryDay, @StrikePrice, @OptionTypeCode, @AsOfDate, @Exists Output		
	--PRINT ''Exists =''
	--PRINT @Exists
	
	IF @Exists = 0 
	BEGIN
		EXEC [ib_InstrumentDetail_Add] @InstrumentId, @ExpiryYear, @ExpiryMonth, @ExpiryDay, @StrikePrice, @OptionTypeCode, @AsOfDate, @CurrencyId, @SettlementPrice			 
	END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[eib_UpdateStagingFileStatus]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[eib_UpdateStagingFileStatus]
(
	@StagingFileId int,
	@Status        int
)
AS

SET NOCOUNT ON

UPDATE
	eib_StagingFile
SET
	eib_StagingFile.[Status] = @Status
WHERE
	eib_StagingFile.StagingFileId = @StagingFileId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[RolfeNolan_Codes]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[RolfeNolan_Codes]
(
[RolfeNolan_CodesID] [int] NOT NULL IDENTITY(1, 1),
[MarketDescription] [varchar] (50) NULL,
[Market] [varchar] (25) NULL,
[LongDescription] [varchar] (50) NULL,
[DecimalPlacesInPrice] [varchar] (50) NULL,
[FuturesTickValue] [varchar] (50) NULL,
[FuturesProductID] [varchar] (50) NULL,
[LotSize] [varchar] (50) NULL,
[Instrument] [varchar] (50) NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_RolfeNolan_Codes_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_RolfeNolan_Codes_CreateDate] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_RolfeNolan_Codes] on [dbo].[RolfeNolan_Codes]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[RolfeNolan_Codes] ADD CONSTRAINT [PK_RolfeNolan_Codes] PRIMARY KEY CLUSTERED  ([RolfeNolan_CodesID])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[RolfeNolan_Codes_Add]''
');

GO
EXECUTE ('-- =============================================
-- Author:		Petru Konrad Bercea
-- Create date: 16.02.2009
-- Description:	Insert into RolfeNolan_Codes table
-- =============================================
CREATE PROCEDURE [dbo].[RolfeNolan_Codes_Add]
	-- Add the parameters for the stored procedure here
	(
		@MarketDescription			varchar(50)=NULL,
		@Market						varchar(25)=NULL,
		@LongDescription			varchar(50)=NULL,
		@DecimalPlacesInPrice		varchar(50)=NULL,
		@FuturesTickValue			varchar(50)=NULL,
		@FuturesProductID			varchar(50)=NULL,
		@LotSize					varchar(50)=NULL,
		@Instrument					varchar(50)=NULL
    )
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

  INSERT INTO [dbo].[RolfeNolan_Codes]
			( 
			[MarketDescription]
			,[Market]
			,[LongDescription]
			,[DecimalPlacesInPrice]
			,[FuturesTickValue]
			,[FuturesProductID]
			,[LotSize]
			,[Instrument]
			)
    VALUES
			( 
			@MarketDescription,
			@Market,
			@LongDescription,
			@DecimalPlacesInPrice,
			@FuturesTickValue,
			@FuturesProductID,
			@LotSize,
			@Instrument
			)
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[vw_aspnet_WebPartState_User]''
');

GO
SET QUOTED_IDENTIFIER OFF

GO
EXECUTE ('
  CREATE VIEW [dbo].[vw_aspnet_WebPartState_User]
  AS SELECT [dbo].[aspnet_PersonalizationPerUser].[PathId], [dbo].[aspnet_PersonalizationPerUser].[UserId], [DataSize]=DATALENGTH([dbo].[aspnet_PersonalizationPerUser].[PageSettings]), [dbo].[aspnet_PersonalizationPerUser].[LastUpdatedDate]
  FROM [dbo].[aspnet_PersonalizationPerUser]
  
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_SiteUser_CheckForDuplicate]''
');

GO
SET QUOTED_IDENTIFIER ON

GO
EXECUTE ('  /*
<details>
 <summary>
	Checks for the duplicate Site Users with same fields. 
</summary>
 <created author="laurentiu.macovei" date="Tue, 03 Oct 2006 06:25:06AM GMT"/>
</details>
*/
CREATE PROCEDURE [dbo].[ib_SiteUser_CheckForDuplicate]
@SiteId varchar(100),
@UserId uniqueidentifier,
@SiteUserId int
AS
SET NOCOUNT ON

DECLARE @Count int
DECLARE @SiteName varchar(100)
DECLARE @UserName varchar(100)

SET @Count=0

SELECT TOP 1 @Count = 1, @SiteName = s.[Name], @UserName = u.[UserName]
	FROM [dbo].[ib_SiteUser] su
		INNER JOIN [dbo].[ib_Site] s ON s.SiteId = su.SiteId
		INNER JOIN [dbo].[aspnet_Users] u ON u.UserId = su.UserId
	WHERE su.SiteId = @SiteId
		AND su.UserId = @UserID
		AND su.SiteUserID <> @SiteUserId

IF @Count > 0
	RAISERROR (N''There is already another Site User with same User (%s) and same Site (%s). Please specify other values!'', 11, 1, @UserName, @SiteName)
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_MatchCode_GetMatchCodesByKeyword]''
');

GO
EXECUTE ('




/*
<details>
 <summary> Filter the MatchCode by a specific MatchCode /summary>
 <created author="Petru Konrad Bercea" Date="02 Mar 2009" />  
 <tasks>
 </tasks>
</details>
*/
CREATE PROCEDURE [dbo].[ib_MatchCode_GetMatchCodesByKeyword]
@MatchCode varchar(100),
@FilterByStartOnly bit=0,
@Top int = 10
AS
SET NOCOUNT ON

IF @FilterByStartOnly = 1 
BEGIN
	SELECT TOP (@Top) CONCAT(m.MatchCode,'' - '', t.Description) AS MatchCode,m.[MatchCodeId] 
	FROM [dbo].[ib_MatchCode] m
	JOIN [dbo].[ib_Template] t ON t.TemplateId = m.TemplateId
	WHERE m.[MatchCode] LIKE @MatchCode + ''%'' 
	ORDER BY m.[MatchCode]
END
ELSE 
BEGIN
	SELECT TOP (@Top)CONCAT(m.MatchCode,'' - '', t.Description) AS MatchCode,m.[MatchCodeId] 
	FROM [dbo].[ib_MatchCode] m
	JOIN [dbo].[ib_Template] t ON t.TemplateId = m.TemplateId
	WHERE m.[MatchCode] LIKE ''%''+@MatchCode + ''%''  
	ORDER BY m.[MatchCode]
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[Package_GetByPackageCode]''
');

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Select records from the Package table through an index
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[Package_GetByPackageCode]
(

	@PackageCode varchar (10)  
)
AS


				SELECT
					[PackageSysId],
					[PackageCode],
					[PackageName],
					[SSISPackagePath],
					[ProjectName],
					[JobName],
					[IsActive],
					[CreateDateTimeUtc],
					[CreateUsername],
					[UpdateDateTimeUtc],
					[UpdateUsername],
					[DeleteDateTimeUtc],
					[DeleteUsername],
					[IsMisc]
				FROM
					[dbo].[Package]
				WHERE
					[PackageCode] = @PackageCode
				SELECT @@ROWCOUNT
					
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[EU_cb010_LoadStateChange]''
');

GO
EXECUTE ('


-- =============================================
-- Author:		Lee Manifold
-- Create date: 12 Jul 2006
-- Description:	Changes the LoadState of the eu80_cb010 table
-- =============================================
CREATE PROCEDURE [dbo].[EU_cb010_LoadStateChange] 
	-- Add the parameters for the stored procedure here
	(
	@OldLoadState	TINYINT,
	@NewLoadState	TINYINT,
	@RecordDate		DATETIME = NULL
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	--raiserror (''Lee2 doing specific raiserror in stored proc for testing'', 19, 1) with log

	-- Need to add code to handle RecordDate
	IF @RecordDate IS NOT NULL 
	BEGIN

		UPDATE [dbo].[EU_cb010grp] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState

	END

	IF @RecordDate IS NULL 
	BEGIN

		UPDATE [dbo].[EU_cb010grp] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState

	END


END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[RolfeNolan_Codes_LoadStateChange]''
');

GO
EXECUTE ('-- =============================================
-- Author:		Petru Konrad Bercea
-- Create date: 16.02.2009
-- Description:	Changes the LoadState of the RolfeNolan_Codes type table
-- =============================================
CREATE PROCEDURE [dbo].[RolfeNolan_Codes_LoadStateChange] 
	-- Add the parameters for the stored procedure here
	(
		@OldLoadState	TINYINT,
		@NewLoadState	TINYINT,
		@RecordDate		DATETIME = NULL
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

		UPDATE [dbo].[RolfeNolan_Codes] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_SiteUser_Delete]''
');

GO
EXECUTE (' /*
<details>
 <summary>Deletes a site user by its id from the ib_SiteUser table</summary>
 <created author="Anil Kripalani" Date="7 Dec 2006" /> 
</details>
*/
 create PROCEDURE [dbo].[ib_SiteUser_Delete]
(
	@SiteUserId int
)
AS
SET NOCOUNT ON

DELETE FROM [dbo].[ib_SiteUser]
      WHERE SiteUserId = @SiteUserId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_MatchCode_GetMatchCodesByTemplateId]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_MatchCode_GetMatchCodesByTemplateId]
(
	@TemplateId INT=NULL
)
AS
SET NOCOUNT ON
--	24	May 2010 ED 		Creation
BEGIN
	SELECT mc.MatchCodeId, mc.MatchCode
	FROM ib_MatchCode mc
	WHERE mc.TemplateId = @TemplateId
	ORDER BY mc.MatchCode

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[Package_GetByPackageSysId]''
');

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Select records from the Package table through an index
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[Package_GetByPackageSysId]
(

	@PackageSysId tinyint   
)
AS


				SELECT
					[PackageSysId],
					[PackageCode],
					[PackageName],
					[SSISPackagePath],
					[ProjectName],
					[JobName],
					[IsActive],
					[CreateDateTimeUtc],
					[CreateUsername],
					[UpdateDateTimeUtc],
					[UpdateUsername],
					[DeleteDateTimeUtc],
					[DeleteUsername],
					[IsMisc]
				FROM
					[dbo].[Package]
				WHERE
					[PackageSysId] = @PackageSysId
				SELECT @@ROWCOUNT
					
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_DataSourceMapping_GetByCode]''
');

GO
EXECUTE ('

-- =============================================
-- Author:		Lee Manifold
-- Create date: 20 Decemeber 2006
-- Description:	Retrieves DataSourceId
-- =============================================
CREATE proc [dbo].[ib_DataSourceMapping_GetByCode]
	(	
	@DataSourceId		int,		
	@DataSrcExCode		varchar(100),
	@MappedDataSourceId int output
	)
AS
SET NOCOUNT ON

	SELECT	@MappedDataSourceId = [MappedDataSourceId] 
    	
	FROM	[dbo].[ib_DataSourceMapping]

	WHERE	[DataSourceExchangeCode]	= @DataSrcExCode
	AND		[DataSourceId]				= @DataSourceId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[EU_cb010_Purge]''
');

GO
EXECUTE ('





-- =============================================
-- Author:		Lee Manifold
-- Create date: 18 Jul 2006
-- Description:	Deletes from all EU_cb010 type files where the LoadState is @LoadState
-- =============================================
CREATE PROCEDURE [dbo].[EU_cb010_Purge]
	(
	@LoadState		TINYINT = 0,
	@FileName       VARCHAR (512)= NULL
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	
	--raiserror (''Lee doing specific raiserror in stored proc for testing'', 19, 1) with log
	DELETE FROM [dbo].[EU_cb010grp] WHERE LoadState= @LoadState AND [FileName] = Coalesce(@FileName, [FileName])
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[RolfeNolan_Codes_Purge]''
');

GO
EXECUTE ('-- =============================================
-- Author:		Petru Konrad Bercea
-- Create date: 16.02.2009
-- Description:	Deletes from RolfeNolan_Codes table all the records where the LoadState is 0
-- =============================================
CREATE PROCEDURE [dbo].[RolfeNolan_Codes_Purge] 
	(
		@LoadState		TINYINT = 0,
		@RecordDate		DATETIME = NULL
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
		DELETE FROM [dbo].[RolfeNolan_Codes] WHERE LoadState= @LoadState

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[Config_Get_List]''
');

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Gets all records from the Config table
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[Config_Get_List]

AS


				
				SELECT
					[ConfigId],
					[Key],
					[Value],
					[CreateDate],
					[CreateUsername],
					[UpdateDate],
					[UpdateUsername]
				FROM
					[dbo].[Config]
					
				SELECT @@ROWCOUNT
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_MatchCodeTolerance]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_MatchCodeTolerance]
(
[MatchCodeToleranceId] [int] NOT NULL IDENTITY(1, 1),
[MatchCode] [varchar] (100) NOT NULL,
[Tolerance] [decimal] (18, 4) NULL CONSTRAINT [DF__ib_MatchC__Toler__3E930684] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_ib_MatchCodeTolerance_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_ib_MatchCodeTolerance_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_ib_MatchCodeTolerance] on [dbo].[ib_MatchCodeTolerance]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_MatchCodeTolerance] ADD CONSTRAINT [PK_ib_MatchCodeTolerance] PRIMARY KEY CLUSTERED  ([MatchCodeToleranceId])
');

GO
EXECUTE ('PRINT N''Creating index [AK_MatchCode] on [dbo].[ib_MatchCodeTolerance]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_MatchCode] ON [dbo].[ib_MatchCodeTolerance] ([MatchCode])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_MatchCodeTolerance_CheckForDuplicate]''
');

GO
EXECUTE ('/*
----------------------------------------------------------------------------------------------------

-- 24 Feb 09 : ED created
-- Purpose: check for duplicate
*/

CREATE PROCEDURE [dbo].[ib_MatchCodeTolerance_CheckForDuplicate]
(
	@MatchCode varchar(100),
	@MatchCodeToleranceId int
)
AS
SET NOCOUNT ON
BEGIN
	DECLARE @Count int

SELECT TOP 1 @Count = 1
	FROM [dbo].[ib_MatchCodeTolerance] mc
	WHERE MatchCode = @MatchCode
		AND MatchCodeToleranceId <> @MatchCodeToleranceId

IF @Count > 0
	RAISERROR (N''There is already another Tolerance with same Match Code (%s). Please specify other code!'', 11, 1, @MatchCode)
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_MatchCodeTolerance_Add]''
');

GO
EXECUTE ('/*
----------------------------------------------------------------------------------------------------

-- 24 Feb 09 : ED created
-- Purpose: add tolerance
*/

CREATE PROCEDURE [dbo].[ib_MatchCodeTolerance_Add]
(
	@MatchCode varchar(100),	
	@Tolerance decimal(18,4),
	@CreateUsername varchar(50),
	@MatchCodeToleranceId int output

)
AS
SET NOCOUNT ON
BEGIN TRY
--check for duplicates 
EXEC [dbo].[ib_MatchCodeTolerance_CheckForDuplicate] @MatchCode, -1

INSERT INTO [dbo].[ib_MatchCodeTolerance]
           ([MatchCode]
           ,[Tolerance]
           ,[CreateUsername])
     VALUES
           (@MatchCode,
            @Tolerance,
            @CreateUsername)

SELECT @MatchCodeToleranceId = Scope_Identity()

END TRY
BEGIN CATCH
	EXEC [dbo].[sp_RethrowError]
END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[EU_cb010grp_Add]''
');

GO
EXECUTE ('

-- =============================================
-- Author:		Lee Manifold
-- Create date: 23 May 2006
-- Description:	Insert into CB010_Records
--
-- Date		Author		Description
-- 14 Nov 2006	LM		Added new field called @ordrCmbTypCod for E90 schema change.
-- 22 April 2009 Konrad Changed columns ''trnIdNo'' and ''origTrnId'' from type int to type varchar
-- 16 June  2009 Konrad Set the default for @trnLngQty and @trnShtQty to 0
-- =============================================
CREATE PROCEDURE [dbo].[EU_cb010grp_Add] 
			(
			@FileName           VARCHAR (512) = NULL,
			@membClgIdCod		varchar(5) = Null,
			@membExchIdCod		varchar(5) = Null,
			@currTypCod			varchar(3) = Null,
			@accTypGrp			varchar(32) = Null,
			@prodTypId			varchar(4) = Null,
			@prodId				varchar(4) = Null,
			@secuTrdUntNo		varchar(12)=Null,--decimal(8,4) = Null,
			@ticSiz				varchar(12)=Null,--decimal(6,5) = Null,
			@ticVal				varchar(12)=Null,--decimal(8,4) = Null,
			@cntrClasCod		varchar(1) = Null,
			@cntrExpMthDat		int = Null,
			@cntrExpYrDat		int = Null,
			@cntrExerPrc		decimal(19,6) = Null,
			@cntrVersNo			int = Null,
			@lstSetlmtPrc		varchar(12)=Null,--decimal(8,5) = Null,
			@currSetlmtPrc		varchar(12)=Null,--decimal(8,5) = Null,
			@trnIdNo			varchar(6) = Null, -- int
			@trnIDSfxNo			int = Null,
			@trnAdjStsCod		varchar(1) = Null,
			@trnHistAdjInd		varchar(1) = Null,
			@ordrTypCod			varchar(1) = Null,
			@ordrCmbTypCod		varchar(1) = Null,
			@buyCod				varchar(1) = Null,
			@opnClsCod			varchar(1) = Null,
			@trdTyp				varchar(1) = Null,
			@trnLngQty			int = 0,
			@trnShtQty			int = 0,
			@netQty				int = Null,
			@trdMtchPrc			varchar(20)=Null,--decimal(9,5) = Null,
			@mkToMktTick		varchar(20)=Null,--decimal(7,2) = Null,
			@prmVmarAmnt		varchar(20)=Null,--decimal(10,2) = Null,
			@feeByUnt			varchar(20)=Null,--decimal(9,2) = Null,
			@trnFeeAmnt			varchar(20)=Null,--decimal(7,2) = Null,
			@partIDCod			varchar(6) = Null,
			@trnTyp				varchar(3) = Null,
			@trnIDSfxNoPnt		int = Null,
			@custText			varchar(36) = Null,
			@userOrdrNum		varchar(12) = Null,
			@text				varchar(36) = Null,
			@origExchId			varchar(4) = Null,
			@origTrnId			varchar(9) = Null, --int
			@origTrnDat			datetime = Null,
			@origOrdrNo			varchar(12) = Null,
			@origTrnTim			datetime = Null,
			@origTrnDatCet		datetime = Null,
			@origTrnTimCet		datetime = Null,
			@membExchIdCodObo	varchar(5) = Null,
			@sumTrnLngQty		int = Null,
			@sumTrnShtQty		int = Null,
			@sumCntrPrmVmarAmnt varchar(20)=Null,--decimal(12,2) = Null,
			@sumCntrTrnFeeAmnt	varchar(20)=Null,--decimal(8,2) = Null,
			@sumProdPrmVmarAmnt varchar(20)=Null,--decimal(12,2) = Null,
			@sumProdTrnFeeAmnt	varchar(20)=Null,--decimal(8,2) = Null,
			@sumAcctPrmVmarAmnt varchar(20)=Null,--decimal(12,2) = Null,
			@sumAccTrnFeeAmnt	varchar(20)=Null, --decimal(8,2) = Null
			@exchNam			varchar(5)=Null,	
			@envText			varchar(1)=Null,	
			@rptCod				varchar(5)=Null,	
			@rptNam				varchar(30)=Null,	
			@rptFlexKey			varchar(14)=Null,	
			@membId				varchar(5)=Null,	
			@membLglNam			varchar(40)=Null,	
			@rptPrntEffDat		datetime=Null,	
			@rptPrntEffTim		datetime=Null,	
			@rptPrntRunDat		datetime=Null	
			)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	DECLARE @origTrnDatTim		DATETIME
	DECLARE @origTrnDatTimCet	DATETIME	

	SET @origTrnDatTim = CONVERT(DATETIME,CONVERT(VARCHAR(12), CONVERT(DATETIME,@origTrnDat,112)) + '' '' + CONVERT(VARCHAR(8),RIGHT(@origTrnTim,8)))
	SET @origTrnDatTimCet = CONVERT(DATETIME,CONVERT(VARCHAR(12), CONVERT(DATETIME,@origTrnDatCet,112)) + '' '' + CONVERT(VARCHAR(8),RIGHT(@origTrnTimCet,8)))

INSERT INTO [dbo].[EU_cb010grp]
           (
		    [membClgIdCod]
           ,[membExchIdCod]
           ,[currTypCod]
           ,[accTypGrp]
           ,[prodTypId]
           ,[prodId]
           ,[secuTrdUntNo]
           ,[ticSiz]
           ,[ticVal]
           ,[cntrClasCod]
           ,[cntrExpMthDat]
           ,[cntrExpYrDat]
           ,[cntrExerPrc]
           ,[cntrVersNo]
           ,[lstSetlmtPrc]
           ,[currSetlmtPrc]
           ,[trnIdNo]
           ,[trnIDSfxNo]
           ,[trnAdjStsCod]
           ,[trnHistAdjInd]
           ,[ordrTypCod]
		   ,[ordrCmbTypCod]
           ,[buyCod]
           ,[opnClsCod]
           ,[trdTyp]
           ,[trnLngQty]
           ,[trnShtQty]
           ,[netQty]
           ,[trdMtchPrc]
           ,[mkToMktTick]
           ,[prmVmarAmnt]
           ,[feeByUnt]
           ,[trnFeeAmnt]
           ,[partIDCod]
           ,[trnTyp]
           ,[trnIDSfxNoPnt]
           ,[custText]
           ,[userOrdrNum]
           ,[text]
           ,[origExchId]
           ,[origTrnId]
           ,[origTrnDat]
           ,[origOrdrNo]
           ,[origTrnTim]
		   ,[origTrnDatTim]	
           ,[origTrnDatCet]
           ,[origTrnTimCet]
		   ,[origTrnDatTimCet]	
           ,[membExchIdCodObo]
           ,[sumTrnLngQty]
           ,[sumTrnShtQty]
           ,[sumCntrPrmVmarAmnt]
           ,[sumCntrTrnFeeAmnt]
           ,[sumProdPrmVmarAmnt]
           ,[sumProdTrnFeeAmnt]
           ,[sumAcctPrmVmarAmnt]
           ,[sumAccTrnFeeAmnt]
		   ,[envText]
		   ,[rptCod]
		   ,[rptNam]
		   ,[rptFlexKey]
		   ,[membId]
		   ,[membLglNam]
		   ,[rptPrntEffDat]
		   ,[rptPrntEffTim]
		   ,[rptPrntRunDat]
		   ,[exchNam]
		   ,[FileName]
			)
     VALUES
           (
			@membClgIdCod		,
			@membExchIdCod		,
			@currTypCod			,
			@accTypGrp			,
			@prodTypId			,
			@prodId				,
			@secuTrdUntNo		,
			@ticSiz				,
			@ticVal				,
			@cntrClasCod		,
			@cntrExpMthDat		,
			@cntrExpYrDat		,
			@cntrExerPrc		,
			@cntrVersNo			,
			@lstSetlmtPrc		,
			@currSetlmtPrc		,
			@trnIdNo			,
			@trnIDSfxNo			,
			@trnAdjStsCod		,
			@trnHistAdjInd		,
			@ordrTypCod			,
			@ordrCmbTypCod		,
			@buyCod				,
			@opnClsCod			,
			@trdTyp				,
			@trnLngQty			,
			@trnShtQty			,
			@netQty				,
			@trdMtchPrc			,
			@mkToMktTick		,
			@prmVmarAmnt		,
			@feeByUnt			,
			@trnFeeAmnt			,
			@partIDCod			,
			@trnTyp				,
			@trnIDSfxNoPnt		,
			@custText			,
			@userOrdrNum		,
			@text				,
			@origExchId			,
			@origTrnId			,
			@origTrnDat			,
			@origOrdrNo			,
			@origTrnTim			,
			@origTrnDatTim		,
			@origTrnDatCet		,
			@origTrnTimCet		,
			@origTrnDatTimCet	,
			@membExchIdCodObo	,
			@sumTrnLngQty		,
			@sumTrnShtQty		,
			@sumCntrPrmVmarAmnt ,
			@sumCntrTrnFeeAmnt	,
			@sumProdPrmVmarAmnt ,
			@sumProdTrnFeeAmnt	,
			@sumAcctPrmVmarAmnt ,
			@sumAccTrnFeeAmnt	,
			@envText			,
			@rptCod				,
			@rptNam				,
			@rptFlexKey			,
			@membId				,
			@membLglNam			,	
			@rptPrntEffDat		,
			@rptPrntEffTim		,
			@rptPrntRunDat		,
			@exchNam			,
			@FileName
			)
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[RolfeNolan_HOSTOPN_Add]''
');

GO
EXECUTE ('

-- =============================================
-- Author:		Petru Konrad Bercea
-- Create date: 10.02.2009
-- Description:	Insert into RolfeNolan_HOSTOPN table
--
-- Revision History
--
-- 15.05.2009 Konrad Added field Filename to the RolfeNolan_HOSTOPN 
-- 23.06.2009 Konrad Added MarketRate and Margin to the HOSTOPN table
-- =============================================
CREATE PROCEDURE [dbo].[RolfeNolan_HOSTOPN_Add]
	-- Add the parameters for the stored procedure here
	(
	@Filename				varchar(512)=NULL,	
	@Ledger					varchar(7)=NULL,
	@HostCurrency			varchar(21)=NULL,
	@BaseCurrency			varchar(3)=NULL,
	@Market					varchar(5)=NULL,
	@MarketCode				varchar(5)=NULL,
	@HostInstrument			varchar(21)=NULL,
	@PromptDate				varchar(8)=NULL,
	@TradeType				varchar(4)=NULL,
	@Series					varchar(6)=NULL,
	@Lots					varchar(21)=NULL,
	@PremiumRate			varchar(21)=NULL,
	@Price					varchar(21)=NULL,
	@MarketRate				varchar(21)=NULL,
	@Margin					varchar(21)=NULL,
	@Strike					VARCHAR(7)=NULL
    )
AS
BEGIN
	-- SET NOCOUNT ON added4 to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

  INSERT INTO [dbo].[RolfeNolan_HOSTOPN]
			( 
			[Ledger]
			,[HostCurrency] 
			,[BaseCurrency]
			,[Market] 
			,[MarketCode]
			,[HostInstrument] 
			,[PromptDate]
			,[TradeType] 
			,[Series]
			,[Lots]
			,[PremiumRate]
			,[Price] 
			,[Filename]
			,[MarketRate]
			,[Margin]
			,[Strike]
			)
    VALUES
			( 
			@Ledger,
			@HostCurrency,
			@BaseCurrency,
			@Market,
			@MarketCode,
			@HostInstrument,
			@PromptDate,
			@TradeType,
			@Series,
			@Lots,
			@PremiumRate,
			@Price,
			@Filename,
			@MarketRate,
			@Margin,
			@Strike
			)
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_SiteUser_GetSitesForUser]''
');

GO
EXECUTE ('/*
<details>
	<summary> Returns the sites for a specific user. </summary>
	<created author="Laurentiu Macovei" Date="Saturday, 05 Aug 2006 05:39AM GMT" />
</details>
*/
CREATE PROCEDURE [dbo].[ib_SiteUser_GetSitesForUser]
	@UserID uniqueidentifier
AS
SET NOCOUNT ON
SELECT s.[Name],s.[SiteId] 
	FROM [dbo].[ib_Site] s
		INNER JOIN [dbo].[ib_SiteUser] su ON 
			s.SiteId = su.SiteID 
			AND @UserId = su.UserId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_MatchCodeTolerance_Update]''
');

GO
EXECUTE ('-- Stored Procedure

/*
----------------------------------------------------------------------------------------------------

-- 24 Feb 09 : ED created
-- Purpose: update tolerance
*/

CREATE PROCEDURE [dbo].[ib_MatchCodeTolerance_Update]
(
	@MatchCodeToleranceId int, 
	@MatchCode varchar(100),	
	@Tolerance decimal(18,4),
	@UpdateUsername varchar(50)


)
AS
SET NOCOUNT ON
BEGIN TRY
--check for duplicates 
EXEC [dbo].[ib_MatchCodeTolerance_CheckForDuplicate] @MatchCode, @MatchCodeToleranceId
UPDATE [dbo].[ib_MatchCodeTolerance]
   SET [MatchCode] = @MatchCode,
       [Tolerance] = @Tolerance,
       [UpdateUsername] = @UpdateUsername,
		UpdateDate=getdate()
 WHERE MatchCodeToleranceId = @MatchCodeToleranceId

END TRY
BEGIN CATCH
	EXEC [dbo].[sp_RethrowError]
END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[EU_cc040grp]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[EU_cc040grp]
(
[membClgIdCod] [varchar] (5) NULL,
[membExchldCod] [varchar] (5) NULL,
[acctGrpCod] [varchar] (2) NULL,
[currTypCod] [varchar] (3) NULL,
[mgnGrpCod] [varchar] (5) NULL,
[mgnClsCod] [varchar] (5) NULL,
[cshIntRat] [varchar] (11) NULL,
[upDownInd] [varchar] (1) NULL,
[undrlsin] [varchar] (12) NULL,
[settlDat] [datetime] NULL,
[cntrClasCod] [varchar] (1) NULL,
[prodId] [varchar] (4) NULL,
[cntrExpMthDat] [int] NULL,
[cntrExpYrDat] [int] NULL,
[cntrExerPrc] [int] NULL,
[cntrVersNo] [int] NULL,
[flxOptTrnIdNo] [int] NULL,
[trnIdSfxNo] [int] NULL,
[flxOptcntrClasCod] [varchar] (1) NULL,
[flxOptProdId] [varchar] (4) NULL,
[flxOptcntrExpDat] [datetime] NULL CONSTRAINT [DF_EU_cc040grp_flxOptcntrExpDat] DEFAULT (NULL),
[flxOptCntrExerPrc] [varchar] (13) NULL,
[flxOptcntrVersNo] [int] NULL,
[flxOptexerStylTyp] [varchar] (1) NULL,
[seculsin] [varchar] (12) NULL,
[netRiskPos] [varchar] (17) NULL,
[lngShtExerAllcInd] [varchar] (1) NULL,
[netFutPos] [varchar] (5) NULL,
[optEquVal] [varchar] (13) NULL,
[trdUntVal] [varchar] (14) NULL,
[posnCurVal] [varchar] (16) NULL,
[posnMaxMinVal] [varchar] (16) NULL,
[theoVal] [varchar] (16) NULL,
[shtOptMinCompTxt] [varchar] (3) NULL,
[shtOptMinCompQty] [int] NULL,
[secuLstClsPrc] [varchar] (14) NULL,
[maxMinUnderVal] [varchar] (16) NULL,
[calcUndPrc] [varchar] (16) NULL,
[sumSecuCntrCurr] [varchar] (16) NULL,
[sumSecuMaxMin] [varchar] (16) NULL,
[sumSecuTheoVal] [varchar] (16) NULL,
[sumUpDownCntrCurr] [varchar] (16) NULL,
[sumUpDownMaxMin] [varchar] (16) NULL,
[sumUpDownTheoVal] [varchar] (16) NULL,
[upDownValDiff] [varchar] (16) NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_EU_cc040grp_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_EU_cc040grp_CreateDate] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating [dbo].[EU_cc040_LoadStateChange]''
');

GO
EXECUTE ('


-- =============================================
-- Author:		Lee Manifold
-- Create date: 3 Aug 2006
-- Description:	Changes the LoadState of the EU_cc040grp type table
-- =============================================
CREATE PROCEDURE [dbo].[EU_cc040_LoadStateChange] 
	-- Add the parameters for the stored procedure here
	(
	@OldLoadState	TINYINT,
	@NewLoadState	TINYINT,
	@RecordDate		DATETIME = NULL
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	-- Need to add code to handle RecordDate
	IF @RecordDate IS NOT NULL 
	BEGIN

		UPDATE [dbo].[EU_cc040grp] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState

	END

	IF @RecordDate IS NULL 
	BEGIN

		UPDATE [dbo].[EU_cc040grp] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState

	END


END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_SiteUser_GetSiteUserById]''
');

GO
EXECUTE ('/* 
<details>
 <summary> Selectes a Site User  from the ib_SiteUser table by its id</summary>
 <created author="laurentiu.macovei" date="Tue, 03 Oct 2006 18:02:11 GMT"/>
</details>
*/
CREATE PROCEDURE [dbo].[ib_SiteUser_GetSiteUserById]
(
	@SiteUserId int
)
AS 
SET NOCOUNT ON


SELECT su.[SiteUserId]
      ,su.[SiteId]
	  ,s.[Name] as SiteName
	  ,s.[Code] as SiteCode
      ,su.[UserId]
	  ,u.[UserName] as UserName
	  ,su.[IsPrimary]
      ,su.[CreateDate]
      ,su.[CreateUsername]
      ,su.[UpdateDate]
      ,su.[UpdateUsername]
  FROM [dbo].[ib_SiteUser] su
INNER JOIN [dbo].[ib_Site] s ON s.[SiteId] = su.[SiteId]
INNER JOIN [dbo].[aspnet_users] u ON u.[UserId] = su.[UserId]
WHERE SiteUserId = @SiteUserId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_MatchCode_GetMatchCodesHintByKeyword]''
');

GO
EXECUTE ('

/*
<details>
 <summary> Returns the MatchCodes hint for a specific MatchCode /summary>
 <created author="Petru Konrad Bercea" Date="02 Mar 2009" />  
 <tasks>
 </tasks>
</details>
*/
CREATE PROCEDURE [dbo].[ib_MatchCode_GetMatchCodesHintByKeyword]
@MatchCode varchar(100),
@HintByStartOnly bit = 0,
@HintLength int = 1
AS
SET NOCOUNT ON

DECLARE @len int
SET @len = LEN(@MatchCode)
IF @HintByStartOnly = 1
BEGIN
	SELECT DISTINCT SUBSTRING ([MatchCode], @len, @HintLength) x
		FROM [dbo].[ib_MatchCode]
		WHERE [MatchCode] LIKE @MatchCode+''%''
		ORDER BY x DESC

END
ELSE
BEGIN
	SELECT DISTINCT SUBSTRING ([MatchCode], PATINDEX(''%''+@MatchCode+''%'', [MatchCode]) + @len, @HintLength) x
		FROM [dbo].[ib_MatchCode]
		WHERE [MatchCode] LIKE ''%''+@MatchCode+''%''
		ORDER BY x DESC
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[Config_Insert]''
');

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Inserts a record into the Config table
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[Config_Insert]
(

	@ConfigId int    OUTPUT,

	@Key nvarchar (50)  ,

	@Value nvarchar (2000)  ,

	@CreateDate datetime   ,

	@CreateUsername varchar (50)  ,

	@UpdateDate datetime   ,

	@UpdateUsername varchar (50)  
)
AS


				
				INSERT INTO [dbo].[Config]
					(
					[Key]
					,[Value]
					,[CreateDate]
					,[CreateUsername]
					,[UpdateDate]
					,[UpdateUsername]
					)
				VALUES
					(
					@Key
					,@Value
					,@CreateDate
					,@CreateUsername
					,@UpdateDate
					,@UpdateUsername
					)
				
				-- Get the identity value
				SET @ConfigId = SCOPE_IDENTITY()
									
							
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Department_Delete]''
');

GO
EXECUTE ('/*
<details>
 <summary>Deletes an Department by its id from the ib_Department table</summary>
 <created author="konrad" date="24 Mar 2009 16:33:45 GMT"/> 
</details>
*/
CREATE PROCEDURE [dbo].[ib_Department_Delete]
(
	@DepartmentId int
)
AS
SET NOCOUNT ON

DELETE FROM [dbo].[ib_Department]
      WHERE DepartmentId  = @DepartmentId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[sch_CreateQueueItem]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[sch_CreateQueueItem]
	@scheduledTaskId INT = NULL,
	@taskTypeId INT = NULL,
	@displayMessage NVARCHAR(50) = NULL,
	@scheduledStart DateTime = NULL,
	@statusId INT = NULL,
	@siteId INT = NULL,
	@templateId INT = NULL,
	@createUsername nvarchar(50) = NULL
AS	
SET NOCOUNT ON
	--DECLARE @allTemplates BIT
	--SET @allTemplates = (CASE @templateId WHEN 0 THEN 1 ELSE NULL END)
	--SET @templateId = (CASE @templateId WHEN 0 THEN NULL ELSE @templateId END)
	
	SELECT @createUsername = COALESCE(@createUsername, USER_NAME())
	SELECT @statusId = COALESCE(@statusId,(SELECT TOP 1 QueueStatusId FROM ib_QueueStatus WHERE Code = ''StandBy''))
	SELECT @scheduledStart = COALESCE(@scheduledStart, getdate())
	SELECT @displayMessage = COALESCE(@displayMessage, ''Standing By'')
	
	INSERT INTO ib_QueueItem 
		(StatusId, DisplayMessage, ScheduledStart, ScheduledTaskId, TaskTypeId, SiteId, TemplateId, createUsername, CreateDate
		--, AllTemplates
		)
	VALUES 
		(@statusId, @displayMessage, @scheduledStart, @scheduledTaskId, @taskTypeId, @siteId,@templateId,@createUsername, getdate()
		--, @allTemplates
		)
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_NostroAutoMatch_RunAutoMatch]''
');

GO
EXECUTE ('
CREATE PROCEDURE [dbo].[ib_NostroAutoMatch_RunAutoMatch]
	@templateId int
	,@CreateUsername VARCHAR(50) = null
AS
SET NOCOUNT ON
	--DECLARE @CreateUsername VARCHAR(50) = null
	--SET @CreateUsername = ''sa''
	--DECLARE @templateId int
	--SELECT TOP 1 @templateId = TemplateId FROM ib_Template

	DECLARE @siteId INT
	DECLARE @typeId INT
	
	SELECT @siteId = SiteId FROM ib_SiteTemplate WHERE TemplateId = @templateId
	
	IF (ISNULL(@siteId,-1) = -1)
	BEGIN
		RAISERROR (''Template or a corresponding Site does not exist'', 16, 2)
	END
	ELSE
	BEGIN
	
		SELECT @typeId = TaskTypeId FROM ib_TaskType WHERE Code = ''AM''
		
		IF (ISNULL(@typeId,-1) = -1)
		BEGIN
			RAISERROR (''Scheduled Tast Type for auto matching does not exist. There should be a task type with code "AM" in database'', 16, 2)
		END
		ELSE
		BEGIN
		
			EXECUTE sch_CreateQueueItem 
				@taskTypeId = @typeId, 
				@templateId = @templateId,
				@siteId = @siteId,
				@createUsername = @CreateUsername
		END
	END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[EU_cc040_Purge]''
');

GO
EXECUTE ('




-- =============================================
-- Author:		Lee Manifold
-- Create date: 18 Jul 2006
-- Description:	Deletes from all is_EU_cc040grp type files where the LoadState is the parameter @LoadState
-- =============================================
CREATE PROCEDURE [dbo].[EU_cc040_Purge]
	(
	@LoadState		TINYINT = 0,
	@RecordDate		DATETIME = NULL
	)
AS
BEGIN

	SET NOCOUNT ON;
	
	--raiserror (''Lee doing specific raiserror in stored proc for testing'', 19, 1) with log
	
	IF @RecordDate IS NOT NULL 
	BEGIN
		--****Need to Add code here to factor in @RecordDate into table fields 
		DELETE FROM [dbo].[EU_cc040grp] WHERE LoadState = @LoadState
	END
	
	IF @RecordDate IS NULL 
	BEGIN
	
		DELETE FROM [dbo].[EU_cc040grp] WHERE LoadState = @LoadState

	END
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[RolfeNolan_HOSTOPN_Purge]''
');

GO
EXECUTE ('-- =============================================
-- Author:		Petru Konrad Bercea
-- Create date: 04.02.2009
-- Description:	Deletes from RolfeNolan_HOSTOPN table all the records where the LoadState is 0
-- =============================================
CREATE PROCEDURE [dbo].[RolfeNolan_HOSTOPN_Purge] 
	(
		@LoadState		TINYINT = 0,
		@FileName       VARCHAR (512)= NULL
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
		DELETE FROM [dbo].[RolfeNolan_HOSTOPN] WHERE LoadState= @LoadState AND [FileName] = Coalesce(@FileName, [FileName])

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[Config_Update]''
');

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Updates a record in the Config table
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[Config_Update]
(

	@ConfigId int   ,

	@Key nvarchar (50)  ,

	@Value nvarchar (2000)  ,

	@CreateDate datetime   ,

	@CreateUsername varchar (50)  ,

	@UpdateDate datetime   ,

	@UpdateUsername varchar (50)  
)
AS


				
				
				-- Modify the updatable columns
				UPDATE
					[dbo].[Config]
				SET
					[Key] = @Key
					,[Value] = @Value
					,[CreateDate] = @CreateDate
					,[CreateUsername] = @CreateUsername
					,[UpdateDate] = @UpdateDate
					,[UpdateUsername] = @UpdateUsername
				WHERE
[ConfigId] = @ConfigId 
				
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Department_GetCodeAndIdForAllDepartments]''
');

GO
EXECUTE ('-- =============================================
-- Author:		<Konrad>
-- Create date: <17 March 2009>
-- Description:	<Get Id and Code for all Departments>
-- =============================================
CREATE PROCEDURE [dbo].[ib_Department_GetCodeAndIdForAllDepartments]
AS
SET NOCOUNT ON

	SELECT Code, DepartmentId 
	FROM ib_Department
    ORDER BY Code
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_NostroBalance_CheckForDuplicate]''
');

GO
EXECUTE ('/*
----------------------------------------------------------------------------------------------------

-- 26 Feb 09 : ED created
-- Purpose: check for duplicate
-- 
-- Revision History
--
-- Konrad - 16.03.2009, Added BalanceDate to the unique check criteria.
--
*/

CREATE PROCEDURE [dbo].[ib_NostroBalance_CheckForDuplicate]
(
	@MatchCode varchar(100),
	@BalanceDate Datetime,
	@TemplateId int,
	@NostroBalanceId int

)
AS
SET NOCOUNT ON
BEGIN
	DECLARE @Count int

DECLARE @MatchCodeId int
SELECT @MatchCodeId=MatchCodeId FROM ib_MatchCode WHERE MatchCode=@MatchCode AND TemplateId=@TemplateId
IF @MatchCodeId Is NULL
	RAISERROR (N''No Match Code (%s) found. Please specify other code!'', 11, 1, @MatchCode)
SELECT TOP 1 @Count = 1
	FROM [dbo].[ib_NostroBalance] nb
	WHERE MatchCodeId = @MatchCodeId AND BalanceDate = @BalanceDate
		AND NostroBalanceId <> @NostroBalanceId

IF @Count > 0
	RAISERROR (N''There is already another Balance with same Match Code (%s). Please specify other code!'', 11, 1, @MatchCode)
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_NostroBalance_Add]''
');

GO
EXECUTE ('/*
----------------------------------------------------------------------------------------------------

-- 26 Feb 09 : ED created
-- Purpose: add balance
-- 
-- Revision History
--
-- Konrad - 16.03.2009, Added BalanceDate to the unique check criteria.
--
*/

CREATE PROCEDURE [dbo].[ib_NostroBalance_Add]
(
	@MatchCode varchar(100),
	@BalanceDate Datetime,
	@TemplateId int,	
	@InternalBalance decimal(18,4),
	@ExternalBalance decimal(18,4),
	@CreateUsername varchar(50),
	@NostroBalanceId int output

)
AS
SET NOCOUNT ON
BEGIN TRY
--check for duplicates 
EXEC [dbo].[ib_NostroBalance_CheckForDuplicate] @MatchCode, @BalanceDate, @TemplateId, - 1
DECLARE @MatchCodeId int
SELECT @MatchCodeId=MatchCodeId FROM ib_MatchCode WHERE MatchCode=@MatchCode AND TemplateId=@TemplateId
INSERT INTO [dbo].[ib_NostroBalance]
           ([MatchCodeId]
           ,BalanceDate
		   ,InternalBalance
		   ,ExternalBalance
           ,[CreateUsername])
     VALUES
           (@MatchCodeId,
			@BalanceDate,
            @InternalBalance,
			@ExternalBalance,
            @CreateUsername)

SELECT @NostroBalanceId = Scope_Identity()

END TRY
BEGIN CATCH
	EXEC [dbo].[sp_RethrowError]
END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[EU_cc040grp_Add]''
');

GO
EXECUTE ('








-- =============================================
-- Author:		Lee Manifold
-- Create date: 30 May 2006
-- Description:	Insert into EU_cc040 header table
-- =============================================
CREATE PROCEDURE [dbo].[EU_cc040grp_Add] 
	(
	@membClgIdCod		varchar(5)  = NULL,
	@membExchldCod		varchar(5)  = NULL,
	@acctGrpCod			varchar(2)  = NULL,
	@currTypCod			varchar(3) = NULL,
	@mgnGrpCod			varchar(5) = NULL,
	@mgnClsCod			varchar(5) = NULL,
	@cshIntRat			varchar(11) = NULL,
	@upDownInd			varchar(1) = NULL,
	@undrlsin			varchar(12) = NULL,
	@settlDat			datetime = NULL,
	@cntrClasCod		varchar(1) = NULL,
	@prodId				varchar(4) = NULL,
	@cntrExpMthDat		int = NULL,
	@cntrExpYrDat		int = NULL,
	@cntrExerPrc		int = NULL,
	@cntrVersNo			int = NULL,
	@flxOptTrnIdNo		int = NULL,
	@trnIdSfxNo			int = NULL,
	@flxOptcntrClasCod	varchar(1) = NULL,
	@flxOptProdId		varchar(4) = NULL,
	@flxOptcntrExpDat	Datetime = NULL,
	@flxOptCntrExerPrc	varchar(13) = NULL,
	@flxOptcntrVersNo	int = NULL,
	@flxOptexerStylTyp	varchar(1) = NULL,
	@seculsin			varchar(12) = NULL,
	@netRiskPos			varchar(17) = NULL,
	@lngShtExerAllcInd	varchar(1) = NULL,
	@netFutPos			varchar(5) = NULL,
	@optEquVal			varchar(13) = NULL,
	@trdUntVal			varchar(14) = NULL,
	@posnCurVal			varchar(16) = NULL,
	@posnMaxMinVal		varchar(16) = NULL,
	@theoVal			varchar(16) = NULL,
	@shtOptMinCompTxt	varchar(3) = NULL,
	@shtOptMinCompQty	int = NULL,
	@secuLstClsPrc		varchar(14) = NULL,
	@maxMinUnderVal		varchar(16) = NULL,
	@calcUndPrc			varchar(16) = NULL,
	@sumSecuCntrCurr	varchar(16) = NULL,
	@sumSecuMaxMin		varchar(16) = NULL,
	@sumSecuTheoVal		varchar(16) = NULL,
	@sumUpDownCntrCurr	varchar(16) = NULL,
	@sumUpDownMaxMin	varchar(16) = NULL,
	@sumUpDownTheoVal	varchar(16) = NULL,
	@upDownValDiff		varchar(16) = NULL
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	INSERT INTO [dbo].[EU_cc040grp]
           ([membClgIdCod]
           ,[membExchldCod]
           ,[acctGrpCod]
           ,[currTypCod]
           ,[mgnGrpCod]
           ,[mgnClsCod]
           ,[cshIntRat]
           ,[upDownInd]
           ,[undrlsin]
           ,[settlDat]
           ,[cntrClasCod]
           ,[prodId]
           ,[cntrExpMthDat]
           ,[cntrExpYrDat]
           ,[cntrExerPrc]
           ,[cntrVersNo]
           ,[flxOptTrnIdNo]
           ,[trnIdSfxNo]
           ,[flxOptcntrClasCod]
           ,[flxOptProdId]
           ,[flxOptcntrExpDat]
           ,[flxOptCntrExerPrc]
           ,[flxOptcntrVersNo]
           ,[flxOptexerStylTyp]
           ,[seculsin]
           ,[netRiskPos]
           ,[lngShtExerAllcInd]
           ,[netFutPos]
           ,[optEquVal]
           ,[trdUntVal]
           ,[posnCurVal]
           ,[posnMaxMinVal]
           ,[theoVal]
           ,[shtOptMinCompTxt]
           ,[shtOptMinCompQty]
           ,[secuLstClsPrc]
           ,[maxMinUnderVal]
           ,[calcUndPrc]
           ,[sumSecuCntrCurr]
           ,[sumSecuMaxMin]
           ,[sumSecuTheoVal]
           ,[sumUpDownCntrCurr]
           ,[sumUpDownMaxMin]
           ,[sumUpDownTheoVal]
           ,[upDownValDiff])
     VALUES
           (
			@membClgIdCod		,
			@membExchldCod		,
			@acctGrpCod			,
			@currTypCod			,
			@mgnGrpCod			,
			@mgnClsCod			,
			@cshIntRat			,
			@upDownInd			,
			@undrlsin			,
			@settlDat			,
			@cntrClasCod		,
			@prodId				,
			@cntrExpMthDat		,
			@cntrExpYrDat		,
			@cntrExerPrc		,
			@cntrVersNo			,
			@flxOptTrnIdNo		,
			@trnIdSfxNo			,
			@flxOptcntrClasCod	,
			@flxOptProdId		,
			@flxOptcntrExpDat	,
			@flxOptCntrExerPrc	,
			@flxOptcntrVersNo	,
			@flxOptexerStylTyp	,
			@seculsin			,
			@netRiskPos			,
			@lngShtExerAllcInd	,
			@netFutPos			,
			@optEquVal			,
			@trdUntVal			,
			@posnCurVal			,
			@posnMaxMinVal		,
			@theoVal			,
			@shtOptMinCompTxt	,
			@shtOptMinCompQty	,
			@secuLstClsPrc		,
			@maxMinUnderVal		,
			@calcUndPrc			,
			@sumSecuCntrCurr	,
			@sumSecuMaxMin		,
			@sumSecuTheoVal		,
			@sumUpDownCntrCurr	,
			@sumUpDownMaxMin	,
			@sumUpDownTheoVal	,
			@upDownValDiff		
)
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[RolfeNolan_HOSTTRN_Add]''
');

GO
EXECUTE ('





-- =============================================
-- Author:		Petru Konrad Bercea
-- Create date: 28.02.2009
-- Description:	Insert into RolfeNolan_HOSTTRN table
--
-- Revision History
--
-- 06.05.09 Konrad Added new columns FASCurrency,BaseCurrency,Market, DummyField and StrikeShort
-- 15.05.09 Konrad Added new field Filename 
-- =============================================
CREATE PROCEDURE [dbo].[RolfeNolan_HOSTTRN_Add]
	-- Add the parameters for the stored procedure here
	(
	@Filename				varchar(512)=NULL,
	@Type					varchar(3)=NULL,
	@Serial					varchar(5)=NULL,
	@Ledger					varchar(7)=NULL,
	@FASCurrency			varchar(3)=NULL,
	@Currency				varchar(3)=NULL,
	@BaseCurrency			varchar(3)=NULL,
	@Market					varchar(5)=NULL,
	@MarketCode				varchar(5)=NULL,
	@DummyField				varchar(3)=NULL,
	@RunDate				varchar(8)=NULL,
	@Serial2				varchar(10)=NULL,
	@PromptDate				varchar(8)=NULL,
	@StrikeShort			varchar(21)=NULL,
	@Strike					varchar(21)=NULL,
	@PutCall				varchar(2)=NULL,
	@Lots					varchar(21)=NULL,
	@Price					varchar(21)=NULL,
	@OpenClose				varchar(1)=NULL
    )
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

  INSERT INTO [dbo].[RolfeNolan_HOSTTRN]
			( 
				[Filename]
				,[Type]
				,[Serial]
				,[Ledger]
				,[FASCurrency]
				,[Currency]
				,[BaseCurrency]
				,[Market]
				,[MarketCode]
				,[DummyField]
				,[RunDate]
				,[Serial2]
				,[PromptDate]
				,[StrikeShort]
				,[Strike]
				,[PutCall]
				,[Lots]
				,[Price]
				,[OpenClose] 
			)
    VALUES
			( 
				@Filename,
				@Type,
				@Serial,
				@Ledger,
				@FASCurrency,
				@Currency,
				@BaseCurrency,
				@Market,	
				@MarketCode,
				@DummyField,
				@RunDate,
				@Serial2,
				@PromptDate,
				@StrikeShort,
				@Strike,
				@PutCall,
				@Lots,
				@Price,
				@OpenClose
			)
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[Config_Delete]''
');

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Deletes a record in the Config table
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[Config_Delete]
(

	@ConfigId int   
)
AS


				DELETE FROM [dbo].[Config] WITH (ROWLOCK) 
				WHERE
					[ConfigId] = @ConfigId
					
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Department_GetDepartmentById]''
');

GO
EXECUTE ('   /*
<details>
 <summary> Selectes an instrument from the ib_Department table by its id</summary>
 <created author="konrad" Date="Tuesday, 24 March 2009 9:34PM GMT" /> 
</details>
*/
CREATE PROCEDURE [dbo].[ib_Department_GetDepartmentById]
(
	@DepartmentId int
)
AS
SET NOCOUNT ON

SELECT d.[DepartmentId]
      ,d.[Code]
      ,d.[Description]
      ,d.[CreateDate]
      ,d.[CreateUsername]
      ,d.[UpdateDate]
      ,d.[UpdateUsername]
FROM [dbo].[ib_Department] d

WHERE d.DepartmentId = @DepartmentId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_NostroBalance_Update]''
');

GO
EXECUTE ('/*
----------------------------------------------------------------------------------------------------

-- 26 Feb 09 : ED created
-- Purpose: update balance
*/

CREATE PROCEDURE [dbo].[ib_NostroBalance_Update]
(
	@NostroBalanceId int, 
	@InternalBalance decimal(18,4),
	@ExternalBalance decimal(18,4),	
	@UpdateUsername varchar(50)
	

)
AS
SET NOCOUNT ON
BEGIN TRY

UPDATE [dbo].[ib_NostroBalance]
   SET InternalBalance = @InternalBalance,
       ExternalBalance = @ExternalBalance,
       [UpdateUsername] = @UpdateUsername,
		UpdateDate=getdate()
 WHERE NostroBalanceId = @NostroBalanceId

END TRY
BEGIN CATCH
	EXEC [dbo].[sp_RethrowError]
END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[EU_cc040hdr]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[EU_cc040hdr]
(
[cc040ID] [int] NOT NULL IDENTITY(1, 1),
[exchNam] [varchar] (5) NULL,
[envText] [varchar] (1) NULL,
[rptCod] [varchar] (5) NULL,
[rptNam] [varchar] (5) NULL,
[rptFlexKey] [varchar] (14) NULL,
[membId] [varchar] (5) NULL,
[membLglNam] [varchar] (40) NULL,
[rptPrntEffDat] [datetime] NULL,
[rptPrntEffTim] [datetime] NULL,
[rptPrntRunDat] [datetime] NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_EU_cc040hdr_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_EU_cc040hdr_CreateDate] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_EU_cc040hdr] on [dbo].[EU_cc040hdr]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[EU_cc040hdr] ADD CONSTRAINT [PK_EU_cc040hdr] PRIMARY KEY CLUSTERED  ([cc040ID])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[EU_cc040hdr_Add]''
');

GO
EXECUTE ('


-- =============================================
-- Author:		Lee Manifold
-- Create date: 30 May 2006
-- Description:	Insert into EU_cc040 header table
-- =============================================
CREATE PROCEDURE [dbo].[EU_cc040hdr_Add] 
	(
		@exchNam		varchar(5) = NULL,
		@envText		varchar(1) = NULL,
		@rptCod			varchar(5) = NULL,
		@rptNam			varchar(5) = NULL,
		@rptFlexKey		varchar(14) = NULL,
		@membId			varchar(5) = NULL,
		@membLglNam		varchar(40) = NULL,
		@rptPrntEffDat	datetime = NULL,
		@rptPrntEffTim	datetime = NULL,
		@rptPrntRunDat datetime = NULL
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	INSERT INTO [dbo].[EU_cc040hdr]
           (
			[exchNam]
           ,[envText]
		   ,[rptCod]	
           ,[rptNam]
           ,[rptFlexKey]
           ,[membId]
           ,[membLglNam]
           ,[rptPrntEffDat]
           ,[rptPrntEffTim]
           ,[rptPrntRunDat]
			)
     VALUES
           (
			@exchNam,
			@envText,
			@rptCod,
			@rptNam,
			@rptFlexKey,
			@membId,
			@membLglNam,
			@rptPrntEffDat,
			@rptPrntEffTim,
			@rptPrntRunDat
			)
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[RolfeNolan_HOSTTRN_LoadStateChange]''
');

GO
EXECUTE ('

-- =============================================
-- Author:		Petru Konrad Bercea
-- Create date: 28.02.2009
-- Description:	Changes the LoadState of the RolfeNolan_HOSTTRN type table
-- =============================================
CREATE PROCEDURE [dbo].[RolfeNolan_HOSTTRN_LoadStateChange] 
	-- Add the parameters for the stored procedure here
	(
		@OldLoadState	TINYINT,
		@NewLoadState	TINYINT,
		@RecordDate		DATETIME = NULL
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

		UPDATE [dbo].[RolfeNolan_HOSTTRN] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_SWIFT_CheckDataIntegrity]''
');

GO
EXECUTE ('



-- =============================================
-- Author:		<P. Konrad Bercea>
-- Create date: <15.04.2009>
-- Description:	<Retrieves the SWIFT Data Integrity Check Result>
-- 
-- Revision History
--
-- 18.04.09 Konrad Fixed checking of Opening Balance based on Sequence Number also.
-- 21.04.09 Created Default Sort Order 
-- 24.06.2009 Konrad Added NostroCloseBalance and CheckedCloseBalanceOnNostro
-- 07.07.2009 Konrad Fixed displaying the NostroClosingBalance
-- 09.07.2009 Konrad Fixed displaying check if Closing Balance equals NostroBalance
-- 14.07.2009 Konrad Fixed bug of subquery returning more than one result.
-- =============================================
CREATE PROCEDURE [dbo].[ib_SWIFT_CheckDataIntegrity] 
	(
		@PeriodId int=2
    )
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    DECLARE @minDateForPeriod DATETIME

    IF @PeriodId = 1 SET @minDateForPeriod = DATEADD(DAY, -1, GETDATE())
	IF @PeriodId = 2 SET @minDateForPeriod = DATEADD(DAY, -7, GETDATE())
	IF @PeriodId = 3 SET @minDateForPeriod = DATEADD(MONTH, -1, GETDATE())
	IF @PeriodId = 4 SET @minDateForPeriod = DATEADD(MONTH, -3, GETDATE())
	IF @PeriodId = 5 SET @minDateForPeriod = DATEADD(MONTH, -6, GETDATE())
	IF @PeriodId = 6 SET @minDateForPeriod = DATEADD(YEAR, -1, GETDATE())
	IF @PeriodId = 7 SET @minDateForPeriod = CONVERT(datetime, ''01/01/1900'', 103)

	IF @PeriodId > 0 
	BEGIN

	SELECT 
		
		stm.[Filename], 
		stm.[CreateDate] as LoadDateTime,
        stm.[BalanceDate] as BalanceDate,
		a.[Code] as AccountNumber,
		stm.[StatementNumber] as StmtNo,
		stm.[StatementSequenceNumber] as StmtSeq,
		stm.[OpenBalance] as OpenBalance,
		stm.[TotalOfLineItemAmounts] as TotalItems,
		stm.[NostroClosingBalance] as NostroCloseBalance,
		CASE WHEN ( SELECT COUNT(*) 
				 FROM dbo.[ib_SwiftStatement] stm1
				 WHERE stm1.[AccountId] = stm.[AccountId] AND stm.[StatementNumber] > stm1.[StatementNumber]) > 0 
        THEN 
        (
			SELECT COUNT(*) 
			FROM dbo.[ib_SwiftStatement] stm1
			WHERE stm1.[AccountId] = stm.[AccountId] 
				  AND stm.[StatementNumber] = stm1.[StatementNumber] + 1 
		) ELSE 1 END as IsNumberInSequence,
		CASE WHEN stm.[StatementSequenceNumber] > 1 THEN (
			SELECT COUNT(*) 
			FROM dbo.[ib_SwiftStatement] stm1
			WHERE stm1.[AccountId] = stm.[AccountId] 
				  AND stm.[StatementNumber] = stm1.[StatementNumber] AND stm.[StatementSequenceNumber] = stm1.[StatementSequenceNumber] + 1 
		) ELSE 1 END as IsSequenceInSequence,
		CASE WHEN stm.[StatementSequenceNumber] = 1 AND 
				( SELECT COUNT(*) 
				 FROM dbo.[ib_SwiftStatement] stm1
				 WHERE stm1.[AccountId] = stm.[AccountId] AND stm.[StatementNumber] = stm1.[StatementNumber] + 1 ) > 0 THEN
                   ( SELECT TOP 1 stm1.[ClosingBalance]
                     FROM dbo.[ib_SwiftStatement] stm1
					 WHERE stm1.[AccountId] = stm.[AccountId] AND
                          stm.[StatementNumber] = stm1.[StatementNumber] + 1 
								AND stm1.[StatementSequenceNumber] = ( SELECT TOP 1 MAX(stm2.[StatementSequenceNumber])
																	   FROM dbo.[ib_SwiftStatement] stm2
																	   WHERE stm2.[AccountId] = stm1.[AccountId] AND stm1.[StatementNumber] = stm2.[StatementNumber] 	
																				)
				   ) - stm.[OpenBalance]
				ELSE CASE WHEN stm.[StatementSequenceNumber] > 1 THEN 
					(  SELECT SUM(stm1.[ClosingBalance])
						FROM dbo.[ib_SwiftStatement] stm1
						WHERE stm1.[AccountId] = stm.[AccountId] AND
                          stm.[StatementNumber] = stm1.[StatementNumber] AND stm.[StatementSequenceNumber] = stm1.[StatementSequenceNumber] + 1 
				   ) - stm.[OpenBalance] ELSE 0 END END as OpenBalanceDifference,
		stm.[OpenBalance] + stm.[TotalOfLineItemAmounts] - stm.[ClosingBalance] as ClosingBalanceDifference,
        stm.[ClosingBalance] as CloseBalance,
        CASE WHEN (stm.[NostroClosingBalance] is null or stm.[ClosingBalance] = stm.[NostroClosingBalance]) THEN 2 ELSE 1 END as CheckedCloseBalanceOnNostro

    FROM dbo.[ib_SwiftStatement] stm
		INNER JOIN dbo.[ib_Account] a on a.[AccountId] = stm.[AccountId]
   
	WHERE stm.[BalanceDate] >= @minDateForPeriod

	order by AccountNumber, StmtNo, StmtSeq

	END

	ELSE IF @PeriodId < 0 
	BEGIN

	SELECT 
		1 as StatementFailed, 
		stm.[Filename], 
		stm.[CreateDate] as LoadDateTime,
        stm.[BalanceDate] as BalanceDate,
		a.[Code] as Account,
		stm.[StatementNumber] as StmtNo,
		stm.[StatementSequenceNumber] as StmtSeq,
		stm.[OpenBalance] as OpenBalance,
		stm.[TotalOfLineItemAmounts] as TotalItems,
		stm.[ClosingBalance] as CloseBalance,
        1 as IsNumberInSequence,
        1 as IsSequenceInSequence,
        0 as OpenBalanceDifference,
        0 as ClosingBalanceDifference,
		stm.[NostroClosingBalance] as NostroCloseBalance,
		0 as CheckedCloseBalanceOnNostro	

    FROM dbo.[ib_SwiftStatement] stm

	INNER JOIN dbo.[ib_Account] a on a.[AccountId] = stm.[AccountId]
     
	WHERE stm.[SwiftStatementId] < 0

	END

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_MatchCode_GetToleranceByMatchCode]''
');

GO
EXECUTE ('/*
----------------------------------------------------------------------------------------------------

-- 16 Feb 09 : ED created
-- Purpose: get tolerance for a match code
-- 24 Feb 09: ED - fixed the tolerance type(decimal  not int)
*/

CREATE PROCEDURE [dbo].[ib_MatchCode_GetToleranceByMatchCode]
(
	@MatchCode varchar(100)
)
AS
SET NOCOUNT ON
BEGIN
	DECLARE @Tolerance decimal(18,4)
	SELECT @Tolerance = Tolerance FROM ib_MatchCodeTolerance
		WHERE ltrim(rtrim(MatchCode))=ltrim(rtrim(@MatchCode))
	IF (@Tolerance IS NULL)
		SET @Tolerance = 0
	SELECT @Tolerance
	RETURN @Tolerance
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[Config_GetByKey]''
');

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Select records from the Config table through an index
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[Config_GetByKey]
(

	@Key nvarchar (50)  
)
AS


				SELECT
					[ConfigId],
					[Key],
					[Value],
					[CreateDate],
					[CreateUsername],
					[UpdateDate],
					[UpdateUsername]
				FROM
					[dbo].[Config]
				WHERE
					[Key] = @Key
				SELECT @@ROWCOUNT
					
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Department_GetDepartmentCodesHintByKeyword]''
');

GO
EXECUTE ('/*
<details>
 <summary> Returns the Departments hint for a specific code /summary>
 <created author="konrad" date="24 Mar 2009 16:33:45 GMT"/>
 <tasks>
 </tasks>
</details>
*/
CREATE PROCEDURE [dbo].[ib_Department_GetDepartmentCodesHintByKeyword]
@DepartmentCode varchar(100),
@HintByStartOnly bit = 0,
@HintLength int = 1
AS
SET NOCOUNT ON

DECLARE @len int
SET @len = LEN(@DepartmentCode)
IF @HintByStartOnly = 1
BEGIN
	SELECT DISTINCT SUBSTRING ([Code], @len, @HintLength) x
		FROM [dbo].[ib_Department]
		WHERE [Code] LIKE @DepartmentCode+''%''
		ORDER BY x

END
ELSE
BEGIN
	SELECT DISTINCT SUBSTRING ([Code], PATINDEX(''%''+@DepartmentCode+''%'', [Code]) + @len, @HintLength) x
		FROM [dbo].[ib_Department]
		WHERE [Code] LIKE ''%''+@DepartmentCode+''%''
		ORDER BY x
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[GMI_EXTF1_Header_Add]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[GMI_EXTF1_Header_Add]
	@AsOfDateText				VARCHAR(6)   
	, @FileName					VARCHAR (512)
AS
--	10 Mar 2010		AAJM		Creation

	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	DECLARE @AsOfDateTime DATETIME
	SET @AsOfDateTime = CONVERT(DATETIME, @AsOfDateText, 12) -- YYMMDD

	UPDATE GMI_EXTF1 
	SET [AsOfDate] = @AsOfDateTime
	WHERE [FileName] = @FileName

RETURN 0
');

GO
EXECUTE ('PRINT N''Creating [dbo].[RolfeNolan_HOSTTRN_Purge]''
');

GO
EXECUTE ('

-- =============================================
-- Author:		Petru Konrad Bercea
-- Create date: 28.04.2009
-- Description:	Deletes from RolfeNolan_HOSTTRN table all the records where the LoadState is 0
-- =============================================
CREATE PROCEDURE [dbo].[RolfeNolan_HOSTTRN_Purge] 
	(
		@LoadState		TINYINT = 0,
		@FileName       VARCHAR (512)= NULL
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
		DELETE FROM [dbo].[RolfeNolan_HOSTTRN] WHERE LoadState= @LoadState AND [FileName] = Coalesce(@FileName, [FileName])

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_MatchCode_Update]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_MatchCode_Update]
 
(
	 @MatchCodeId int
	 , @TemplateTypeClassId int
     , @UpdateUsername varchar(50)
     , @BrokerId INT = NULL
)
AS
SET NOCOUNT ON

UPDATE [dbo].[ib_MatchCode]
   SET [TemplateTypeClassId] = @TemplateTypeClassId
            , [UpdateUsername] = @UpdateUsername
            , [UpdateDate] = GETDATE()
            , [BrokerId] = @BrokerId
 WHERE MatchCodeId = @MatchCodeId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[Config_GetByConfigId]''
');

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Select records from the Config table through an index
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[Config_GetByConfigId]
(

	@ConfigId int   
)
AS


				SELECT
					[ConfigId],
					[Key],
					[Value],
					[CreateDate],
					[CreateUsername],
					[UpdateDate],
					[UpdateUsername]
				FROM
					[dbo].[Config]
				WHERE
					[ConfigId] = @ConfigId
				SELECT @@ROWCOUNT
					
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Department_GetDepartmentDescriptionsHintByKeyword]''
');

GO
EXECUTE ('/*
<details>
 <summary> Returns the departments hint for a specific code /summary>
 <created author="konrad" date="24 Mar 2009 16:33:45 GMT"/>  
 <tasks>
 </tasks>
</details>
*/
CREATE PROCEDURE [dbo].[ib_Department_GetDepartmentDescriptionsHintByKeyword]
@DepartmentDescription varchar(100),
@HintByStartOnly bit = 0,
@HintLength int = 1
AS
SET NOCOUNT ON

DECLARE @len int
SET @len = LEN(@DepartmentDescription)
IF @HintByStartOnly = 1
BEGIN
	SELECT DISTINCT SUBSTRING ([Description], @len, @HintLength) x
		FROM [dbo].[ib_Department]
		WHERE [Description] LIKE @DepartmentDescription+''%''
		ORDER BY x DESC

END
ELSE
BEGIN
	SELECT DISTINCT SUBSTRING ([Description], PATINDEX(''%''+@DepartmentDescription+''%'', [Description]) + @len, @HintLength) x
		FROM [dbo].[ib_Department]
		WHERE [Description] LIKE ''%''+@DepartmentDescription+''%''
		ORDER BY x DESC
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[Split]''
');

GO
EXECUTE ('/*
----------------------------------------------------------------------------------------------------

-- 16 Feb 09 : ED created
-- Purpose: get list of ids into a table from a csv list
-- 2 Mar 09 : change function nvarchar size
*/

CREATE FUNCTION [dbo].[Split](@String nvarchar(max), @Delimiter char(1))
RETURNS @Results TABLE (Items nvarchar(4000))
AS
BEGIN
DECLARE @INDEX INT
DECLARE @SLICE nvarchar(4000)
-- HAVE TO SET TO 1 SO IT DOESNT EQUAL Z
-- ERO FIRST TIME IN LOOP
SELECT @INDEX = 1
WHILE @INDEX !=0


BEGIN
-- GET THE INDEX OF THE FIRST OCCURENCE OF THE SPLIT CHARACTER
SELECT @INDEX = CHARINDEX(@Delimiter,@STRING)
-- NOW PUSH EVERYTHING TO THE LEFT OF IT INTO THE SLICE VARIABLE
IF @INDEX !=0
SELECT @SLICE = LEFT(@STRING,@INDEX - 1)
ELSE
SELECT @SLICE = @STRING
-- PUT THE ITEM INTO THE RESULTS SET
IF (@SLICE != ''0'' AND @SLICE != ''-1'')
	INSERT INTO @Results(Items) VALUES(@SLICE)
-- CHOP THE ITEM REMOVED OFF THE MAIN STRING
SELECT @STRING = RIGHT(@STRING,LEN(@STRING) - @INDEX)
-- BREAK OUT IF WE ARE DONE
IF LEN(@STRING) = 0 BREAK
END
RETURN
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_NextNumber]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[ib_NextNumber]
(
[NextNumberId] [int] NOT NULL IDENTITY(1, 1),
[TableName] [varchar] (100) NOT NULL,
[FieldName] [varchar] (100) NOT NULL,
[NextNumber] [int] NOT NULL,
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_ib_NextNumber_CreateDate] DEFAULT (getdate()),
[CreateUsername] [varchar] (50) NOT NULL CONSTRAINT [DF_ib_NextNumber_CreateUsername] DEFAULT (suser_sname()),
[UpdateDate] [datetime] NULL,
[UpdateUsername] [varchar] (50) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_ib_NextNumber] on [dbo].[ib_NextNumber]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_NextNumber] ADD CONSTRAINT [PK_ib_NextNumber] PRIMARY KEY CLUSTERED  ([NextNumberId])
');

GO
EXECUTE ('PRINT N''Creating index [AK_Table_Field] on [dbo].[ib_NextNumber]''
');

GO
EXECUTE ('CREATE UNIQUE NONCLUSTERED INDEX [AK_Table_Field] ON [dbo].[ib_NextNumber] ([TableName], [FieldName])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_NextNumber_GetNextNumber]''
');

GO
EXECUTE ('/*
----------------------------------------------------------------------------------------------------

-- 16 Feb 09 : ED created
-- Purpose: get next number for a table/field
*/

CREATE PROCEDURE [dbo].[ib_NextNumber_GetNextNumber]
(
	@TableName varchar(100), @FieldName varchar(100)
)
AS
SET NOCOUNT ON
BEGIN
	DECLARE @NextNumber int
	SELECT @NextNumber = NextNumber FROM ib_NextNumber WITH(ROWLOCK)
		WHERE TableName=@TableName AND FieldName=@FieldName
	IF (@NextNumber IS NULL)
	BEGIN
		SET @NextNumber = 1
		INSERT INTO ib_NextNumber(TableName,FieldName,NextNumber)
		VALUES(@TableName,@FieldName,1)
		RETURN @NextNumber
	END
	
	SET @NextNumber=@NextNumber+1
	UPDATE ib_NextNumber SET NextNumber = @NextNumber WHERE TableName=@TableName AND FieldName=@FieldName
	RETURN @NextNumber
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_NostroMatch_InsertMatchGroup]''
');

GO
SET ANSI_NULLS OFF

GO
EXECUTE ('/*
----------------------------------------------------------------------------------------------------

-- 16 Feb 09 : ED created
-- Purpose: insert records into nostro match group
-- 27 Feb 09: ED : 10124 - don''t add balancing if only from one side
-- 1 Mar 09 : ED : 10149 - change rule to an extended one
-- 2 Mar 09 : change parameter varchar size, added try/catch with rollback on transaction
--30 Sep 09 : amk: get and store username on records
--20 Oct 09 : amk : MBAL-13528 - Create second nostro balancing item - equal and opposite and put in match group
--21 Oct 09 : amk : MBAL-13528 - Change narrative on adjustment per Marc
--27 Oct 09 : amk : MBAL-13532 - 1) Raise error if problem
--							     2) Bug Fix: Remove hard-coded i-balancer db name!!


	Updated By: Kirill Shilin
	Update On: 07.10.2011
	Issue: MBAL-19022: Please update the ib_NostroMatch table to add RuleId
	Changes: RuleId update introduced
-- 02 Jul 12: ED	MBAL 20233 - create a new column for NostroMatch
-- 10 Aug 12: ED	MBAL 21445 - fix the update of ib_Nostro.NostroMatchId on inserting into ib_NostroMatch
*/


CREATE PROCEDURE [dbo].[ib_NostroMatch_InsertMatchGroup]
(
	@InternalNostroIds varchar(max)
	, @ExternalNostroIds varchar(max)
	, @NostroMatchTypeCode varchar(100)
	, @Comments varchar(1024)
	, @Username VARCHAR(50)
	, @RuleId INT = NULL
)
AS
SET NOCOUNT ON
BEGIN
BEGIN TRANSACTION t1

BEGIN TRY

DECLARE @GroupNumber INT
DECLARE @ITableIds TABLE(ItemId int)
DECLARE @ETableIds TABLE(ItemId int)
DECLARE @NostroMatchTypeId int
--get data to insert
exec @GroupNumber=dbo.ib_nextnumber_getnextnumber ''ib_NostroMatch'',''GroupNumber''

INSERT INTO @ITableIds(ItemId)
	SELECT CAST(items AS INT) AS Example2
	FROM dbo.split(@InternalNostroIds,'','')
INSERT INTO @ETableIds(ItemId)
	SELECT CAST(items AS INT) AS Example2
	FROM dbo.split(@ExternalNostroIds,'','')

SELECT @NostroMatchTypeId=NostroMatchTypeId FROM ib_NostroMatchType WHERE Code=@NostroMatchTypeCode
--insert data
INSERT INTO ib_NostroMatch(GroupNumber,NostroId,NostroMatchTypeId,Comments,CreateUsername, RuleId)
SELECT @GroupNumber,ItemId,@NostroMatchTypeId,@Comments,@Username, @RuleId
	FROM @ITableIds

INSERT INTO ib_NostroMatch(GroupNumber,NostroId,NostroMatchTypeId,Comments,CreateUsername, RuleId)
SELECT @GroupNumber,ItemId,@NostroMatchTypeId,@Comments,@Username, @RuleId
	FROM @ETableIds

--insert balancing item if it is the case
DECLARE @Difference DECIMAL(18,4)
DECLARE @InternalPayment DECIMAL(18,4)
DECLARE @ExternalPayment DECIMAL(18,4)
DECLARE @InternalReceipt DECIMAL(18,4)
DECLARE @ExternalReceipt DECIMAL(18,4)

SELECT @InternalPayment=ABS(SUM(Amount)) FROM ib_Nostro n
	INNER JOIN @ITableIds i ON n.NostroId=i.ItemId WHERE Amount<0
SELECT @InternalReceipt=ABS(SUM(Amount)) FROM ib_Nostro n
	INNER JOIN @ITableIds i ON n.NostroId=i.ItemId WHERE Amount>0

SELECT @ExternalPayment=ABS(SUM(Amount)) FROM ib_Nostro n
	INNER JOIN @ETableIds i ON n.NostroId=i.ItemId WHERE Amount<0
SELECT @ExternalReceipt=ABS(SUM(Amount)) FROM ib_Nostro n
	INNER JOIN @ETableIds i ON n.NostroId=i.ItemId WHERE Amount>0
SET @Difference = (ISNULL(@ExternalReceipt,0)-ISNULL(@ExternalPayment,0)) - (ISNULL(@InternalReceipt,0)-ISNULL(@InternalPayment,0))
DECLARE @NostroBalancingItemId int
DECLARE @AccountId int 
DECLARE @CurrencyId int
DECLARE @DataSourceId Int
DECLARE @ValueDate datetime
DECLARE @TransDate datetime
DECLARE @TempTableRecordId int
--if we have difference, insert a difference item
IF (@Difference != 0)
BEGIN
	IF (@Difference > 0)
		INSERT INTO ib_NostroBalancingItem(GroupNumber,AmountPayments,AmountReceipts,CreateUsername)
			VALUES(@GroupNumber,0,@Difference,@Username)
	ELSE
		INSERT INTO ib_NostroBalancingItem(GroupNumber,AmountPayments,AmountReceipts,CreateUsername)
			VALUES(@GroupNumber,-1*@Difference,0,@Username)
	
	SELECT @NostroBalancingItemId = Scope_Identity()
    
	IF (@InternalNostroIds != ''-1'')
	BEGIN
		SELECT TOP 1 @ValueDate = ValueDate,@TransDate = TransDate,@AccountId = AccountId,@CurrencyId = CurrencyId,@DataSourceId = DataSourceId
			, @TempTableRecordId = TempTableRecordId
			FROM ib_Nostro n
			INNER JOIN @ITableIds i ON n.NostroId=i.ItemId order by i.ItemId desc
	END
	ELSE
	BEGIN
		DECLARE @MatchCode varchar(100)
		DECLARE @TemplateId int
		SELECT TOP 1 @MatchCode=tg.Description,@TemplateId = t.TemplateId
				FROM ib_Nostro n
				INNER JOIN ib_Account a ON a.AccountId=n.AccountId
				INNER JOIN ib_Firm f ON f.FirmId=a.FirmId
				INNER JOIN ib_TemplateCompare tc ON tc.DataSourceId=n.DataSourceId AND tc.FirmId=f.FirmId
				INNER JOIN ib_Template t ON t.TemplateId=tc.TemplateId
				INNER JOIN ib_TemplateGroup tg ON tg.TemplateId=t.TemplateId AND tg.AccountId=n.AccountId  AND tg.CurrencyId=n.CurrencyId
				INNER JOIN @ETableIds i ON n.NostroId=i.ItemId WHERE Amount>0
		SELECT TOP 1 @ValueDate = ValueDate,@TransDate = TransDate,@AccountId = n.AccountId,@CurrencyId = n.CurrencyId,@DataSourceId = n.DataSourceId 
				, @TempTableRecordId = TempTableRecordId
				FROM ib_Nostro n
				INNER JOIN ib_Account a ON a.AccountId=n.AccountId
				INNER JOIN ib_Firm f ON f.FirmId=a.FirmId
				INNER JOIN ib_TemplateCompare tc ON tc.DataSourceId=n.DataSourceId AND tc.FirmId=f.FirmId
				INNER JOIN ib_Template t ON t.TemplateId=tc.TemplateId
				INNER JOIN ib_TemplateGroup tg ON tg.TemplateId=t.TemplateId AND tg.AccountId=n.AccountId  AND tg.CurrencyId=n.CurrencyId
				WHERE tg.[Description]=@MatchCode AND InternalExternalCode=''I'' and t.templateId=@TemplateId
	END
	INSERT INTO [ib_Nostro]
           ([ValueDate],[TransDate],[Amount],[TransactionType],[InternalReference],[ExternalReference],[Narrative]
           ,[AccountId],[CurrencyId],[DataSourceId]
           ,[NostroBalancingItemId],TempTableRecordId
			, [CreateUsername])
		VALUES(@ValueDate,@TransDate,-1*@Difference,''ADJ'','''','''',''Small Difference-negative'',
			@AccountId,@CurrencyId,@DataSourceId,@NostroBalancingItemId, @TempTableRecordId
			, @Username)

	-- equal and opposite entry - so balance doesn''t need updating
	DECLARE @OppositeNostroId INT
	INSERT INTO [ib_Nostro]
           ([ValueDate],[TransDate],[Amount],[TransactionType],[InternalReference],[ExternalReference],[Narrative]
           ,[AccountId],[CurrencyId],[DataSourceId]
           ,[NostroBalancingItemId],TempTableRecordId
			, [CreateUsername])
		VALUES(@ValueDate,@TransDate,@Difference,''ADJ'','''','''',''Small Difference-positive'',
			@AccountId,@CurrencyId,@DataSourceId,@NostroBalancingItemId, @TempTableRecordId
			, @Username)
	SET @OppositeNostroId = SCOPE_IDENTITY()

	-- also now put that second nostro entry into the match group
	INSERT INTO ib_NostroMatch(GroupNumber,NostroId,NostroMatchTypeId,Comments,CreateUsername, RuleId)
	VALUES (@GroupNumber,@OppositeNostroId,@NostroMatchTypeId,@Comments,@Username, @RuleId)

END

UPDATE ib_Nostro
		SET ib_Nostro.NostroMatchId=ib_NostroMatch.NostroMatchId,
			UpdateUsername=@Username,
			UpdateDate=GETDATE()
	FROM ib_Nostro
	INNER JOIN ib_NostroMatch ON ib_Nostro.NostroId=ib_NostroMatch.NostroId
	WHERE GroupNumber = @GroupNumber

COMMIT TRANSACTION t1

END TRY
BEGIN CATCH
	ROLLBACK TRANSACTION t1
	EXEC sp_RethrowError ''Error matching''
END CATCH
		
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[GMI_EXTF1_Transaction_Add]''
');

GO
SET ANSI_NULLS ON

GO
EXECUTE ('CREATE PROCEDURE [dbo].[GMI_EXTF1_Transaction_Add]
	@RecordType					VARCHAR(1)
	, @TransactionType			VARCHAR(1)
    , @Tracer					VARCHAR(10)			
	, @GmiFirmIdent				VARCHAR(1)
	, @OfficeIdent				VARCHAR(3)
	, @AccountIdent				VARCHAR(5)		
	, @Exchange					VARCHAR(2)
	, @FuturesCodeSymbolCusip	VARCHAR(6)
	, @PutCallCode				VARCHAR(1)
	, @StrikeOrCusip			VARCHAR(17)
	, @SecurityType				VARCHAR(1)
	, @ContractYearMonth		VARCHAR(6)
	, @ContractDay				VARCHAR(2)
	, @TradeDate				VARCHAR(8)
	, @InputTradePrice			DECIMAL(19,8)
	, @BuySell					VARCHAR(1)
	, @Quantity					DECIMAL(19,4)
	, @Spread					VARCHAR(1)
	, @OpenCloseCode			VARCHAR(1)
	, @SettlementDate			VARCHAR(8)
	, @CalculationTradePrice	DECIMAL(19,8)
    , @PrintableTradePrice		VARCHAR(11)
    , @Salesman					VARCHAR(5)
    , @AccountType				VARCHAR(2)
    , @CommentCode1				VARCHAR(1)
    , @CommentCode2				VARCHAR(1)
    , @CommentCode3				VARCHAR(1)
    , @CurrencySymbol			VARCHAR(3)
    , @CurrencyCode				VARCHAR(2)
    , @DeltaFactor				DECIMAL(9,4)
    , @InstrumentCode			VARCHAR(1)
    , @ChargeControlCodeCommissionFees	VARCHAR(1)
    , @ChargeControlCodePremiumPAndSPrincipal	VARCHAR(1)
    , @ContractMultiplier		DECIMAL(19,7)
    , @LocationCode				VARCHAR(1)
    , @SubexchangeCode			VARCHAR(1)
    , @AccountTypeCurrencyCodeSymbol	VARCHAR(3)
    , @CUSIP2					VARCHAR(12)
    , @UnusedButCanContainCUSIP	VARCHAR(9)
    , @ExecutingBroker			VARCHAR(5)
    , @OpposingBroker			VARCHAR(5)
    , @OpposingFirm				VARCHAR(5)
    , @CardNumber				VARCHAR(4)
    , @OrderNumber				VARCHAR(25)
    , @ChitNumber				VARCHAR(15)
    , @ClearingFeeCode			VARCHAR(1)
    , @ExchangeFeeCode			VARCHAR(1)
    , @CTICode					VARCHAR(1)
    , @OrderTypeCode			VARCHAR(1)
    , @OrderTime				VARCHAR(6)
    , @TimeBracket				VARCHAR(2)
    , @TradeTypeCode			VARCHAR(1)
    , @GiveInGiveOutCode		VARCHAR(2)
    , @GiveInGiveOutFirm		VARCHAR(5)
    , @InterExchangeCode		VARCHAR(2)
    , @InterExchangeFirm		VARCHAR(5)
    , @ReferredSalesman			VARCHAR(5)
    , @MarketValueOrOpenTradeEquity	DECIMAL(19,2)
    , @PriorMarketValueOrOpenTradeEquity DECIMAL(19,2)
    , @NumericClosingPrice		DECIMAL(19,8)
    , @PrintableClosingPrice	VARCHAR(11)
    , @PriceDate				VARCHAR(9)
    , @UnderlyingClosingPrice	DECIMAL(19,8)
    , @GrossAmount				DECIMAL(19,2)
    , @DayQuantity				DECIMAL(19,4)	
    , @OvernightQuantity		DECIMAL(19,4)
    , @ScratchQuantity			DECIMAL(19,4)
    , @SpreadQuantity			DECIMAL(19,4)
    , @VariationMarginDueOnTrade	DECIMAL(19,2)
    , @LastTradeDate			VARCHAR(10)
    , @FirstNoticeDate			VARCHAR(10)
    , @ExpirationDate			VARCHAR(10)
	, @FileName					VARCHAR (512)


AS
--	08 Mar 2010		AAJM		Creation

	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	INSERT INTO GMI_EXTF1 (
	[RecordType]					
	, [TransactionType]			
    , [Tracer]								
	, [GmiFirmIdent]				
	, [OfficeIdent]				
	, [AccountIdent]						
	, [Exchange]				
	, [FuturesCodeSymbolCusip]	
	, [PutCallCode]				
	, [StrikeOrCusip]			
	, [SecurityType]				
	, [ContractYearMonth]		
	, [ContractDay]				
	, [TradeDate]				
	, [InputTradePrice]			
	, [BuySell]					
	, [Quantity]					
	, [Spread]					
	, [OpenCloseCode]			
	, [SettlementDate]			
	, [CalculationTradePrice]	
    , [PrintableTradePrice]		
    , [Salesman]					
    , [AccountType]				
    , [CommentCode1]				
    , [CommentCode2]				
    , [CommentCode3]				
    , [CurrencySymbol]			
    , [CurrencyCode]				
    , [DeltaFactor]				
    , [InstrumentCode]			
    , [ChargeControlCodeCommissionFees]	
    , [ChargeControlCodePremiumPAndSPrincipal]	
    , [ContractMultiplier]		
    , [LocationCode]				
    , [SubexchangeCode]			
    , [AccountTypeCurrencyCodeSymbol]	
    , [CUSIP2]					
    , [UnusedButCanContainCUSIP]	
    , [ExecutingBroker]			
    , [OpposingBroker]			
    , [OpposingFirm]				
    , [CardNumber]				
    , [OrderNumber]				
    , [ChitNumber]				
    , [ClearingFeeCode]			
    , [ExchangeFeeCode]			
    , [CTICode]					
    , [OrderTypeCode]			
    , [OrderTime]				
    , [TimeBracket]				
    , [TradeTypeCode]			
    , [GiveInGiveOutCode]		
    , [GiveInGiveOutFirm]		
    , [InterExchangeCode]		
    , [InterExchangeFirm]		
    , [ReferredSalesman]			
    , [MarketValueOrOpenTradeEquity]	
    , [PriorMarketValueOrOpenTradeEquity] 
    , [NumericClosingPrice]		
    , [PrintableClosingPrice]	
    , [PriceDate]				
    , [UnderlyingClosingPrice]	
    , [GrossAmount]				
    , [DayQuantity]					
    , [OvernightQuantity]		
    , [ScratchQuantity]			
    , [SpreadQuantity]			
    , [VariationMarginDueOnTrade]	
    , [LastTradeDate]			
    , [FirstNoticeDate]			
    , [ExpirationDate]			
	, [FileName]			
    )
	VALUES (
	@RecordType					
	, @TransactionType			
    , @Tracer								
	, @GmiFirmIdent				
	, @OfficeIdent				
	, @AccountIdent						
	, @Exchange					
	, @FuturesCodeSymbolCusip	
	, @PutCallCode				
	, @StrikeOrCusip			
	, @SecurityType				
	, @ContractYearMonth		
	, @ContractDay				
	, @TradeDate				
	, @InputTradePrice			
	, @BuySell					
	, @Quantity					
	, @Spread					
	, @OpenCloseCode			
	, @SettlementDate			
	, @CalculationTradePrice	
    , @PrintableTradePrice		
    , @Salesman					
    , @AccountType				
    , @CommentCode1				
    , @CommentCode2				
    , @CommentCode3				
    , @CurrencySymbol			
    , @CurrencyCode				
    , @DeltaFactor				
    , @InstrumentCode			
    , @ChargeControlCodeCommissionFees	
    , @ChargeControlCodePremiumPAndSPrincipal	
    , @ContractMultiplier		
    , @LocationCode				
    , @SubexchangeCode			
    , @AccountTypeCurrencyCodeSymbol	
    , @CUSIP2					
    , @UnusedButCanContainCUSIP	
    , @ExecutingBroker			
    , @OpposingBroker			
    , @OpposingFirm				
    , @CardNumber				
    , @OrderNumber				
    , @ChitNumber				
    , @ClearingFeeCode			
    , @ExchangeFeeCode			
    , @CTICode					
    , @OrderTypeCode			
    , @OrderTime				
    , @TimeBracket				
    , @TradeTypeCode			
    , @GiveInGiveOutCode		
    , @GiveInGiveOutFirm		
    , @InterExchangeCode		
    , @InterExchangeFirm		
    , @ReferredSalesman			
    , @MarketValueOrOpenTradeEquity	
    , @PriorMarketValueOrOpenTradeEquity 
    , @NumericClosingPrice		
    , @PrintableClosingPrice	
    , @PriceDate				
    , @UnderlyingClosingPrice	
    , @GrossAmount				
    , @DayQuantity					
    , @OvernightQuantity		
    , @ScratchQuantity			
    , @SpreadQuantity			
    , @VariationMarginDueOnTrade	
    , @LastTradeDate			
    , @FirstNoticeDate			
    , @ExpirationDate			
	, @FileName					
	)
RETURN 0
');

GO
EXECUTE ('PRINT N''Creating [dbo].[RolfeNolan_HOSTTRN_V2_Add]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[RolfeNolan_HOSTTRN_V2_Add]
	@Filename				varchar(512)=NULL,
	@Type					varchar(3)=NULL,
	@Serial					varchar(5)=NULL,
	@Ledger					varchar(10)=NULL,
	@FASCurrency			varchar(3)=NULL,
	@Currency				varchar(3)=NULL,
	@BaseCurrency			varchar(3)=NULL,
	@Market					varchar(5)=NULL,
	@MarketCode				varchar(5)=NULL,
	@DummyField				varchar(3)=NULL,
	@RunDate				varchar(8)=NULL,
	@RecordType_Field1		VARCHAR(100)=NULL,
	@RecordType_Field2		VARCHAR(100)=NULL,
	@RecordType_Field3		VARCHAR(100)=NULL,
	@RecordType_Field4		VARCHAR(100)=NULL,
	@RecordType_Field5		VARCHAR(100)=NULL,
	@RecordType_Field6		VARCHAR(100)=NULL,
	@RecordType_Field7		VARCHAR(100)=NULL,
	@RecordType_Field8		VARCHAR(100)=NULL,
	@RecordType_Field9		varchar(100)=NULL,
	@RecordType_Field10		varchar(100)=NULL,
	@RecordType_Field11		varchar(100)=NULL,
	@RecordType_Field12		varchar(100)=NULL,
	@RecordType_Field13		varchar(100)=NULL, -- NOT used as @ 08 Mar 2010. Only here for possible expansion in the future.
	@RecordType_Field14		varchar(100)=NULL, -- NOT used as @ 08 Mar 2010. Only here for possible expansion in the future.
	@RecordType_Field15		varchar(100)=NULL  -- NOT used as @ 08 Mar 2010. Only here for possible expansion in the future.
AS
SET NOCOUNT ON;

/*
Author		Date			Description
KevinP		05 Mar 2010		Added this SP for the new Host Tran loader...
KevinP		17 Mar 2010		Fixed Strike Price to be zero
KevinP		17 Mar 2010		Changed where Strike Price was being sourced from for record types 003,004,020,093, 006, 012, 013.
-- 24 Jun 2014		ED			EIB 25764 - add UTI
*/


--KevinP : TODO: Work out where to grab the fields for the table depending on the RecordType!
DECLARE @StrikeShort VARCHAR(21)
DECLARE @Strike VARCHAR(21)
DECLARE @PutCall VARCHAR(2)
DECLARE @Lots VARCHAR(21)
DECLARE @Price VARCHAR(21)
DECLARE @OpenClose VARCHAR(1)
DECLARE @PostingAmount VARCHAR(20)
DECLARE @IsMergedTrade CHAR(1)
DECLARE @Serial2 VARCHAR(10)
DECLARE @PromptDate VARCHAR(8)
DECLARE @UTI VARCHAR(100)
--Used for 003, 004,020,093,006,007,012,013
DECLARE @Series VARCHAR(20)
DECLARE @FullSeries VARCHAR(20)
DECLARE @Premium VARCHAR(20)

--This is just to make sure that we dont add record types we don''t know about...
DECLARE @IsValidToInsertRecord BIT
SET @IsValidToInsertRecord = 0

-- Used for 005 only
DECLARE @IsCashSettlingOption CHAR(1)

IF	@Type = ''001'' OR 
	@Type = ''002'' OR
	@Type = ''014'' OR 
	@Type = ''018'' OR 
	@Type = ''019'' OR 
	@Type = ''091'' 
BEGIN
	SET @Serial2= @RecordType_Field1
	SET @PromptDate = @RecordType_Field2
	SET @Lots = @RecordType_Field3
	SET @Price = @RecordType_Field4
	SET @PostingAmount = @RecordType_Field5
	SET @OpenClose = @RecordType_Field6
	SET @IsMergedTrade = @RecordType_Field7
	SET @Strike = 0
	SET @StrikeShort = NULL
	SET @PutCall = NULL
	SET @IsValidToInsertRecord = 1
	SET @UTI = @RecordType_Field9
END


IF	@Type = ''003'' OR 
	@Type = ''004'' OR
	@Type = ''020'' OR 
	@Type = ''093'' 
BEGIN
	SET @Serial2= @RecordType_Field1
	SET @PromptDate = @RecordType_Field2
	SET @Series = @RecordType_Field3
	SET @PutCall = @RecordType_Field4
	SET @Lots = @RecordType_Field5
	SET @Price = @RecordType_Field6
	SET @Premium = @RecordType_Field7
	SET @Strike = @RecordType_Field3 -- We get this from Series Column because Price doesn''t hold anything...
	SET @PostingAmount = @RecordType_Field9
	SET @OpenClose = @RecordType_Field10
	SET @IsMergedTrade = @RecordType_Field11
	SET @FullSeries = @RecordType_Field12
	SET @IsValidToInsertRecord = 1
	SET @UTI = @RecordType_Field14
END

IF	@Type = ''005'' 
BEGIN
	SET @Serial2= @RecordType_Field1
	SET @Lots = @RecordType_Field2
	SET @PromptDate = @RecordType_Field3
	SET @PostingAmount = @RecordType_Field4
	SET @IsCashSettlingOption = @RecordType_Field5
	SET @PutCall = NULL -- N/A for 005 Record Types.
	SET @Price = NULL -- N/A
	SET @Strike = NULL -- N/A
	SET @StrikeShort = NULL --N/A
	SET @IsValidToInsertRecord = 1
	SET @UTI = @RecordType_Field6
END

IF	@Type = ''006'' 
BEGIN
	SET @Serial2= @RecordType_Field1
	SET @PromptDate = @RecordType_Field2
	SET @Series = @RecordType_Field3
	SET @PutCall = @RecordType_Field4
	SET @Lots = @RecordType_Field5
	SET @Price = @RecordType_Field6 -- NB:- Price will actuall hold the value in the Premium Rate Column
	SET @Premium = @RecordType_Field7
	SET @PostingAmount = @RecordType_Field8 
	SET @Strike = @RecordType_Field3 --NB:- We get this from Series Column because Price doesn''t hold anything...
	SET @OpenClose = @RecordType_Field10
	SET @FullSeries = @RecordType_Field10
	SET @StrikeShort = NULL --N/A
	SET @IsValidToInsertRecord = 1
	SET @UTI = @RecordType_Field11
END

IF	@Type = ''007'' 
BEGIN
	SET @Serial2= @RecordType_Field3
	SET @Lots = @RecordType_Field4
	SET @PromptDate = @RecordType_Field5
	SET @PostingAmount = @RecordType_Field6
	SET @Series = @RecordType_Field7
	SET @PutCall = @RecordType_Field8
	SET @FullSeries = @RecordType_Field10

	SET @Price = NULL
	SET @Premium = NULL
	SET @Strike = @RecordType_Field7
	SET @OpenClose = NULL
	SET @StrikeShort = NULL --N/A
	SET @IsValidToInsertRecord = 1
	SET @UTI = @RecordType_Field11
END

IF	@Type = ''012'' OR
	@Type = ''013''
BEGIN
	SET @Serial2= @RecordType_Field1
	SET @PromptDate = @RecordType_Field2
	SET @Series = @RecordType_Field3
	SET @PutCall = @RecordType_Field4
	SET @Lots = @RecordType_Field5
	SET @Price = @RecordType_Field6
	SET @Premium = @RecordType_Field7
	SET @PostingAmount = @RecordType_Field8
	SET @Strike = @RecordType_Field3 -- We get this from Series Column because Price doesn''t hold anything...
	SET @OpenClose = @RecordType_Field10
	SET @FullSeries = @RecordType_Field11	
	SET @StrikeShort = NULL --N/A
	SET @IsValidToInsertRecord = 1
	SET @UTI = @RecordType_Field12
END


IF @IsValidToInsertRecord = 1
BEGIN
	INSERT INTO [dbo].[RolfeNolan_HOSTTRN]
				( 
					[Filename]
					,[Type]
					,[Serial]
					,[Ledger]
					,[FASCurrency]
					,[Currency]
					,[BaseCurrency]
					,[Market]
					,[MarketCode]
					,[DummyField]
					,[RunDate]
					,[Serial2]
					,[PromptDate]
					,[StrikeShort]
					,[Strike]
					,[PutCall]
					,[Lots]
					,[Price]
					,[OpenClose]
					,[PostingAmount]
					,[IsMergedTrade]
					,[Series]
					,[FullSeries]
					,[Premium]
					,[IsCashSettlingOption]
					,[UTI]
				)
		VALUES
				( 
					@Filename,
					@Type,
					@Serial,
					@Ledger,
					@FASCurrency,
					@Currency,
					@BaseCurrency,
					@Market,	
					@MarketCode,
					@DummyField,
					@RunDate,
					@Serial2,
					@PromptDate,
					@StrikeShort,
					@Strike,
					@PutCall,
					@Lots,
					@Price,
					@OpenClose,
					@PostingAmount,
					@IsMergedTrade,
					@Series,
					@FullSeries,
					@Premium,
					@IsCashSettlingOption,
					@UTI
				)
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TaskType_Add]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_TaskType_Add](
	@Name NVARCHAR(100)
	,@Description NVARCHAR(400) = null
	,@Code NVARCHAR(50)
	,@IsActive bit = null
	,@AssemblyId int
    ,@TypeName NVARCHAR(50)
    ,@CreateUsername VARCHAR(50) = null
    ,@@TaskTypeId INT OUTPUT 
)
AS
SET NOCOUNT ON
	SELECT @IsActive = CAST(COALESCE(@IsActive, 0) AS BIT)
	
	INSERT INTO ib_TaskType (Code, Name, Description, IsActive, CreateUsername, UpdateUserName, AssemblyId, TypeName, CreateDate, UpdateDate)
	VALUES 
	(@Code, @Name, @Description, @IsActive, @CreateUsername, null, @AssemblyId, @TypeName, getdate(), null)
	
	SELECT 
		@@TaskTypeId = SCOPE_IDENTITY()
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_DataSource_Get_List]''
');

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Gets all records from the ib_DataSource table
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[ib_DataSource_Get_List]

AS


				
				SELECT
					[DataSourceId],
					[Code],
					[Name],
					[DefaultCurrencyId],
					[ProvidesVariation],
					[DefaultStrikePriceDivisor],
					[CreateDate],
					[CreateUsername],
					[UpdateDate],
					[UpdateUsername],
					[IncludeDetailAccountInTradeReconciliation],
					[UseTrxsForTradedOnDay]
				FROM
					[dbo].[ib_DataSource]
					
				SELECT @@ROWCOUNT
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[GMI_FUTM]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[GMI_FUTM]
(
[GMI_FUTMID] [int] NOT NULL IDENTITY(1, 1),
[ExchangeCode] [varchar] (2) NULL,
[FuturesCode] [varchar] (2) NULL,
[ContractType] [varchar] (1) NULL,
[ContractDescription] [varchar] (14) NULL,
[MultiplicationFactor] [varchar] (13) NULL,
[PriceEditCode] [varchar] (1) NULL,
[InstrumentTypeCode] [varchar] (1) NULL,
[MultiplierCode] [varchar] (1) NULL,
[CashSettledCode] [varchar] (1) NULL,
[OtherDescription] [varchar] (9) NULL,
[CurrencyCode] [varchar] (2) NULL,
[SubExchange] [varchar] (1) NULL,
[RecordDateAdded] [varchar] (6) NULL,
[RecordDateChange] [varchar] (6) NULL,
[ImportFileId] [int] NOT NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_GMI_FUTM_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_GMI_FUTM_CreateDate] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_GMI_FUTM] on [dbo].[GMI_FUTM]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[GMI_FUTM] ADD CONSTRAINT [PK_GMI_FUTM] PRIMARY KEY CLUSTERED  ([GMI_FUTMID])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[GMI_FUTM_Add]''
');

GO
EXECUTE ('
-- ==========================================================================
-- Author:		Lee Manifold
-- Create date: 15 Nov 2006
-- Description:	Insert into GMI_FUTM
--
-- History
--
-- Version		Date			Author		Desc
-- 1.1			30 Jan 2007		LM			Added extra field @RecordDataAdded	
-- ===========================================================================
CREATE PROCEDURE [dbo].[GMI_FUTM_Add]
	(
	@ExchangeCode			varchar(2) = Null,
	@FuturesCode			varchar(2) = Null,
	@ContractType			varchar(1) = Null,
	@ContractDescription	varchar(14) = Null,
	@MultiplicationFactor	varchar(13) = Null,
	@PriceEditCode			varchar(1) = Null,
	@InstrumentTypeCode		varchar(1) = Null,
	@MultiplierCode			varchar(1) = Null,
	@CashSettledCode		varchar(1) = Null,
	@OtherDescription		varchar(9) = Null,
	@CurrencyCode			varchar(2) = Null,
	@SubExchange			varchar(1) = Null,
	@RecordDateAdded		varchar(6) = Null,
	@RecordDateChange		varchar(6) = Null,
	@ImportFileId			int
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	INSERT INTO	[dbo].[GMI_FUTM]
				(
				[ImportFileId],
				[ExchangeCode],
				[FuturesCode],
				[ContractType],
				[ContractDescription],
				[MultiplicationFactor],
				[PriceEditCode],
				[InstrumentTypeCode],
				[MultiplierCode],
				[CashSettledCode],
				[OtherDescription],
				[CurrencyCode],
				[SubExchange],
				[RecordDateAdded],
				[RecordDateChange]
				)
     VALUES
			   (
				@ImportFileId,
				@ExchangeCode,
				@FuturesCode,
				@ContractType,
				@ContractDescription,
				@MultiplicationFactor,
				@PriceEditCode,
				@InstrumentTypeCode,
				@MultiplierCode,
				@CashSettledCode,
				@OtherDescription,
				@CurrencyCode,
				@SubExchange,
				@RecordDateAdded,
				@RecordDateChange
				)
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[RolfeNolan_HOSTTRN_V2_LoadStateChange]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[RolfeNolan_HOSTTRN_V2_LoadStateChange]
		@OldLoadState	TINYINT,
		@NewLoadState	TINYINT,
		@FileName VARCHAR(512) = NULL
AS
BEGIN
/*
Author		Date			Description
KevinP		05 Mar 2010		Added this SP for the new Host Tran loader... NB:- This is different as it accepts
							Filename as a parameter i.s.o RecordDate in all other SP''s, which evidentally never gets used!
*/


	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	UPDATE [dbo].[RolfeNolan_HOSTTRN] SET LoadState = @NewLoadState   
	WHERE LoadState= @OldLoadState
	  AND [FileName] = COALESCE(@FileName, [FileName])
	
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TaskType_Delete]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_TaskType_Delete]
	@taskTypeId int
AS
SET NOCOUNT ON
	DELETE FROM ib_TaskType WHERE TaskTypeId = @taskTypeId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_MatchCodeTolerance_Delete]''
');

GO
EXECUTE ('-- Stored Procedure

/*
----------------------------------------------------------------------------------------------------

-- 24 Feb 09 : ED created
-- Purpose: delete tolerance
*/

CREATE PROCEDURE [dbo].[ib_MatchCodeTolerance_Delete]
(
	@MatchCodeToleranceId int

)
AS
SET NOCOUNT ON
BEGIN
DELETE FROM ib_MatchCodeTolerance WHERE MatchCodeToleranceId=@MatchCodeToleranceId
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_PriceReport_GatherAdjustments]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_PriceReport_GatherAdjustments]
(
	@ReportId int,
	@PriceReportId int
)
AS
SET NOCOUNT ON

--  07 May 2010		ED		CREATE

DECLARE @Today		DATETIME
DECLARE @TemplateId	INT

-- get variables

SELECT @Today = pr.TodaysDate
	, @TemplateId = pr.TemplateId
FROM ib_PriceReport pr
WHERE pr.PriceReportId = @PriceReportId

-- internal OTE

UPDATE ib_PriceReportSummary
SET Internal_SettlementPrice = Internal_SettlementPrice+ISNULL(SettlementPriceAdjustment, 0)
FROM ib_PriceReportSummary prs
	JOIN ib_AdjustmentHeader a ON a.PriceId = prs.Internal_PriceId
WHERE prs.PriceReportId=@PriceReportId

-- external OTE

UPDATE ib_PriceReportSummary
SET External_SettlementPrice = External_SettlementPrice+ISNULL(SettlementPriceAdjustment, 0)
FROM ib_PriceReportSummary prs
	JOIN ib_AdjustmentHeader a ON a.PriceId = prs.External_PriceId
WHERE prs.PriceReportId=@PriceReportId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_PriceReport_BuildReport]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_PriceReport_BuildReport]
(
	@PriceReportId INT
	,@ReportId INT
)
AS
SET NOCOUNT ON
BEGIN

--	4 May 2010		amk		MBAL-15416: increase size of settlement price fields
--  5 May 2010      ED      Add some logic to populate notes
--  1 Jul 2010      ED      MBAL 15729 don''t get prices with InstrumentTypeCode = ''P'' - premium paid opt
DECLARE @TemplateId INT
DECLARE @AsOfDate DATETIME

SELECT @AsOfDate = TodaysDate,
		@TemplateId = TemplateId
FROM ib_PriceReport
WHERE PriceReportId = @PriceReportId

BEGIN TRY

DECLARE @Table TABLE(
	[PriceReportId]		INT             NOT NULL,
	[ExchangeId] INT NOT NULL,
	[ExchangeCode] nvarchar(50) NOT NULL,
	[CurrencyId] INT NOT NULL,
	[CurrencyCode] nvarchar(50) NOT NULL,
	[InstrumentId] INT NOT NULL,
	[InstrumentCode] nvarchar(50) NOT NULL,
	[ExpiryDay] INT NOT NULL,
	[ExpiryMonth] INT NOT NULL,
	[ExpiryYear] INT NOT NULL,
	[PutCall] nvarchar(5),
	[StrikePrice] DECIMAL(19,4),
	[Internal_DataSourceId] INT NULL,
	[Internal_DataSourceCode] nvarchar(50) NULL,
	[Internal_SettlementPrice] DECIMAL(24,10),
	[Internal_PriceId] INT,
	[External_DataSourceId] INT,
	[External_DataSourceCode] nvarchar(50),
	[External_SettlementPrice] DECIMAL(24,10),
	[External_PriceId] INT,
	[Variation] DECIMAL(24,10)
)
--Insert all possible values.
INSERT INTO @Table
SELECT @PriceReportId AS PriceReportId,
	   price.ExchangeId AS ExchangeId,
	   ex.Code AS ExchangeCode,
		price.CurrencyId AS CurrencyId,
		curr.Code AS CurrencyCode,
		price.InstrumentId AS InstrumentId,
		instr.Code AS InstrumentCode,
		price.ExpiryDay AS ExpiryDay,
		price.ExpiryMonth AS ExpiryMonth,
		price.ExpiryYear AS ExpiryYear,
		ISNULL(price.OptionTypeCode,'''') AS PutCall, -- I am doing this to prevent difference in record just because one is NULL and another is blank. This way they''re ALL blank.
		price.StrikePrice AS StrikePrice,
		NULL AS [Internal_DataSourceId],
		NULL AS [Internal_DataSourceCode],
		NULL AS [Internal_SettlementPrice],
		NULL AS [Internal_PriceId],
		NULL AS [External_DataSourceId],
		NULL AS [External_DataSourceCode],
		NULL AS [External_SettlementPrice],
		NULL AS [External_PriceId],
		NULL AS [Variation]
FROM ib_Price price
-- This sub select is to avoid the Firm Id causing duplicate DataSource Id''s appearing...
INNER JOIN (SELECT DISTINCT TemplateId, DataSourceId, InternalExternalCode
				FROM [dbo].[ib_TemplateCompare]
				WHERE TemplateId = @TemplateId
		) tc ON tc.DataSourceId = price.DataSourceId
INNER JOIN [dbo].[ib_DataSource] ds ON [tc].[DataSourceId] = [ds].[DataSourceId]
INNER JOIN ib_Exchange ex ON ex.ExchangeId = price.ExchangeId
INNER JOIN ib_Currency curr ON curr.CurrencyId = price.CurrencyId
INNER JOIN ib_Instrument instr ON instr.InstrumentId = price.InstrumentId
INNER JOIN ib_InstrumentType it ON instr.InstrumentTypeId=it.InstrumentTypeId
WHERE price.AsOfDate = @AsOfDate AND ex.RunBalanceReport=1 AND it.Code != ''P'' --don''t get premium paid instruments

--Update all possible Internal Values.
UPDATE @Table SET [Internal_DataSourceId] = price.DataSourceId,
		[Internal_DataSourceCode] = ds.Code,
		[Internal_SettlementPrice] = price.SettlementPrice,
		[Internal_PriceId] = price.PriceId
FROM @Table tmp
INNER JOIN ib_Price price ON tmp.PriceReportId = @PriceReportId
							AND tmp.ExchangeId = price.ExchangeId
							AND tmp.CurrencyId = price.CurrencyId
							AND tmp.InstrumentId = price.InstrumentId
							AND tmp.ExpiryYear = price.ExpiryYear 
							AND tmp.ExpiryMonth  = price.ExpiryMonth
							AND tmp.ExpiryDay = price.ExpiryDay
							AND ISNULL(tmp.StrikePrice,-1) = ISNULL(price.StrikePrice,-1)
							AND ISNULL(tmp.PutCall,'''') = ISNULL(price.OptionTypeCode,'''')
INNER JOIN (SELECT DISTINCT TemplateId, DataSourceId, InternalExternalCode
				FROM [dbo].[ib_TemplateCompare]
				WHERE TemplateId = @TemplateId
		) tc ON tc.DataSourceId = price.DataSourceId
INNER JOIN [dbo].[ib_DataSource] ds ON [tc].[DataSourceId] = [ds].[DataSourceId]
WHERE price.AsOfDate = @AsOfDate
AND tc.InternalExternalCode = ''I''


--Update all external values
UPDATE @Table SET [External_DataSourceId] = price.DataSourceId, 
				[External_DataSourceCode] = ds.Code,
		[External_SettlementPrice] = price.SettlementPrice,
		[External_PriceId] = price.PriceId
FROM ib_Price price 
LEFT JOIN @Table tmp ON tmp.PriceReportId = @PriceReportId
							AND tmp.ExchangeId = price.ExchangeId
							AND tmp.CurrencyId = price.CurrencyId
							AND tmp.InstrumentId = price.InstrumentId
							AND tmp.ExpiryYear = price.ExpiryYear 
							AND tmp.ExpiryMonth  = price.ExpiryMonth
							AND tmp.ExpiryDay = price.ExpiryDay
							AND ISNULL(tmp.StrikePrice,-1) = ISNULL(price.StrikePrice,-1)
							AND ISNULL(tmp.PutCall,'''') = ISNULL(price.OptionTypeCode,'''')
INNER JOIN (SELECT DISTINCT TemplateId, DataSourceId, InternalExternalCode 
				FROM [dbo].[ib_TemplateCompare]
				WHERE TemplateId = @TemplateId
		) tc ON tc.DataSourceId = price.DataSourceId
INNER JOIN [dbo].[ib_DataSource] ds ON [price].[DataSourceId] = [ds].[DataSourceId]
WHERE price.AsOfDate = @AsOfDate
AND tc.InternalExternalCode = ''E''

UPDATE @Table SET Variation = ISNULL(Internal_SettlementPrice,0) - ISNULL(External_SettlementPrice,0)


--

INSERT INTO ib_PriceReportSummary(
	[PriceReportId],
	[ExchangeId],
	[ExchangeCode],
	[CurrencyId],
	[CurrencyCode],
	[InstrumentId],
	[InstrumentCode],
	[ExpiryDay],
	[ExpiryMonth],
	[ExpiryYear],
	[PutCall],
	[StrikePrice],
	[Internal_DataSourceId],
	[Internal_DataSourceCode], 
	[Internal_SettlementPrice],
	[Internal_PriceId],
	[External_DataSourceId],
	[External_DataSourceCode], 
	[External_SettlementPrice],
	[External_PriceId],
	[Variation]
)
SELECT DISTINCT	tmp.[PriceReportId],
	tmp.[ExchangeId],
	tmp.[ExchangeCode],
	tmp.[CurrencyId],
	tmp.[CurrencyCode],
	tmp.[InstrumentId],
	tmp.[InstrumentCode],
	tmp.[ExpiryDay],
	tmp.[ExpiryMonth],
	tmp.[ExpiryYear],
	tmp.[PutCall],
	tmp.[StrikePrice],
	tmp.[Internal_DataSourceId],
	tmp.[Internal_DataSourceCode], 
	tmp.[Internal_SettlementPrice],
	tmp.[Internal_PriceId],
	tmp.[External_DataSourceId],
	tmp.[External_DataSourceCode], 
	tmp.[External_SettlementPrice],
	tmp.[External_PriceId],
	tmp.[Variation]
FROM @Table tmp
ORDER BY tmp.ExchangeCode, tmp.CurrencyCode, tmp.InstrumentCode, ExpiryYear, ExpiryMonth, ExpiryDay, PutCall, StrikePrice

--gather adjustments
EXEC [dbo].[ib_PriceReport_GatherAdjustments]  @ReportId, @PriceReportId

UPDATE ib_PriceReportSummary SET Variation = ISNULL(Internal_SettlementPrice,0) - ISNULL(External_SettlementPrice,0)
--build Notes

DECLARE @TemplateName VARCHAR(100)
SELECT @TemplateName = Description 
FROM ib_Template 
WHERE TemplateId = @TemplateId

DECLARE @Notes VARCHAR(255)
SET @Notes = @TemplateName
	+ '', '' + CONVERT(VARCHAR(10), @AsOfDate, 103) 

--update the report status
	UPDATE [dbo].[ib_Report]
		SET [Notes] = @Notes
		WHERE ReportId = @ReportId

END TRY
BEGIN CATCH
	DECLARE @ErrorMessage NVARCHAR(4000);
	SET @ErrorMessage = ERROR_MESSAGE()
	--update the error
	UPDATE [dbo].[ib_Report]
		SET Status = ''Error'',
			ErrorMessage = @ErrorMessage,
			ErrorDetails = ''The error was thrown in the '' + ERROR_PROCEDURE() + '' stored procedure at line '' + CAST(ERROR_LINE() as varchar(10)) + '' with severity '' + CAST(ERROR_SEVERITY() as varchar(10)) + '', state '' + CAST(ERROR_STATE() as varchar(10)) + '' and error number '' + Cast(ERROR_NUMBER() as varchar(10))
			, [Notes] = @Notes
	WHERE ReportId = @ReportId

END CATCH

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[GMI_FUTM_LoadStateChange]''
');

GO
EXECUTE ('


-- =============================================
-- Author:		Lee Manifold
-- Create date: 15 Nov 2006
-- Description:	Changes the LoadState of the GMI_FUTM type table
-- =============================================
CREATE PROCEDURE [dbo].[GMI_FUTM_LoadStateChange] 
	-- Add the parameters for the stored procedure here
	(
	@OldLoadState	TINYINT,
	@NewLoadState	TINYINT,
	@RecordDate		DATETIME = NULL,
	@ImportFileId	INT
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	-- Need to add code to handle RecordDate
	IF @RecordDate IS NOT NULL 
	BEGIN

		UPDATE [dbo].[GMI_FUTM] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState AND ImportFileId = @ImportFileId

	END

	IF @RecordDate IS NULL 
	BEGIN

		UPDATE [dbo].[GMI_FUTM] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState AND ImportFileId = @ImportFileId

	END


END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TaskType_GetAssemblies]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_TaskType_GetAssemblies]
AS
SET NOCOUNT ON
	SELECT
		AssemblyId,
		FullName,
		ShortName
	FROM
		ib_Assembly
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_DataSource_Insert]''
');

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Inserts a record into the ib_DataSource table
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[ib_DataSource_Insert]
(

	@DataSourceId int    OUTPUT,

	@Code varchar (100)  ,

	@Name varchar (100)  ,

	@DefaultCurrencyId int   ,

	@ProvidesVariation bit   ,

	@DefaultStrikePriceDivisor decimal (19, 6)  ,

	@CreateDate datetime   ,

	@CreateUsername varchar (50)  ,

	@UpdateDate datetime   ,

	@UpdateUsername varchar (50)  ,

	@IncludeDetailAccountInTradeReconciliation bit   ,

	@UseTrxsForTradedOnDay bit   
)
AS


				
				INSERT INTO [dbo].[ib_DataSource]
					(
					[Code]
					,[Name]
					,[DefaultCurrencyId]
					,[ProvidesVariation]
					,[DefaultStrikePriceDivisor]
					,[CreateDate]
					,[CreateUsername]
					,[UpdateDate]
					,[UpdateUsername]
					,[IncludeDetailAccountInTradeReconciliation]
					,[UseTrxsForTradedOnDay]
					)
				VALUES
					(
					@Code
					,@Name
					,@DefaultCurrencyId
					,@ProvidesVariation
					,@DefaultStrikePriceDivisor
					,@CreateDate
					,@CreateUsername
					,@UpdateDate
					,@UpdateUsername
					,@IncludeDetailAccountInTradeReconciliation
					,@UseTrxsForTradedOnDay
					)
				
				-- Get the identity value
				SET @DataSourceId = SCOPE_IDENTITY()
									
							
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Equity_Insert]''
');

GO
EXECUTE ('





/*
Created By:  McQuien
Date:  2006-11-24

Purpose:  Inserts record into Equity Table.

Modifications:
*/


CREATE PROC [dbo].[ib_Equity_Insert]

		   @EquityHeaderId int
		   ,@InternalExternalCode char(1)
           ,@OpenBalance decimal(19,6)
           ,@Commission decimal(19,6)
           ,@RealisedPL decimal(19,6)
           ,@OptionPremium decimal(19,6)
           ,@JournalCash decimal(19,6)
           ,@Adjustments decimal(19,6)
           ,@OpenTradeEquity decimal(19,6)
           ,@FuturesPL decimal(19,6)
           ,@OptionsPL decimal(19,6)
		   ,@Premium decimal(19,6)
		   ,@PendingCash decimal(19,6)
		   ,@OptionValDiff decimal(19,6)
		   ,@OpenOptValue decimal(19,6)
           ,@Collateral decimal(19,6)
           ,@InitialMargin decimal(19,6)
   

AS
SET NOCOUNT ON

INSERT INTO dbo.ib_Equity
			([EquityHeaderId]
           ,[InternalExternalCode]
           ,[OpenBalance]
           ,[Commission]
           ,[RealisedPL]
           ,[OptionPremium]
           ,[JournalCash]
           ,[Adjustments]
           ,[OpenTradeEquity]
           ,[FuturesPL]
           ,[OptionsPL]
		   ,[Premium]
		   ,[PendingCash]
		   ,[OptionValueDiff]
		   ,[OpenOptionValue]
           ,[Collateral]
           ,[InitialMargin])
     VALUES
           (@EquityHeaderId
		   ,@InternalExternalCode
           ,@OpenBalance
           ,@Commission
           ,@RealisedPL
           ,@OptionPremium
           ,@JournalCash
           ,@Adjustments
           ,@OpenTradeEquity
           ,@FuturesPL
           ,@OptionsPL
		   ,@Premium
           ,@PendingCash
		   ,@OptionValDiff
		   ,@OpenOptValue
           ,@Collateral
           ,@InitialMargin
)
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_ImbalanceReportSummary_GetDetailsPosition]''
');

GO
EXECUTE ('
CREATE Procedure [dbo].[ib_ImbalanceReportSummary_GetDetailsPosition]
(
		@ImbalanceReportSummaryId int
)
AS
SET NOCOUNT ON
/*
<details>
	<summary> Get the Position values for a Summary Record</summary>
	<created author="ED" Date="28 Apr 2009" />
	<changed ED - MBAL-11570 - OptionTypeCode AND StrikePrice may be null in position table />
	<changed KevinP - 10 Mar 2010 - MBAL-14919 - Changed to return Account Code rather than Name/>
	<changed KevinP - 11 Mar 2010 - MBAL-14924 - Changed SP to return a Long and Short Value i.s.o the Quantity value it was returning, and also summed them />
	<changed KevinP - 12 Mar 2010 - MBAL-14939 - Changed SP to not group by Market Value but to SUM Market Value instead />
</details>
*/
SELECT AsOfDate, d.[Name] Datasource, f.[Name] Firm, ISNULL(a.[Code],'''') Account, SUM(LongQuantity) AS LongQuantity, SUM(ShortQuantity) AS ShortQuantity, SUM(MarketValue) AS MarketValue 
		,ISNULL(c.Description,'''') Class
		,InternalExternalCode, d.DataSourceId, f.FirmId, a.AccountId
FROM [dbo].[ib_ImbalanceReportSummary] irs
	INNER JOIN ib_ImbalanceReport ir ON ir.ImbalanceReportId=irs.ImbalanceReportId
	INNER JOIN ib_ImbalanceReportDetail ird ON ird.ImbalanceReportId=ir.ImbalanceReportId
		AND ird.[ExchangeId]=irs.[ExchangeId]
		AND ird.[InstrumentId]=irs.[InstrumentId]
		AND ird.[CurrencyId]=irs.[CurrencyId]
		AND ird.[ExpiryMonth]=irs.[ExpiryMonth]
		AND ird.[ExpiryYear]=irs.[ExpiryYear]
		AND (ird.[ExpiryDay]=irs.[ExpiryDay] OR (ird.[ExpiryDay] IS NULL AND irs.[ExpiryDay] IS NULL))
		AND ISNULL(ird.[OptionTypeCode],'''')=ISNULL(irs.[OptionTypeCode],'''')
		AND ISNULL(ird.[StrikePrice],0)=ISNULL(irs.[StrikePrice],0)
	INNER JOIN ib_ImbalanceReportPhase2Trace IRP2T ON irs.Description=irp2t.Description 
		AND ird.ImbalanceReportDetailId=irp2t.ImbalanceReportDetailId
	INNER JOIN ib_Position p ON p.ExchangeId=ird.ExchangeId
		AND p.FirmId = ird.FirmId
		AND (p.AccountId=ird.AccountId OR (p.AccountId IS NULL AND ird.AccountId IS NULL))
		AND p.InstrumentId=ird.InstrumentId
		AND (p.ClassId=ird.ClassId OR (p.ClassId IS NULL AND ird.ClassId IS NULL))
		AND p.ExpiryYear=ird.ExpiryYear
		AND p.ExpiryMonth=ird.ExpiryMonth	
		AND (p.ExpiryDay=ird.ExpiryDay OR (p.ExpiryDay IS NULL AND ird.ExpiryDay IS NULL))
		AND ISNULL(p.OptionTypeCode,'''')=ISNULL(ird.OptionTypeCode,'''')
		AND p.CurrencyId=ird.CurrencyId
		AND ISNULL(p.StrikePrice,0)=ISNULL(ird.StrikePrice,0)
		AND (p.AsOfDate=ir.Today OR p.AsOfDate=ir.Yesterday)
	INNER JOIN ib_Template t ON t.TemplateId=ir.TemplateId
	INNER JOIN ib_TemplateCompare tc ON tc.TemplateId=t.TemplateId AND tc.DataSourceId=p.DataSourceId AND tc.FirmId=p.FirmId
	INNER JOIN ib_Datasource d ON d.DatasourceId=p.DataSourceId
	INNER JOIN ib_Firm f ON f.FirmId=p.FirmId
	LEFT JOIN ib_Account a ON a.AccountId=p.AccountId
	LEFT JOIN ib_Class c ON c.ClassId=p.ClassId
WHERE ImbalanceReportSummaryId=@ImbalanceReportSummaryId
GROUP BY AsOfDate, d.[Name], f.[Name], ISNULL(a.[Code],'''') ,ISNULL(c.Description,''''),InternalExternalCode, d.DataSourceId, f.FirmId, a.AccountId
ORDER BY AsOfDate, Datasource, Firm, Account, LongQuantity, ShortQuantity, MarketValue, d.DataSourceId, f.FirmId, a.AccountId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_PriceReportSummary_InsertPriceAdjustments]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_PriceReportSummary_InsertPriceAdjustments]
(
	@PriceReportSummaryId INT
	,@IsExternal BIT
	,@CreateUsername VARCHAR(50)
)
AS
SET NOCOUNT ON
	--	Insert price adjustments
	
	-- 07 May 2010		ED		creation
	-- 28 May 2010		ED		MBAL-15685: error message if no imbalance report records found to update
	-- 02 Jun 2010		ED		MBAL-15717: convert strikeprice to 0 in case it is null
	-- 06 Aug 2010		amk		1) Externalize calculate imbalance logic so it can be re-used
	--							2) MBAL-16405: only update imbalance report adjustments for the new adj header

BEGIN TRY
	BEGIN TRAN

	DECLARE @TemplateId INT
	DECLARE @PriceId INT
	DECLARE @SettlementPriceAdjustment DECIMAL(24,10)
	DECLARE @Tick DECIMAL(24,10)
	DECLARE @AsOfDate DATETIME
	DECLARE @ImbalanceReportId INT
	DECLARE @ImbalanceReportSummaryId INT
	DECLARE @AdjustmentTypeId INT
	DECLARE @AdjustmentHeaderId INT

	--get all needed data
	SELECT @TemplateId = TemplateId, @AsOfDate = TodaysDate 
	FROM ib_PriceReport pr
		INNER JOIN ib_PriceReportSummary prs ON pr.PriceReportId = prs.PriceReportId
	WHERE PriceReportSummaryId = @PriceReportSummaryId

	SELECT @PriceId = CASE WHEN @IsExternal = 1 THEN External_PriceId ELSE Internal_PriceId END
		, @SettlementPriceAdjustment = CASE 
				WHEN @IsExternal = 1 THEN Internal_SettlementPrice-External_SettlementPrice 
									 ELSE -1*(Internal_SettlementPrice-External_SettlementPrice)  
				END
	FROM ib_PriceReportSummary 
	WHERE PriceReportSummaryId = @PriceReportSummaryId

	SELECT @Tick = ISNULL(TickSize,1) 
	FROM ib_Instrument i 
		INNER JOIN ib_PriceReportSummary prs ON i.InstrumentId = prs.InstrumentId
	WHERE PriceReportSummaryId = @PriceReportSummaryId
			
	IF (@Tick = 0 ) SET @Tick = 1

	CREATE TABLE #temp_ImbalanceReportId(ImbalanceReportId INT)
	INSERT INTO #temp_ImbalanceReportId(ImbalanceReportId)
		EXEC [dbo].[ib_ImbalanceReport_GetLatestImbalanceReportIdByTemplateIdAndDate] @TemplateId, @AsOfDate

	SELECT  @ImbalanceReportId=ImbalanceReportId FROM #temp_ImbalanceReportId
	DROP TABLE #temp_ImbalanceReportId

	SELECT @AdjustmentTypeId = AdjustmentTypeId 
	FROM ib_AdjustmentType 
	WHERE Code = ''SP''

	--insert header as we need id for the adjustment rows
	INSERT INTO [dbo].[ib_AdjustmentHeader] ([AdjustmentTypeId],[PriceId],[SettlementPriceAdjustment],  [CreateDate], [CreateUsername])
		SELECT @AdjustmentTypeId, @PriceId, @SettlementPriceAdjustment, GETDATE(), @CreateUsername

	SET @AdjustmentHeaderId = SCOPE_IDENTITY()

	--find all matching imbalancereportsummary records for the selected price report summary 
	DECLARE @FoundItems INT
	DECLARE @FoundItemsIndividual INT
	SET @FoundItems = 0
	 
	DECLARE pos_cursor CURSOR FOR
	SELECT ImbalanceReportSummaryId 
	FROM ib_ImbalanceReportSummary irs
		INNER JOIN ib_PriceReportSummary prs 
			ON [prs].[ExchangeId] = [irs].[ExchangeId]
				AND [prs].[InstrumentId] = [irs].[InstrumentId]
				AND [prs].[ExpiryYear] = [irs].[ExpiryYear]
				AND [prs].[ExpiryMonth] = [irs].[ExpiryMonth]
				AND [prs].[ExpiryDay] = [irs].[ExpiryDay]
				AND (([prs].[PutCall] = [irs].[OptionTypeCode]) OR ([prs].[PutCall] IS NULL AND [irs].[OptionTypeCode] IS NULL))
				AND [prs].[CurrencyId] = [irs].[CurrencyId]
				AND ISNULL([prs].[StrikePrice],0) = ISNULL([irs].[StrikePrice],0)
	WHERE prs.PriceReportSummaryId = @PriceReportSummaryId 
		AND irs.ImbalanceReportId = @ImbalanceReportId
	
	OPEN pos_cursor
	
	FETCH NEXT FROM pos_cursor
	INTO @ImbalanceReportSummaryId
		
	-- Check @@FETCH_STATUS to see IF there are any more rows to fetch.
	WHILE @@FETCH_STATUS = 0
	BEGIN
		
		DECLARE @MatchCodeId INT
		
		SELECT @MatchCodeId = MatchCodeId 
		FROM ib_MatchCode 
		WHERE TemplateId = @TemplateId AND MatchCode IN 
			(SELECT Description FROM ib_ImbalanceReportSummary
				WHERE ImbalanceReportSummaryId = @ImbalanceReportSummaryId)
		
		--foreach ImbalanceReportSummary records get the positions that compose it
		IF OBJECT_ID(''tempdb..#tempPos'') IS NOT NULL 
		DROP TABLE #tempPos
                                                                                                                                                                
		CREATE TABLE #tempPos
		(
			ImbalanceReportSummaryId INT
			, AsOfDate		DATETIME
			, Datasource			VARCHAR(1000)
			, Firm		VARCHAR(1000)
			, Account	VARCHAR(1000)
			, LongQuantity		DECIMAL(24,10)
			, ShortQuantity	DECIMAL(24,10)
			, MarketValue		DECIMAL(24,10)
			, CLASS			VARCHAR(1000)
			, InternalExternalCode		VARCHAR(1)
			, DataSourceId INT 
			, FirmId INT 
			, AccountId INT 
		)
		INSERT INTO #tempPos(AsOfDate, Datasource, Firm, Account , LongQuantity	, ShortQuantity	, MarketValue, CLASS, InternalExternalCode, DataSourceId, FirmId, AccountId)
		EXEC [dbo].[ib_ImbalanceReportSummary_GetDetailsPosition] @ImbalanceReportSummaryId
		
		UPDATE #tempPos 
		SET ImbalanceReportSummaryId = @ImbalanceReportSummaryId
		
		--insert records into the adjustment table	
		INSERT INTO ib_Adjustment
			(TemplateId,ExchangeId,InstrumentId
			,InternalExternalCode
			,TradeDate
			,AdjustmentDate
			,Quantity
			,QuantityShort
			,QuantityLong
			,CurrencyId
			,ExpiryYear
			,ExpiryMonth
			,ExpiryDay
			,StrikePrice
			,TradePrice
			,SettlementPrice
			,OptionTypeCode
			,VALUE
			,MatchCodeId 
			,AdjustmentHeaderId
			,CreateUsername
			,IsBuy
			,DataSourceId
			,FirmId
			,AccountId)
		SELECT @TemplateId, ExchangeId, InstrumentId
			,InternalExternalCode
			,@AsOfDate
			,@AsOfDate
			,LongQuantity-ShortQuantity
			,ShortQuantity
			,LongQuantity
			,CurrencyId
			,ExpiryYear
			,ExpiryMonth
			,ExpiryDay
			,StrikePrice
			,0--TradePrice, decimal(24,10),>
			,0--<SettlementPrice, decimal(24,10),>
			,OptionTypeCode
			,@SettlementPriceAdjustment*@Tick*(LongQuantity-ShortQuantity)
			,@MatchCodeId
			,@AdjustmentHeaderId
			,@CreateUsername
			,1--<IsBuy, bit,>
			,DataSourceId
			,FirmId
			,AccountId
		FROM #tempPos tp 
			INNER JOIN ib_ImbalanceReportSummary irs 
				ON irs.ImbalanceReportSummaryId = tp.ImbalanceReportSummaryId
		WHERE tp.ImbalanceReportSummaryId = @ImbalanceReportSummaryId 
			AND AsOfDate = @AsOfDate
			AND (( @IsExternal = 1 AND InternalExternalCode = ''E'') 
				OR (@IsExternal = 0 AND InternalExternalCode = ''I''))
		
		SET @FoundItemsIndividual = @@ROWCOUNT 
		SET @FoundItems = @FoundItems + @FoundItemsIndividual
		
		IF @FoundItemsIndividual > 0
		BEGIN
			--update imbalance report summary to reflect the new adjustments
			EXEC [dbo].[ib_ImbalanceReport_GatherAdjustments]
				@ImbalanceReportId, @ImbalanceReportSummaryId, @AdjustmentHeaderId

			--calculate Lots and variation
			EXEC ib_ImbalanceReport_CalculateImbalance
				@ImbalanceReportId, @ImbalanceReportSummaryId
		END
		
		FETCH NEXT FROM pos_cursor
		INTO @ImbalanceReportSummaryId
	END
						
	CLOSE pos_cursor
	DEALLOCATE pos_cursor
		
	IF @FoundItems = 0 -- no imbalance row found, throw error message
		RAISERROR (''No imbalance report rows found to adjust.'', 16, 10)

	--update existing price report summary record
	IF (@IsExternal = 1)
		UPDATE ib_PriceReportSummary
		SET External_SettlementPrice = Internal_SettlementPrice
		WHERE PriceReportSummaryId = @PriceReportSummaryId
	ELSE
		UPDATE ib_PriceReportSummary
		SET Internal_SettlementPrice = External_SettlementPrice
		WHERE PriceReportSummaryId = @PriceReportSummaryId

	UPDATE ib_PriceReportSummary
	SET [Variation] = 0
	WHERE PriceReportSummaryId = @PriceReportSummaryId

	COMMIT TRAN
END TRY
BEGIN CATCH
	ROLLBACK TRAN
	EXEC [dbo].[sp_RethrowError]
END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[GMI_FUTM_Purge]''
');

GO
EXECUTE ('



-- =============================================
-- Author:		Lee Manifold
-- Create date: 15 Nov 2006
-- Description:	Deletes from all is_GMI_FUTM type files where the LoadState is 0
-- =============================================
CREATE PROCEDURE [dbo].[GMI_FUTM_Purge]
	(
	@LoadState		TINYINT = 0,
	@RecordDate		DATETIME = NULL,
	@ImportFileId	INT
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	
	--raiserror (''Lee doing specific raiserror in stored proc for testing'', 19, 1) with log
	
	IF @RecordDate IS NOT NULL 
	BEGIN
		--****Need to Add code here to factor in @RecordDate into table fields 
		DELETE FROM [dbo].[GMI_FUTM] WHERE LoadState= @LoadState AND ImportFileId = @ImportFileId

	END
	
	IF @RecordDate IS NULL 
	BEGIN
	
		DELETE FROM [dbo].[GMI_FUTM] WHERE LoadState= @LoadState AND ImportFileId = @ImportFileId

	END
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[sch_GetAllTasks]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[sch_GetAllTasks]
AS
SET NOCOUNT ON
	SELECT
		*
	FROM
		ib_ScheduledTask
	WHERE
		IsActive = 1
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TaskType_GetAssemblyById]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_TaskType_GetAssemblyById]
	@assemblyId int
AS
SET NOCOUNT ON
	SELECT
		*
	FROM
		vw_Assembly
	WHERE
		AssemblyId = @assemblyId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_MatchCodeTolerance_GetToleranceById]''
');

GO
EXECUTE ('-- Stored Procedure

/*
----------------------------------------------------------------------------------------------------

-- 24 Feb 09 : ED created
-- Purpose: get by id
--
-- Revision History
--
-- Konrad, 11.03.2009 - Added MatchCodeId output field for MatchCode Picker Control
--
*/

CREATE PROCEDURE [dbo].[ib_MatchCodeTolerance_GetToleranceById]
(
	@MatchCodeToleranceId int
)
AS
SET NOCOUNT ON
BEGIN
SELECT mct.[MatchCodeToleranceId] as MatchCodeToleranceId
      ,mct.[MatchCode] as MatchCode
	  ,mc.[MatchCodeId] as MatchCodeId
      ,mct.[Tolerance] as Tolerance
      ,mct.[CreateDate] as CreateDate
      ,mct.[CreateUsername] as CreateUsername
      ,mct.[UpdateDate] as UpdateDate
      ,mct.[UpdateUsername] as UpdateUsername
  FROM [dbo].[ib_MatchCodeTolerance] mct

	INNER JOIN [dbo].[ib_MatchCode] mc ON mc.[MatchCode] = mct.[MatchCode]		

  WHERE MatchCodeToleranceId=@MatchCodeToleranceId
	
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_DataSource_Update]''
');

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Updates a record in the ib_DataSource table
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[ib_DataSource_Update]
(

	@DataSourceId int   ,

	@Code varchar (100)  ,

	@Name varchar (100)  ,

	@DefaultCurrencyId int   ,

	@ProvidesVariation bit   ,

	@DefaultStrikePriceDivisor decimal (19, 6)  ,

	@CreateDate datetime   ,

	@CreateUsername varchar (50)  ,

	@UpdateDate datetime   ,

	@UpdateUsername varchar (50)  ,

	@IncludeDetailAccountInTradeReconciliation bit   ,

	@UseTrxsForTradedOnDay bit   
)
AS


				
				
				-- Modify the updatable columns
				UPDATE
					[dbo].[ib_DataSource]
				SET
					[Code] = @Code
					,[Name] = @Name
					,[DefaultCurrencyId] = @DefaultCurrencyId
					,[ProvidesVariation] = @ProvidesVariation
					,[DefaultStrikePriceDivisor] = @DefaultStrikePriceDivisor
					,[CreateDate] = @CreateDate
					,[CreateUsername] = @CreateUsername
					,[UpdateDate] = @UpdateDate
					,[UpdateUsername] = @UpdateUsername
					,[IncludeDetailAccountInTradeReconciliation] = @IncludeDetailAccountInTradeReconciliation
					,[UseTrxsForTradedOnDay] = @UseTrxsForTradedOnDay
				WHERE
[DataSourceId] = @DataSourceId 
				
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Equity_Reconciliation_Select]''
');

GO
EXECUTE ('






/*
Programmer:  Bruce McQuien

Purpose:  Retrieve fields for reconciliation form

Date:  24/11/2006
*/
CREATE PROC [dbo].[ib_Equity_Reconciliation_Select]
@EquityHeaderId int

AS
SET NOCOUNT ON

SELECT a.InternalExternalCode,
a.OpenBalance,
a.Commission,
a.RealisedPL,
a.OptionPremium,
a.JournalCash,
a.Adjustments,
a.OpenTradeEquity,
a.FuturesPL,
a.OptionsPL,
a.Premium,
a.PendingCash,
a.OptionValueDiff,	
a.OpenOptionValue,
a.Collateral,
a.InitialMargin,
b.Section1SignOffDate,
b.Section1SignOffUser,
b.Section2SignOffDate,
b.Section2SignOffUser, 
b.Section3SignOffDate,
b.Section3SignOffUser 
FROM ib_Equity a inner join
ib_EquityHeader b on
a.EquityHeaderId = b.EquityHeaderId
WHERE a.EquityHeaderId = @EquityHeaderId
ORDER BY InternalExternalCode Desc
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Instrument_GetByCode]''
');

GO
EXECUTE ('

-- =============================================
-- Author:		Konrad
-- Create date: 18 02 2009
-- Description:	Retrieve Instrument id

CREATE proc [dbo].[ib_Instrument_GetByCode]
	(
	@Code varchar(25),
	@InstrumentId int output
	)

AS
SET NOCOUNT ON

	SELECT	@InstrumentId = InstrumentId 

	FROM	[dbo].[ib_Instrument]
	
	WHERE	Code = @Code
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_RolfeNolan_Codes_Load]''
');

GO
EXECUTE ('
-- =============================================
-- Author:		Petru Konrad Bercea
-- Create date: 17.02.2009
-- Description:	This stored procedure pulls data from the RolfeNolan_Codes temp
-- table and inserts it into ib_Position
-- Whilst iterating through the records in RolfeNolan_Codes, all 
-- of these inserts are wrapped in a transaction so that any failure causes
-- the changes to not commit.
--
-- Revision History
--
-- 30.04.09         Konrad      Changed the DataSource Code to unique value RolfeNolan for all RolfeNolan data types
-- 09.01.2014		ED			EIB 25004 - remove importLog table and use Log table
-- =============================================
CREATE PROCEDURE [dbo].[ib_RolfeNolan_Codes_Load] 
	-- Add the parameters for the stored procedure here
	(
		@LocationPath	varchar(100) = NULL
	)
AS
SET NOCOUNT ON

CREATE TABLE #temp1
	(
		RolfeNolan_CodesID			int,
		MarketDescription			varchar(50),
		Market						varchar(25),
		LongDescription				varchar(50),
		FuturesTickValue			varchar(50),
		LotSize						varchar(50),
		Instrument					varchar(50)
	)

	INSERT INTO #temp1
	(
		RolfeNolan_CodesID,
		MarketDescription,
		Market,
		LongDescription,
		FuturesTickValue,
		LotSize,
		Instrument
	)
	SELECT 	
		RolfeNolan_CodesID,
		MarketDescription,
		Market,
		LongDescription,
		FuturesTickValue,
		LotSize,
		Instrument
	
	FROM	[dbo].[RolfeNolan_Codes]
	
	WHERE	LoadState = 1

	BEGIN TRAN T1

			DECLARE @RolfeNolan_CodesID		int
			DECLARE @MarketDescription		varchar(50)
			DECLARE @Market					varchar(25)
			DECLARE @LongDescription		varchar(50)
			DECLARE @LongDescriptionWType	varchar(50)
			DECLARE @FuturesTickValue		varchar(50)
			DECLARE @LotSize				varchar(50)
			DECLARE @Instrument				varchar(50)
			DECLARE @InstrumentWType		varchar(50)
			DECLARE @Started				bit

			SET @Started = 0

			DECLARE pos_cursor CURSOR FOR
			SELECT	RolfeNolan_CodesID,
					MarketDescription,
					Market,
					LongDescription,
					FuturesTickValue,
					LotSize,
					Instrument
	
			FROM	#temp1


			OPEN pos_cursor

			FETCH NEXT FROM pos_cursor
			INTO 
					@RolfeNolan_CodesID,
					@MarketDescription,
					@Market,
					@LongDescription,
					@FuturesTickValue,
					@LotSize,
					@Instrument

				-- Check @@FETCH_STATUS to see IF there are any more rows to fetch.
				WHILE @@FETCH_STATUS = 0
				BEGIN
					DECLARE 	@DataSourceCd			varchar(100)
					DECLARE 	@DataSourceId			int
					DECLARE 	@InstrumentId			int
					DECLARE 	@InstrumentTypeId		int
					DECLARE 	@ExchangeId				int
					DECLARE 	@DataSourceExchangeId	int
					DECLARE 	@RunBalanceReport		bit
					DECLARE 	@RunCloseOutReport		bit
					DECLARE		@IsApproved				bit
					DECLARE		@TickSizeDec			decimal(24,10)
					DECLARE		@LotSizeDec				decimal(24,10)
					-- Temporary variables
                    DECLARE 	@ReturnValue int, @Output int, @Output2 int
					DECLARE 	@Code varchar(100), @Code2 varchar(100)
					
				IF @Started = 0
				BEGIN
					-- COMMENT: specify datasource in proc.
					SET @DataSourceCd = ''RolfeNolan''
					IF @LocationPath IS NULL SET @LocationPath = @DataSourceCd
					
					EXEC @ReturnValue= [_ib_DataSource_GetByCodeForOutput] @DataSourceCd,@OutPut output, @Output2 output
					
					SET @DataSourceId = @Output
										
					SET @Started = 1
				END
		           
			-- Add Data to the ib_Exchange table
            SET @RunBalanceReport = 0
			SET @RunCloseOutReport = 0
			EXEC [dbo].[ib_Exchange_AddAsNeeded] @Market, @MarketDescription, @RunBalanceReport, @RunCloseOutReport, @ExchangeId output
			
			SET @Output = NULL

			-- Add Data to the ib_Instrument table

			SET @IsApproved = 0
			
			IF ISNUMERIC(@FuturesTickValue) > 0
					SET	@TickSizeDec = CONVERT(money,@FuturesTickValue)
			IF ISNUMERIC(@LotSize) > 0
					SET	@LotSizeDec = CONVERT(money,@LotSize)

			SET @InstrumentTypeId = NULL
			SET @InstrumentId = NULL
			SET @Output = NULL

			EXEC [dbo].[ib_InstrumentType_GetByCode] ''O'', @InstrumentTypeId output

			
			SET @InstrumentWType = ''O'' + @Instrument
			SET @LongDescriptionWType = @LongDescription + '' (O)''

			EXEC @ReturnValue= [ib_Instrument_GetByCode] @InstrumentWType,@InstrumentId output
			
			IF @InstrumentId IS NULL
			EXEC [dbo].[ib_Instrument_Add]
				@InstrumentTypeId,
				@InstrumentWType,
				@LongDescriptionWType,
				@IsApproved,
				@LotSizeDec,
				@TickSizeDec,
				NULL,
				NULL,	
				@InstrumentId output,
				NULL

			EXEC @ReturnValue= [ib_InstrumentDataSource_GetByCode] @DataSourceId,@InstrumentWType,@OutPut output,@OutPut2 output
			
			IF @OutPut IS NULL
			EXEC [dbo].[ib_InstrumentDataSource_Add]
				@InstrumentId,
				@DataSourceId,
				@InstrumentWType,
				NULL,
				1,
				NULL,
				NULL,
				@Output output
			
			SET @InstrumentTypeId = NULL
			SET @InstrumentId = NULL
			SET @Output = NULL
			EXEC [dbo].[ib_InstrumentType_GetByCode] ''F'', @InstrumentTypeId output

			SET @InstrumentWType = ''F'' + @Instrument
			SET @LongDescriptionWType = @LongDescription + '' (F)'' 

			EXEC @ReturnValue= [ib_Instrument_GetByCode] @InstrumentWType,@InstrumentId output
			
			IF @InstrumentId IS NULL
			EXEC [dbo].[ib_Instrument_Add]
				@InstrumentTypeId,
				@InstrumentWType,
				@LongDescriptionWType,
				@IsApproved,
				@LotSizeDec,
				@TickSizeDec,
				NULL,
				NULL,	
				@InstrumentId output,
				NULL

			EXEC @ReturnValue= [ib_InstrumentDataSource_GetByCode] @DataSourceId,@InstrumentWType,@OutPut output,@OutPut2 output
			
			IF @OutPut IS NULL
			EXEC [dbo].[ib_InstrumentDataSource_Add]
				@InstrumentId,
				@DataSourceId,
				@InstrumentWType,
				NULL,
				1,
				NULL,
				NULL,
				@Output output

			FETCH NEXT FROM pos_cursor
			INTO 
					@RolfeNolan_CodesID,
					@MarketDescription,
					@Market,
					@LongDescription,
					@FuturesTickValue,
					@LotSize,
					@Instrument

		END
			
			CLOSE pos_cursor
			DEALLOCATE pos_cursor

		COMMIT TRAN T1

		BEGIN TRAN T2

			SET @RolfeNolan_CodesID	= NULL
			SET @MarketDescription	= NULL
			SET @Market				= NULL
			SET @Started			= NULL

			SET @Started = 0

			DECLARE pos_cursor CURSOR FOR
			SELECT	RolfeNolan_CodesID,
					MarketDescription,
					Market
	
			FROM	#temp1


			OPEN pos_cursor

			FETCH NEXT FROM pos_cursor
			INTO 
					@RolfeNolan_CodesID,
					@MarketDescription,
					@Market
				

				-- Check @@FETCH_STATUS to see IF there are any more rows to fetch.
				WHILE @@FETCH_STATUS = 0
				BEGIN
					SET 	@DataSourceCd	= NULL
					SET		@ExchangeId	= NULL
					SET 	@DataSourceExchangeId	= NULL
					SET 	@RunBalanceReport		= NULL
					SET 	@RunCloseOutReport		= NULL
										
					-- Temporary variables
                    SET 	@ReturnValue = NULL 
					SET		@Output = NULL
					SET		@Output2 = NULL
					SET 	@Code = NULL
					
				IF @Started = 0
				BEGIN
					-- COMMENT: specify datasource in proc.
					SET @DataSourceCd = ''RolfeNolan''
					IF @LocationPath IS NULL SET @LocationPath = @DataSourceCd
					
					EXEC @ReturnValue= [_ib_DataSource_GetByCodeForOutput] @DataSourceCd,@OutPut output, @Output2 output
					
					SET @DataSourceId = @Output
										
					SET @Started = 1
				END
		           
			-- Add Data to the ib_Exchange table
            SET @RunBalanceReport = 0
			SET @RunCloseOutReport = 0
			EXEC [dbo].[ib_Exchange_AddAsNeeded] @Market, @MarketDescription, @RunBalanceReport, @RunCloseOutReport, @ExchangeId output
		
			
			SET @Output = NULL

			-- Check if the ExchangeIs is mapped to the Datasource already
			EXEC [dbo].[ib_DataSourceExchange_AddAsNeeded] @DataSourceId, @ExchangeId, @Market, @Output output

			SET @ExchangeId = NULL
		
			--flip processed flag in source table.
			UPDATE	[RolfeNolan_Codes]
			SET		[LoadState] = 2
			WHERE	[RolfeNolan_CodesID] = @RolfeNolan_CodesID
			AND		[LoadState] = 1

			FETCH NEXT FROM pos_cursor
			INTO 
					@RolfeNolan_CodesID,
					@MarketDescription,
					@Market

		END
			
			CLOSE pos_cursor
			DEALLOCATE pos_cursor

		COMMIT TRAN T2

	DROP TABLE #temp1
');

GO
EXECUTE ('PRINT N''Creating [dbo].[GMI_GNACMFF1]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[GMI_GNACMFF1]
(
[GMI_GNACMFF1ID] [int] NOT NULL IDENTITY(1, 1),
[RecordID] [varchar] (1) NULL,
[FirmID] [varchar] (1) NULL,
[OfficeNumber] [varchar] (3) NULL,
[AccountNumber] [varchar] (5) NULL,
[AccountClassCode] [varchar] (1) NULL,
[SubClassCode] [varchar] (1) NULL,
[ShortName] [varchar] (20) NULL,
[HalfTurnFutures] [varchar] (1) NULL,
[GroupSalesman] [varchar] (5) NULL,
[DateRecordWasOpened] [varchar] (9) NULL,
[DateRecordWasChanged] [varchar] (9) NULL,
[ImportFileId] [int] NOT NULL,
[Loadstate] [tinyint] NOT NULL CONSTRAINT [DF_GMI_GNACMFF1_Loadstate] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_GMI_GNACMFF1_CreateDate] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_GMI_GNACMFF1] on [dbo].[GMI_GNACMFF1]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[GMI_GNACMFF1] ADD CONSTRAINT [PK_GMI_GNACMFF1] PRIMARY KEY CLUSTERED  ([GMI_GNACMFF1ID])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[GMI_GNACMFF1_Add]''
');

GO
EXECUTE ('




-- =============================================
-- Author:		Lee Manifold
-- Create date: 29 Nov 2006
-- Description:	Insert into GMI_GNACMFF1
-- =============================================
CREATE PROCEDURE [dbo].[GMI_GNACMFF1_Add]
	(
    @ImportFileId			int
   ,@RecordID				varchar(1)
   ,@FirmID					varchar(1)
   ,@OfficeNumber			varchar(3)
   ,@AccountNumber			varchar(5)
   ,@AccountClassCode		varchar(1)
   ,@SubClassCode			varchar(1)
   ,@ShortName				varchar(20)
   ,@HalfTurnFutures		varchar(1)
   ,@GroupSalesman			varchar(5)
   ,@DateRecordWasOpened  	varchar(9)
   ,@DateRecordWasChanged	varchar(9)
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;


	INSERT INTO [dbo].[GMI_GNACMFF1]
           (
		    [ImportFileId]
		   ,[RecordID]
           ,[FirmID]
           ,[OfficeNumber]
           ,[AccountNumber]
           ,[AccountClassCode]
           ,[SubClassCode]
		   ,[ShortName]	
           ,[HalfTurnFutures]
		   ,[GroupSalesman]
           ,[DateRecordWasOpened]
           ,[DateRecordWasChanged]	
			)
     VALUES
           (
			@ImportFileId
		   ,@RecordID
           ,@FirmID
           ,@OfficeNumber
           ,@AccountNumber
           ,@AccountClassCode
           ,@SubClassCode
		   ,@ShortName	
           ,@HalfTurnFutures
		   ,@GroupSalesman
           ,@DateRecordWasOpened
           ,@DateRecordWasChanged
			)
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[sch_GetAssemblyBin]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[sch_GetAssemblyBin]
	@assemblyId int
AS
SET NOCOUNT ON
	SELECT Bin FROM ib_Assembly WHERE AssemblyId = @assemblyId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TaskType_GetTaskTypeById]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_TaskType_GetTaskTypeById]
	@taskTypeId int
AS
SET NOCOUNT ON
	SELECT 
		TT.*,
		A.ShortName AS AssemblyName
	FROM
		ib_TaskType TT
	INNER JOIN
		ib_Assembly A ON A.AssemblyId = TT.AssemblyId
	WHERE
		TT.TaskTypeId = @taskTypeId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_DataSource_Delete]''
');

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Deletes a record in the ib_DataSource table
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[ib_DataSource_Delete]
(

	@DataSourceId int   
)
AS


				DELETE FROM [dbo].[ib_DataSource] WITH (ROWLOCK) 
				WHERE
					[DataSourceId] = @DataSourceId
					
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Equity_Reconciliation_SelectInitialValues]''
');

GO
EXECUTE ('



/*
Programmer:  Bruce McQuien

Purpose:  Retrieve fields for reconciliation form

Date:  24/11/2006

History:
-------
10 Jan 2007		amk		Bug Fix: For postition temp, select from position, not trx

*/
CREATE PROC [dbo].[ib_Equity_Reconciliation_SelectInitialValues]
@EquityHeaderId int

AS
SET NOCOUNT ON

DECLARE @OpeningLedgerBalanceInt decimal
DECLARE @OpeningLedgerBalanceExt decimal
DECLARE @CommissionInt decimal
DECLARE @CommissionExt decimal
DECLARE @OpenTradeEquityInt decimal
DECLARE @OpenTradeEquityExt decimal 
DECLARE @OpenOptionValueInt decimal
DECLARE @OpenOptionValueExt decimal
DECLARE @CollateralValueInt decimal
DECLARE @CollateralValueExt decimal
DECLARE @InitialMarginInt decimal
DECLARE @InitialMarginExt decimal
DECLARE @RealisedPNLInt decimal
DECLARE @RealisedPNLExt decimal
DECLARE @OptionPremiumInt decimal
DECLARE @OptionPremiumExt decimal

-- process 1 of x: step 1 of 3 - match on template group

SELECT d.*
INTO #moneyTemp
FROM 
	ib_EquityHeader a
	inner join ib_templategroup b on
		a.templateid = b.templateid
		and a.templategroupdescription = b.description
	inner join ib_money d on
	    b.accountid = d.accountid
WHERE a.equityheaderid = @EquityHeaderId
	and d.asofdate = a.asofdate
	and d.currencyid = a.currencyid

SELECT d.*
INTO #TrxTemp
FROM 
	ib_EquityHeader a
	inner join ib_templategroup b on
		a.templateid = b.templateid
		and a.templategroupdescription = b.description
	inner join ib_Trx d on
	    b.accountid = d.accountid
WHERE a.equityheaderid = @EquityHeaderId
	and d.asofdate = a.asofdate
	and d.currencyid = a.currencyid
	and d.exchangeid = b.exchangeid


SELECT d.*
INTO #PositionTemp
FROM 
	ib_EquityHeader a
	inner join ib_templategroup b on
		a.templateid = b.templateid
		and a.templategroupdescription = b.description
	inner join ib_Position d on
	    b.accountid = d.accountid
WHERE a.equityheaderid = @EquityHeaderId
	and d.asofdate = a.asofdate
	and d.currencyid = a.currencyid
	and d.exchangeid = b.exchangeid


--note here adjustment contains a internalexternalcode
SELECT d.*
INTO #AdjustmentTemp
FROM 
	ib_EquityHeader a
	inner join ib_templategroup b on
		a.templateid = b.templateid
		and a.templategroupdescription = b.description
	inner join ib_Adjustment d on
	    --b.accountid = d.accountid
	d.tradedate = a.asofdate
	and d.currencyid = a.currencyid
	and d.exchangeid = b.exchangeid
WHERE a.equityheaderid = @EquityHeaderId
	



-- process 1 of x: step 2 of 3 - match on template compare

SELECT 
	@OpeningLedgerBalanceInt = sum(case when c.internalexternalcode = ''I'' then d.previousaccountbalance else 0 end),
	@OpeningLedgerBalanceExt= sum(case when c.internalexternalcode = ''E'' then d.previousaccountbalance else 0 end),
    @OpenOptionValueInt = sum(case when c.internalexternalcode = ''I'' then d.longoptionmarketvalue + d.shortoptionmarketvalue else 0 end),
	@OpenOptionValueExt = sum(case when c.internalexternalcode = ''E'' then d.longoptionmarketvalue + d.shortoptionmarketvalue else 0 end),
	@CollateralValueInt = sum(case when c.internalexternalcode = ''I'' then d.margincollateralvalue else 0 end),
	@CollateralValueExt = sum(case when c.internalexternalcode = ''E'' then d.margincollateralvalue else 0 end),
	@InitialMarginInt = sum(case when c.internalexternalcode = ''I'' then d.futuresinitialmargin + d.equitiesinitialmargin else 0 end),
	@InitialMarginExt = sum(case when c.internalexternalcode = ''E'' then d.futuresinitialmargin + d.equitiesinitialmargin else 0 end)
FROM 
	ib_EquityHeader a
	inner join ib_templatecompare c on
		a.templateid = c.templateid
	inner join #moneyTemp d on
		c.firmid = d.firmid 
		and c.datasourceid = d.datasourceid
WHERE a.equityheaderid = @EquityHeaderId

-- process 1 of x: step 3 of 3 - cleanup

drop table #moneyTemp


SELECT
	@CommissionInt = sum(case when c.internalexternalcode = ''I'' then e.amount else 0 end),
	@CommissionExt = sum(case when c.internalexternalcode = ''E'' then e.amount else 0 end)
FROM 
	ib_EquityHeader a
	inner join ib_templatecompare c on
	a.templateid = c.templateid
	inner join #TrxTemp d on
	c.firmid = d.firmid 
	and c.datasourceid = d.datasourceid
	inner join ib_fee e on
	d.trxid = e.trxid
	inner join ib_account f on
	--d.firmid = f.firmid McQuien commented out based on Krip''s suggestion.
	 d.accountid = f.accountid
	WHERE a.equityheaderid = @EquityHeaderId
	AND f.code in (''o'',''r'')

SELECT
	@RealisedPNLInt = sum(case when c.internalexternalcode = ''I'' and e.IsPandL = 1 then d.marketvalue else 0 end),
	@RealisedPNLExt = sum(case when c.internalexternalcode = ''E'' and e.IsPandL = 1 then d.marketvalue else 0 end),
	@OptionPremiumInt = sum(case when c.internalexternalcode = ''I'' and e.IsPandS = 1 then d.marketvalue else 0 end),
	@OptionPremiumExt = sum(case when c.internalexternalcode = ''E'' and e.IsPandS = 1 then d.marketvalue else 0 end)
FROM 
	ib_EquityHeader a
	inner join ib_templatecompare c on
	a.templateid = c.templateid
	inner join #TrxTemp d on
	c.firmid = d.firmid 
	and c.datasourceid = d.datasourceid
	inner join ib_TrxType e on
    d.datasourceid = e.datasourceid
	and d.trxtypecode = e.code
	WHERE a.equityheaderid = @EquityHeaderId



drop table #TrxTemp

SELECT 
	@OpenTradeEquityInt = sum(case when c.internalexternalcode = ''I'' then d.marketvalue else 0 end),
	@OpenTradeEquityExt = sum(case when c.internalexternalcode = ''E'' then d.marketvalue else 0 end)
FROM 
		ib_EquityHeader a
	inner join ib_templatecompare c on
		a.templateid = c.templateid
	inner join #PositionTemp d on
		c.firmid = d.firmid 
		and c.datasourceid = d.datasourceid
	inner join ib_datasource e on
		d.datasourceid = e.datasourceid
WHERE a.equityheaderid = @EquityHeaderId
	AND e.providesvariation = 0
	
drop table #PositionTemp


SELECT @OpeningLedgerBalanceInt as OpeningBalanceInt,
@OpeningLedgerBalanceExt as OpeningBalanceExt,
@CommissionInt as CommissionInt,
@CommissionExt as CommissionExt,
@OpenTradeEquityInt as OpenTradeEquityInt,
@OpenTradeEquityExt as OpenTradeEquityExt,
@OpenOptionValueInt as OpenOptionValueInt,
@OpenOptionValueExt as OpenOptionValueExt,
@CollateralValueInt as CollateralInt,
@CollateralValueExt as CollateralExt,
@InitialMarginInt as InitialMarginInt,
@InitialMarginExt as InitialMarginExt,
@RealisedPNLInt as RealisedPNLInt,
@RealisedPNLExt as RealisedPNLExt,
@OptionPremiumInt as OptionPremiumInt,
@OptionPremiumExt as OptionPremiumExt
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Rule_Add]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Rule_Add](
	@Name NVARCHAR(100)
	,@TemplateId int
    ,@RuleTypeId int
    ,@Description NVARCHAR(400) = null
    ,@IsEnabled bit = 0
    ,@MatchCountTypeId int = null
    
    ,@ToleranceTypeId int = null
    ,@Tolerance decimal(18,4) = null
    ,@CreateUsername VARCHAR(50) = null
    ,@@RuleId INT OUTPUT 
)
AS
SET NOCOUNT ON
	DECLARE @RuleNumber int
	SELECT @RuleTypeId = CASE WHEN @RuleTypeId IS NULL THEN (SELECT TOP 1 RuleTypeId FROM ib_RuleType) ELSE @RuleTypeId END
	SELECT @MatchCountTypeId = CASE WHEN @MatchCountTypeId IS NULL THEN (SELECT TOP 1 MatchCountTypeId FROM ib_MatchCountType) ELSE @MatchCountTypeId END
	SELECT @ToleranceTypeId = CASE WHEN @ToleranceTypeId IS NULL THEN (SELECT TOP 1 ToleranceTypeId FROM ib_ToleranceType) ELSE @ToleranceTypeId END
	SELECT @Tolerance = CASE WHEN @Tolerance IS NULL THEN 0 ELSE @Tolerance END
	SELECT @RuleNumber = ISNULL(MAX(RuleNumber),0) + 1 FROM ib_Rule
	SELECT @CreateUsername = CASE WHEN @CreateUsername IS NULL THEN USER_NAME() ELSE @CreateUsername END
	
	IF EXISTS (SELECT RuleId FROM ib_Rule WHERE Name = @Name)
	BEGIN
		RAISERROR (N''There is already another Rule with same name (%s). Please specify another name'', 16, 2, @Name)
	END
	ELSE
	BEGIN
	
		INSERT INTO ib_Rule (RuleTypeId, TemplateId, RuleNumber, Name, Description, MatchCountTypeId,
			ToleranceTypeId, Tolerance, IsEnabled, CreateDate, CreateUsername, UpdateDate, Updateusername)
		VALUES(@RuleTypeId, @TemplateId, @RuleNumber,
			@Name, @Description, @MatchCountTypeId,
			@ToleranceTypeId, @Tolerance, @IsEnabled, getdate(),@CreateUsername, getdate(),@CreateUsername)
		
		SELECT 
			@@RuleId = SCOPE_IDENTITY()
		
	END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Rule_Copy]''
');

GO
EXECUTE ('--SELECT * FROM ib_Rule

CREATE PROCEDURE [dbo].[ib_Rule_Copy]
	@RuleId int,
	@CreateUsername VARCHAR(50) = null,
	@CopyMatchCodes BIT = NULL,
	@@RuleId INT OUTPUT 
AS
SET NOCOUNT ON
--DECLARE @RuleId INT
--DECLARE @@RuleId INT
--SELECT @RuleId = RuleId FROM ib_Rule
--DECLARE @CreateUsername NVARCHAR(50)
--SET @CreateUsername= ''sa''

SELECT @CopyMatchCodes = COALESCE(@CopyMatchCodes, 1)

      DECLARE @RuleTypeId INT
      DECLARE @TemplateId INT      
      DECLARE @Name NVARCHAR(100)
      DECLARE @Description NVARCHAR(400)
      DECLARE @MatchCountTypeId INT
      DECLARE @ToleranceTypeId INT
      DECLARE @Tolerance DECIMAL
    
	SELECT 
	  @RuleId = [RuleId],
      @RuleTypeId = [RuleTypeId],
      @TemplateId = [TemplateId],
      @Name = [Name],
      @Description = [Description] + '' Copy'',
      @MatchCountTypeId = [MatchCountTypeId],
      @ToleranceTypeId = [ToleranceTypeId],
      @Tolerance = [Tolerance]
	FROM 
		[dbo].[ib_Rule]
	WHERE
		RuleId = @RuleId

	DECLARE @C INT
	SELECT @C = ISNULL(COUNT(RuleId),0) + 1 FROM ib_Rule 
	WHERE 
		[Name] = @Name
		OR
		[Name] LIKE @Name + '' (Copy %''
		
	SET @Name = @Name + '' (Copy ''+ CAST(@C AS NVARCHAR(10)) + '')''
	
	EXEC ib_Rule_Add @Name, @TemplateId, @RuleTypeId, @Description, 0, @MatchCountTypeId, @ToleranceTypeId, @Tolerance, @CreateUsername, @@RuleId OUTPUT
	
	--DECLARE @Description NVARCHAR(255)	
	DECLARE @InternalExternalCode CHAR(1)
	DECLARE @Field1Id int
	DECLARE @OperatorId int
	DECLARE @Field2Id int
	DECLARE @Value NVARCHAR(255)
	DECLARE @IsEnabled bit
	DECLARE @@ConditionId bit

	DECLARE ConditionsCursor CURSOR FORWARD_ONLY
	FOR
		SELECT 		
		  [Description]
		  ,[InternalExternalCode]
		  ,[Field1Id]
		  ,[OperatorId]
		  ,[Field2Id]
		  ,[Value]
		  ,[IsEnabled]      
		FROM [dbo].[ib_RuleCondition]
		WHERE RuleId = @RuleId

		OPEN ConditionsCursor

		FETCH NEXT FROM ConditionsCursor
		INTO @Description,@InternalExternalCode,@Field1Id,@OperatorId,@Field2Id,@Value,@IsEnabled

		WHILE @@FETCH_STATUS = 0
		BEGIN
			EXEC ib_RuleCondition_Add 
				@@RuleId
				,@InternalExternalCode
				,@Field1Id
				,@IsEnabled
				,@OperatorId 
				,@Value
				,@Field2Id
				,@Description
				,@CreateUsername
				,@@ConditionId OUTPUT
			FETCH NEXT FROM ConditionsCursor
				INTO @Description,@InternalExternalCode,@Field1Id,@OperatorId,@Field2Id,@Value,@IsEnabled
		END

	CLOSE ConditionsCursor;
	DEALLOCATE ConditionsCursor;
	
	IF (@CopyMatchCodes = 1)
	BEGIN
		DECLARE @MatchCodeId INT
		DECLARE MatchCodeCursor CURSOR FORWARD_ONLY
		FOR
			SELECT 		
			  MatchCodeId		  
			FROM	
				[dbo].[ib_RuleMatchCode]
			WHERE 
				RuleId = @RuleId

			OPEN MatchCodeCursor

			FETCH NEXT FROM MatchCodeCursor
			INTO @MatchCodeId

			WHILE @@FETCH_STATUS = 0
			BEGIN
				EXEC [dbo].[ib_Rule_ManageMatchCode] @ruleId=@@RuleId,@inlclude=1,@matchCodeId=@MatchCodeId
				
				FETCH NEXT FROM MatchCodeCursor
					INTO @MatchCodeId
			END

		CLOSE MatchCodeCursor;
		DEALLOCATE MatchCodeCursor;
	END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[GMI_GNACMFF1_LoadStateChange]''
');

GO
EXECUTE ('

-- =============================================
-- Author:		Lee Manifold
-- Create date: 29 Nov 2006
-- Description:	Changes the LoadState of the GMI_GNACMFF1 type table
-- =============================================
CREATE PROCEDURE [dbo].[GMI_GNACMFF1_LoadStateChange] 
	-- Add the parameters for the stored procedure here
	(
	@OldLoadState	TINYINT,
	@NewLoadState	TINYINT,
	@ImportFileId	INT,
	@RecordDate		DATETIME = NULL
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	-- Need to add code to handle RecordDate
	IF @RecordDate IS NOT NULL 
	BEGIN

		UPDATE [dbo].[GMI_GNACMFF1] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState AND ImportFileId = @ImportFileId

	END

	IF @RecordDate IS NULL 
	BEGIN

		UPDATE [dbo].[GMI_GNACMFF1] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState AND ImportFileId = @ImportFileId

	END


END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[sch_GetNextQueueItems]''
');

GO
EXECUTE ('--EXEC [sch_GetNextQueueItems]

CREATE PROCEDURE [dbo].[sch_GetNextQueueItems]
AS
SET NOCOUNT ON
	SELECT 
		QueueItemId
		,StatusId
		,S.Code AS StatusCode
		,DisplayMessage
		,ScheduledStart
		,I.SiteId
		,I.TemplateId
		,SI.Name AS SiteName
		,CASE
			WHEN ((I.SiteId IS NOT NULL) AND (I.TemplateId IS NULL)) THEN ''AllTemplates''
			ELSE T.Description
		END AS TemplateName
		,TaskTypeId
		,ScheduledTaskId
		--, AllTemplates
	FROM 
		ib_QueueItem I
	INNER JOIN
		ib_QueueStatus S ON S.QueueStatusId = I.StatusId 
	LEFT OUTER JOIN 
		ib_Site SI (NOLOCK) ON SI.SiteId = I.SiteId
	LEFT OUTER JOIN 
		ib_Template T (NOLOCK) ON T.TemplateId = I.TemplateId
	WHERE
		(S.Code = ''StandBy'' OR S.Code = ''Waiting'') AND ScheduledStart < getdate()
	ORDER BY
		StatusId, ScheduledStart
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TaskType_GetTaskTypes]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_TaskType_GetTaskTypes]
AS
SET NOCOUNT ON
	SELECT TaskTypeId, Name FROM ib_TaskType TT
		INNER JOIN vw_Assembly A ON A.AssemblyId = TT.AssemblyId
	WHERE 
		Code <> ''SCHD''
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_MatchCodeTolerance_GetTolerancesSortableAndPaginateCount]''
');

GO
EXECUTE ('-- Stored Procedure

/*
----------------------------------------------------------------------------------------------------

-- 24 Feb 09 : ED created
-- Purpose: get list count
*/

CREATE PROCEDURE [dbo].[ib_MatchCodeTolerance_GetTolerancesSortableAndPaginateCount]

AS
SET NOCOUNT ON
BEGIN
SELECT COUNT(MatchCodeToleranceId) FROM ib_MatchCodeTolerance
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_DataSource_GetByDefaultCurrencyId]''
');

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Select records from the ib_DataSource table through a foreign key
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[ib_DataSource_GetByDefaultCurrencyId]
(

	@DefaultCurrencyId int   
)
AS


				SET ANSI_NULLS ON
				
				SELECT
					[DataSourceId],
					[Code],
					[Name],
					[DefaultCurrencyId],
					[ProvidesVariation],
					[DefaultStrikePriceDivisor],
					[CreateDate],
					[CreateUsername],
					[UpdateDate],
					[UpdateUsername],
					[IncludeDetailAccountInTradeReconciliation],
					[UseTrxsForTradedOnDay]
				FROM
					[dbo].[ib_DataSource]
				WHERE
					[DefaultCurrencyId] = @DefaultCurrencyId
				
				SELECT @@ROWCOUNT
				SET ANSI_NULLS ON
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Equity_Update]''
');

GO
EXECUTE ('




/*
Created By:  McQuien
Date:  2006-11-27

Purpose:  Updates record from ib_Equity Table.

Modifications:
*/
CREATE PROC [dbo].[ib_Equity_Update]

@EquityHeaderId int,
@InternalExternalCode char(1),
@OpenBalance decimal(19,6),
@Commission decimal(19,6),
@RealisedPL decimal(19,6),
@OptionPremium decimal(19,6),
@JournalCash decimal(19,6),
@Adjustments decimal(19,6),
@OpenTradeEquity decimal(19,6),
@FuturesPL decimal(19,6),
@OptionsPL decimal(19,6),
@Premium decimal(19,6),
@PendingCash decimal(19,6),
@OptionValDiff decimal(19,6),
@OpenOptValue decimal(19,6),
@Collateral decimal(19,6),
@InitialMargin decimal(19,6)
AS
SET NOCOUNT ON

UPDATE [dbo].[ib_Equity]
   SET [OpenBalance] = @OpenBalance
      ,[Commission] = @Commission
      ,[RealisedPL] = @RealisedPL
      ,[OptionPremium] = @OptionPremium
      ,[JournalCash] = @JournalCash
      ,[Adjustments] = @Adjustments
      ,[OpenTradeEquity] = @OpenTradeEquity
      ,[FuturesPL] = @FuturesPL
      ,[OptionsPL] = @OptionsPL
	  ,[Premium] = @Premium
	  ,[PendingCash] = @PendingCash
      ,[OptionValueDiff] = @OptionValDiff
	  ,[OpenOptionValue]=@OpenOptValue
      ,[Collateral] = @Collateral
      ,[InitialMargin] = @InitialMargin 
 WHERE EquityHeaderId = @EquityHeaderId
 AND InternalExternalCode = @InternalExternalCode
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_SiteTemplate_Add]''
');

GO
SET ANSI_NULLS OFF

GO
EXECUTE (' /*
<details>
 <summary>Adds a site template into the ib_SiteTemplate table</summary>
 <created author="Laurentiu Macovei" Date="Sunday, 10 September 2006 12:26AM GMT" /> 
</details>
*/
CREATE PROCEDURE [dbo].[ib_SiteTemplate_Add]
(
	@SiteId int,
    @TemplateId int,
    @CreateUsername varchar(50),
	@@SiteTemplateId int OUTPUT
)
AS
SET NOCOUNT ON

BEGIN TRY
--check for duplicates 
EXEC [dbo].[ib_SiteTemplate_CheckForDuplicate] @SiteId, @TemplateId, -1

INSERT INTO [dbo].[ib_SiteTemplate]
           ([SiteId],
           [TemplateId],
           [CreateUsername])
     VALUES
           (@SiteId,
            @TemplateId,
            @CreateUsername)
SELECT @@SiteTemplateId = Scope_Identity()

END TRY
BEGIN CATCH
	EXEC [dbo].[sp_RethrowError]
END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[GMI_GNACMFF1_Purge]''
');

GO
SET ANSI_NULLS ON

GO
EXECUTE ('





-- =============================================
-- Author:		Lee Manifold
-- Create date: 29 Nov 2006
-- Description:	Deletes from all is_GMI_GNACMFF1 type files where the LoadState is 0
-- =============================================
CREATE PROCEDURE [dbo].[GMI_GNACMFF1_Purge]
	(
	@LoadState		TINYINT = 0,
	@ImportFileId	INT,
	@RecordDate		DATETIME = NULL
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	
	--raiserror (''Lee doing specific raiserror in stored proc for testing'', 19, 1) with log
	
	IF @RecordDate IS NOT NULL 
	BEGIN
		--****Need to Add code here to factor in @RecordDate into table fields 
		DELETE FROM [dbo].[GMI_GNACMFF1] WHERE LoadState= @LoadState AND ImportFileId = @ImportFileId

	END
	
	IF @RecordDate IS NULL 
	BEGIN
	
		DELETE FROM [dbo].[GMI_FUTM] WHERE LoadState= @LoadState AND ImportFileId = @ImportFileId

	END
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[sch_GetQueueItemByNextRun]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[sch_GetQueueItemByNextRun]
	@scheduledTaskId int
AS
SET NOCOUNT ON
	SELECT 
		I.*
		,S.Code AS StatusCode
	FROM
		ib_QueueItem I
	INNER JOIN
		ib_QueueStatus S ON S.QueueStatusId = I.StatusId
	WHERE
		ScheduledTaskId = @scheduledTaskId
		AND
		StatusId = 1
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Money_Add]''
');

GO
EXECUTE ('-- =============================================
-- Author:		Lee Manifold
-- Create date: 23 Nov 2006
-- Description:	Insert into the ib_Money table
-- Revision History:
-- =============================================

CREATE proc [dbo].[ib_Money_Add]
	(
	@DataSourceId			int,
	@AsOfDate				datetime,
	@FirmId					int,
	@OfficeCode				varchar(100),
	@AccountId				int,
	@CurrencyId				int,
	@LongOptionMarketValue	decimal(19,6),
	@ShortOptionMarketValue decimal(19,6),
	@FuturesInitialMargin	decimal(19,6),
	@EquitiesInitialMargin	decimal(19,6),
	@MarginCollateralValue	decimal(19,6),
	@PreviousAccountBalance decimal(19,6),
	@MoneyId				int Output
	)
AS
SET NOCOUNT ON

	DECLARE @AsOfDateNoTime datetime

	-- remove time part from AsOfDate
	SET @AsOfDateNoTime = CAST(CONVERT(CHAR(10), @AsOfDate, 101) AS DATETIME)

	INSERT INTO [dbo].[ib_Money]
           (
		    [DataSourceId]
           ,[AsOfDate]
           ,[FirmId]
           ,[OfficeCode]
           ,[AccountId]
           ,[CurrencyId]
           ,[LongOptionMarketValue]
           ,[ShortOptionMarketValue]
           ,[FuturesInitialMargin]
           ,[EquitiesInitialMargin]
           ,[MarginCollateralValue]
           ,[PreviousAccountBalance]
			)
     VALUES
           (
			@DataSourceId,
			@AsOfDateNoTime,
			@FirmId,
			@OfficeCode,
			@AccountId,
			@CurrencyId,
			@LongOptionMarketValue,
			@ShortOptionMarketValue,
			@FuturesInitialMargin,
			@EquitiesInitialMargin,
			@MarginCollateralValue,
			@PreviousAccountBalance
			)

	 SELECT @MoneyId = SCOPE_IDENTITY()
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_DataSource_GetByCode]''
');

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Select records from the ib_DataSource table through an index
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[ib_DataSource_GetByCode]
(

	@Code varchar (100)  
)
AS


				SELECT
					[DataSourceId],
					[Code],
					[Name],
					[DefaultCurrencyId],
					[ProvidesVariation],
					[DefaultStrikePriceDivisor],
					[CreateDate],
					[CreateUsername],
					[UpdateDate],
					[UpdateUsername],
					[IncludeDetailAccountInTradeReconciliation],
					[UseTrxsForTradedOnDay]
				FROM
					[dbo].[ib_DataSource]
				WHERE
					[Code] = @Code
				SELECT @@ROWCOUNT
					
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_EquityCash_Delete]''
');

GO
EXECUTE ('/*
Programmer:  Bruce McQuien	
Description:  Deletes cash records so that new ones can be inserted.
Date:  28/11/2006
*/
CREATE PROC [dbo].[ib_EquityCash_Delete]
@EquityHeaderId int

AS
SET NOCOUNT ON

DELETE FROM [dbo].[ib_EquityCash]
      WHERE EquityHeaderId=@EquityHeaderId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_SiteTemplate_Update]''
');

GO
SET ANSI_NULLS OFF

GO
EXECUTE (' /*
<details>
 <summary>Updates a site template from the ib_SiteTemplate table by its id</summary>
 <created author="Laurentiu Macovei" Date=" Sunday 10 September 2006 12:26AM GMT" /> 
</details>
*/
CREATE PROCEDURE [dbo].[ib_SiteTemplate_Update]
(
	@SiteTemplateId int,
	@SiteId int,
    @TemplateId int,
    @UpdateUsername varchar(50)
)
AS
SET NOCOUNT ON

BEGIN TRY
--check for duplicates 
EXEC [dbo].[ib_SiteTemplate_CheckForDuplicate] @SiteId, @TemplateId, @SiteTemplateId

UPDATE [dbo].[ib_SiteTemplate]
   SET [SiteId] = @SiteId,
       [TemplateId] = @TemplateId,
       [UpdateUsername] = @UpdateUsername
 WHERE SiteTemplateId = @SiteTemplateId

END TRY
BEGIN CATCH
	EXEC [dbo].[sp_RethrowError]
END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[GMI_MAST]''
');

GO
SET ANSI_NULLS ON

GO
EXECUTE ('CREATE TABLE [dbo].[GMI_MAST]
(
[GMIMastId] [int] NOT NULL IDENTITY(1, 1),
[ImportFileId] [int] NOT NULL,
[K00001] [varchar] (10) NULL,
[F00001] [varchar] (190) NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_GMIMast_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_GMIMast_CreateDate] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_GMIMast] on [dbo].[GMI_MAST]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[GMI_MAST] ADD CONSTRAINT [PK_GMIMast] PRIMARY KEY CLUSTERED  ([GMIMastId])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[GMI_MAST_Add]''
');

GO
EXECUTE ('

-- =============================================
-- Author:		Lee Manifold
-- Create date: 30 Nov 2006
-- Description:	Insert into GMI_MAST
-- =============================================
CREATE PROCEDURE [dbo].[GMI_MAST_Add]
	(
		@K00001			varchar(10)		= NULL,
		@F00001			varchar(190)	= NULL,
		@ImportFileId	int
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	INSERT INTO [dbo].[GMI_MAST]
           (
			[ImportFileId]
		   ,[K00001]
           ,[F00001]
			)
     VALUES
           (
			@ImportFileId
		   ,@K00001
           ,@F00001
			)
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[sch_GetScheduledTaskById]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[sch_GetScheduledTaskById]
	@scheduledTaskId int
AS
SET NOCOUNT ON
	SELECT 
		* 
	FROM 
		ib_ScheduledTask
	WHERE	
		ScheduledTaskId = @scheduledTaskId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_DataSource_GetByName]''
');

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Select records from the ib_DataSource table through an index
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[ib_DataSource_GetByName]
(

	@Name varchar (100)  
)
AS


				SELECT
					[DataSourceId],
					[Code],
					[Name],
					[DefaultCurrencyId],
					[ProvidesVariation],
					[DefaultStrikePriceDivisor],
					[CreateDate],
					[CreateUsername],
					[UpdateDate],
					[UpdateUsername],
					[IncludeDetailAccountInTradeReconciliation],
					[UseTrxsForTradedOnDay]
				FROM
					[dbo].[ib_DataSource]
				WHERE
					[Name] = @Name
				SELECT @@ROWCOUNT
					
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_EquityCash_Insert]''
');

GO
EXECUTE ('/*
Programmer:  Bruce McQuien	
Description:  Inserts cash records to ib_equitycash.
Date:  28/11/2006
*/

CREATE PROC [dbo].[ib_EquityCash_Insert]
	@EquityHeaderId int,
    @InternalExternalCode char(1),
	@Description varchar(50),
	@Amount decimal

AS
SET NOCOUNT ON

INSERT INTO ib_EquityCash
			([EquityHeaderId]
           ,[InternalExternalCode]
           ,[Amount]
           ,[Description])
     VALUES
           (@EquityHeaderId
           ,@InternalExternalCode
           ,@Amount
           ,@Description)
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_SiteUser_Add]''
');

GO
EXECUTE (' /*
<details>
 <summary>Adds a Site User into the ib_SiteUser table</summary>
 <created author="laurentiu.macovei" date="Tue, 03 Oct 2006 17:48:27 GMT"/>
</details>
*/
CREATE PROCEDURE [dbo].[ib_SiteUser_Add]
(
	@SiteId int,
    @UserId uniqueidentifier,
	@IsPrimary bit,
    @CreateUsername varchar(50),
	@@SiteUserId int OUTPUT
)
AS
SET NOCOUNT ON

BEGIN TRY
--check for duplicates 
EXEC [dbo].[ib_SiteUser_CheckForDuplicate] @SiteId, @UserId, -1

INSERT INTO [dbo].[ib_SiteUser]
           ([SiteId],
           [UserId],
           [IsPrimary],
           [CreateUsername])
     VALUES
           (@SiteId,
            @UserId,
            @IsPrimary,
            @CreateUsername)
SELECT @@SiteUserId = Scope_Identity()

END TRY
BEGIN CATCH
	EXEC [dbo].[sp_RethrowError]
END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[GMI_MAST_LoadStateChange]''
');

GO
EXECUTE ('



-- =============================================
-- Author:		Lee Manifold
-- Create date: 30 Nov 2006
-- Description:	Changes the LoadState of the GMI_MAST type table
-- =============================================
CREATE PROCEDURE [dbo].[GMI_MAST_LoadStateChange] 
	-- Add the parameters for the stored procedure here
	(
	@OldLoadState	TINYINT,
	@NewLoadState	TINYINT,
	@RecordDate		DATETIME = NULL,
	@ImportFileId	INT
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	-- Need to add code to handle RecordDate
	IF @RecordDate IS NOT NULL 
	BEGIN

		UPDATE [dbo].[GMI_MAST] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState AND ImportFileId = @ImportFileId

	END

	IF @RecordDate IS NULL 
	BEGIN

		UPDATE [dbo].[GMI_MAST] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState AND ImportFileId = @ImportFileId

	END


END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[sch_GetTaskTypeById]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[sch_GetTaskTypeById]
	@taskTypeId int
AS
SET NOCOUNT ON

	SELECT
		TT.*
		,A.FullName AS AssemblyName
		,A.IsStored
	FROM
		ib_TaskType TT
	INNER JOIN vw_Assembly A ON A.AssemblyId = TT.AssemblyId
	
	WHERE
		TaskTypeId = @taskTypeId
');

GO
EXECUTE ('PRINT N''Creating [admin].[PurgeData_CloseoutReports]''
');

GO
EXECUTE ('CREATE PROCEDURE [admin].[PurgeData_CloseoutReports]

AS
-- =============================================
-- Author:		ED
-- Create date: 04 Jul 2014
-- Description:	purge data
-- 04 Jul 2014   ED   Create
-- =============================================
BEGIN
	SET NOCOUNT ON;

	declare @end datetime

	set @end = DATEADD(d, -7, GETDATE())

	---------------------------------------------------------------------
	---------------------------------------------------------------------
	--Purge Closeout Reports---------------------------------------------
	---------------------------------------------------------------------
	---------------------------------------------------------------------
	begin transaction

	--delete from child where parent''s createdate is older than x days
	delete ib_closeoutreportdetail
	from ib_closeoutreportdetail crd, ib_closeoutreport cr
	where crd.closeoutreportid = cr.closeoutreportid
		and cr.createdate < @end

	--delete from child where parent''s createdate is older than x days
	delete ib_closeoutreportsummary
	from ib_closeoutreportsummary crs, ib_closeoutreport cr
	where crs.closeoutreportid = cr.closeoutreportid
		and cr.createdate < @end

	delete from ib_closeoutreport
	where createdate < @end

	commit transaction

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TaskType_Update]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_TaskType_Update]
	@taskTypeId INT,
	@name NVARCHAR(50) = NULL,
	@description NVARCHAR(200) = NULL,
	@isActive BIT = NULL,
	@updateUsername NVARCHAR(50)
AS
SET NOCOUNT ON
	SELECT
		@name = COALESCE(@name,Name),
		@description = COALESCE(@description,Description),
		@isActive = COALESCE(@isActive,IsActive)
	FROM
		ib_TaskType
	WHERE
		TaskTypeId = @taskTypeId 
	
	UPDATE
		ib_TaskType
	SET
		Name = @name,
		Description = @description,
		IsActive = @isActive,
		UpdateUsername = @updateUsername
	WHERE
		TaskTypeId = @taskTypeId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_DataSource_GetByDataSourceId]''
');

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Select records from the ib_DataSource table through an index
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[ib_DataSource_GetByDataSourceId]
(

	@DataSourceId int   
)
AS


				SELECT
					[DataSourceId],
					[Code],
					[Name],
					[DefaultCurrencyId],
					[ProvidesVariation],
					[DefaultStrikePriceDivisor],
					[CreateDate],
					[CreateUsername],
					[UpdateDate],
					[UpdateUsername],
					[IncludeDetailAccountInTradeReconciliation],
					[UseTrxsForTradedOnDay]
				FROM
					[dbo].[ib_DataSource]
				WHERE
					[DataSourceId] = @DataSourceId
				SELECT @@ROWCOUNT
					
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_EquityCash_Select]''
');

GO
EXECUTE ('/*
Programmer:  Bruce McQuien	
Description:  Selects cash records from ib_equitycash.
Date:  28/11/2006
*/

CREATE PROC [dbo].[ib_EquityCash_Select]
@EquityHeaderId int,
@InternalExternalCode char(1)

AS
SET NOCOUNT ON


SELECT [Description]
      ,[Amount]
	  ,[InternalExternalCode] 
FROM [dbo].[ib_EquityCash]
WHERE EquityHeaderId = @EquityHeaderId
AND InternalExternalCode = @InternalExternalCode
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_SiteUser_Update]''
');

GO
EXECUTE (' /*
<details>
 <summary>Updates a Site User from the ib_SiteUser table by its id</summary>
 <created author="laurentiu.macovei" date="Tue, 03 Oct 2006 17:50:36 GMT"/>
</details>
*/
CREATE PROCEDURE [dbo].[ib_SiteUser_Update]
(
	@SiteUserId int,
	@SiteId int,
    @UserId uniqueidentifier,
    @IsPrimary bit,
    @UpdateUsername varchar(50)
)
AS
SET NOCOUNT ON

BEGIN TRY
--check for duplicates 
EXEC [dbo].[ib_SiteUser_CheckForDuplicate] @SiteId, @UserId, @SiteUserId

UPDATE [dbo].[ib_SiteUser]
   SET [SiteId] = @SiteId,
       [UserId] = @UserId,
	   [IsPrimary] = @IsPrimary,
       [UpdateUsername] = @UpdateUsername
 WHERE SiteUserId = @SiteUserId

END TRY
BEGIN CATCH
	EXEC [dbo].[sp_RethrowError]
END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[GMI_MAST_Purge]''
');

GO
EXECUTE ('-- =============================================
-- Author:		Lee Manifold
-- Create date: 30 Nov 2006
-- Description:	Deletes from all is_GMI_GNACMFF1 type files where the LoadState is 0
-- =============================================
CREATE PROCEDURE [dbo].[GMI_MAST_Purge]
	(
	@LoadState		TINYINT = 0,
	@RecordDate		DATETIME = NULL,
	@ImportFileId	INT
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	
	--raiserror (''Lee doing specific raiserror in stored proc for testing'', 19, 1) with log
	
	IF @RecordDate IS NOT NULL 
	BEGIN
		--****Need to Add code here to factor in @RecordDate into table fields 
		DELETE FROM [dbo].[GMI_MAST] WHERE LoadState= @LoadState AND ImportFileId = @ImportFileId

	END
	
	IF @RecordDate IS NULL 
	BEGIN
	
		DELETE FROM [dbo].[GMI_MAST] WHERE LoadState= @LoadState AND ImportFileId = @ImportFileId

	END
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[sch_UpdateQueueItem]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[sch_UpdateQueueItem]
	@queueItemId int, 
	@statusId int,
	@displayMessage NVARCHAR(50) = NULL,
	@errorMessage NVARCHAR(200) = NULL,
	@completedOn DateTime = NULL,
	@scheduledStart DateTime = NULL,
	@updateUsername NVARCHAR(50) = NULL
AS
SET NOCOUNT ON
	SELECT @updateUsername = COALESCE(@updateUsername, USER_NAME())
	SELECT 
		@displayMessage = COALESCE (@displayMessage,DisplayMessage)
		, @errorMessage = COALESCE(@errorMessage,ErrorMessage)
		,@completedOn = COALESCE(@completedOn, CompletedOn)
		,@scheduledStart = COALESCE(@scheduledStart , ScheduledStart)
	FROM 
		ib_QueueItem 
	WHERE 
		QueueItemId = @queueItemId
	
	UPDATE
		ib_QueueItem
	SET
		DisplayMessage = @displayMessage,
		ErrorMessage = @errorMessage,
		StatusId = @statusId,
		CompletedOn = @completedOn
		,ScheduledStart = @scheduledStart
		,UpdateUsername = @updateUsername
		,UpdateDate = getdate()		
	WHERE
		QueueItemId = @queueItemId
');

GO
EXECUTE ('PRINT N''Creating [admin].[PurgeData_ImbalanceReports]''
');

GO
EXECUTE ('CREATE PROCEDURE [admin].[PurgeData_ImbalanceReports]

AS
-- =============================================
-- Author:		ED
-- Create date: 04 Jul 2014
-- Description:	purge data
-- 04 Jul 2014   ED   Create
-- =============================================
BEGIN
	SET NOCOUNT ON;

	declare @end datetime

	set @end = DATEADD(d, -7, GETDATE())

	---------------------------------------------------------------------
	---------------------------------------------------------------------
	--Purge Imbalance Reports--------------------------------------------
	---------------------------------------------------------------------
	---------------------------------------------------------------------
	begin transaction

	--delete from child where parent''s createdate is older than x days
	delete ib_imbalancereportdetail
	from ib_imbalancereportdetail ird, ib_imbalancereport ir
	where ird.imbalancereportid = ir.imbalancereportid
		and ir.createdate < @end

	--delete from child where parent''s createdate is older than x days
	delete ib_imbalancereportsummary
	from ib_imbalancereportsummary irs, ib_imbalancereport ir
	where irs.imbalancereportid = ir.imbalancereportid
		and ir.createdate < @end

	--there''s no declared FK so can delete the trace records after parent deleted
	delete from ib_imbalancereportphase2trace
	where imbalancereportdetailid not in (select imbalancereportdetailid from ib_imbalancereportdetail)

	--delete from child where parent''s createdate is older than x days
	delete ib_cashreportsummary
	from ib_cashreportsummary crs, ib_imbalancereport ir
	where crs.imbalancereportid = ir.imbalancereportid
		and ir.createdate < @end

	--delete from child where parent''s createdate is older than x days
	delete ib_cashreportdetail
	from ib_cashreportdetail crd, ib_cashreport cr, ib_imbalancereport ir
	where crd.cashreportid = cr.cashreportid
		and cr.imbalancereportid = ir.imbalancereportid
		and ir.createdate < @end

	--delete from child where parent''s createdate is older than x days
	delete ib_cashreport
	from ib_cashreport cr, ib_imbalancereport ir
	where cr.imbalancereportid = ir.imbalancereportid
		and ir.createdate < @end

	--now delete the parent
	delete from ib_imbalancereport
	where createdate < @end

	commit transaction

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Template_CheckForDuplicate]''
');

GO
EXECUTE ('  /*
<details>
 <summary>
	Checks for the duplicate Templates with same TypeCode or Description. 
</summary>
   <created author="laurentiu.macovei" date="Sat, 30 Sep 2006 05:40:06am GMT"/>
</details>
*/
CREATE PROCEDURE [dbo].[ib_Template_CheckForDuplicate]
@TypeCode varchar(100),
@Description varchar(100),
@TemplateId int
AS
SET NOCOUNT ON

DECLARE @Count int

SELECT TOP 1 @Count = 1
	FROM [dbo].[ib_Template] c
	WHERE TypeCode = @TypeCode
		AND Description = @Description
		AND TemplateID <> @TemplateId

IF @Count > 0
	RAISERROR (N''There is already another Template with same Type Code (%s). Please specify other TypeCode!'', 11, 1, @TypeCode)
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Nostro_DeleteNostroRecord]''
');

GO
EXECUTE ('/*
Author			Date			Description
KevinP			25 Sep 2009		Created for the Nostro Split.
*/

CREATE PROC [dbo].[ib_Nostro_DeleteNostroRecord]
	@NostroId INT
AS
SET NOCOUNT ON

DELETE FROM  [dbo].[ib_Nostro]
WHERE NostroId = @NostroId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ReceiveLocation_Get_List]''
');

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Gets all records from the ReceiveLocation table
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[ReceiveLocation_Get_List]

AS


				
				SELECT
					[ReceiveLocationSysId],
					[ReceiveLocationName],
					[PackageSysId],
					[FileMask],
					[InputFolder],
					[OutputFolder],
					[ErrorFolder],
					[DataSourceId],
					[Priority],
					[IsActive],
					[IsRunning],
					[CreateDateTimeUtc],
					[CreateUsername],
					[UpdateDateTimeUtc],
					[UpdateUsername],
					[DeleteDateTimeUtc],
					[DeleteUsername]
				FROM
					[dbo].[ReceiveLocation]
					
				SELECT @@ROWCOUNT
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_EquityHeader_Delete]''
');

GO
EXECUTE ('
/*
Created By:  McQuien
Date:  2006-11-22

Purpose:  Deletes records into ib_equityheader
--29/11/06  McQuien added other delete stmts and transaction processing.

Modifications:
*/

CREATE PROC [dbo].[ib_EquityHeader_Delete]
@EquityHeaderId int

as
SET NOCOUNT ON

BEGIN TRAN Tran1
DELETE from ib_EquityCash
WHERE EquityHeaderId = @EquityHeaderId

DELETE from ib_Equity
WHERE EquityHeaderId = @EquityHeaderId

DELETE from ib_EquityHeader
WHERE EquityHeaderId = @EquityHeaderId
Commit TRAN Tran1
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Template_Add]''
');

GO
EXECUTE (' /*
<details>
 <summary>Adds a template into the ib_Template table</summary>
 <created author="Laurentiu Macovei" Date="Wednesday, 6 September 2006 11:46PM GMT" /> 
</details>
*/
CREATE PROCEDURE [dbo].[ib_Template_Add]
(
	@TypeCode varchar(50),
    @Description varchar(100),
    @CreateUsername varchar(50),
	@@TemplateId int OUTPUT
)
AS
SET NOCOUNT ON

BEGIN TRY
--check for duplicates 
EXEC [dbo].[ib_Template_CheckForDuplicate] @TypeCode, @Description, -1


INSERT INTO [dbo].[ib_Template]
           ([TypeCode]
           ,[Description]
           ,[CreateUsername])
     VALUES
           (@TypeCode, 
           @Description,
           @CreateUsername)

SELECT @@TemplateId = Scope_Identity()

END TRY
BEGIN CATCH
	EXEC [dbo].[sp_RethrowError]
END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[GMI_MNYF1]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[GMI_MNYF1]
(
[GMI_MNYF1ID] [int] NOT NULL IDENTITY(1, 1),
[RecordID] [varchar] (1) NULL,
[FirmID] [varchar] (1) NULL,
[OfficeNumber] [varchar] (3) NULL,
[AccountNumber] [varchar] (5) NULL,
[AccountTypeCurrencyCodeSymbol] [varchar] (3) NULL,
[ProductCurrencyCode] [varchar] (2) NULL,
[LngOptMktValue] [varchar] (8) NULL,
[ShtOptMktValue] [varchar] (8) NULL,
[FuturesInitMarginReqt] [varchar] (8) NULL,
[FuturesOpenTradeEquity] [varchar] (8) NULL,
[EquitiesInitMarginReqt] [varchar] (8) NULL,
[MarginCollateralValue] [varchar] (8) NULL,
[PreviousAccountBalance] [varchar] (8) NULL,
[ImportFileId] [int] NOT NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_GMI_MNYF1_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_GMI_MNYF1_CreateDate] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_GMI_MNYF1] on [dbo].[GMI_MNYF1]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[GMI_MNYF1] ADD CONSTRAINT [PK_GMI_MNYF1] PRIMARY KEY CLUSTERED  ([GMI_MNYF1ID])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[GMI_MNYF1_Add]''
');

GO
EXECUTE ('

-- =============================================
-- Author:		Lee Manifold
-- Create date: 21 Nov 2006
-- Description:	Insert into GMI_MNYF1
-- =============================================
CREATE PROCEDURE [dbo].[GMI_MNYF1_Add]
	(
	@RecordID						varchar(1) = Null,
	@FirmID							varchar(1) = Null,
	@OfficeNumber					varchar(3) = Null,
	@AccountNumber					varchar(5) = Null,
	@AccountTypeCurrencyCodeSymbol	varchar(3) = Null,
	@ProductCurrencyCode			varchar(2) = Null,
	@LngOptMktValue					varchar(8) = Null,
	@ShtOptMktValue					varchar(8) = Null,
	@FuturesInitMarginReqt			varchar(8) = Null,
	@FuturesOpenTradeEquity			varchar(8) = Null,
	@EquitiesInitMarginReqt			varchar(8) = Null,
	@MarginCollateralValue			varchar(8) = Null,
	@PreviousAccountBalance			varchar(8) = Null,
	@ImportFileId					int		
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	INSERT INTO [dbo].[GMI_MNYF1]
           (
			[RecordID]
           ,[FirmID]
           ,[OfficeNumber]
           ,[AccountNumber]
           ,[AccountTypeCurrencyCodeSymbol]
           ,[ProductCurrencyCode]
           ,[LngOptMktValue]
           ,[ShtOptMktValue]
           ,[FuturesInitMarginReqt]
           ,[FuturesOpenTradeEquity]
           ,[EquitiesInitMarginReqt]
           ,[MarginCollateralValue]
           ,[PreviousAccountBalance]
		   ,[ImportFileId]	
			)
     VALUES
           (
			@RecordID,
			@FirmID,
			@OfficeNumber,
			@AccountNumber,
			@AccountTypeCurrencyCodeSymbol,
			@ProductCurrencyCode,
			@LngOptMktValue,
			@ShtOptMktValue,
			@FuturesInitMarginReqt,
			@FuturesOpenTradeEquity,
			@EquitiesInitMarginReqt,
			@MarginCollateralValue,
			@PreviousAccountBalance,
			@ImportFileId
			)
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[sch_UpdateScheduleTaskRunInfo]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[sch_UpdateScheduleTaskRunInfo]
	@lastRun DateTime = NULL,
	@nextRun DateTime = NULL,
	@scheduledTaskId INT
AS
SET NOCOUNT ON
	SELECT 
		@lastRun = COALESCE(@lastRun, LastRun)
		,@nextRun = COALESCE(@nextRun, NextRun)
	FROM
		ib_ScheduledTask
	WHERE
		ScheduledTaskId = @scheduledTaskId
	
	UPDATE
		ib_ScheduledTask
	SET
		LastRun = @lastRun
		,NextRun = @nextRun
	WHERE
		ScheduledTaskId = @scheduledTaskId
');

GO
EXECUTE ('PRINT N''Creating [admin].[PurgeData_Logs]''
');

GO
EXECUTE ('CREATE PROCEDURE [admin].[PurgeData_Logs]

AS
-- =============================================
-- Author:		ED
-- Create date: 04 Jul 2014
-- Description:	purge data
-- 04 Jul 2014   ED   Create
-- =============================================
BEGIN
	SET NOCOUNT ON;

	declare @end datetime

	set @end = DATEADD(d, -7, GETDATE())

	---------------------------------------------------------------------
	---------------------------------------------------------------------
	--Import Log tables (old and new)------------------------------------
	---------------------------------------------------------------------
	---------------------------------------------------------------------
	delete from dbo.[Log] where CreateDateTimeUtc < @end
	
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Template_GetAvailableTemplatesForSiteId]''
');

GO
EXECUTE ('/*
<details>
 <summary> We have data populated in the ib_ImbalanceReportDetail table from [ib_ImbalanceReport_BuildReportPhase1],
  we need to take that and group it (I.e., Consolidate it) suitable for output on a report. /summary>
 <created author="Laurentiu Macovei" Date="Tuesday, 28 July 2006" /> 
 <updated author="Laurentiu Macovei" Date="Tuesday, 20 August 2006"> 
	Filter imbalance report
 </updated>
 <updated author="Laurentiu Macovei" Date="Tuesday, 10 October 2006"> 
	Filter generic template type
 </updated>	
 <updated author="Anil Kripalani" Date="18 Jan 2007">
	BUG FIX: Don''t return duplicate template rows
 </updated>
</details>
*/
CREATE PROCEDURE [dbo].[ib_Template_GetAvailableTemplatesForSiteId]
@UserId uniqueidentifier,
@TemplateType varchar(100)
AS
SET NOCOUNT ON
SELECT DISTINCT t.TemplateId, t.Description 
	FROM ib_SiteUser su
		INNER JOIN ib_SiteTemplate st ON 
			su.UserId = @UserId 
			AND su.SiteId = st.SiteId
		INNER JOIN ib_Template t ON 
			st.TemplateId = t.TemplateId 
			AND t.TypeCode = @TemplateType
ORDER BY t.Description
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Nostro_GetByNostroId]''
');

GO
EXECUTE ('/*
----------------------------------------------------------------------------------------------------

-- 17 Feb 09 : ED created
-- Purpose: get nostro record by Nostro Id
--
-- Revision History
-- konrad 19.03.2009 Added [DepartmentId] and [Notes]
*/

CREATE PROCEDURE [dbo].[ib_Nostro_GetByNostroId]
(
	@NostroId int
)
AS
SET NOCOUNT ON
BEGIN
	SELECT [NostroId],[ValueDate],[TransDate],[Amount],[TransactionType],[InternalReference],[ExternalReference]
      ,[Narrative],[AccountId],[CurrencyId],[DataSourceId],[TempTableRecordId],[CreateDate],[CreateUsername]
      ,[UpdateDate],[UpdateUsername],[DepartmentId],[Notes]
	FROM [dbo].[ib_Nostro]
	WHERE NostroId=@NostroId
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_EquityHeader_GenerateAll]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_EquityHeader_GenerateAll]
AS
BEGIN
	--	11 Jan 2007		amk		Creation

	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	insert into ib_equityheader (asofdate, templateid, currencyid, templategroupdescription)
	select distinct m.asofdate, t.templateid, m.currencyid, tg.description
	from ib_template t
		join ib_templategroup tg on tg.templateid = t.templateid
		join ib_templatecompare tc on tc.templateid = t.templateid
		join ib_money m on m.accountid = tg.accountid
			and m.datasourceid = tc.datasourceid
			and m.firmid = tc.firmid
	where t.TypeCode = ''Equity Report''
		and m.asofdate = convert(datetime, convert(varchar(10), dateadd(d, -1, getdate()), 120))

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Template_Copy]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Template_Copy]
	@sourceTemplateId INT
AS
	--	24 Nov 2010		amk		Creation
	--	25 Nov 2010		amk		Also copy other fields on match code record (template type and broker)
	--	30 Nov 2010		amk		MBAL-17073: get rid of SELECT * per code review comments
	--							(improves performance)

	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	DECLARE @targetTemplateId INT

	SET XACT_ABORT ON
	BEGIN TRANSACTION
	BEGIN TRY
		-- 1. template record
		INSERT INTO ib_template (typecode, description)
		SELECT typecode, description + '' NEW''
		FROM ib_template
		WHERE templateid = @sourceTemplateId

		SET @targetTemplateId = SCOPE_IDENTITY()

		-- 2. template compare records
		INSERT INTO ib_TemplateCompare (TemplateId, DataSourceId, FirmId, InternalExternalCode)
		SELECT @targetTemplateId, DataSourceId, FirmId, InternalExternalCode
		FROM ib_TemplateCompare
		WHERE templateid = @sourceTemplateId

		-- 3. template group records
		INSERT INTO ib_TemplateGroup (TemplateId, ExchangeId, FirmId, ClassId, AccountId
			, InstrumentId, Description, CurrencyId)
		SELECT @targetTemplateId, ExchangeId, FirmId, ClassId, AccountId
			, InstrumentId, Description, CurrencyId
		FROM ib_TemplateGroup
		WHERE templateid = @sourceTemplateId

		-- 4. now go back and update the match code records (that were automatically added by trigger on TG)
		-- and set the template type and broker

		SELECT mc.TemplateTypeClassId, mc.Brokerid, mc.MatchCode
		INTO #sourceMatchCode
		FROM ib_MatchCode mc
		WHERE mc.TemplateId = @sourceTemplateId

		-- avoiding self-join in UPDATE - so selected into temp table first

		UPDATE ib_MatchCode
		SET TemplateTypeClassid = mSource.TemplateTypeClassId
			, BrokerId = mSource.Brokerid
			, UpdateDate = GETDATE(), UpdateUsername = SUSER_SNAME()
		FROM ib_MatchCode mTarget
			JOIN #sourceMatchCode mSource ON mSource.MatchCode = mTarget.MatchCode
		WHERE mTarget.TemplateId = @targetTemplateId

		DROP TABLE #sourceMatchCode

		-- 5. site templates
		INSERT INTO ib_SiteTemplate (SiteId, TemplateId)
		SELECT SiteId, @targetTemplateId
		FROM ib_SiteTemplate
		WHERE templateid = @sourceTemplateId

		COMMIT TRANSACTION
	END TRY
	BEGIN CATCH
		IF XACT_STATE() = -1
			BEGIN
				ROLLBACK TRANSACTION
				EXEC sp_RethrowError
		END
	END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[GMI_MNYF1_LoadStateChange]''
');

GO
EXECUTE ('
-- =============================================
-- Author:		Lee Manifold
-- Create date: 21 Nov 2006
-- Description:	Changes the LoadState of the GMI_MNYF1 type table
-- =============================================
CREATE PROCEDURE [dbo].[GMI_MNYF1_LoadStateChange] 
	-- Add the parameters for the stored procedure here
	(
	@OldLoadState	TINYINT,
	@NewLoadState	TINYINT,
	@RecordDate		DATETIME = NULL,
	@ImportFileId	INT
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	-- Need to add code to handle RecordDate
	IF @RecordDate IS NOT NULL 
	BEGIN

		UPDATE [dbo].[GMI_MNYF1] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState AND ImportFileId = @ImportFileId

	END

	IF @RecordDate IS NULL 
	BEGIN

		UPDATE [dbo].[GMI_MNYF1] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState AND ImportFileId = @ImportFileId

	END


END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[aspnet_Applications_CreateApplication]''
');

GO
SET QUOTED_IDENTIFIER OFF

GO
EXECUTE ('
CREATE PROCEDURE [dbo].[aspnet_Applications_CreateApplication]
    @ApplicationName      nvarchar(256),
    @ApplicationId        uniqueidentifier OUTPUT
AS
SET NOCOUNT ON
BEGIN
    SELECT  @ApplicationId = ApplicationId FROM dbo.aspnet_Applications WHERE LOWER(@ApplicationName) = LoweredApplicationName

    IF(@ApplicationId IS NULL)
    BEGIN
        DECLARE @TranStarted   bit
        SET @TranStarted = 0

        IF( @@TRANCOUNT = 0 )
        BEGIN
	        BEGIN TRANSACTION
	        SET @TranStarted = 1
        END
        ELSE
    	    SET @TranStarted = 0

        SELECT  @ApplicationId = ApplicationId
        FROM dbo.aspnet_Applications WITH (UPDLOCK, HOLDLOCK)
        WHERE LOWER(@ApplicationName) = LoweredApplicationName

        IF(@ApplicationId IS NULL)
        BEGIN
            SELECT  @ApplicationId = NEWID()
            INSERT  dbo.aspnet_Applications (ApplicationId, ApplicationName, LoweredApplicationName)
            VALUES  (@ApplicationId, @ApplicationName, LOWER(@ApplicationName))
        END


        IF( @TranStarted = 1 )
        BEGIN
            IF(@@ERROR = 0)
            BEGIN
	        SET @TranStarted = 0
	        COMMIT TRANSACTION
            END
            ELSE
            BEGIN
                SET @TranStarted = 0
                ROLLBACK TRANSACTION
            END
        END
    END
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[sp_aspnet_Membership_ChangeUserName]''
');

GO
SET QUOTED_IDENTIFIER ON

GO
EXECUTE ('
/*
<details>
 <summary> Returns the PasswordAnswer from the aspnet_Membership table</summary>
 <created author="laurentiu.macovei" date="Mon, 02 Oct 2006 16:00:41 GMT"/>
</details>
*/

CREATE PROCEDURE [dbo].[sp_aspnet_Membership_ChangeUserName]
    @ApplicationName nvarchar(256),
    @UserId uniqueidentifier,
    @NewUserName nvarchar(256)
AS
SET NOCOUNT ON
BEGIN
    DECLARE @ApplicationId uniqueidentifier
    SELECT  @ApplicationId = NULL

    DECLARE @ExistingUserId uniqueidentifier
    SELECT @ExistingUserId = NULL

    DECLARE @ErrorCode     int
    SET @ErrorCode = 0

    DECLARE @TranStarted   bit
    SET @TranStarted = 0

    IF( @@TRANCOUNT = 0 )
    BEGIN
	    BEGIN TRANSACTION
	    SET @TranStarted = 1
    END
    ELSE
    	SET @TranStarted = 0

    EXEC dbo.aspnet_Applications_CreateApplication @ApplicationName, @ApplicationId OUTPUT

    IF( @@ERROR <> 0 )
    BEGIN
        SET @ErrorCode = -1
        GOTO Cleanup
    END


    SELECT  @ExistingUserId = UserId 
		FROM dbo.aspnet_Users 
		WITH ( UPDLOCK, HOLDLOCK )
		WHERE LOWER(@NewUserName) = LoweredUserName AND @ApplicationId = ApplicationId
    
	IF ( @ExistingUserID IS NULL)
		BEGIN
			/* wehn userName is available */
			UPDATE dbo.aspnet_Users 
				SET UserName = @NewUserName, 
					LoweredUserName= LOWER(@NewUserName) 
				WHERE userID=@UserID
		END
    ELSE
		BEGIN
			IF( @ExistingUserID = @UserId)
				BEGIN
					SET @ErrorCode = 1
					GOTO Cleanup
				END
			ELSE
				BEGIN
					SET @ErrorCode = 2
					GOTO Cleanup

				END
		END

    IF( @@ERROR <> 0 )
    BEGIN
        SET @ErrorCode = -1
        GOTO Cleanup
    END

    IF( @TranStarted = 1 )
    BEGIN
	    SET @TranStarted = 0
	    COMMIT TRANSACTION
    END

    RETURN 0

Cleanup:

    IF( @TranStarted = 1 )
    BEGIN
        SET @TranStarted = 0
    	ROLLBACK TRANSACTION
    END

    RETURN @ErrorCode

END
');

GO
EXECUTE ('PRINT N''Creating [admin].[PurgeData_PosTrxMoney]''
');

GO
EXECUTE ('CREATE PROCEDURE [admin].[PurgeData_PosTrxMoney]

AS
-- =============================================
-- Author:		ED
-- Create date: 04 Jul 2014
-- Description:	purge data
-- 04 Jul 2014   ED   Create
-- =============================================
BEGIN
	SET NOCOUNT ON;

	DECLARE @end DATETIME

	SET @end = DATEADD(d, -7, GETDATE())

	---------------------------------------------------------------------
	---------------------------------------------------------------------
	--Purge Positions, Trxs, Money---------------------------------------
	---------------------------------------------------------------------
	---------------------------------------------------------------------
	
	DELETE FROM ib_trx WHERE createdate < @end
	AND trxid NOT IN (SELECT trxid FROM ib_tradereconciliationdetail WHERE trxid IS NOT NULL)

	UPDATE ib_trx SET relatedposition_id = NULL 
		WHERE relatedposition_id IN (SELECT positionid FROM ib_position WHERE createdate < @end)

	DELETE FROM ib_money 
	WHERE createdate < @end

	DECLARE @counter INT
	SET @counter = 0

	CREATE TABLE #ib_positions_del
	(
		PositionId INT,
	)

	DECLARE @PositionTemp TABLE
	(
		PositionId INT
	)

	INSERT INTO #ib_positions_del (PositionId)	
	SELECT PositionId FROM ib_position WHERE createdate < @end

	DECLARE @total VARCHAR(50)
	SET @total = CONVERT(VARCHAR(50), (SELECT COUNT(*) AS Total FROM #ib_positions_del));
	DECLARE @msg VARCHAR(500)

	WHILE (SELECT COUNT(PositionId) AS NumberRemaining FROM #ib_positions_del) > 0
	BEGIN

		INSERT INTO @PositionTemp 
		SELECT TOP 1000000 PositionId FROM #ib_positions_del --CHANGE THE NUMBER BEING SELECTED HERE TO REDUCE THE STRAIN ON THE TRANSACTION LOG FURTHER
		ORDER BY PositionId ASC

		DELETE FROM ib_Position WHERE PositionID IN (SELECT PositionId FROM @PositionTemp)
		DELETE FROM #ib_positions_del WHERE PositionId IN (SELECT PositionId FROM @PositionTemp)
		DELETE FROM @PositionTemp;
	
		SET @counter = @counter + 1000000; --CHANGE THE INCREMENTAL COUNT NUMBER HERE ALSO SO THAT YOU GET THE CORRECT NUMBER REPORTED BACK

		SET @msg = ''Deleted rows '' + CONVERT(VARCHAR(100), @counter) + '' of '' + @total;
		RAISERROR(@msg, 0, 1) WITH NOWAIT
	END

	DROP TABLE #ib_positions_del

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Template_GetFandOforUser]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Template_GetFandOforUser]
	@UserID UNIQUEIDENTIFIER
AS
	--	05 Jan 2011		amk		Creation

	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	SELECT DISTINCT t.TemplateId, t.Description 
	FROM ib_SiteUser su
		INNER JOIN ib_SiteTemplate st ON su.UserId = @UserId 
			AND su.SiteId = st.SiteId
		INNER JOIN ib_Template t ON st.TemplateId = t.TemplateId 
			AND t.TypeCode IN (''Imbalance Report'', ''CloseOut Report'')
	ORDER BY t.Description
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Nostro_GetFirms]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Nostro_GetFirms]
(
	@TemplateId int = null
)
AS
SET NOCOUNT ON

--	13 Dec 2011	GC	Creation
--  04 May 2012 ED  MBAL-19859 - get also code
--  04 May 2012 ED	No matchcode filtering
BEGIN


SELECT ib_Firm.Code, ib_Firm.FirmId, ib_Firm.Name
FROM ib_Firm
WHERE 
@TemplateId IS NULL OR ib_Firm.FirmId IN 
		(SELECT ib_TemplateGroup.FirmId 
			FROM ib_TemplateGroup 
			WHERE ib_TemplateGroup.FirmId IS NOT NULL AND
			ib_TemplateGroup.TemplateId = @TemplateId)
ORDER BY ib_Firm.Name			
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ReceiveLocation_Insert]''
');

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Inserts a record into the ReceiveLocation table
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[ReceiveLocation_Insert]
(

	@ReceiveLocationSysId tinyint    OUTPUT,

	@ReceiveLocationName varchar (255)  ,

	@PackageSysId tinyint   ,

	@FileMask varchar (50)  ,

	@InputFolder varchar (255)  ,

	@OutputFolder varchar (255)  ,

	@ErrorFolder varchar (255)  ,

	@DataSourceId int   ,

	@Priority tinyint   ,

	@IsActive bit   ,

	@IsRunning bit   ,

	@CreateDateTimeUtc smalldatetime   ,

	@CreateUsername varchar (100)  ,

	@UpdateDateTimeUtc smalldatetime   ,

	@UpdateUsername varchar (100)  ,

	@DeleteDateTimeUtc smalldatetime   ,

	@DeleteUsername varchar (100)  
)
AS


				
				INSERT INTO [dbo].[ReceiveLocation]
					(
					[ReceiveLocationName]
					,[PackageSysId]
					,[FileMask]
					,[InputFolder]
					,[OutputFolder]
					,[ErrorFolder]
					,[DataSourceId]
					,[Priority]
					,[IsActive]
					,[IsRunning]
					,[CreateDateTimeUtc]
					,[CreateUsername]
					,[UpdateDateTimeUtc]
					,[UpdateUsername]
					,[DeleteDateTimeUtc]
					,[DeleteUsername]
					)
				VALUES
					(
					@ReceiveLocationName
					,@PackageSysId
					,@FileMask
					,@InputFolder
					,@OutputFolder
					,@ErrorFolder
					,@DataSourceId
					,@Priority
					,@IsActive
					,@IsRunning
					,@CreateDateTimeUtc
					,@CreateUsername
					,@UpdateDateTimeUtc
					,@UpdateUsername
					,@DeleteDateTimeUtc
					,@DeleteUsername
					)
				
				-- Get the identity value
				SET @ReceiveLocationSysId = SCOPE_IDENTITY()
									
							
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_EquityHeader_Insert]''
');

GO
EXECUTE ('
/*
Created By:  McQuien
Date:  2006-11-21

Purpose:  Inserts records into equity header in order to construct the equity reports.

Modifications:
*/
CREATE proc [dbo].[ib_EquityHeader_Insert]
@AsOfDate datetime,
@TemplateId int,
@CurrencyId int,
@TemplateGroupDescription varchar(50)

as
SET NOCOUNT ON

INSERT into ib_EquityHeader(AsOfDate,
TemplateId,
CurrencyId,
TemplateGroupDescription)
VALUES (@AsOfDate,
@TemplateId,
@CurrencyId,
@TemplateGroupDescription)
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Template_Delete]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Template_Delete]
(
	@TemplateId int
)
AS
SET NOCOUNT ON

--	Deletes a template by its id from the ib_Template table

--	08 Sep 2006		laurentiu	Creation
--	15 Jul 2010		amk			MBAL-16175: Cascade delete to child tables

	BEGIN TRANSACTION

	BEGIN TRY
		DELETE FROM ib_SiteTemplate
			WHERE TemplateId = @TemplateId

		DELETE FROM ib_TemplateCompare
			WHERE TemplateId = @TemplateId

		DELETE FROM ib_TemplateGroup
			WHERE TemplateId = @TemplateId

		DELETE FROM ib_MatchCode
			WHERE TemplateId = @TemplateId

		DELETE FROM [dbo].[ib_Template]
			WHERE TemplateId = @TemplateId

		COMMIT TRANSACTION
	END TRY
	BEGIN CATCH
		ROLLBACK TRANSACTION
		EXEC [dbo].[sp_RethrowError] ''Template is currently in use.''
	END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[GMI_MNYF1_Purge]''
');

GO
EXECUTE ('
-- =============================================
-- Author:		Lee Manifold
-- Create date: 21 Nov 2006
-- Description:	Deletes from all is_GMI_MNYF1 type files where the LoadState is 0
-- =============================================
CREATE PROCEDURE [dbo].[GMI_MNYF1_Purge]
	(
	@LoadState		TINYINT = 0,
	@RecordDate		DATETIME = NULL,
	@ImportFileId	INT
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;


	IF @RecordDate IS NOT NULL 
	BEGIN
		--****Need to Add code here to factor in @RecordDate into table fields 
		DELETE FROM [dbo].[GMI_MNYF1] WHERE LoadState= @LoadState AND ImportFileId = @ImportFileId

	END
	
	IF @RecordDate IS NULL 
	BEGIN
	
		DELETE FROM [dbo].[GMI_MNYF1] WHERE LoadState= @LoadState AND ImportFileId = @ImportFileId

	END
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[sp_aspnet_Membership_GetPasswordAnswer]''
');

GO
EXECUTE ('
/*
<details>
 <summary> Returns the PasswordAnswer from the aspnet_Membership table</summary>
 <created author="laurentiu.macovei" date="Mon, 02 Oct 2006 15:59:56 GMT"/>
</details>
*/

CREATE PROCEDURE [dbo].[sp_aspnet_Membership_GetPasswordAnswer]
    @UserId UNIQUEIDENTIFIER
AS
SET NOCOUNT ON
SELECT PasswordAnswer 
	FROM dbo.aspnet_Membership 
	WHERE UserID=@UserID
');

GO
EXECUTE ('PRINT N''Creating [admin].[PurgeData_QueueItem]''
');

GO
EXECUTE ('CREATE PROCEDURE [admin].[PurgeData_QueueItem]

AS
-- =============================================
-- Author:		ED
-- Create date: 04 Jul 2014
-- Description:	purge data
-- 04 Jul 2014   ED   Create
-- =============================================
BEGIN
	SET NOCOUNT ON;

	declare @end datetime

	set @end = DATEADD(d, -7, GETDATE())

	---------------------------------------------------------------------
	---------------------------------------------------------------------
	--Purge Queue Item---------------------------------------------------
	---------------------------------------------------------------------
	---------------------------------------------------------------------
	begin transaction
	--delete from queue log
	DELETE ib_QueueLog
	FROM ib_QueueLog ql, ib_QueueItem qi
	WHERE ql.QueueItemId = qi.QueueItemId
		and qi.CreateDate < @end

	--delete from queue item
	DELETE FROM ib_QueueItem WHERE CreateDate < @end

	commit transaction

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Nostro_GetMatchCodes]''
');

GO
SET ANSI_NULLS OFF

GO
EXECUTE ('
--	03 Sep 09	amk		Creation

CREATE PROCEDURE [dbo].[ib_Nostro_GetMatchCodes]
(
	@TemplateId int = null
)
AS
SET NOCOUNT ON
BEGIN

	IF @TemplateId IS NULL
		SELECT mc.MatchCode, mc.MatchCodeId
		FROM ib_MatchCode mc
			INNER JOIN ib_Template t ON mc.TemplateId = t.TemplateId
		WHERE t.TypeCode = ''Nostro Rec''
		ORDER BY mc.MatchCode
	ELSE
		SELECT mc.MatchCode, mc.MatchCodeId
		FROM ib_MatchCode mc
		WHERE mc.TemplateId = @TemplateId
		ORDER BY mc.MatchCode
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ReceiveLocation_Update]''
');

GO
SET ANSI_NULLS ON

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Updates a record in the ReceiveLocation table
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[ReceiveLocation_Update]
(

	@ReceiveLocationSysId tinyint   ,

	@ReceiveLocationName varchar (255)  ,

	@PackageSysId tinyint   ,

	@FileMask varchar (50)  ,

	@InputFolder varchar (255)  ,

	@OutputFolder varchar (255)  ,

	@ErrorFolder varchar (255)  ,

	@DataSourceId int   ,

	@Priority tinyint   ,

	@IsActive bit   ,

	@IsRunning bit   ,

	@CreateDateTimeUtc smalldatetime   ,

	@CreateUsername varchar (100)  ,

	@UpdateDateTimeUtc smalldatetime   ,

	@UpdateUsername varchar (100)  ,

	@DeleteDateTimeUtc smalldatetime   ,

	@DeleteUsername varchar (100)  
)
AS


				
				
				-- Modify the updatable columns
				UPDATE
					[dbo].[ReceiveLocation]
				SET
					[ReceiveLocationName] = @ReceiveLocationName
					,[PackageSysId] = @PackageSysId
					,[FileMask] = @FileMask
					,[InputFolder] = @InputFolder
					,[OutputFolder] = @OutputFolder
					,[ErrorFolder] = @ErrorFolder
					,[DataSourceId] = @DataSourceId
					,[Priority] = @Priority
					,[IsActive] = @IsActive
					,[IsRunning] = @IsRunning
					,[CreateDateTimeUtc] = @CreateDateTimeUtc
					,[CreateUsername] = @CreateUsername
					,[UpdateDateTimeUtc] = @UpdateDateTimeUtc
					,[UpdateUsername] = @UpdateUsername
					,[DeleteDateTimeUtc] = @DeleteDateTimeUtc
					,[DeleteUsername] = @DeleteUsername
				WHERE
[ReceiveLocationSysId] = @ReceiveLocationSysId 
				
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_EquityHeader_Select]''
');

GO
EXECUTE ('



/*
Created By:  McQuien
Date:  2006-11-21

Purpose:  Selects records into equity header in order to construct the equity reports.

Modifications:
SWA 23/12/2006 - Changed Exchange join to outer to revolve point 1 in IBAL-2624
*/


CREATE PROC [dbo].[ib_EquityHeader_Select]
@AsOfDate datetime,
@SiteId int=null

as
SET NOCOUNT ON

IF @SiteId is not null 
BEGIN
SELECT  distinct b.equityheaderid as Id,f.name as Exchange,g.name as Account,c.description as Currency,e.description as [Match Code],b.section1signoffdate as [Section1 SignOff],section2signoffdate as [Section2 SignOff],section3signoffdate as [Section3 SignOff]
FROM ib_Currency c 
INNER JOIN ib_EquityHeader b on
c.currencyid = b.currencyid
INNER JOIN ib_SiteTemplate d on
b.templateid = d.templateid
INNER JOIN ib_TemplateGroup e on
b.TemplateId = e.templateid
and b.templategroupdescription = e.description
LEFT OUTER JOIN ib_Exchange f on
e.ExchangeId = f.exchangeid
inner join ib_account g on
e.accountid = g.accountid
WHERE b.AsOfDate = @AsOfDate
and d.siteid = @SiteId
END
ELSE
BEGIN
SELECT  distinct b.equityheaderid as Id,f.name as Exchange,g.name as Account,c.description as Currency,e.description as [Match Code],b.section1signoffdate as [Section1 SignOff],section2signoffdate as [Section2 SignOff],section3signoffdate as [Section3 SignOff]
FROM ib_Currency c 
INNER JOIN ib_EquityHeader b on
c.currencyid = b.currencyid
INNER JOIN ib_SiteTemplate d on
b.templateid = d.templateid
INNER JOIN ib_TemplateGroup e on
b.TemplateId = e.templateid
and b.templategroupdescription = e.description
LEFT OUTER JOIN ib_Exchange f on
e.ExchangeId = f.exchangeid
inner join ib_account g on
e.accountid = g.accountid
WHERE b.AsOfDate = @AsOfDate
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Template_Update]''
');

GO
EXECUTE (' /*
<details>
 <summary>Updates a template from the ib_Template table by its id</summary>
 <created author="Laurentiu Macovei" Date="Monday, 8 September 2006 11:46PM GMT" /> 
</details>
*/
CREATE PROCEDURE [dbo].[ib_Template_Update]
(
	@TemplateId int,
	@TypeCode varchar(50),
    @Description varchar(100),
    @UpdateUsername varchar(50)
)
AS
SET NOCOUNT ON

BEGIN TRY
--check for duplicates 
EXEC [dbo].[ib_Template_CheckForDuplicate] @TypeCode, @Description, @TemplateId

UPDATE [dbo].[ib_Template]
   SET [TypeCode] = @TypeCode,
       [Description] = @Description,
       [UpdateUsername] = @UpdateUsername
 WHERE TemplateId = @TemplateId

END TRY
BEGIN CATCH
	EXEC [dbo].[sp_RethrowError]
END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[GMI_POSF1]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[GMI_POSF1]
(
[GMI_POSF1ID] [int] NOT NULL IDENTITY(1, 1),
[FirmID] [varchar] (1) NULL,
[AccountNumber] [varchar] (5) NULL,
[ContractYrMnth] [varchar] (6) NULL,
[SubCusip] [varchar] (2) NULL,
[SecuritySubType] [varchar] (1) NULL,
[StrikePrice] [varchar] (15) NULL,
[BuySellCode] [int] NULL,
[AccountCountry] [varchar] (2) NULL,
[AccountClassCode] [varchar] (1) NULL,
[Quantity] [varchar] (30) NULL,
[Exchange] [varchar] (15) NULL,
[ExchangeCode] [varchar] (2) NULL,
[FuturesCode] [varchar] (2) NULL,
[ContractTypeCode] [varchar] (1) NULL,
[InputExercisePrice] [varchar] (7) NULL,
[ProductCurrencyCode] [varchar] (2) NULL,
[OmnibusCode] [varchar] (1) NULL,
[RelatedFirmNo1] [varchar] (1) NULL,
[RelatedAcctNo1] [varchar] (5) NULL,
[CountryCode] [varchar] (2) NULL,
[Symbol] [varchar] (6) NULL,
[ClosingMarketPrice] [varchar] (15) NULL,
[OfficeNumber] [varchar] (3) NULL,
[SubClassCode] [varchar] (1) NULL,
[ImportFileId] [int] NOT NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_GMI_POSF1_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_GMI_POSF1_CreateDate] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_GMI_Test] on [dbo].[GMI_POSF1]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[GMI_POSF1] ADD CONSTRAINT [PK_GMI_Test] PRIMARY KEY CLUSTERED  ([GMI_POSF1ID])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[GMI_POSF1_Add]''
');

GO
EXECUTE ('
-- =============================================
-- Author:		Lee Manifold
-- Create date: 28 Jun 2006
-- Description:	Insert into GMI_Test
--
-- History
--
-- Date			Author			Description
-- 28 Feb 2007	LM				Added Extra field ImportFileId
-- =============================================
CREATE PROCEDURE [dbo].[GMI_POSF1_Add]
	(
	@FirmID					varchar(1) = NULL,
	@AccountNumber			varchar(5) = NULL,
	@ContractYrMnth			varchar(6) = NULL,
	@SubCusip				varchar(2) = NULL,
	@SecuritySubType		varchar(1) = NULL,
	@StrikePrice			varchar(15) = NULL, --Decimal 8,7
	@BuySellCode			int = NULL,
	@AccountCountry			varchar(2) = NULL,
	@AccountClassCode		varchar(1) = NULL,
	@Quantity				varchar(15) = NULL,
	@Exchange				varchar(15) = NULL, --Decimal 13,2
	@ExchangeCode			varchar(2) = NULL,
	@FuturesCode			varchar(2) = NULL,
	@ContractTypeCode		varchar(1) = NULL,
	@InputExercisePrice		varchar(7) = NULL,
	@ProductCurrencyCode	varchar(2) = NULL,
	@OmnibusCode			varchar(1) = NULL,
	@RelatedFirmNo1			varchar(1) = NULL,
	@RelatedAcctNo1			varchar(5) = NULL,
	@CountryCode			varchar(2) = NULL,
	@Symbol					varchar(6) = NULL,
	@ClosingMarketPrice		varchar(15) = NULL, --Decimal(7,8)
	@OfficeNumber			varchar(3) = NULL,
	@SubClassCode			varchar(1) = NULL,
	@ImportFileId			int = NULL
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	INSERT INTO [dbo].[GMI_POSF1]
           (
			[FirmID]
           ,[AccountNumber]
           ,[ContractYrMnth]
           ,[SubCusip]
           ,[SecuritySubType]
           ,[StrikePrice]
           ,[BuySellCode]
           ,[AccountCountry]
           ,[AccountClassCode]
           ,[Quantity]
           ,[Exchange]
           ,[ExchangeCode]
           ,[FuturesCode]
           ,[ContractTypeCode]
           ,[InputExercisePrice]
           ,[ProductCurrencyCode]
           ,[OmnibusCode]
           ,[RelatedFirmNo1]
           ,[RelatedAcctNo1]
		   ,[CountryCode]
		   ,[Symbol]
		   ,[ClosingMarketPrice]
		   ,[OfficeNumber]
		   ,[SubClassCode]
		   ,[ImportFileId]			  	
			)
     VALUES
           (
			@FirmID					,
			@AccountNumber			,
			@ContractYrMnth			,
			@SubCusip				,
			@SecuritySubType		,
			@StrikePrice			,
			@BuySellCode			,
			@AccountCountry			,
			@AccountClassCode		,
			@Quantity				,
			@Exchange				,
			@ExchangeCode			,
			@FuturesCode			,
			@ContractTypeCode		,
			@InputExercisePrice		,
			@ProductCurrencyCode	,
			@OmnibusCode			,
			@RelatedFirmNo1			,
			@RelatedAcctNo1			,
			@CountryCode			,
			@Symbol					,
			@ClosingMarketPrice		,
			@OfficeNumber			,
			@SubClassCode			,
			@ImportFileId			
			)
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[is_GProductTotal]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[is_GProductTotal]
(
[GProductTotalId] [int] NOT NULL IDENTITY(1, 1),
[CorporationCode] [varchar] (4) NULL,
[PrincipalBrokerageID] [varchar] (1) NULL,
[OfficeCode] [varchar] (4) NULL,
[ACNumber] [varchar] (10) NULL,
[RecordID] [varchar] (2) NULL,
[BaseDate] [datetime] NULL,
[CalculationDate] [datetime] NULL,
[CalculationStartTime] [datetime] NULL,
[CalculationDateStartTime] [datetime] NULL,
[FuturesSubId] [varchar] (3) NULL,
[DerivativesCode] [varchar] (10) NULL,
[BuyContractQuantity] [int] NULL,
[SellContractQuantity] [int] NULL,
[Yen01] [varchar] (10) NULL,
[Yen02] [varchar] (15) NULL,
[Yen03] [varchar] (1) NULL,
[UnrealizedPLSign] [varchar] (1) NULL,
[UnrealizedPL] [decimal] (15, 0) NULL,
[UnrealizedPLSigned] [decimal] (15, 0) NULL,
[UnrealizedPLNonCalculableFlag] [varchar] (1) NULL,
[AdjustmentFPDAmountSign] [varchar] (1) NULL,
[AdjustmentFPDAmount] [decimal] (15, 0) NULL,
[AdjustmentFPDAmountSigned] [decimal] (15, 0) NULL,
[AdjustmentFPDFuturesRealizedPLSign] [varchar] (1) NULL,
[AdjustmentFPDFuturesRealizedPL] [decimal] (15, 0) NULL,
[AdjustmentFPDFuturesRealizedPLSigned] [decimal] (15, 0) NULL,
[AdjustmentFPDOptionsPremiumAmountBuySign] [varchar] (1) NULL,
[AdjustmentFPDOptionsPremiumAmount] [decimal] (15, 0) NULL,
[AdjustmentFPDOptionsPremiumAmountBuySigned] [decimal] (15, 0) NULL,
[AdjustmentFPDOptionsPremiumAmountSellSign] [varchar] (1) NULL,
[AdjustmentFPDOptionsPremiumAmountSell] [decimal] (15, 0) NULL,
[AdjustmentFPDOptionsPremiumAmountSellSigned] [decimal] (15, 0) NULL,
[AdjustmentFPDNetStrikePriceForExerciseSign] [varchar] (1) NULL,
[AdjustmentFPDNetStrikePriceForExercise] [decimal] (15, 0) NULL,
[AdjustmentFPDNetStrikePriceForExerciseSigned] [decimal] (15, 0) NULL,
[AdjustmentFPDNetStrikePriceForAllotmentSign] [varchar] (1) NULL,
[AdjustmentFPDNetStrikePriceForAllotment] [decimal] (15, 0) NULL,
[AdjustmentFPDNetStrikePriceForAllotmentSigned] [decimal] (15, 0) NULL,
[AdjustmentFPDCommissionAmountSign] [varchar] (1) NULL,
[AdjustmentFPDCommissionAmount] [decimal] (15, 0) NULL,
[AdjustmentFPDCommissionAmountSigned] [decimal] (15, 0) NULL,
[AdjustmentFPDConsumptionTaxAmountSign] [varchar] (1) NULL,
[AdjustmentFPDConsumptionTaxAmount] [decimal] (15, 0) NULL,
[AdjustmentFPDConsumptionTaxAmountSigned] [decimal] (15, 0) NULL,
[AdjustmentFPDExchangeTaxAmountSign] [varchar] (1) NULL,
[AdjustmentFPDExchangeTaxAmount] [decimal] (15, 0) NULL,
[AdjustmentFPDExchangeTaxAmountSigned] [decimal] (15, 0) NULL,
[SettlementAmountFCDTradingSign] [varchar] (1) NULL,
[SettlementAmountFCDTrading] [decimal] (15, 0) NULL,
[SettlementAmountFCDTradingSigned] [decimal] (15, 0) NULL,
[RealizedPLFCDFuturesTradingSign] [varchar] (1) NULL,
[RealizedPLFCDFuturesTrading] [decimal] (15, 0) NULL,
[RealizedPLFCDFuturesTradingSigned] [decimal] (15, 0) NULL,
[OptionsPremiumFCDTradingBuySign] [varchar] (1) NULL,
[OptionsPremiumFCDTradingBuy] [decimal] (15, 0) NULL,
[OptionsPremiumFCDTradingBuySigned] [decimal] (15, 0) NULL,
[OptionsPremiumFCDTradingSellSign] [varchar] (1) NULL,
[OptionsPremiumFCDTradingSell] [decimal] (15, 0) NULL,
[OptionsPremiumFCDTradingSellSigned] [decimal] (15, 0) NULL,
[NetStrikePriceFCDTradingForExerciseSign] [varchar] (1) NULL,
[NetStrikePriceFCDTradingForExercise] [decimal] (15, 0) NULL,
[NetStrikePriceFCDTradingForExerciseSigned] [decimal] (15, 0) NULL,
[NetStrikePriceFCDTradingForAllotmentSign] [varchar] (1) NULL,
[NetStrikePriceFCDTradingForAllotment] [decimal] (15, 0) NULL,
[NetStrikePriceFCDTradingForAllotmentSigned] [decimal] (15, 0) NULL,
[CommissionAmountFCDTradingSign] [varchar] (1) NULL,
[CommissionAmountFCDTrading] [decimal] (15, 0) NULL,
[CommissionAmountFCDTradingSigned] [decimal] (15, 0) NULL,
[ConsumptionTaxAmountFCDTradingSign] [varchar] (1) NULL,
[ConsumptionTaxAmountFCDTrading] [decimal] (15, 0) NULL,
[ConsumptionTaxAmountFCDTradingSigned] [decimal] (15, 0) NULL,
[ExchangeTaxAmountFCDTradingSign] [varchar] (1) NULL,
[ExchangeTaxAmountFCDTrading] [decimal] (15, 0) NULL,
[ExchangeTaxAmountFCDTradingSigned] [decimal] (15, 0) NULL,
[ProductNameEnglish] [varchar] (28) NULL,
[ProductNameKan] [varchar] (24) NULL,
[LongOptionValue] [decimal] (15, 0) NULL,
[ShortOptionValue] [decimal] (15, 0) NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_is_GProductTotal_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_GProductTotal_CreationDate] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_GProductTotal] on [dbo].[is_GProductTotal]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[is_GProductTotal] ADD CONSTRAINT [PK_GProductTotal] PRIMARY KEY CLUSTERED  ([GProductTotalId])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[is_GCollateralSecuritiesMovement]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[is_GCollateralSecuritiesMovement]
(
[GCollateralSecuritiesMovementId] [int] NOT NULL IDENTITY(1, 1),
[CorporationCode] [varchar] (4) NULL,
[PrincipalBrokerageId] [varchar] (1) NULL,
[OfficeCode] [varchar] (4) NULL,
[ACNo] [varchar] (10) NULL,
[RecordId] [varchar] (2) NULL,
[BaseDate] [datetime] NULL,
[CalculationDate] [datetime] NULL,
[CalculationStartTime] [datetime] NULL,
[CalculationDateStartTime] [datetime] NULL,
[DepositId] [varchar] (2) NULL,
[DepositWithdrawalDate] [datetime] NULL,
[DepositWithdrawalId] [varchar] (1) NULL,
[ProductId] [varchar] (2) NULL,
[CompanyCode] [varchar] (7) NULL,
[SeriesNo] [varchar] (4) NULL,
[SubCode] [varchar] (2) NULL,
[NewOldId] [varchar] (1) NULL,
[DepositDate] [datetime] NULL,
[RecordNo] [varchar] (5) NULL,
[Quantity] [decimal] (15, 0) NULL,
[MarketValue] [decimal] (15, 0) NULL,
[CollateralRate] [varchar] (3) NULL,
[UnitValuePerCollateral] [decimal] (15, 0) NULL,
[EvaluationOfCollateralSecurities] [decimal] (15, 0) NULL,
[CustodianCode] [varchar] (3) NULL,
[DepositaryReceiptNo] [varchar] (5) NULL,
[JasdecMemberCodeMemberToWhichCollateralIsPlaced] [varchar] (7) NULL,
[DirectCustodian] [varchar] (2) NULL,
[CustomerNameAbbreviated] [varchar] (35) NULL,
[SecurityNameEnglish] [varchar] (28) NULL,
[SecurityNameKana] [varchar] (24) NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_is_GCollateralSecuritiesMovement_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_GCollateralSecuritiesMovement_CreationDate] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_GCollateralSecuritiesMovement] on [dbo].[is_GCollateralSecuritiesMovement]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[is_GCollateralSecuritiesMovement] ADD CONSTRAINT [PK_GCollateralSecuritiesMovement] PRIMARY KEY CLUSTERED  ([GCollateralSecuritiesMovementId])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[is_GCollateralSecuritiesDetails]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[is_GCollateralSecuritiesDetails]
(
[GCollateralSecuritiesDetailsId] [int] NOT NULL IDENTITY(1, 1),
[CorporationCode] [varchar] (4) NULL,
[PrincipalBrokerageId] [varchar] (1) NULL,
[OfficeCode] [varchar] (4) NULL,
[ACNo] [varchar] (10) NULL,
[RecordId] [varchar] (2) NULL,
[BaseDate] [datetime] NULL,
[CalculationDate] [datetime] NULL,
[CalculationStartTime] [datetime] NULL,
[CalculationDateStartTime] [datetime] NULL,
[DepositId] [varchar] (2) NULL,
[ProductId] [varchar] (2) NULL,
[CompanyCode] [varchar] (7) NULL,
[SeriesNo] [varchar] (4) NULL,
[SubCode] [varchar] (2) NULL,
[NewOldId] [varchar] (1) NULL,
[DepositDate] [datetime] NULL,
[WithdrawalDate] [datetime] NULL,
[RecordNo] [varchar] (5) NULL,
[Quantity] [decimal] (15, 0) NULL,
[MarketValue] [decimal] (15, 0) NULL,
[CollateralRate] [varchar] (3) NULL,
[UnitValuePerCollateral] [decimal] (15, 0) NULL,
[EvaluationOfCollateralSecurities] [decimal] (15, 0) NULL,
[CustodianCode] [varchar] (3) NULL,
[DepositaryReceiptNo] [varchar] (5) NULL,
[MemberCodeMemberToWhichCollateralIsPlaced] [varchar] (7) NULL,
[DirectCustodian] [varchar] (2) NULL,
[CustomerNameAbbreviated] [varchar] (35) NULL,
[SecurityNameEnglish] [varchar] (28) NULL,
[SecurityNameKana] [varchar] (24) NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_is_GCollateralSecuritiesDetails_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_GCollateralSecuritiesDetails_CreationDate] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_GCollateralSecuritiesDetails] on [dbo].[is_GCollateralSecuritiesDetails]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[is_GCollateralSecuritiesDetails] ADD CONSTRAINT [PK_GCollateralSecuritiesDetails] PRIMARY KEY CLUSTERED  ([GCollateralSecuritiesDetailsId])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[is_GAccountTotal]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[is_GAccountTotal]
(
[GAccountTotalId] [int] NOT NULL IDENTITY(1, 1),
[CorporationCode] [varchar] (4) NULL,
[PrincipalBrokerageId] [varchar] (1) NULL,
[OfficeCode] [varchar] (4) NULL,
[ACNo] [varchar] (10) NULL,
[RecordId] [varchar] (2) NULL,
[BaseDate] [datetime] NULL,
[CalculationDate] [datetime] NULL,
[CalculationStartTime] [datetime] NULL,
[CalculationDateStartTime] [datetime] NULL,
[PreviousDaySFinalCashBalanceSign] [varchar] (1) NULL,
[PreviousDaySFinalCashBalance] [decimal] (15, 0) NULL,
[PreviousDaySFinalCashBalanceSigned] [decimal] (15, 0) NULL,
[PreviousDaySSettlementAmountSign] [varchar] (1) NULL,
[PreviousDaySSettlementAmount] [decimal] (15, 0) NULL,
[PreviousDaySSettlementAmountSigned] [decimal] (15, 0) NULL,
[PreviousDaySReportedCashBalanceSign] [varchar] (1) NULL,
[PreviousDaySReportedCashBalance] [decimal] (15, 0) NULL,
[PreviousDaySReportedCashBalanceSigned] [decimal] (15, 0) NULL,
[AdjustmentFPDAmountSign] [varchar] (1) NULL,
[AdjustmentFPDAmount] [decimal] (15, 0) NULL,
[AdjustmentFPDAmountSigned] [nchar] (10) NULL,
[AdjustmentFPDFuturesRealizedPLSign] [varchar] (1) NULL,
[AdjustmentFPDFuturesRealizedPL] [decimal] (15, 0) NULL,
[AdjustmentFPDFuturesRealizedPLSigned] [decimal] (15, 0) NULL,
[AdjustmentFPDOptionsPremiumAmountBuySign] [varchar] (1) NULL,
[AdjustmentFPDOptionsPremiumAmountBuy] [decimal] (15, 0) NULL,
[AdjustmentFPDOptionsPremiumAmountBuySigned] [decimal] (15, 0) NULL,
[AdjustmentFPDOptionsPremiumAmountSellSign] [varchar] (1) NULL,
[AdjustmentFPDOptionsPremiumAmountSell] [decimal] (15, 0) NULL,
[AdjustmentFPDOptionsPremiumAmountSellSigned] [decimal] (15, 0) NULL,
[AdjustmentFPDNetStrikePriceForExerciseSign] [varchar] (1) NULL,
[AdjustmentFPDNetStrikePriceForExercise] [decimal] (15, 0) NULL,
[AdjustmentFPDNetStrikePriceForExerciseSigned] [decimal] (15, 0) NULL,
[AdjustmentFPDNetStrikePriceForAllotmentSign] [varchar] (1) NULL,
[AdjustmentFPDNetStrikePriceForAllotment] [decimal] (15, 0) NULL,
[AdjustmentFPDNetStrikePriceForAllotmentSigned] [decimal] (15, 0) NULL,
[AdjustmentFPDDomesticCommissionSign] [varchar] (1) NULL,
[AdjustmentFPDDomesticCommission] [decimal] (15, 0) NULL,
[AdjustmentFPDDomesticCommissionSigned] [decimal] (15, 0) NULL,
[AdjustmentFPDConsumptionTaxOnCommissionSign] [varchar] (1) NULL,
[AdjustmentFPDConsumptionTaxOnCommission] [decimal] (15, 0) NULL,
[AdjustmentFPDConsumptionTaxOnCommissionSigned] [decimal] (15, 0) NULL,
[AdjustmentFPDExchangeTaxSign] [varchar] (1) NULL,
[AdjustmentFPDExchangeTax] [decimal] (15, 0) NULL,
[AdjustmentFPDExchangeTaxSigned] [decimal] (15, 0) NULL,
[AdjustmentFPDReceiptPaymentAmountSign] [varchar] (1) NULL,
[AdjustmentFPDReceiptPaymentAmount] [decimal] (15, 0) NULL,
[AdjustmentFPDReceiptPaymentAmountSigned] [decimal] (15, 0) NULL,
[ReceiptPaymentAmountFCDSign] [varchar] (1) NULL,
[ReceiptPaymentAmountFCD] [decimal] (15, 0) NULL,
[ReceiptPaymentAmountFCDSigned] [decimal] (15, 0) NULL,
[FinalCashBalanceFCDSign] [varchar] (1) NULL,
[FinalCashBalanceFCD] [decimal] (15, 0) NULL,
[FinalCashBalanceFCDSigned] [decimal] (15, 0) NULL,
[SettlementAmountFCDTradingSign] [varchar] (1) NULL,
[SettlementAmountFCDTrading] [decimal] (15, 0) NULL,
[SettlementAmountFCDTradingSigned] [decimal] (15, 0) NULL,
[RealizedPLFCDFuturesTradingSign] [varchar] (1) NULL,
[RealizedPLFCDFuturesTrading] [decimal] (15, 0) NULL,
[RealizedPLFCDFuturesTradingSigned] [decimal] (15, 0) NULL,
[OptionsPremiumFCDTradingBuySign] [varchar] (1) NULL,
[OptionsPremiumFCDTradingBuy] [decimal] (15, 0) NULL,
[OptionsPremiumFCDTradingBuySigned] [decimal] (15, 0) NULL,
[OptionsPremiumFCDTradingSellSign] [varchar] (1) NULL,
[OptionsPremiumFCDTradingSell] [decimal] (15, 0) NULL,
[OptionsPremiumFCDTradingSellSigned] [decimal] (15, 0) NULL,
[NetStrikePriceFCDTradingForExerciseSign] [varchar] (1) NULL,
[NetStrikePriceFCDTradingForExercise] [decimal] (15, 0) NULL,
[NetStrikePriceFCDTradingForExerciseSigned] [decimal] (15, 0) NULL,
[NetStrikePriceFCDTradingForAllotmentSign] [varchar] (1) NULL,
[NetStrikePriceFCDTradingForAllotment] [decimal] (15, 0) NULL,
[NetStrikePriceFCDTradingForAllotmentSigned] [decimal] (15, 0) NULL,
[DomesticCommissionFCDTradingSign] [varchar] (1) NULL,
[DomesticCommissionFCDTrading] [decimal] (15, 0) NULL,
[DomesticCommissionFCDTradingSigned] [decimal] (15, 0) NULL,
[ConsumptionTaxOnCommissionFCDTradingSign] [varchar] (1) NULL,
[ConsumptionTaxOnCommissionFCDTrading] [decimal] (15, 0) NULL,
[ConsumptionTaxOnCommissionFCDTradingSigned] [decimal] (15, 0) NULL,
[ExchangeTaxFCDTradingSign] [varchar] (1) NULL,
[ExchangeTaxFCDTrading] [decimal] (15, 0) NULL,
[ExchangeTaxFCDTradingSigned] [decimal] (15, 0) NULL,
[CashBalanceReportedOnCurrentDaySign] [varchar] (1) NULL,
[CashBalanceReportedOnCurrentDay] [decimal] (15, 0) NULL,
[CashBalanceReportedOnCurrentDaySigned] [decimal] (15, 0) NULL,
[UnrealizedPLSign] [varchar] (1) NULL,
[UnrealizedPL] [decimal] (15, 0) NULL,
[UnrealizedPLSigned] [decimal] (15, 0) NULL,
[UnrealizedPLNonCalculableFlag] [varchar] (1) NULL,
[TotalMarginCashSign] [varchar] (1) NULL,
[TotalMarginCash] [decimal] (15, 0) NULL,
[TotalMarginCashSigned] [decimal] (15, 0) NULL,
[CollateralValueFCDTseDirectDeposit] [decimal] (15, 0) NULL,
[CollateralValueFCDOseDirectDeposit] [decimal] (15, 0) NULL,
[CollateralValueFCDMemberDirectDeposit] [decimal] (15, 0) NULL,
[CollateralValueFCDDepositForReplacement] [decimal] (15, 0) NULL,
[CollateralValueFCDTotal] [decimal] (15, 0) NULL,
[ScheduledCollateralMovementAmountFFDSignTseDirectDeposit] [varchar] (1) NULL,
[ScheduledCollateralMovementAmountFFDTseDirectDeposit] [decimal] (15, 0) NULL,
[ScheduledCollateralMovementAmountFFDSignTseDirectDepositSigned] [decimal] (15, 0) NULL,
[ScheduledCollateralMovementAmountFFDSignOseDirectDeposit] [varchar] (1) NULL,
[CollateralMovementScheduledAmountFFDOseDirectDeposit] [decimal] (15, 0) NULL,
[ScheduledCollateralMovementAmountFFDSignOseDirectDepositSigned] [decimal] (15, 0) NULL,
[ScheduledCollateralMovementAmountFFDSignMemberDirect] [varchar] (1) NULL,
[ScheduledCollateralMovementAmountFFDMemberDirectDeposit] [decimal] (15, 0) NULL,
[ScheduledCollateralMovementAmountFFDSignMemberDirectSigned] [decimal] (15, 0) NULL,
[ScheduledCollateralMovementAmountFFDSignDepositForReplacement] [varchar] (1) NULL,
[ScheduledCollateralMovementAmountFFDDepositForReplacement] [decimal] (15, 0) NULL,
[ScheduledCollateralMovementAmountFFDSignDepositForReplacementSigned] [decimal] (15, 0) NULL,
[ScheduledCollateralMovementAmountFFDSignTotal] [varchar] (1) NULL,
[ScheduledCollateralMovementAmountFFDTotal] [decimal] (15, 0) NULL,
[ScheduledCollateralMovementAmountFFDSignTotalSigned] [decimal] (15, 0) NULL,
[CollateralNonCalculableFlagTotal] [varchar] (1) NULL,
[TotalMarginMoneySign] [varchar] (1) NULL,
[TotalMarginMoney] [decimal] (15, 0) NULL,
[TotalMarginMoneySigned] [decimal] (15, 0) NULL,
[MarginRequirementTse] [decimal] (15, 0) NULL,
[MarginRequirementOse] [decimal] (15, 0) NULL,
[MarginRequirementExchangeTotal] [decimal] (15, 0) NULL,
[RequiredAmountNonCalculableFlagTotal] [varchar] (1) NULL,
[MarginDeficitExcessAmountTotalSign] [varchar] (1) NULL,
[MarginDeficitExcessAmountTotal] [decimal] (15, 0) NULL,
[MarginDeficitExcessAmountTotalSigned] [decimal] (15, 0) NULL,
[MarginDeficitExcessAmountCashSign] [varchar] (1) NULL,
[MarginDeficitExcessAmountCash] [decimal] (15, 0) NULL,
[MarginDeficitExcessAmountCashSigned] [decimal] (15, 0) NULL,
[MarginDeficitExcessAmountCollateralSign] [varchar] (1) NULL,
[MarginDeficitExcessAmountCollateral] [decimal] (15, 0) NULL,
[MarginDeficitExcessAmountCollateralSigned] [decimal] (15, 0) NULL,
[StandardReceiptPaymentAmountSign] [varchar] (1) NULL,
[StandardReceiptPaymentAmount] [decimal] (15, 0) NULL,
[StandardReceiptPaymentAmountSigned] [decimal] (15, 0) NULL,
[ReceiptPaymentDate] [datetime] NULL,
[ScheduledReceiptPaymentAmountFFDSign] [varchar] (1) NULL,
[ScheduledReceiptPaymentAmountFFD] [decimal] (15, 0) NULL,
[ScheduledReceiptPaymentAmountFFDSigned] [decimal] (15, 0) NULL,
[ScheduledReceiptPaymentAmountForDayAfterNextSign] [varchar] (1) NULL,
[ScheduledReceiptPaymentAmountForDayAfterNext] [decimal] (15, 0) NULL,
[ScheduledReceiptPaymentAmountForDayAfterNextSigned] [decimal] (15, 0) NULL,
[ScheduledCollateralMovementAmountForDayAfterNextSign] [varchar] (1) NULL,
[ScheduledCollateralMovementAmountForDayAfterNext] [decimal] (15, 0) NULL,
[ScheduledCollateralMovementAmountForDayAfterNextSigned] [decimal] (15, 0) NULL,
[LongOptionValue] [decimal] (15, 0) NULL,
[ShortOptionValue] [decimal] (15, 0) NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_is_GAccountTotal_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NULL CONSTRAINT [DF_GAccountTotal_CreationDate] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_GAccountTotal] on [dbo].[is_GAccountTotal]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[is_GAccountTotal] ADD CONSTRAINT [PK_GAccountTotal] PRIMARY KEY CLUSTERED  ([GAccountTotalId])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[is_GAccountAttribute]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[is_GAccountAttribute]
(
[GAccountAttributeId] [int] NOT NULL IDENTITY(1, 1),
[CorporationCode] [varchar] (4) NULL,
[PrincipalBrokerageID] [varchar] (1) NULL,
[OfficeCode] [varchar] (4) NULL,
[ACNumber] [varchar] (10) NULL,
[RecordID] [varchar] (2) NULL,
[BaseDate] [datetime] NULL,
[CalculationDate] [datetime] NULL,
[CalculationStartTime] [datetime] NULL,
[CalculationDateStartTime] [datetime] NULL,
[SettlementCycle] [varchar] (1) NULL,
[SettlementType] [varchar] (2) NULL,
[Remarks] [varchar] (45) NULL,
[AccountOpenIDTSE] [varchar] (1) NULL,
[AccountOpenIDOSE] [varchar] (1) NULL,
[DailyStatementID] [varchar] (1) NULL,
[DailyStatementIDTradeDetails] [varchar] (1) NULL,
[DailyStatementIDAccountTotal] [varchar] (1) NULL,
[DailyStatementIDUnclosedContract] [varchar] (1) NULL,
[DailyStatementIDReceiptRepaymentMovement] [varchar] (1) NULL,
[DailyStatementIDCollateralSecuritiesMovement] [varchar] (1) NULL,
[DailyStatementIDCollateralSecuritiesDetails] [varchar] (1) NULL,
[BusinessID] [varchar] (2) NULL,
[TrustBankBranchCode] [varchar] (4) NULL,
[FundNumber] [int] NULL,
[FundName] [varchar] (20) NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_is_GAccountAttribute_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NULL CONSTRAINT [DF_GAccountAttribute_CreationDate] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_GAccountAttribute] on [dbo].[is_GAccountAttribute]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[is_GAccountAttribute] ADD CONSTRAINT [PK_GAccountAttribute] PRIMARY KEY CLUSTERED  ([GAccountAttributeId])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[IDEM_DS14]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[IDEM_DS14]
(
[IDEM_DS14_Id] [int] NOT NULL IDENTITY(1, 1),
[MemberClearingCode] [varchar] (4) NULL,
[DataFileCode] [varchar] (4) NULL,
[RecordNumber] [varchar] (6) NULL,
[Date] [varchar] (8) NULL,
[ABIMemberCode] [varchar] (5) NULL,
[Account] [varchar] (1) NULL,
[SubAccount] [varchar] (4) NULL,
[Symbol] [varchar] (6) NULL,
[Expiry] [varchar] (8) NULL,
[Strike] [varchar] (13) NULL,
[ProductType] [varchar] (1) NULL,
[InfoType] [varchar] (2) NULL,
[ISINCode] [varchar] (12) NULL,
[Description] [varchar] (20) NULL,
[LongPositions] [varchar] (20) NULL,
[LongPositionsSign] [varchar] (1) NULL,
[ShortPositions] [varchar] (50) NULL,
[ShortPositionsSign] [varchar] (1) NULL,
[OpenClose] [varchar] (1) NULL,
[BuySell] [varchar] (1) NULL,
[MarginValue] [varchar] (13) NULL,
[DebitCredit] [varchar] (1) NULL,
[ReferenceNumber] [varchar] (8) NULL,
[Price] [varchar] (13) NULL,
[SettlementPrice] [varchar] (13) NULL,
[ReferenceDate] [varchar] (8) NULL,
[GCMABIcode] [varchar] (5) NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_IDEM_DS14_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_IDEM_DS14_CreateDate] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_IDEM_DS14] on [dbo].[IDEM_DS14]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[IDEM_DS14] ADD CONSTRAINT [PK_IDEM_DS14] PRIMARY KEY CLUSTERED  ([IDEM_DS14_Id])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[IDEM_DS13]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[IDEM_DS13]
(
[IDEM_D13_ID] [int] NOT NULL IDENTITY(1, 1),
[MemberClearCode] [varchar] (4) NULL,
[DataFileCode] [varchar] (4) NULL,
[RecordNumber] [varchar] (6) NULL,
[Date] [varchar] (8) NULL,
[ABIMemberCode] [varchar] (5) NULL,
[MarketCode] [varchar] (2) NULL,
[Account] [varchar] (1) NULL,
[PositionType] [varchar] (1) NULL,
[Symbol] [varchar] (6) NULL,
[InstrumentType] [varchar] (1) NULL,
[Expiry] [varchar] (8) NULL,
[OptionType] [varchar] (1) NULL,
[RepoType] [varchar] (1) NULL,
[StrikePrice] [varchar] (13) NULL,
[IsinCode] [varchar] (12) NULL,
[Description] [varchar] (20) NULL,
[LongPosition] [varchar] (10) NULL,
[ShortPosition] [varchar] (10) NULL,
[LongPositionCounterValue] [varchar] (17) NULL,
[ShortPositionCounterValue] [varchar] (17) NULL,
[LongAccruedCoupen] [varchar] (17) NULL,
[ShortAccruedCoupen] [varchar] (17) NULL,
[CurrencyCode] [varchar] (2) NULL,
[UnderlyingPrice] [varchar] (13) NULL,
[GCMABICode] [varchar] (5) NULL,
[DeliveryABICode] [varchar] (5) NULL,
[DeliveryAccount] [varchar] (5) NULL,
[PositionAlreadyDelivered] [varchar] (50) NULL,
[ValoreSottostante] [varchar] (13) NULL,
[FailExecution] [varchar] (1) NULL,
[BondShareCash] [varchar] (1) NULL,
[BonisMalis] [varchar] (1) NULL,
[Multiplier] [varchar] (6) NULL,
[SubAccount] [varchar] (4) NULL,
[SettlementPrice] [varchar] (13) NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_IDEM_DS13_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_IDEM_DS13_CreateDate] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_IDEM_DS13] on [dbo].[IDEM_DS13]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[IDEM_DS13] ADD CONSTRAINT [PK_IDEM_DS13] PRIMARY KEY CLUSTERED  ([IDEM_D13_ID])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[HKFE_TP001_Header]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[HKFE_TP001_Header]
(
[Header_Id] [int] NOT NULL IDENTITY(1, 1),
[RecordType] [varchar] (2) NULL,
[FileId] [varchar] (5) NULL,
[Source] [varchar] (5) NULL,
[BusinessDate] [varchar] (8) NULL,
[CreationDateTime] [varchar] (14) NULL,
[ClearingHouse] [varchar] (50) NULL,
[NoOfDetailRecordTypes] [varchar] (2) NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_HKFE_Header_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_HKFE_Header_CreateDate] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_HKFE_Header] on [dbo].[HKFE_TP001_Header]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[HKFE_TP001_Header] ADD CONSTRAINT [PK_HKFE_Header] PRIMARY KEY CLUSTERED  ([Header_Id])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[GMI_ST4F1]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[GMI_ST4F1]
(
[GMI_ST4F1ID] [int] NOT NULL IDENTITY(1, 1),
[RecordID] [varchar] (1) NULL,
[FirmID] [varchar] (1) NULL,
[OfficeNumber] [varchar] (3) NULL,
[AccountNumber] [varchar] (5) NULL,
[ContractYrMth] [varchar] (6) NULL,
[SubCusip] [varchar] (2) NULL,
[SecuritySubType] [varchar] (1) NULL,
[StrikePrice] [decimal] (15, 8) NULL,
[ExpirationDate] [varchar] (9) NULL,
[TradeDate] [varchar] (9) NULL,
[TradePrice] [decimal] (15, 8) NULL,
[BuySellCode] [varchar] (1) NULL,
[SpreadCode] [varchar] (1) NULL,
[AccountClassCode] [varchar] (1) NULL,
[SubClassCode] [varchar] (1) NULL,
[Quantity] [decimal] (19, 4) NULL,
[ExchangeCode] [varchar] (2) NULL,
[FuturesCode] [varchar] (2) NULL,
[ContractTypeCode] [varchar] (1) NULL,
[PrintableTradePrice] [varchar] (20) NULL,
[InputExercisePrice] [varchar] (7) NULL,
[InputTradePrice] [varchar] (12) NULL,
[ProductCurrencySymbol] [varchar] (3) NULL,
[ProductCurrencyCode] [varchar] (2) NULL,
[ExecutingBroker] [varchar] (5) NULL,
[OppositeFirm] [varchar] (5) NULL,
[GiveInOutCode] [varchar] (2) NULL,
[GiveInOutFirm] [varchar] (5) NULL,
[InterExchangeExchange] [varchar] (2) NULL,
[InterExchangeFirm] [varchar] (5) NULL,
[CardNumber] [varchar] (4) NULL,
[FuturesTradeType] [varchar] (1) NULL,
[CommisionAmount] [decimal] (15, 2) NULL,
[ClearingFee] [decimal] (15, 2) NULL,
[ExchFee] [decimal] (15, 2) NULL,
[FeeNFA] [decimal] (15, 2) NULL,
[FeeExecCharge] [decimal] (15, 2) NULL,
[FeeAmt5Fee] [decimal] (15, 2) NULL,
[FeeAmount6] [decimal] (15, 2) NULL,
[FeeAmount7] [decimal] (15, 2) NULL,
[FeeAmount8] [decimal] (15, 2) NULL,
[FeeAmount9] [decimal] (15, 2) NULL,
[GiveInOutCharge] [decimal] (15, 2) NULL,
[BrokerageCharge] [decimal] (15, 2) NULL,
[OtherCharges] [decimal] (15, 2) NULL,
[GrossAmount] [decimal] (15, 2) NULL,
[BackOfficeCharge] [decimal] (15, 2) NULL,
[WireCharges] [decimal] (15, 2) NULL,
[AccountTypeCommissionPosted] [varchar] (2) NULL,
[AccountTypeFee1Posted] [varchar] (2) NULL,
[AccountTypeFee2Posted] [varchar] (2) NULL,
[AccountTypeFee3Posted] [varchar] (2) NULL,
[AccountTypeFee4Posted] [varchar] (2) NULL,
[AccountTypeFee5Posted] [varchar] (2) NULL,
[AccountTypeFee6Posted] [varchar] (2) NULL,
[AccountTypeFee7Posted] [varchar] (2) NULL,
[AccountTypeFee8Posted] [varchar] (2) NULL,
[AccountTypeFee9Posted] [varchar] (2) NULL,
[AccountTypeGiveInOutAmount] [varchar] (2) NULL,
[AccountTypeBrockeragePosted] [varchar] (2) NULL,
[AccountTypeOtherChargesPos] [varchar] (2) NULL,
[PosFileSortKey] [varchar] (50) NULL,
[Countrycode] [varchar] (2) NULL,
[Symbol] [varchar] (6) NULL,
[ImportFileId] [int] NOT NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_GMI_ST4F1_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_GMI_ST4F1_CreateDate] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_GMI_ST4F1] on [dbo].[GMI_ST4F1]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[GMI_ST4F1] ADD CONSTRAINT [PK_GMI_ST4F1] PRIMARY KEY CLUSTERED  ([GMI_ST4F1ID])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[GMI_PPMF1]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[GMI_PPMF1]
(
[GMI_PPMF1ID] [int] NOT NULL IDENTITY(1, 1),
[ImportFileId] [int] NOT NULL,
[CUSIPNumber] [varchar] (12) NULL,
[Contract] [varchar] (6) NULL,
[DecimalStrikePrice] [varchar] (15) NULL,
[SecurityTypeCode] [varchar] (1) NULL,
[SecuritySubCode] [varchar] (1) NULL,
[SubCusip] [varchar] (2) NULL,
[Symbol] [varchar] (6) NULL,
[UnderlyingCusipNumber] [varchar] (12) NULL,
[SecurityDescLine1] [varchar] (30) NULL,
[DateRecordWasOpened] [varchar] (9) NULL,
[DateRecordLastChange] [varchar] (9) NULL,
[MultiplicationFactor] [varchar] (15) NULL,
[CountryCode] [varchar] (2) NULL,
[ProductCurrencyCode] [varchar] (2) NULL,
[ExchangeCode] [varchar] (2) NULL,
[StrikePriceEditCode] [varchar] (1) NULL,
[TradePriceEditCode] [varchar] (1) NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_GMI_PPMF1_LoadStateChange] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_GMI_PPMF1_CreateDate] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_GMI_PPMF1] on [dbo].[GMI_PPMF1]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[GMI_PPMF1] ADD CONSTRAINT [PK_GMI_PPMF1] PRIMARY KEY CLUSTERED  ([GMI_PPMF1ID])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[Account]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[Account]
(
[AccountId] [int] NOT NULL IDENTITY(1, 1),
[LedgerCode] [varchar] (100) NULL,
[ActiveAccount] [varchar] (100) NULL,
[LedgerName] [varchar] (100) NULL,
[SalesCode] [varchar] (100) NULL,
[Class] [varchar] (100) NULL,
[BusinessType] [varchar] (100) NULL,
[FileName] [varchar] (512) NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [AccountLoadStateDefaultConstraint] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [AccountCreateDateDefaultConstraint] DEFAULT (getdate()),
[FamilyCode] [varchar] (100) NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [AccountPrimaryKeyConstraint] on [dbo].[Account]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[Account] ADD CONSTRAINT [AccountPrimaryKeyConstraint] PRIMARY KEY CLUSTERED  ([AccountId])
');

GO
EXECUTE ('PRINT N''Creating [admin].[PurgeData_TempTables]''
');

GO
EXECUTE ('CREATE PROCEDURE [admin].[PurgeData_TempTables]

AS
-- =============================================
-- Author:		ED
-- Create date: 04 Jul 2014
-- Description:	purge data
-- 04 Jul 2014   ED   Create
-- 29 Jul 2014   ED   EIB 25856 - clean also CME tables
-- =============================================
BEGIN
	SET NOCOUNT ON;

	DECLARE @end DATETIME

	SET @end = DATEADD(d, -7, GETDATE())

	---------------------------------------------------------------------
	---------------------------------------------------------------------
	--temp tables--------------------------------------------------------
	---------------------------------------------------------------------
	---------------------------------------------------------------------

	DELETE FROM account WHERE CreateDate < @end

	DELETE FROM broker_position WHERE CreateDate < @end
	DELETE FROM broker_transaction WHERE CreateDate < @end

	DELETE FROM c21_detailline WHERE CreateDate < @end
	DELETE FROM c21_footer WHERE CreateDate < @end
	DELETE FROM c21_header WHERE CreateDate < @end
	DELETE FROM c21_previousdayline WHERE CreateDate < @end
	DELETE FROM c21_resumeline WHERE CreateDate < @end

	DELETE FROM eu_cb010grp WHERE CreateDate < @end
	DELETE FROM eu_cc040grp WHERE CreateDate < @end

	DELETE FROM gmi_extf1 WHERE CreateDate < @end
	DELETE FROM gmi_futm WHERE CreateDate < @end
	DELETE FROM gmi_gnacmff1 WHERE CreateDate < @end
	DELETE FROM gmi_mast WHERE CreateDate < @end
	DELETE FROM gmi_mnyf1 WHERE CreateDate < @end
	DELETE FROM gmi_posf1 WHERE CreateDate < @end
	DELETE FROM gmi_ppmf1 WHERE CreateDate < @end
	DELETE FROM gmi_st4f1 WHERE CreateDate < @end

	DELETE FROM hkfe_tp001_header WHERE CreateDate < @end
	DELETE FROM hkfe_tp001_type01 WHERE CreateDate < @end
	DELETE FROM hkfe_tp001_type02 WHERE CreateDate < @end

	DELETE FROM ICE_TrdCaptRpt WHERE CreateDate < @end
	DELETE FROM ICE_PosRpt WHERE CreateDate < @end
	DELETE FROM ICE_AsgnRpt WHERE CreateDate < @end

	DELETE FROM idem_ds13 WHERE CreateDate < @end
	DELETE FROM idem_ds14 WHERE CreateDate < @end

	DELETE FROM is_gaccountattribute WHERE CreateDate < @end
	DELETE FROM is_gaccounttotal WHERE CreateDate < @end
	DELETE FROM is_gcollateralsecuritiesdetails WHERE CreateDate < @end
	DELETE FROM is_gcollateralsecuritiesmovement WHERE CreateDate < @end
	DELETE FROM is_gproducttotal WHERE CreateDate < @end
	DELETE FROM is_grealizedprofitlossdetails WHERE CreateDate < @end
	DELETE FROM is_greceiptpaymentdetails WHERE CreateDate < @end
	DELETE FROM is_gtradedetails WHERE CreateDate < @end
	DELETE FROM is_gunclosedcontractdetails WHERE CreateDate < @end

	DELETE FROM is_haccountattribute WHERE CreateDate < @end
	DELETE FROM is_haccounttotal WHERE CreateDate < @end
	DELETE FROM is_hcollateralsecuritiesdetails WHERE CreateDate < @end
	DELETE FROM is_hcollateralsecuritiesmovement WHERE CreateDate < @end
	DELETE FROM is_hproducttotal WHERE CreateDate < @end
	DELETE FROM is_hrealizedprofitlossdetails WHERE CreateDate < @end
	DELETE FROM is_hreceiptpaymentdetails WHERE CreateDate < @end
	DELETE FROM is_htradedetails WHERE CreateDate < @end
	DELETE FROM is_hunsettledcontractdetails WHERE CreateDate < @end

	DELETE FROM lch_typent WHERE CreateDate < @end
	DELETE FROM lch_typeps_0101 WHERE CreateDate < @end
	DELETE FROM lch_typetr WHERE CreateDate < @end

	DELETE FROM liffe_notification WHERE CreateDate < @end
	DELETE FROM liffe_position WHERE CreateDate < @end
	DELETE FROM liffe_tradereport WHERE CreateDate < @end

	DELETE FROM dgcx_position WHERE CreateDate < @end
	DELETE FROM dgcx_transaction WHERE CreateDate < @end

	DELETE FROM bancosantander_hostopn WHERE CreateDate < @end
	DELETE FROM bancosantander_hosttrn WHERE CreateDate < @end

	-- DO NOT DELETE Peoplesoft since app reads that data for integrity checks
	-- DELETE FROM peoplesoft WHERE CreateDate < @end

	DELETE FROM rolfenolan_codes WHERE CreateDate < @end
	DELETE FROM rolfenolan_hostopn WHERE CreateDate < @end
	DELETE FROM rolfenolan_hosttrn WHERE CreateDate < @end

	DELETE FROM swift_mt940 WHERE CreateDate < @end
	DELETE FROM swift_mt950 WHERE CreateDate < @end

	DELETE FROM creditsuisse_position WHERE CreateDate < @end
	DELETE FROM creditsuisse_transaction WHERE CreateDate < @end

	DELETE FROM stage.LmePosition WHERE CreateDate < @end
	DELETE FROM stage.LmeTrade WHERE CreateDate < @end
	DELETE FROM stage.LmePositionsRealisedCash WHERE CreateDate < @end

	DELETE FROM stage.CME_AsgnRpt WHERE CreateDate < @end
	DELETE FROM stage.CME_PosRpt WHERE CreateDate < @end
	DELETE FROM stage.CME_TrdCaptRpt WHERE CreateDate < @end

	DELETE FROM stage.MacquariePosition WHERE CreateDate < @end
	DELETE FROM stage.MacquarieTrade WHERE CreateDate < @end

	DELETE FROM stage.BmfPosition WHERE CreateDate < @end
	DELETE FROM stage.BmfTrade WHERE CreateDate < @end
	DELETE FROM stage.BmfPositionsRealisedCash WHERE CreateDate < @end

	DELETE FROM stage.Europower WHERE CreateDate < @end

	DELETE FROM stage.RosenthalCollinsPosition WHERE CreateDate < @end
	DELETE FROM stage.RosenthalCollinsTrade WHERE CreateDate < @end

	DELETE FROM stage.MGEPosition WHERE CreateDate < @end
	DELETE FROM stage.MGETrade WHERE CreateDate < @end

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Template_GetTemplateById]''
');

GO
EXECUTE ('
 /*
<details>
 <summary> Selectes a template from the ib_Template table by its id</summary>
 <created author="Laurentiu Macovei" Date="Tuesday, 12 September 2006 9:34PM GMT" /> 
</details>
*/
CREATE PROCEDURE [dbo].[ib_Template_GetTemplateById]
(
	@TemplateId int
)
AS 
SET NOCOUNT ON


SELECT [TemplateId]
      ,[TypeCode]
      ,[Description]
      ,[CreateDate]
      ,[CreateUsername]
      ,[UpdateDate]
      ,[UpdateUsername]
  FROM [dbo].[ib_Template]
WHERE TemplateId = @TemplateId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Nostro_GetMatchCodesWithSecurity]''
');

GO
SET ANSI_NULLS OFF

GO
EXECUTE ('
--	06 Oct 2009	AAJM	Creation
--  04 May 2012 ED		Add firm for filtering
--	15 May 2012 ED		MBAL 19859 - fix duplicate if no firm selected
CREATE PROCEDURE [dbo].[ib_Nostro_GetMatchCodesWithSecurity]
(
	@TemplateId INT = NULL,
	@UserId UNIQUEIDENTIFIER,
	@FirmId INT = NULL
)
AS
SET NOCOUNT ON
BEGIN

	IF @TemplateId IS NULL
		SELECT mc.MatchCode, mc.MatchCodeId
		FROM ib_MatchCode mc
			INNER JOIN ib_Template t ON mc.TemplateId = t.TemplateId
			INNER JOIN ib_UserMatchCodeAccess umca ON umca.UserId = @UserId AND umca.MatchCodeId = mc.MatchCodeId 
			INNER JOIN ib_AccessRight ar ON umca.AccessRightId = ar.AccessRightId
			INNER JOIN ib_TemplateGroup tg ON tg.templateId = mc.TemplateId AND mc.MatchCode = tg.Description AND (@FirmId IS NULL OR tg.FirmId = @FirmId)
		WHERE t.TypeCode = ''Nostro Rec'' AND (ar.Code = ''ReadOnly'' OR ar.Code = ''Full'')
		ORDER BY mc.MatchCode
	ELSE
		SELECT DISTINCT mc.MatchCode, mc.MatchCodeId
		FROM ib_MatchCode mc
		INNER JOIN ib_UserMatchCodeAccess umca ON umca.UserId = @UserId AND umca.MatchCodeId = mc.MatchCodeId 
		INNER JOIN ib_AccessRight ar ON umca.AccessRightId = ar.AccessRightId
		INNER JOIN ib_TemplateGroup tg ON tg.templateId = mc.TemplateId AND mc.MatchCode = tg.Description AND (@FirmId IS NULL OR tg.FirmId = @FirmId)
		WHERE mc.TemplateId = @TemplateId AND (ar.Code = ''ReadOnly'' OR ar.Code = ''Full'')
		ORDER BY mc.MatchCode
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ReceiveLocation_Delete]''
');

GO
SET ANSI_NULLS ON

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Deletes a record in the ReceiveLocation table
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[ReceiveLocation_Delete]
(

	@ReceiveLocationSysId tinyint   
)
AS


				DELETE FROM [dbo].[ReceiveLocation] WITH (ROWLOCK) 
				WHERE
					[ReceiveLocationSysId] = @ReceiveLocationSysId
					
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_EquityHeader_SelectByEquityHeaderId]''
');

GO
EXECUTE ('
/*
Created By:  McQuien
Date:  2006-11-23

Purpose:  Selects records into equity header based on equityheaderid in order to construct the equity reports.

Modifications:
SWA 23/12/2006 - Changed Exchange join to outer to revolve point 1 in IBAL-2624
*/



CREATE Proc [dbo].[ib_EquityHeader_SelectByEquityHeaderId]
@EquityHeaderId int

as
SET NOCOUNT ON

SELECT  distinct b.equityheaderid as Id,f.name as Exchange,g.name as Account,c.description as Currency,e.description as [Match Code],b.section1signoffdate as [Section1 SignOff],section2signoffdate as [Section2 SignOff],section3signoffdate as [Section3 SignOff],b.templateid
FROM ib_Currency c 
INNER JOIN ib_EquityHeader b on
c.currencyid = b.currencyid
INNER JOIN ib_SiteTemplate d on
b.templateid = d.templateid
INNER JOIN ib_TemplateGroup e on
b.TemplateId = e.templateid
and b.templategroupdescription = e.description
LEFT OUTER JOIN ib_Exchange f on
e.ExchangeId = f.exchangeid
inner join ib_account g on
e.accountid = g.accountid
WHERE b.equityheaderid = @EquityHeaderId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TemplateCompare_CheckForDuplicate]''
');

GO
EXECUTE ('  /*
<details>
 <summary>
	Checks for the duplicate template compares with same code. 
</summary>
   <created author="laurentiu.macovei" date="Fri, 29 Sep 2006 13:19:55 GMT"/>
</details>
*/
create PROCEDURE [dbo].[ib_TemplateCompare_CheckForDuplicate]
@TemplateId int,
@FirmId int,
@DataSourceId int,
@InternalExternalCode char(1),
@TemplateCompareId int
AS
SET NOCOUNT ON

DECLARE @Count int
DECLARE @TemplateDescription varchar(100)
DECLARE @FirmCode varchar(100)
DECLARE @DataSourceCode varchar(100)

SELECT TOP 1 @Count = 1, @FirmCode = i.Code, @DataSourceCode = ds.Code, @TemplateDescription = t.Description
	FROM [dbo].[ib_TemplateCompare] tc
	INNER JOIN [dbo].[ib_DataSource] ds 
		ON tc.DataSourceId = ds.DataSourceId
	INNER JOIN [dbo].[ib_Template] t 
		ON tc.TemplateId = t.TemplateId
	INNER JOIN [dbo].[ib_Firm] i 
		ON tc.FirmId = i.FirmId
	WHERE tc.TemplateId = @TemplateId
		AND tc.FirmId = @FirmId
		AND tc.DataSourceId = @DataSourceId
		AND tc.TemplateCompareID <> @TemplateCompareId

IF @Count > 0
	RAISERROR (N''There is already another Template Compare with same Template (%s), same Firm (%s) and same Data Source (%s). Please specify other values!'', 11, 1, @TemplateDescription, @FirmCode, @DataSourceCode)

SET @Count = 0

SELECT TOP 1 @Count = 1, @FirmCode = i.Code, @TemplateDescription = t.Description
	FROM [dbo].[ib_TemplateCompare] tc
	INNER JOIN [dbo].[ib_Template] t 
		ON tc.TemplateId = t.TemplateId
	INNER JOIN [dbo].[ib_Firm] i 
		ON tc.FirmId = i.FirmId
	WHERE tc.TemplateId = @TemplateId
		AND tc.FirmId = @FirmId
		AND tc.InternalExternalCode = @InternalExternalCode
		AND tc.TemplateCompareID <> @TemplateCompareId

IF @Count > 0
	RAISERROR (N''There is already another Template Compare with same Template (%s), same Firm (%s) and same Internal External Code (%s). Please specify other values!'', 11, 1, @TemplateDescription, @FirmCode, @InternalExternalCode)
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TemplateCompare_Add]''
');

GO
EXECUTE (' /*
<details>
 <summary>Adds a template compare into the ib_TemplateCompare table</summary>
 <created author="Laurentiu Macovei" Date="Friday, 8 September 2006 11:56PM GMT" /> 
 <updated author="laurentiu.macovei" date="Fri, 29 Sep 2006 14:40:29 GMT">
	Check for duplicates
 </updated>
</details>
*/
CREATE PROCEDURE [dbo].[ib_TemplateCompare_Add]
(
	 @TemplateId int,
	 @DataSourceId int,
     @FirmId int,
     @InternalExternalCode char(1),
     @CreateUsername varchar(50),
	 @@TemplateCompareId int OUTPUT
)
AS
SET NOCOUNT ON
BEGIN TRY
--check for duplicates 
EXEC [dbo].[ib_TemplateCompare_CheckForDuplicate] @TemplateId, @FirmId, @DataSourceId, @InternalExternalCode, -1


INSERT INTO [dbo].[ib_TemplateCompare]
           ([TemplateId]
           ,[DataSourceId]
           ,[FirmId]
           ,[InternalExternalCode]
           ,[CreateUsername])
     VALUES
           (@TemplateId,
           @DataSourceId,
           @FirmId, 
           @InternalExternalCode,
           @CreateUsername)

SELECT @@TemplateCompareId = Scope_Identity()
END TRY
BEGIN CATCH
	EXEC [dbo].[sp_RethrowError]
END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[GMI_POSF1_LoadStateChange]''
');

GO
EXECUTE ('


-- =============================================
-- Author:		Lee Manifold
-- Create date: 18 Jul 2006
-- Description:	Changes the LoadState of the GMI_POSF1 type table
--
-- History
--
-- Date			Author			Description
-- 28 Feb 2007	LM				Added Extra field ImportFileId
-- =============================================
CREATE PROCEDURE [dbo].[GMI_POSF1_LoadStateChange] 
	-- Add the parameters for the stored procedure here
	(
	@OldLoadState	TINYINT,
	@NewLoadState	TINYINT,
	@RecordDate		DATETIME = NULL,
	@ImportFileId	INT
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	-- Need to add code to handle RecordDate
	IF @RecordDate IS NOT NULL 
	BEGIN

		UPDATE [dbo].[GMI_POSF1] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState AND ImportFileId = @ImportFileId

	END

	IF @RecordDate IS NULL 
	BEGIN

		UPDATE [dbo].[GMI_POSF1] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState AND ImportFileId = @ImportFileId

	END


END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[SWIFT_MT940_Add]''
');

GO
EXECUTE ('
-- =============================================
-- Author:		Petru Konrad Bercea
-- Create date: 21.01.2009
-- Description:	Insert into SWIFT_MT940 table
--
--	Revision History 
--
--  Konrad 15.04.2009 Added FileName field
--  Konrad 23.04.2009 Changed the type of @StatmtNoSeqNo_28C from decimal to varchar(5)
-- =============================================
CREATE PROCEDURE [dbo].[SWIFT_MT940_Add]
	-- Add the parameters for the stored procedure here
	(
	@FileName								varchar(512) = Null,
	@AppId									varchar(1) = Null ,
	@ServiceId								tinyint = Null ,
	@LTAdrs									varchar(12) = Null ,
    @SessionNo								varchar(4) = Null ,
	@SequenceNo								varchar(6) = Null ,
	@AppHBlckInpMsgType						varchar(3) = Null ,
	@AppHBlckInpDestAdrs					varchar(12) = Null ,
	@AppHBlckInpMsgPriority					varchar(1) = Null ,
	@AppHBlckInpDelivMonitoring				varchar(1) = Null ,
	@AppHBlckInpObslscPeriod				varchar(3) = Null ,
	@AppHBlckOutpMsgType					varchar(3) = Null ,
	@AppHBlckOutInpTime						varchar(4) = Null ,
	@AppHBlckOutMsgRefInpDate				varchar(6) = Null ,
	@AppHBlckOutMsgRefLTAdrs				varchar(12) = Null ,
	@AppHBlckOutMsgRefSessionNo				varchar(4) = Null ,
	@AppHBlckOutMsgRefSeqNo					varchar(6) = Null ,
	@AppHBlckOutMsgRefOutpDate				varchar(6) = Null ,
	@AppHBlckOutMsgRefOutpTime				varchar(4) = Null ,
	@AppHBlckOutMsgRefMsgPriority			varchar(1) = Null ,
	@FINServiceId_103						varchar(3) = Null ,
	@BankingPriority_113					varchar(4) = Null ,
	@MsgUserRef_108							varchar(16) = Null ,
	@ValidationFlag_119						varchar(8) = Null ,
	@AddresseeInfo_115						varchar(32) = Null ,
	@Swift_HTextBlock						varchar(max) = Null ,
	@TrxRefNo_20							varchar(16) = Null ,
	@RelatedRef_21							varchar(16) = Null ,
	@AccountId_25							varchar(35) = Null ,
	@StatmtNo_28C							varchar(5) = Null ,
	@StatmtNoSeqNo_28C						varchar(5) = Null ,
	@OpenBalance_60F_DCMark					char(1) = Null ,
	@OpenBalance_60F_Date					varchar(6) = Null ,
	@OpenBalance_60F_CurrencyCode			varchar(3) = Null ,
	@OpenBalance_60F_Amount					varchar(15) = Null ,
	@OpenBalance_60M_DCMark					char(1) = Null ,
	@OpenBalance_60M_Date					varchar(6) = Null ,
	@OpenBalance_60M_CurrencyCode			varchar(3) = Null ,
	@OpenBalance_60M_Amount					varchar(15) = Null ,
	@StatmtLine_61							varchar(66) = Null ,
	@StatmtLine_61_SupplemDetails			varchar(34) = Null ,
	@InfoToAccOwn_1_86_line1				varchar(65) = Null ,
	@InfoToAccOwn_1_86_line2				varchar(65) = Null ,
	@InfoToAccOwn_1_86_line3				varchar(65) = Null ,
	@InfoToAccOwn_1_86_line4				varchar(65) = Null ,
	@InfoToAccOwn_1_86_line5				varchar(65) = Null ,
    @InfoToAccOwn_1_86_line6				varchar(65) = Null ,
    @ClosingBalance_62F_DCMark				char(1) = Null ,
	@ClosingBalance_62F_Date				varchar(6) = Null ,
	@ClosingBalance_62F_CurrencyCode		varchar(3) = Null ,
	@ClosingBalance_62F_Amount				varchar(15) = Null ,
	@ClosingBalance_62M_DCMark				char(1) = Null ,
	@ClosingBalance_62M_Date				varchar(6) = Null ,
	@ClosingBalance_62M_CurrencyCode		varchar(3) = Null ,
	@ClosingBalance_62M_Amount				varchar(15) = Null ,
    @ClosingAvailBalance_64_DCMark			char(1) = Null ,
	@ClosingAvailBalance_64_Date			varchar(6) = Null ,
	@ClosingAvailBalance_64_CurrencyCode	varchar(3) = Null ,
	@ClosingAvailBalance_64_Amount			varchar(15) = Null , 
	@ForwardAvailBalance_65_DCMark			char(1) = Null ,
	@ForwardAvailBalance_65_Date			varchar(6) = Null ,
	@ForwardAvailBalance_65_CurrencyCode	varchar(3) = Null ,
	@ForwardAvailBalance_65_Amount			varchar(15) = Null , 
    @InfoToAccOwn_2_86_line1				varchar(65) = Null ,
	@InfoToAccOwn_2_86_line2				varchar(65) = Null ,
	@InfoToAccOwn_2_86_line3				varchar(65) = Null ,
	@InfoToAccOwn_2_86_line4				varchar(65) = Null ,
	@InfoToAccOwn_2_86_line5				varchar(65) = Null ,
    @InfoToAccOwn_2_86_line6				varchar(65) = Null ,
    @EndTextBlock							varchar(max) = Null ,
    @MAC									varchar(8) = Null ,
	@PAC									varchar(8) = Null ,
	@CHK									varchar(12) = Null ,
	@SYS									varchar(max) = Null ,
	@TNG									varchar(max) = Null ,
    @PDE									varchar(max) = Null ,
	@DLM									varchar(max) = Null ,
	@PDM									varchar(max) = Null ,
	@MRF									varchar(max) = Null ,
	@RTV									varchar(max) = Null ,
    @AllianceTrailerData					varchar(max) = Null  
    )
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

  INSERT INTO [dbo].[SWIFT_MT940]
			( 
			[AppId]
			,[ServiceId]
			,[LTAdrs]
			,[SessionNo]
			,[SequenceNo]
			,[AppHBlckInpMsgType]
			,[AppHBlckInpDestAdrs]
			,[AppHBlckInpMsgPriority]
			,[AppHBlckInpDelivMonitoring]
			,[AppHBlckInpObslscPeriod]
			,[AppHBlckOutpMsgType]
			,[AppHBlckOutInpTime]
			,[AppHBlckOutMsgRefInpDate]
			,[AppHBlckOutMsgRefLTAdrs]
			,[AppHBlckOutMsgRefSessionNo]
			,[AppHBlckOutMsgRefSeqNo]
			,[AppHBlckOutMsgRefOutpDate]
			,[AppHBlckOutMsgRefOutpTime]
			,[AppHBlckOutMsgRefMsgPriority]
			,[FINServiceId_103]
			,[BankingPriority_113]
			,[MsgUserRef_108]
			,[ValidationFlag_119]
			,[AddresseeInfo_115]
			,[Swift_HTextBlock]
			,[TrxRefNo_20]
			,[RelatedRef_21]
			,[AccountId_25]
			,[StatmtNo_28C]
			,[StatmtNoSeqNo_28C]
			,[OpenBalance_60F_DCMark]
			,[OpenBalance_60F_Date]
			,[OpenBalance_60F_CurrencyCode]
			,[OpenBalance_60F_Amount]
			,[OpenBalance_60M_DCMark]
			,[OpenBalance_60M_Date]
			,[OpenBalance_60M_CurrencyCode]
			,[OpenBalance_60M_Amount]
			,[StatmtLine_61]
			,[StatmtLine_61_SupplemDetails]
			,[InfoToAccOwn_1_86_line1]
			,[InfoToAccOwn_1_86_line2]
			,[InfoToAccOwn_1_86_line3]
			,[InfoToAccOwn_1_86_line4]
			,[InfoToAccOwn_1_86_line5]
			,[InfoToAccOwn_1_86_line6]
			,[ClosingBalance_62F_DCMark]
			,[ClosingBalance_62F_Date]
			,[ClosingBalance_62F_CurrencyCode]
			,[ClosingBalance_62F_Amount]
			,[ClosingBalance_62M_DCMark]
			,[ClosingBalance_62M_Date]
			,[ClosingBalance_62M_CurrencyCode]
			,[ClosingBalance_62M_Amount]
			,[ClosingAvailBalance_64_DCMark]
			,[ClosingAvailBalance_64_Date]
			,[ClosingAvailBalance_64_CurrencyCode]
			,[ClosingAvailBalance_64_Amount] 
			,[ForwardAvailBalance_65_DCMark]
			,[ForwardAvailBalance_65_Date]
			,[ForwardAvailBalance_65_CurrencyCode]
			,[ForwardAvailBalance_65_Amount]
			,[InfoToAccOwn_2_86_line1]
			,[InfoToAccOwn_2_86_line2]
			,[InfoToAccOwn_2_86_line3]
			,[InfoToAccOwn_2_86_line4]
			,[InfoToAccOwn_2_86_line5]
			,[InfoToAccOwn_2_86_line6]
			,[EndTextBlock] 
			,[MAC]
			,[PAC]
			,[CHK]
			,[SYS]
			,[TNG]
			,[PDE]
			,[DLM]
			,[PDM]
			,[MRF]
			,[RTV]
			,[AllianceTrailerData]
			,[FileName]
			)
    VALUES
			( 
			@AppId,
			@ServiceId,
			@LTAdrs,
			@SessionNo,
			@SequenceNo,
			@AppHBlckInpMsgType,
			@AppHBlckInpDestAdrs,
			@AppHBlckInpMsgPriority,
			@AppHBlckInpDelivMonitoring,
			@AppHBlckInpObslscPeriod,
			@AppHBlckOutpMsgType,
			@AppHBlckOutInpTime,
			@AppHBlckOutMsgRefInpDate,
			@AppHBlckOutMsgRefLTAdrs,
			@AppHBlckOutMsgRefSessionNo,
			@AppHBlckOutMsgRefSeqNo,
			@AppHBlckOutMsgRefOutpDate,
			@AppHBlckOutMsgRefOutpTime,
			@AppHBlckOutMsgRefMsgPriority,
			@FINServiceId_103,
			@BankingPriority_113,
			@MsgUserRef_108,
			@ValidationFlag_119,
			@AddresseeInfo_115,
			@Swift_HTextBlock,
			@TrxRefNo_20,
			@RelatedRef_21,
			@AccountId_25,
			@StatmtNo_28C,
			@StatmtNoSeqNo_28C,
			@OpenBalance_60F_DCMark,
			@OpenBalance_60F_Date,
			@OpenBalance_60F_CurrencyCode,
			@OpenBalance_60F_Amount,
			@OpenBalance_60M_DCMark,
			@OpenBalance_60M_Date,
			@OpenBalance_60M_CurrencyCode,
			@OpenBalance_60M_Amount,
			@StatmtLine_61,
			@StatmtLine_61_SupplemDetails,
			@InfoToAccOwn_1_86_line1,
			@InfoToAccOwn_1_86_line2,
			@InfoToAccOwn_1_86_line3,
			@InfoToAccOwn_1_86_line4,
			@InfoToAccOwn_1_86_line5,
			@InfoToAccOwn_1_86_line6,
			@ClosingBalance_62F_DCMark,
			@ClosingBalance_62F_Date,
			@ClosingBalance_62F_CurrencyCode,
			@ClosingBalance_62F_Amount,
			@ClosingBalance_62M_DCMark,
			@ClosingBalance_62M_Date,
			@ClosingBalance_62M_CurrencyCode,
			@ClosingBalance_62M_Amount,
			@ClosingAvailBalance_64_DCMark,
			@ClosingAvailBalance_64_Date,
			@ClosingAvailBalance_64_CurrencyCode,
			@ClosingAvailBalance_64_Amount, 
			@ForwardAvailBalance_65_DCMark,
			@ForwardAvailBalance_65_Date,
			@ForwardAvailBalance_65_CurrencyCode,
			@ForwardAvailBalance_65_Amount, 
			@InfoToAccOwn_2_86_line1,
			@InfoToAccOwn_2_86_line2,
			@InfoToAccOwn_2_86_line3,
			@InfoToAccOwn_2_86_line4,
			@InfoToAccOwn_2_86_line5,
			@InfoToAccOwn_2_86_line6,
			@EndTextBlock,
			@MAC,
			@PAC,
			@CHK,
			@SYS,
			@TNG,
			@PDE,
			@DLM,
			@PDM,
			@MRF,
			@RTV,
			@AllianceTrailerData,
			@FileName 
			)
END
');

GO
EXECUTE ('PRINT N''Creating [admin].[PurgeData_TradeRecs]''
');

GO
EXECUTE ('CREATE PROCEDURE [admin].[PurgeData_TradeRecs]

AS
-- =============================================
-- Author:		ED
-- Create date: 04 Jul 2014
-- Description:	purge data
-- 04 Jul 2014   ED   Create
-- =============================================
BEGIN
	SET NOCOUNT ON;

	declare @end datetime

	set @end = DATEADD(d, -7, GETDATE())


	---------------------------------------------------------------------
	---------------------------------------------------------------------
	--Purge Trade Recs---------------------------------------------------
	---------------------------------------------------------------------
	---------------------------------------------------------------------
	begin transaction

	--delete from child where parent''s createdate is older than x days
	delete ib_tradereconciliationdetail
	from ib_tradereconciliationdetail trd, ib_tradereconciliation tr
	where trd.tradereconciliationid = tr.tradereconciliationid
		and tr.createdate < @end

	--delete from child where parent''s createdate is older than x days
	delete ib_tradereconciliationsummary
	from ib_tradereconciliationsummary trs, ib_tradereconciliation tr
	where trs.tradereconciliationid = tr.tradereconciliationid
		and tr.createdate < @end
		and tradereconciliationsummaryid not in (
			select tradereconciliationsummaryid
			from ib_adjustmentheader
			where tradereconciliationsummaryid is not null)

	delete from ib_tradereconciliation
	where createdate < @end
		and tradereconciliationid not in (
			select tradereconciliationid
			from ib_tradereconciliationsummary)

	commit transaction

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Template_GetTemplatesBySite]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Template_GetTemplatesBySite]
	@siteId int,
	@taskTypeId int = NULL
AS
SET NOCOUNT ON
	DECLARE @code NVARCHAR(100)
	SELECT @code = Code FROM ib_TaskType WHERE TaskTypeId = @taskTypeId
	
	IF (@code = ''AM'')
	BEGIN
		SELECT
			''All Templates''  AS TypeCode, 0 AS TemplateId
		UNION
		SELECT	
			Description AS TypeCode, T.TemplateId 
		FROM
			ib_Template T
		INNER JOIN
			ib_SiteTemplate ST ON T.TemplateId = ST.TemplateId AND ST.SiteId = @siteId
		INNER JOIN
			ib_TemplateType TT ON T.TypeCode = TT.Code AND IsAutomatchEnabled = 1
	END
	ELSE
	BEGIN		
		SELECT	
			Description AS TypeCode, T.TemplateId 
		FROM
			ib_Template T
		INNER JOIN
			ib_SiteTemplate ST ON T.TemplateId = ST.TemplateId AND ST.SiteId = @siteId
	END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Nostro_GetMatchGroup]''
');

GO
SET ANSI_NULLS OFF

GO
EXECUTE ('-- 17 Feb 09	ED		created
-- 26 Feb 09			Added MatchCodeId and Variation
-- 14 Jul 09	AAJM	Added columns IUnGroupedValue, ILedgerBalance, EUnGroupedValue, EStatementBalance, CurrencyCode and reorder
-- 22 Sep 09	amk		New filter on firm & remove some columns and add in a replacement
-- 01 Oct 09	amk		Get variation inline rather than calling udf (twice as fast)
-- 05 Oct 09	AAJM	Enforce new Nostro user permissions by UserId
-- 19 Nov 10	amk		MBAL-17014: speed up by breaking into 2 queries so no OR condition on templateid
--									in production goes from 30 seconds to 7.
/*
	Updated By: Kirill Shilin
	Update On: 04.10.2011
	Issue: MBAL-19137 When creating a rule the Nostro Matching unmatched balance for an associated matchcode in increased
	Changes: count of rulematchcodes added to the final select
	
	Updated By: Kirill Shilin
	Update On: 12.01.2011
	Issue: MBAL-19673 Green rules button on Nostro > Matching page shows when matchcode attached to non-active rules
	Changes: Rule.IsActive added to join condition
-- 02 Jul 12: ED	MBAL 20233 - improve sp performance
*/

CREATE PROCEDURE [dbo].[ib_Nostro_GetMatchGroup]
(	
	@UserId uniqueidentifier
	, @TemplateId int = null
	, @FirmId int = null
	, @CurrencyId int = null
)
AS
SET NOCOUNT ON
BEGIN


DECLARE @NostroGroupTable TABLE (AccountId INT , DataSourceId INT , CurrencyId INT, Cnt INT)

INSERT INTO @NostroGroupTable(AccountId, DataSourceId, CurrencyId,Cnt)
SELECT AccountId, DataSourceId, CurrencyId,COUNT(*) AS Cnt FROM ib_Nostro WHERE NostroMatchId IS NOT NULL GROUP BY AccountId, DataSourceId, CurrencyId

CREATE TABLE #matchCodes (MatchCode VARCHAR(100) COLLATE Latin1_General_CI_AS NOT NULL)

-- first get the full list of match codes - filter for ones matching internal firm if supplied
IF @FirmId IS NULL
	INSERT INTO #matchCodes
	SELECT DISTINCT tg.Description
	FROM ib_TemplateGroup tg
	WHERE tg.TemplateId = @TemplateId
ELSE
	INSERT INTO #matchCodes
	SELECT DISTINCT tg.Description
	FROM ib_TemplateGroup tg
	WHERE tg.TemplateId = @TemplateId
		AND tg.FirmId = @FirmId

DECLARE @MatchGroupTable TABLE (
	AccountId INT , DataSourceId INT , CurrencyId INT , Description VARCHAR(100), MatchCodeId INT , HasAccess BIT,
	TemplateId INT , InternalExternalCode VARCHAR(2), EStatementBalance DECIMAL(18,4), ILedgerBalance DECIMAL(18,4)
	)
INSERT INTO @MatchGroupTable
	(AccountId, DataSourceId, CurrencyId, Description, MatchCodeId, HasAccess,
	TemplateId, InternalExternalCode, EStatementBalance, ILedgerBalance
	)
SELECT a.AccountId, tc.DataSourceId, tg.CurrencyId, tg.Description, mc.MatchCodeId, 
		CASE WHEN (ar.Code = ''ReadOnly'' OR ar.Code = ''Full'') THEN 1 ELSE 0 END AS HasAccess
		,tg.TemplateId, InternalExternalCode
		,(SELECT nb.ExternalBalance
			FROM [ib_NostroBalance] nb
			WHERE nb.[MatchCodeId] = mc.MatchCodeId
			AND nb.[BalanceDate] = (SELECT MAX(BalanceDate) AS LatestBalanceDate FROM [ib_NostroBalance] nb1 WHERE nb1.MatchCodeId = mc.MatchCodeId)) AS EStatementBalance
		,(SELECT nb.InternalBalance
			FROM [ib_NostroBalance] nb
			WHERE nb.[MatchCodeId] = mc.MatchCodeId
			AND nb.[BalanceDate] = (SELECT MAX(BalanceDate) AS LatestBalanceDate FROM [ib_NostroBalance] nb1 WHERE nb1.MatchCodeId = mc.MatchCodeId)) AS ILedgerBalance		
	FROM ib_Account a 
		INNER JOIN ib_Firm f ON f.FirmId=a.FirmId
		INNER JOIN ib_TemplateCompare tc ON tc.FirmId=f.FirmId
		INNER JOIN ib_Template t ON t.TemplateId=tc.TemplateId
		INNER JOIN ib_TemplateGroup tg ON tg.TemplateId=t.TemplateId AND tg.AccountId=a.AccountId 
		INNER JOIN ib_MatchCode mc ON mc.MatchCode=tg.Description AND mc.TemplateId=tg.TemplateId
		INNER JOIN #MatchCodes mc_filter ON mc_filter.MatchCode = tg.Description
		INNER JOIN ib_UserMatchCodeAccess umca ON umca.UserId = @UserId AND umca.MatchCodeId = mc.MatchCodeId 
		INNER JOIN ib_AccessRight ar ON umca.AccessRightId = ar.AccessRightId


DECLARE @TempTable TABLE (
	MatchCode					varchar(100)
	, MatchCodeId				int
	, ITotal					int null
	, IUnGrouped				int null
	, IUnGroupedValue			DECIMAL(18,4)
	, ILedgerBalance			DECIMAL(18,4)
	, ETotal					int null
	, EUnGrouped				int null
	, EStatementBalance 		DECIMAL(18,4)
	, Dif						decimal(18,4) null
	, CurrencyCode				VARCHAR(100) NOT NULL
	, LessOpenStatementReceipts decimal(18,4)
	, PlusOpenStatementPayments decimal(18,4)
	, LessOpenLedgerPayments 	decimal(18,4)	
	, PlusOpenLedgerReceipts 	decimal(18,4)
	, HasRules					BIT
)

INSERT INTO @TempTable(MatchCode, MatchCodeId
		, ITotal, IUnGrouped
		, ILedgerBalance, ETotal, EUnGrouped
		, EStatementBalance, Dif, CurrencyCode
		, LessOpenStatementReceipts, PlusOpenStatementPayments
		, LessOpenLedgerPayments, PlusOpenLedgerReceipts
		, HasRules		 
		)
	SELECT DISTINCT MatchCode, MatchCodeId
		, SUM(ITotal), SUM(IUnGrouped)
		, MAX(ILedgerBalance), SUM(ETotal), SUM(EUnGrouped)
		, MAX(EStatementBalance), SUM(Dif), CurrencyCode
		, SUM(LessOpenStatementReceipts), SUM(PlusOpenStatementPayments)
		, SUM(LessOpenLedgerPayments), SUM(PlusOpenLedgerReceipts)
		, 0 AS HasRules
	FROM (
		SELECT it.Description AS MatchCode
			, MatchCodeId
			, CASE WHEN InternalExternalCode=''I'' THEN 1 ELSE 0 END AS ITotal
			, CASE WHEN InternalExternalCode<>''I'' THEN 0 ELSE 1 END AS IUnGrouped
			, ILedgerBalance
			, CASE WHEN InternalExternalCode=''E'' THEN 1 ELSE 0 END AS ETotal
			, CASE WHEN InternalExternalCode<>''E'' THEN 0 ELSE 1 END AS EUnGrouped
			, EStatementBalance
			, CASE WHEN InternalExternalCode <> ''E'' THEN 0 ELSE n.Amount END
				-
				CASE WHEN InternalExternalCode <> ''I'' THEN 0 ELSE n.Amount END
			  AS Dif
			, c.Code AS CurrencyCode
			, CASE WHEN InternalExternalCode=''I'' THEN 0 
					ELSE CASE WHEN Amount<0 THEN 0 ELSE ABS(Amount) END END AS LessOpenStatementReceipts
			, CASE WHEN InternalExternalCode=''I'' THEN 0 
					ELSE CASE WHEN Amount>0 THEN 0 ELSE ABS(Amount) END END AS PlusOpenStatementPayments
			, CASE WHEN InternalExternalCode=''E'' THEN 0 
					ELSE CASE WHEN Amount>0 THEN 0 ELSE ABS(Amount) END END AS LessOpenLedgerPayments
			, CASE WHEN InternalExternalCode=''E'' THEN 0 
					ELSE CASE WHEN Amount<0 THEN 0 ELSE ABS(Amount) END END AS PlusOpenLedgerReceipts
			FROM ib_Nostro AS n 
				INNER JOIN @MatchGroupTable it ON it.AccountId = n.AccountId AND it.CurrencyId=n.CurrencyId AND it.DataSourceId=n.DataSourceId
				INNER JOIN ib_Currency c ON c.CurrencyId = n.CurrencyId	 
			WHERE NostroMatchId IS NULL AND HasAccess = 1 
				AND (@TemplateId IS NULL OR TemplateId = @TemplateId)
				AND (@CurrencyId IS NULL OR n.CurrencyId = @CurrencyId)
		UNION ALL	
			SELECT DISTINCT it.Description AS MatchCode
				, MatchCodeId
				, SUM(CASE WHEN InternalExternalCode=''I'' THEN Cnt ELSE 0 END) AS ITotal
				, 0 AS IUnGrouped
				, MAX(ILedgerBalance) ILedgerBalance
				, SUM(CASE WHEN InternalExternalCode=''E'' THEN Cnt ELSE 0 END) AS ETotal
				, 0 AS EUnGrouped
				, MAX(EStatementBalance) EStatementBalance
				, 0 AS Dif
				, c.Code AS CurrencyCode
				, 0 AS LessOpenStatementReceipts
				, 0 AS PlusOpenStatementPayments
				, 0 AS LessOpenLedgerPayments
				, 0 AS PlusOpenLedgerReceipts
			FROM @NostroGroupTable AS n 
				INNER JOIN  @MatchGroupTable it ON it.AccountId = n.AccountId AND it.CurrencyId=n.CurrencyId AND it.DataSourceId=n.DataSourceId
				INNER JOIN ib_Currency c ON c.CurrencyId = n.CurrencyId	 
			WHERE HasAccess = 1 
				AND (@TemplateId IS NULL OR TemplateId = @TemplateId)
				AND (@CurrencyId IS NULL OR n.CurrencyId = @CurrencyId)
			GROUP BY it.Description, it.MatchCodeId, c.Code 
		) AS X
	GROUP BY X.MatchCode, MatchCodeId, X.CurrencyCode

UPDATE @TempTable
	SET HasRules = 1
FROM @TempTable T
	INNER JOIN ib_RuleMatchCode RMC ON RMC.MatchCodeId = T.MatchCodeId	
	INNER JOIN ib_Rule R ON RMC.RuleId = R.RuleId AND IsActive = 1

SELECT 
	t.EStatementBalance 
		- LessOpenStatementReceipts 
		+ PlusOpenStatementPayments 
		- LessOpenLedgerPayments 
		+ PlusOpenLedgerReceipts 
		- t.ILedgerBalance
		AS variation
	, t.*
	, EUnGrouped + IunGrouped 
		AS EandIUnGrouped
FROM @temptable t
ORDER BY IUnGrouped DESC, MatchCode

DROP TABLE #matchCodes

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ReceiveLocation_GetByDataSourceId]''
');

GO
SET ANSI_NULLS ON

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Select records from the ReceiveLocation table through a foreign key
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[ReceiveLocation_GetByDataSourceId]
(

	@DataSourceId int   
)
AS


				SET ANSI_NULLS ON
				
				SELECT
					[ReceiveLocationSysId],
					[ReceiveLocationName],
					[PackageSysId],
					[FileMask],
					[InputFolder],
					[OutputFolder],
					[ErrorFolder],
					[DataSourceId],
					[Priority],
					[IsActive],
					[IsRunning],
					[CreateDateTimeUtc],
					[CreateUsername],
					[UpdateDateTimeUtc],
					[UpdateUsername],
					[DeleteDateTimeUtc],
					[DeleteUsername]
				FROM
					[dbo].[ReceiveLocation]
				WHERE
					[DataSourceId] = @DataSourceId
				
				SELECT @@ROWCOUNT
				SET ANSI_NULLS ON
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_EquityHeader_Update]''
');

GO
EXECUTE ('

/*
Created By:  McQuien
Date:  2006-11-21

Purpose:  Updates records into equity header in order to construct the equity reports.

Modifications:
*/
CREATE proc [dbo].[ib_EquityHeader_Update]
@EquityHeaderId int,
@TemplateId int=null,
@CurrencyId int=null,
@TemplateGroupDescription varchar(50)=null,
@Sec1SignDate datetime=null,
@Sec1SignUser varchar(50)=null,
@Sec2SignDate datetime=null,
@Sec2SignUser varchar(50)=null,
@Sec3SignDate datetime=null,
@Sec3SignUser varchar(50)=null

as
SET NOCOUNT ON

/*
Update ib_EquityHeader
SET TemplateId=@TemplateId,
CurrencyId=@CurrencyId,
TemplateGroupDescription=@TemplateGroupDescription
WHERE EquityHeaderId = @EquityheaderId
*/

IF @TemplateId is not null
BEGIN
UPDATE ib_EquityHeader
SET TemplateId=@TemplateId
WHERE EquityHeaderId = @EquityheaderId
END

IF @CurrencyId is not null
BEGIN
UPDATE ib_EquityHeader
SET CurrencyId=@CurrencyId
WHERE EquityHeaderId = @EquityheaderId
END

IF @TemplateGroupDescription is not null
BEGIN
UPDATE ib_EquityHeader
SET TemplateGroupDescription=@TemplateGroupDescription
WHERE EquityHeaderId = @EquityheaderId
END


IF @Sec1SignDate is not null and @Sec1SignDate <> ''''
BEGIN
UPDATE ib_EquityHeader
SET Section1SignOffDate=@Sec1SignDate,
Section1SignOffUser=@Sec1SignUser
WHERE EquityHeaderId = @EquityheaderId
END

IF @Sec2SignDate is not null and @Sec2SignDate <> ''''
BEGIN
UPDATE ib_EquityHeader
SET Section2SignOffDate=@Sec2SignDate,
Section2SignOffUser=@Sec2SignUser
WHERE EquityHeaderId = @EquityheaderId
END

IF @Sec3SignDate is not null and @Sec3SignDate <> ''''
BEGIN
UPDATE ib_EquityHeader
SET Section3SignOffDate=@Sec3SignDate,
Section3SignOffUser=@Sec3SignUser
WHERE EquityHeaderId = @EquityheaderId
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TemplateCompare_Update]''
');

GO
EXECUTE ('  /*
<details>
 <summary>Updates a template compare from the ib_TemplateCompare table by its id</summary>
 <created author="Laurentiu Macovei" Date="Saturday, 9 September 2006 0:26AM GMT" /> 
 <updated author="laurentiu.macovei" date="Fri, 29 Sep 2006 14:40:29 GMT">
	Check for duplicates
 </updated>
</details>
*/
 CREATE PROCEDURE [dbo].[ib_TemplateCompare_Update]
(
	 @TemplateCompareId int,
	 @TemplateId int,
	 @DataSourceId int,
     @FirmId int,
     @InternalExternalCode char(1),
     @UpdateUsername varchar(50)
)
AS
SET NOCOUNT ON

BEGIN TRY
--check for duplicates 
EXEC [dbo].[ib_TemplateCompare_CheckForDuplicate] @TemplateId, @FirmId, @DataSourceId, @InternalExternalCode, @TemplateCompareId

UPDATE [dbo].[ib_TemplateCompare]
   SET [TemplateId] = @TemplateId,
      [DataSourceId] = @DataSourceId,
      [FirmId] = @FirmId,
      [InternalExternalCode] = @InternalExternalCode,
      [UpdateUsername] = @UpdateUsername
 WHERE TemplateCompareId = @TemplateCompareId

END TRY
BEGIN CATCH
	EXEC [dbo].[sp_RethrowError]
END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[GMI_POSF1_Purge]''
');

GO
EXECUTE ('



-- =============================================
-- Author:		Lee Manifold
-- Create date: 18 Jul 2006
-- Description:	Deletes from all is_GMI_POSF1 type files where the LoadState is 0
--
-- History
--
-- Date			Author			Description
-- 28 Feb 2007	LM				Added Extra field ImportFileId
-- =============================================
CREATE PROCEDURE [dbo].[GMI_POSF1_Purge]
	(
	@LoadState		TINYINT = 0,
	@RecordDate		DATETIME = NULL,
	@ImportFileId	INT
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	
	--raiserror (''Lee doing specific raiserror in stored proc for testing'', 19, 1) with log
	
	IF @RecordDate IS NOT NULL 
	BEGIN
		--****Need to Add code here to factor in @RecordDate into table fields 
		DELETE FROM [dbo].[GMI_POSF1] WHERE LoadState= @LoadState AND ImportFileId = @ImportFileId

	END
	
	IF @RecordDate IS NULL 
	BEGIN
	
		DELETE FROM [dbo].[GMI_POSF1] WHERE LoadState= @LoadState AND ImportFileId = @ImportFileId

	END
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Nostro_GetNostroRecordsByNostroIdsAndGroupNumber]''
');

GO
SET ANSI_NULLS OFF

GO
EXECUTE ('/*
----------------------------------------------------------------------------------------------------

-- 13 Feb 09 : ED created
-- Purpose: Get the nostro records by nostroids or group number
-- 27 Feb 09: ED : 10124 - don''t add balancing if only from one side
-- 1 Mar 09 : ED : 10149 - change rule to an extended one
-- 2 Mar 09 : change function nvarchar size, also changed the dynamic sql
-- 2 Mar 09: Change the sql to get item to display, to show on both difference and balancing item
*/


CREATE PROCEDURE [dbo].[ib_Nostro_GetNostroRecordsByNostroIdsAndGroupNumber]
(
	@GroupNumber int = null,
	@InternalNostroIds varchar(max),
	@ExternalNostroIds varchar(max),
	@IsGrouped bit
)
AS
SET NOCOUNT ON
BEGIN
DECLARE @ITableIds TABLE(ItemId int)
DECLARE @ETableIds TABLE(ItemId int)
DECLARE @ExternalPayments decimal(18,4)
DECLARE @InternalPayments decimal(18,4)
DECLARE @ExternalReceipts decimal(18,4)
DECLARE @InternalReceipts decimal(18,4)
DECLARE @ExternalItems int
DECLARE @InternalItems int

	If (@GroupNumber IS NOT NULL)
		BEGIN
			SET @InternalNostroIds = ''-1''
			SELECT @InternalNostroIds = @InternalNostroIds+'','' +  cast(nm.NostroId as varchar(100)) FROM ib_NostroMatch nm
				INNER JOIN ib_Nostro n ON n.NostroId=nm.NostroId
				INNER JOIN ib_Account a ON a.AccountId=n.AccountId
				INNER JOIN ib_Firm f ON f.FirmId=a.FirmId
				INNER JOIN ib_TemplateCompare tc ON tc.DataSourceId=n.DataSourceId AND tc.FirmId=f.FirmId
				INNER JOIN ib_Template t ON t.TemplateId=tc.TemplateId
				INNER JOIN ib_TemplateGroup tg ON tg.TemplateId=t.TemplateId AND tg.AccountId=n.AccountId  AND tg.CurrencyId=n.CurrencyId
				WHERE GroupNumber=@GroupNumber AND InternalExternalCode=''I''
			SET @ExternalNostroIds = ''-1''
			SELECT @ExternalNostroIds = @ExternalNostroIds+'','' + cast(nm.NostroId as varchar(100)) FROM ib_NostroMatch nm 
				INNER JOIN ib_Nostro n ON n.NostroId=nm.NostroId
				INNER JOIN ib_Account a ON a.AccountId=n.AccountId
				INNER JOIN ib_Firm f ON f.FirmId=a.FirmId
				INNER JOIN ib_TemplateCompare tc ON tc.DataSourceId=n.DataSourceId AND tc.FirmId=f.FirmId
				INNER JOIN ib_Template t ON t.TemplateId=tc.TemplateId
				INNER JOIN ib_TemplateGroup tg ON tg.TemplateId=t.TemplateId AND tg.AccountId=n.AccountId  AND tg.CurrencyId=n.CurrencyId
				WHERE GroupNumber=@GroupNumber AND InternalExternalCode=''E''
		
			INSERT INTO @ITableIds(ItemId)
				SELECT CAST(items AS INT) AS Example2
				FROM dbo.split(@InternalNostroIds,'','')
			INSERT INTO @ETableIds(ItemId)
				SELECT CAST(items AS INT) AS Example2
				FROM dbo.split(@ExternalNostroIds,'','')
			
			DECLARE @BalancingItems int
			DECLARE @BalancingPayments decimal(18,4)
			DECLARE @BalancingReceipts decimal(18,4)
			SET @BalancingPayments = 0
			SET @BalancingReceipts = 0
				SELECT @ExternalItems = COUNT(n.NostroId),
					@ExternalPayments = SUM(CASE WHEN ABS(AMOUNT)!=AMOUNT THEN ABS(AMOUNT) ELSE 0 END),
					@ExternalReceipts = SUM(CASE WHEN ABS(AMOUNT)=AMOUNT THEN AMOUNT ELSE 0 END)
				FROM ib_Nostro n
				INNER JOIN @ETableIds i ON n.NostroId=i.ItemId
				

				SELECT @InternalItems = COUNT(n.NostroId),
					@InternalPayments = SUM(CASE WHEN ABS(AMOUNT)!=AMOUNT THEN ABS(AMOUNT) ELSE 0 END),
					@InternalReceipts = SUM(CASE WHEN ABS(AMOUNT)=AMOUNT THEN AMOUNT ELSE 0 END)
				FROM ib_Nostro n
				INNER JOIN @ITableIds i ON n.NostroId=i.ItemId
				SELECT @BalancingItems = COUNT(NostroBalancingItemId),
					@BalancingPayments = SUM(AmountPayments),
					@BalancingReceipts = SUM(AmountReceipts)
				FROM ib_NostroBalancingItem  WHERE GroupNumber=@GroupNumber Group By GroupNumber			


				SELECT ''Balancing Entry'' RowName, ISNULL(@BalancingItems,0) Items, ISNULL(@BalancingPayments,0) Payments,ISNULL(@BalancingReceipts,0) Receipts,4 Id
				UNION
				SELECT ''Difference'' RowName, NULL Items, ISNULL(@BalancingPayments,0) Payments,ISNULL(@BalancingReceipts,0) Receipts,3 Id
				UNION		
				SELECT ''Internal (Ledger)'' RowName, @InternalItems Items, @InternalPayments Payments,@InternalReceipts Receipts, 2 Id
				UNION
				SELECT ''External (Statement)'' RowName, @ExternalItems Items, @ExternalPayments Payments,@ExternalReceipts Receipts, 1 Id
				ORDER By Id
				
		END
		ELSE
			BEGIN
				
			DECLARE @DifferenceReceipts decimal(18,4)
			DECLARE @DifferencePayments decimal(18,4)
			DECLARE @Difference decimal(18,4)

			INSERT INTO @ITableIds(ItemId)
				SELECT CAST(items AS INT) AS Example2
				FROM dbo.split(@InternalNostroIds,'','')
			INSERT INTO @ETableIds(ItemId)
				SELECT CAST(items AS INT) AS Example2
				FROM dbo.split(@ExternalNostroIds,'','')
			
			SELECT @ExternalItems = COUNT(n.NostroId),
					@ExternalPayments = SUM(CASE WHEN ABS(AMOUNT)!=AMOUNT THEN ABS(AMOUNT) ELSE 0 END),
					@ExternalReceipts = SUM(CASE WHEN ABS(AMOUNT)=AMOUNT THEN AMOUNT ELSE 0 END)
				FROM ib_Nostro n
				INNER JOIN @ETableIds i ON n.NostroId=i.ItemId
				

				SELECT @InternalItems = COUNT(n.NostroId),
					@InternalPayments = SUM(CASE WHEN ABS(AMOUNT)!=AMOUNT THEN ABS(AMOUNT) ELSE 0 END),
					@InternalReceipts = SUM(CASE WHEN ABS(AMOUNT)=AMOUNT THEN AMOUNT ELSE 0 END)
				FROM ib_Nostro n
				INNER JOIN @ITableIds i ON n.NostroId=i.ItemId
				
				SET @Difference = (ISNULL(@ExternalReceipts,0)-ISNULL(@ExternalPayments,0)) - (ISNULL(@InternalReceipts,0)-ISNULL(@InternalPayments,0)) 
				
				SET @DifferenceReceipts = 0
				SET @DifferencePayments = 0
				IF (@Difference > 0)
					SET @DifferenceReceipts = ABS(@Difference)
				ELSE
					SET @DifferencePayments = ABS(@Difference)
				DECLARE @BItems int
				SET @BItems = 0
				IF @Difference!=0
					SET @BItems = 1
				SELECT ''Balancing Entry'' RowName, @BItems Items, @DifferencePayments Payments,@DifferenceReceipts Receipts,4 Id
				UNION
				SELECT ''Difference'' RowName, NULL Items, @DifferencePayments Payments,@DifferenceReceipts Receipts,3 Id
				UNION		
				SELECT ''Internal (Ledger)'' RowName, @InternalItems Items, @InternalPayments Payments,@InternalReceipts Receipts, 2 Id
				UNION
				SELECT ''External (Statement)'' RowName, @ExternalItems Items, @ExternalPayments Payments,@ExternalReceipts Receipts, 1 Id
				ORDER By Id
				
			END
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ReceiveLocation_GetByPackageSysIdInputFolderFileMaskOutputFolderErrorFolder]''
');

GO
SET ANSI_NULLS ON

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Select records from the ReceiveLocation table through an index
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[ReceiveLocation_GetByPackageSysIdInputFolderFileMaskOutputFolderErrorFolder]
(

	@PackageSysId tinyint   ,

	@InputFolder varchar (255)  ,

	@FileMask varchar (50)  ,

	@OutputFolder varchar (255)  ,

	@ErrorFolder varchar (255)  
)
AS


				SELECT
					[ReceiveLocationSysId],
					[ReceiveLocationName],
					[PackageSysId],
					[FileMask],
					[InputFolder],
					[OutputFolder],
					[ErrorFolder],
					[DataSourceId],
					[Priority],
					[IsActive],
					[IsRunning],
					[CreateDateTimeUtc],
					[CreateUsername],
					[UpdateDateTimeUtc],
					[UpdateUsername],
					[DeleteDateTimeUtc],
					[DeleteUsername]
				FROM
					[dbo].[ReceiveLocation]
				WHERE
					[PackageSysId] = @PackageSysId
					AND [InputFolder] = @InputFolder
					AND [FileMask] = @FileMask
					AND [OutputFolder] = @OutputFolder
					AND [ErrorFolder] = @ErrorFolder
				SELECT @@ROWCOUNT
					
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TemplateGroup_ValidateAccount]''
');

GO
EXECUTE ('-- =============================================
-- Author:		Anil Kripalani
-- Create date: 07 Feb 2007
-- =============================================
CREATE PROCEDURE [dbo].[ib_TemplateGroup_ValidateAccount]
	@AccountId	int
	, @FirmId	int
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	IF @FirmId IS NOT NULL AND @AccountId IS NOT NULL
	BEGIN
		SELECT 1
		FROM ib_Account a
		WHERE a.AccountId = @AccountId
			AND a.FirmID = @FirmId

		IF @@ROWCOUNT = 0
			RAISERROR (N''Account is on a different firm than the firm selected for this same match code'', 11, 1)
	END

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TemplateGroup_CheckForDuplicate]''
');

GO
SET ANSI_NULLS OFF

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_TemplateGroup_CheckForDuplicate]
@TemplateId int,
@ExchangeId int,
@FirmId int,
@AccountId int,
@InstrumentId int,
@TemplateGroupId int,
@ClassId int,
@CurrencyId int
AS
SET NOCOUNT ON

--	27 Nov 2006		amk		Bug Fix: ClassId is part of alternate key too!

DECLARE @Count int
SET @Count =0

SELECT TOP 1 @Count = 1
	FROM [dbo].[ib_TemplateGroup] tg
	WHERE tg.TemplateId = @TemplateId
		AND tg.ExchangeId = @ExchangeId
		AND tg.FirmId =  @FirmId
		AND tg.AccountId = @AccountId
		AND tg.InstrumentId = @InstrumentId
		AND tg.TemplateGroupID <> @TemplateGroupId
		AND tg.ClassId = @ClassId
		AND tg.CurrencyId = @CurrencyId
print @count
SELECT @count
IF @Count > 0
BEGIN
	DECLARE @TemplateDescription varchar(100)
	DECLARE @ExchangeCode varchar(100)
	DECLARE @FirmCode varchar(100)
	DECLARE @AccountCode varchar(100)
	DECLARE @InstrumentCode varchar(100)
	DECLARE @ClassCode varchar(100)
	DECLARE @CurrencyCode varchar(100)

	SELECT TOP 1 @Count = 1, @FirmCode = i.Code, @ExchangeCode = e.Code
		, @AccountCode = a.Code, @FirmCode = f.Code, @InstrumentCode = i.Code
		, @TemplateDescription = t.Description
		, @ClassCode = c.Code, @CurrencyCode = crrcy.Code
		FROM [dbo].[ib_TemplateGroup] tg
		LEFT JOIN [dbo].[ib_Exchange] e 
			ON tg.ExchangeId = e.ExchangeId
		LEFT JOIN [dbo].[ib_Firm] f 
			ON tg.FirmId = f.FirmId
		LEFT JOIN [dbo].[ib_Account] a 
			ON tg.AccountId = a.AccountId
		LEFT JOIN [dbo].[ib_Instrument] i
			ON tg.InstrumentId = i.InstrumentId
		INNER JOIN [dbo].[ib_Template] t 
			ON tg.TemplateId = t.TemplateId
		LEFT JOIN [dbo].[ib_Class] c
			ON tg.ClassId = c.ClassId
		LEFT JOIN [dbo].[ib_Currency] crrcy
			ON tg.CurrencyId = crrcy.CurrencyId
		WHERE tg.TemplateId = @TemplateId
			AND tg.ExchangeId = @ExchangeId
			AND tg.FirmId = @FirmId
			AND tg.AccountId = @AccountId
			AND tg.InstrumentId = @InstrumentId
			AND tg.TemplateGroupID <> @TemplateGroupId
			AND tg.ClassId = @ClassId
			AND tg.CurrencyId = @CurrencyId

	SET @ExchangeCode = ISNULL(@ExchangeCode, ''<No Exchange>'')
	SET @FirmCode = ISNULL(@FirmCode, ''<No Firm>'')
	SET @AccountCode = ISNULL(@AccountCode, ''<No Account>'')
	SET @InstrumentCode = ISNULL(@InstrumentCode, ''<No Instrument>'')
	SET @ClassCode = ISNULL(@ClassCode, ''<No Class>'')
	SET @CurrencyCode = ISNULL(@CurrencyCode, ''<No Currency>'')
	RAISERROR (N''There is already another Template Group with same Template (%s), same Exchange (%s), same Firm (%s), same Account (%s), same Instrument (%s), same Class (%s) and same Currency (%s). Please specify other values!'', 11, 1, 
		@TemplateDescription, 
		@ExchangeCode, 
		@FirmCode, 
		@AccountCode,
		@InstrumentCode,
		@ClassCode,
		@CurrencyCode
		)
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TemplateGroup_Add]''
');

GO
EXECUTE (' /*
<details>
 <summary>Adds a template group into the ib_TemplateGroup table</summary>
 <created author="Laurentiu Macovei" Date="Saturday, 9 September 2006 0:26PM GMT" /> 
 <updated author="laurentiu.macovei" date="Fri, 29 Sep 2006 14:40:29 GMT">
	Check for duplicates
 </updated>
--	27 Nov 2006		amk		Bug Fix: ClassId is part of alternate key too!
--	07 Feb 2007		amk		Validate account / firm
--	23 Feb 2009		konrad	Currency added
</details>
*/
CREATE PROCEDURE [dbo].[ib_TemplateGroup_Add]
(
	@TemplateId int,
    @ExchangeId int,
    @FirmId int,
    @ClassId int,
	@CurrencyId int,
    @AccountId int,
    @InstrumentId int,
    @Description varchar(100),
    @CreateUsername varchar(50),
	@@TemplateGroupId int OUTPUT
)
AS
SET NOCOUNT ON

BEGIN TRY
--check for duplicates 
EXEC [dbo].[ib_TemplateGroup_CheckForDuplicate] @TemplateId, @ExchangeId, @FirmId, @AccountId, @InstrumentId, -1, @ClassId, @CurrencyId 

EXEC [dbo].[ib_TemplateGroup_ValidateAccount] @AccountId, @FirmId

INSERT INTO [dbo].[ib_TemplateGroup]
           ([TemplateId]
           ,[ExchangeId]
           ,[FirmId]
           ,[ClassId]
		   ,[CurrencyId]
           ,[AccountId]
           ,[InstrumentId]
           ,[Description]
           ,[CreateUsername])
     VALUES
           (@TemplateId,
            @ExchangeId,
            @FirmId, 
            @ClassId,
			@CurrencyId,
            @AccountId,
            @InstrumentId,
            @Description,
            @CreateUsername)

SELECT @@TemplateGroupId = Scope_Identity()

END TRY
BEGIN CATCH
	EXEC [dbo].[sp_RethrowError]
END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[GMI_PPMF1_Add]''
');

GO
SET ANSI_NULLS ON

GO
EXECUTE ('
-- =============================================
-- Author:		Lee Manifold
-- Create date: 12 Dec 2006
-- Description:	Insert into GMI_PPMF1
-- =============================================
CREATE PROCEDURE [dbo].[GMI_PPMF1_Add]
	(
	@CUSIPNumber			varchar(12),
    @Contract				varchar(6),
    @DecimalStrikePrice		varchar(15),
    @SecurityTypeCode		varchar(1),
    @SecuritySubCode		varchar(1),
    @SubCusip				varchar(2),
    @Symbol					varchar(6),
    @UnderlyingCusipNumber	varchar(12),
    @SecurityDescLine1		varchar(30),
	@DateRecordWasOpened	varchar(9),
    @DateRecordLastChange	varchar(9),
    @MultiplicationFactor	varchar(15),
    @CountryCode			varchar(2),
    @ProductCurrencyCode	varchar(2),
    @ExchangeCode			varchar(2),
    @StrikePriceEditCode	varchar(1),
    @TradePriceEditCode		varchar(1),
	@ImportFileId			int	
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	INSERT INTO [dbo].[GMI_PPMF1]
			(
			[CUSIPNumber],
			[Contract],
			[DecimalStrikePrice],
			[SecurityTypeCode],
			[SecuritySubCode],
			[SubCusip],
			[Symbol],
			[UnderlyingCusipNumber],
			[SecurityDescLine1],
			[DateRecordWasOpened],
			[DateRecordLastChange],
			[MultiplicationFactor],
			[CountryCode],
			[ProductCurrencyCode],
			[ExchangeCode],
			[StrikePriceEditCode],
			[TradePriceEditCode],
			[ImportFileId]	
			)
     VALUES
           (
			@CUSIPNumber,
            @Contract,
            @DecimalStrikePrice,
            @SecurityTypeCode,
            @SecuritySubCode,
            @SubCusip,
            @Symbol,
            @UnderlyingCusipNumber,
            @SecurityDescLine1,
			@DateRecordWasOpened,
            @DateRecordLastChange,
            @MultiplicationFactor,
            @CountryCode,
            @ProductCurrencyCode,
            @ExchangeCode,
            @StrikePriceEditCode,
            @TradePriceEditCode,
			@ImportFileId
			)
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Nostro_GetOutstandingItemsReport]''
');

GO
EXECUTE ('/*
----------------------------------------------------------------------------------------------------
Author		Date			Description
KevinP		21 Sep 2009		Created - MBAL-12845.
KevinP		16 Oct 2009		Made a change to correctly calc the difference between Internal and External as Marc Gozzett wanted it. I need to actually turn the 
							Internal amounts in the nostro table to be opposite sinage in order to correctly SUM all the figures together to get the actual diff
							You''ll see the totals on this PDF report will equal the diff on the Nostro Rec screen
*/

CREATE PROCEDURE [dbo].[ib_Nostro_GetOutstandingItemsReport]
(
	@TemplateId int
)
AS
SET NOCOUNT ON
BEGIN
DECLARE @TodaysDate DATETIME
SET @TodaysDate = GETDATE()

/*
This temop table will hold our ranges for the brackets which data will fall into.
*/
DECLARE @AgingBrackets TABLE
(
	StartDay INT,
	EndDay INT,
	BracketNumber INT,
	BracketLabel VARCHAR(20)
)

INSERT INTO @AgingBrackets VALUES(0,7,1,''1 - 7 Days'')
INSERT INTO @AgingBrackets VALUES(8,15,2,''8 - 15 Days'')
INSERT INTO @AgingBrackets VALUES(16,31,3,''16 - 31 Days'')
INSERT INTO @AgingBrackets VALUES(32,999999, 4,''> 31 Days'')

DECLARE @AgingDetails TABLE 
(
	FirmId INT,
	FirmCode VARCHAR(50),
	FirmName VARCHAR(50),
	MatchCodeId INT,
	MatchCode VARCHAR(150),
	CurrencyId INT,
	CurrencyCode VARCHAR(10),
    TransactionAmountBracket1 DECIMAL(14,2),
	TransactionAmountBracket2 DECIMAL(14,2),
	TransactionAmountBracket3 DECIMAL(14,2), 
	TransactionAmountBracket4 DECIMAL(14,2),
	TransactionCountBracket1 INT,
	TransactionCountBracket2 INT,
	TransactionCountBracket3 INT, 
	TransactionCountBracket4 INT
)

/*
Here we''re going to PIVOT the Amount from the Nostro table to arrive at a total which fits into the brackets specified in the temp table above.
*/
INSERT INTO @AgingDetails
SELECT FirmId,
		FirmCode,
		FirmName,
		MatchCodeId,
		MatchCode,
		CurrencyId,
		CurrencyCode,
		SUM(ISNULL([1],0)),
		SUM(ISNULL([2],0)),
		SUM(ISNULL([3],0)),
		SUM(ISNULL([4],0)),
		NULL,
		NULL,
		NULL,
		NULL
FROM
(
		SELECT FirmId,
				FirmCode,
				FirmName,
				MatchCodeId,
				MatchCode,
				CurrencyId,
				CurrencyCode,
				SUM(ISNULL([1],0)) as [1],
				SUM(ISNULL([2],0)) as [2],
				SUM(ISNULL([3],0)) as [3],
				SUM(ISNULL([4],0)) as [4]
		FROM (
			SELECT	X.* -- Get the PIVOT Records for the Grouping of the age totals.
					 FROM(
							SELECT	firm.FirmId, 
									firm.[Code] AS FirmCode, 
									firm.[Name] AS FirmName, 
									mc.MatchCodeId, 
									mc.MatchCode,
									cur.CurrencyId,
									cur.[Code] AS CurrencyCode,
									ROUND(n.Amount, 2) AS Amount,
									TBR.BracketNumber
							FROM ib_Nostro n 
							INNER JOIN @AgingBrackets TBR ON DATEDIFF(dd,n.TransDate,@TodaysDate) BETWEEN TBR.StartDay and TBR.EndDay
							INNER JOIN ib_Account account ON account.AccountId = n.AccountId
							INNER JOIN ib_Firm firm ON firm.FirmId = account.FirmId
							INNER JOIN ib_TemplateGroup tg ON tg.AccountId = account.AccountId AND tg.FirmId = account.FirmId AND n.CurrencyId = tg.CurrencyId
							INNER JOIN ib_TemplateCompare tc ON tc.FirmId = account.FirmId
															AND tc.InternalExternalCode = ''E''
							INNER JOIN ib_MatchCode mc ON mc.TemplateId = tg.TemplateId AND mc.MatchCode = tg.[Description]
							INNER JOIN ib_Currency cur ON cur.CurrencyId = n.CurrencyId
							LEFT JOIN ib_NostroMatch nm on n.NostroId = nm.NostroId
							WHERE nm.NostroId IS NULL 
							  AND tg.TemplateId = @TemplateId
						) innerTemp
					PIVOT(SUM(innerTemp.Amount) FOR BracketNumber In([1],[2],[3],[4])) AS X
		) outerTemp
		GROUP BY outerTemp.FirmId,
				 outerTemp.FirmName, 
				 outerTemp.FirmCode,
				 outerTemp.MatchCodeId,
				 outerTemp.MatchCode, 
				 outerTemp.CurrencyId, 
				 outerTemp.CurrencyCode

UNION ALL

		SELECT FirmId,
				FirmCode,
				FirmName,
				MatchCodeId,
				MatchCode,
				CurrencyId,
				CurrencyCode,
				SUM(ISNULL([1],0)) as [1],
				SUM(ISNULL([2],0)) as [2],
				SUM(ISNULL([3],0)) as [3],
				SUM(ISNULL([4],0)) as [4]
		FROM (
			SELECT	X.* -- Get the PIVOT Records for the Grouping of the age totals.
					 FROM(
							SELECT	firm.FirmId, 
									firm.[Code] AS FirmCode, 
									firm.[Name] AS FirmName, 
									mc.MatchCodeId, 
									mc.MatchCode,
									cur.CurrencyId,
									cur.[Code] AS CurrencyCode,
									ROUND(n.Amount, 2)*-1 AS Amount,
									TBR.BracketNumber
							FROM ib_Nostro n 
							INNER JOIN @AgingBrackets TBR ON DATEDIFF(dd,n.TransDate,@TodaysDate) BETWEEN TBR.StartDay and TBR.EndDay
							INNER JOIN ib_Account account ON account.AccountId = n.AccountId
							INNER JOIN ib_Firm firm ON firm.FirmId = account.FirmId
							INNER JOIN ib_TemplateGroup tg ON tg.AccountId = account.AccountId AND tg.FirmId = account.FirmId AND n.CurrencyId = tg.CurrencyId
							INNER JOIN ib_TemplateCompare tc ON tc.FirmId = account.FirmId
															AND tc.InternalExternalCode = ''I''
							INNER JOIN ib_MatchCode mc ON mc.TemplateId = tg.TemplateId AND mc.MatchCode = tg.[Description]
							INNER JOIN ib_Currency cur ON cur.CurrencyId = n.CurrencyId
							LEFT JOIN ib_NostroMatch nm on n.NostroId = nm.NostroId
							WHERE nm.NostroId IS NULL 
							  AND tg.TemplateId = @TemplateId
						) innerTemp
					PIVOT(SUM(innerTemp.Amount) FOR BracketNumber In([1],[2],[3],[4])) AS X
		) outerTemp
		GROUP BY outerTemp.FirmId,
				 outerTemp.FirmName, 
				 outerTemp.FirmCode,
				 outerTemp.MatchCodeId,
				 outerTemp.MatchCode, 
				 outerTemp.CurrencyId, 
				 outerTemp.CurrencyCode
) fullGroup
GROUP BY fullGroup.FirmId,
		 fullGroup.FirmName, 
		 fullGroup.FirmCode,
		 fullGroup.MatchCodeId,
		 fullGroup.MatchCode, 
		 fullGroup.CurrencyId, 
		 fullGroup.CurrencyCode
/*
We are now going to update the PIVOT COUNT of transactions on the temp table
*/
UPDATE @AgingDetails
	SET	TransactionCountBracket1 = results.[1],
		TransactionCountBracket2 = results.[2],
		TransactionCountBracket3 = results.[3], 
		TransactionCountBracket4 = results.[4]
FROM @AgingDetails tempTable
INNER JOIN 
(
		SELECT FirmId,
				MatchCodeId,
				CurrencyId,
				SUM([1]) AS [1],
				SUM([2]) AS [2],
				SUM([3]) AS [3],
				SUM([4]) AS [4]
		FROM (
			SELECT	X.* -- Get the PIVOT Records for the Grouping of the age totals.
					 FROM(
							SELECT	firm.FirmId, 
									mc.MatchCodeId, 
									cur.CurrencyId,
									n.NostroId,
									TBR.BracketNumber
							FROM ib_Nostro n 
							INNER JOIN @AgingBrackets TBR ON DATEDIFF(dd,n.TransDate,@TodaysDate) BETWEEN TBR.StartDay and TBR.EndDay
							INNER JOIN ib_Account account ON account.AccountId = n.AccountId
							INNER JOIN ib_Firm firm ON firm.FirmId = account.FirmId
							INNER JOIN ib_TemplateGroup tg ON tg.AccountId = account.AccountId AND tg.FirmId = account.FirmId AND n.CurrencyId = tg.CurrencyId
							INNER JOIN ib_MatchCode mc ON mc.TemplateId = tg.TemplateId AND mc.MatchCode = tg.[Description]
							INNER JOIN ib_Currency cur ON cur.CurrencyId = n.CurrencyId
							LEFT JOIN ib_NostroMatch nm on n.NostroId = nm.NostroId
							WHERE nm.NostroId IS NULL 
							  AND tg.TemplateId = @TemplateId
						) innerTemp
					PIVOT(Count(NostroId) FOR BracketNumber In([1],[2],[3],[4])) AS X
		) outerTemp
		GROUP BY outerTemp.FirmId,
				 outerTemp.MatchCodeId,
				 outerTemp.CurrencyId 
) AS results ON tempTable.FirmId = results.FirmId AND tempTable.MatchCodeId = results.MatchCodeId AND tempTable.CurrencyId = results.CurrencyId
			 


/*
the reason we are doing the following SQL is because we need to roll up the ficures for a match code,
but present the firm as the internal firm code across the rollup of Internal and External figures.
*/
SELECT firm.FirmId as FirmId,
	firm.Code as FirmCode,
	firm.Name as FirmName,
	ad.MatchCodeId as MatchCodeId,
	ad.MatchCode,
	ad.CurrencyId as CurrencyId,
	ad.CurrencyCode as CurrencyCode,
    SUM(TransactionAmountBracket1) AS TransactionAmountBracket1,
	SUM(TransactionAmountBracket2) AS TransactionAmountBracket2,
	SUM(TransactionAmountBracket3) AS TransactionAmountBracket3,
	SUM(TransactionAmountBracket4) AS TransactionAmountBracket4,
	SUM(TransactionCountBracket1) AS TransactionCountBracket1,
	SUM(TransactionCountBracket2) AS TransactionCountBracket2,
	SUM(TransactionCountBracket3) AS TransactionCountBracket3,
	SUM(TransactionCountBracket4) AS TransactionCountBracket4
FROM @AgingDetails ad
INNER JOIN (
	SELECT DISTINCT tg.Description AS MatchCode, tg.FirmId
	FROM ib_TemplateGroup tg
	WHERE tg.TemplateId = @TemplateId
		AND tg.FirmId IN (	
								SELECT f.FirmId
								FROM ib_TemplateCompare tc
									INNER JOIN ib_Firm f ON f.Firmid = tc.FirmId
								WHERE TemplateId = @TemplateId
								  AND InternalExternalCode = ''I''
							)
) as tempResults ON tempResults.MatchCode = ad.MatchCode
INNER JOIN ib_Firm firm ON tempResults.FirmId = firm.FirmId
GROUP BY ad.MatchCodeId, ad.MatchCode, firm.FirmId, firm.[Code], firm.Name, ad.CurrencyId, ad.CurrencyCode

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ReceiveLocation_GetByReceiveLocationName]''
');

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Select records from the ReceiveLocation table through an index
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[ReceiveLocation_GetByReceiveLocationName]
(

	@ReceiveLocationName varchar (255)  
)
AS


				SELECT
					[ReceiveLocationSysId],
					[ReceiveLocationName],
					[PackageSysId],
					[FileMask],
					[InputFolder],
					[OutputFolder],
					[ErrorFolder],
					[DataSourceId],
					[Priority],
					[IsActive],
					[IsRunning],
					[CreateDateTimeUtc],
					[CreateUsername],
					[UpdateDateTimeUtc],
					[UpdateUsername],
					[DeleteDateTimeUtc],
					[DeleteUsername]
				FROM
					[dbo].[ReceiveLocation]
				WHERE
					[ReceiveLocationName] = @ReceiveLocationName
				SELECT @@ROWCOUNT
					
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Exchange_GetAll]''
');

GO
EXECUTE ('
  /*
<details>
 <summary>Returns all the exchanges</summary>
 <created author="anil.kripalani" date="17 Oct 2006"/>
</details>
*/
--
-- Revision History
-- 
-- 19.05.2009 Konrad Added extra field which concatenates Code and Name values
--
CREATE PROCEDURE [dbo].[ib_Exchange_GetAll]
AS
SET NOCOUNT ON
SELECT [Name], ExchangeId, Code, Code+'' - ''+[Name] as [CodeName]
	FROM ib_Exchange
	ORDER BY [Name]
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TemplateGroup_Update]''
');

GO
SET ANSI_NULLS OFF

GO
EXECUTE (' /*
<details>
 <summary>Updates a template group from the ib_TemplateGroup table by its id</summary>
 <created author="Laurentiu Macovei" Date="Saturday, 9 September 2006 0:26AM GMT" /> 
 <updated author="laurentiu.macovei" date="Fri, 29 Sep 2006 14:40:29 GMT">
	Check for duplicates
 </updated>
--	27 Nov 2006		amk		Bug Fix: ClassId is part of alternate key too!
--	07 Feb 2007		amk		Validate account / firm
--	23 Feb 2009		konrad	Currency added
</details>
*/
CREATE PROCEDURE [dbo].[ib_TemplateGroup_Update]
(
	@TemplateGroupId int,
	@TemplateId int,
    @ExchangeId int,
    @FirmId int,
    @ClassId int,
	@CurrencyId int,
    @AccountId int,
    @InstrumentId int,
    @Description varchar(100),
    @UpdateUsername varchar(50)
)
AS
SET NOCOUNT ON

BEGIN TRY
--check for duplicates 
EXEC [dbo].[ib_TemplateGroup_CheckForDuplicate] @TemplateId, @ExchangeId, @FirmId, @AccountId, @InstrumentId, @TemplateGroupId, @ClassId, @CurrencyId

EXEC [dbo].[ib_TemplateGroup_ValidateAccount] @AccountId, @FirmId

UPDATE [dbo].[ib_TemplateGroup]
   SET [TemplateId] = @TemplateId,
      [ExchangeId] = @ExchangeId,
      [FirmId] = @FirmId,
      [ClassId] = @ClassId,
	  [CurrencyId] = @CurrencyId, 	
      [AccountId] = @AccountId,
      [InstrumentId] = @InstrumentId,
      [Description] = @Description,
      [UpdateUsername] = @UpdateUsername
 WHERE TemplateGroupId = @TemplateGroupId

END TRY
BEGIN CATCH
	EXEC [dbo].[sp_RethrowError]
END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[GMI_PPMF1_LoadStateChange]''
');

GO
SET ANSI_NULLS ON

GO
EXECUTE ('
-- =============================================
-- Author:		Lee Manifold
-- Create date: 12 Dec 2006
-- Description:	Changes the LoadState of the GMI_PPMF1 type table
-- =============================================
CREATE PROCEDURE [dbo].[GMI_PPMF1_LoadStateChange] 
	-- Add the parameters for the stored procedure here
	(
	@OldLoadState	TINYINT,
	@NewLoadState	TINYINT,
	@ImportFileId	INT,
	@RecordDate		DATETIME = NULL
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	-- Need to add code to handle RecordDate
	IF @RecordDate IS NOT NULL 
	BEGIN

		UPDATE [dbo].[GMI_PPMF1] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState AND ImportFileId = @ImportFileId

	END

	IF @RecordDate IS NULL 
	BEGIN

		UPDATE [dbo].[GMI_PPMF1] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState AND ImportFileId = @ImportFileId

	END


END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[SWIFT_MT950_Add]''
');

GO
EXECUTE ('
-- =============================================
-- Author:		Petru Konrad Bercea
-- Create date: 16.01.2009
-- Description:	Insert into SWIFT_MT950 table
--
--	Revision History 
--
--  Konrad 14.04.2009 Added FileName field
--	Konrad 23.04.2009 Changed the type of @StatmtNoSeqNo_28C from decimal to varchar(5)
-- =============================================
CREATE PROCEDURE [dbo].[SWIFT_MT950_Add]
	-- Add the parameters for the stored procedure here
	(
	@FileName								varchar(512) = Null,
	@AppId									varchar(1) = Null ,
	@ServiceId								tinyint = Null,
	@LTAdrs									varchar(12) = Null ,
    @SessionNo								varchar(4) = Null ,
	@SequenceNo								varchar(6) = Null ,
	@AppHBlckInpMsgType						varchar(3) = Null ,
	@AppHBlckInpDestAdrs					varchar(12) = Null ,
	@AppHBlckInpMsgPriority					varchar(1) = Null ,
	@AppHBlckInpDelivMonitoring				varchar(1) = Null ,
	@AppHBlckInpObslscPeriod				varchar(3) = Null ,
	@AppHBlckOutpMsgType					varchar(3) = Null ,
	@AppHBlckOutInpTime						varchar(4) = Null ,
	@AppHBlckOutMsgRefInpDate				varchar(6) = Null ,
	@AppHBlckOutMsgRefLTAdrs				varchar(12) = Null ,
	@AppHBlckOutMsgRefSessionNo				varchar(4) = Null ,
	@AppHBlckOutMsgRefSeqNo					varchar(6) = Null ,
	@AppHBlckOutMsgRefOutpDate				varchar(6) = Null ,
	@AppHBlckOutMsgRefOutpTime				varchar(4) = Null ,
	@AppHBlckOutMsgRefMsgPriority			varchar(1) = Null ,
	@FINServiceId_103						varchar(3) = Null ,
	@BankingPriority_113					varchar(4) = Null ,
	@MsgUserRef_108							varchar(16) = Null ,
	@ValidationFlag_119						varchar(8) = Null ,
	@AddresseeInfo_115						varchar(32) = Null ,
	@Swift_HTextBlock						varchar(max) = Null ,
	@TrxRefNo_20							varchar(16) = Null ,
	@AccountId_25							varchar(35) = Null ,
	@StatmtNo_28C							varchar(5) = Null ,
	@StatmtNoSeqNo_28C						varchar(5) = Null ,
	@OpenBalance_60F_DCMark					char(1) = Null ,
	@OpenBalance_60F_Date					varchar(6) = Null ,
	@OpenBalance_60F_CurrencyCode			varchar(3) = Null ,
	@OpenBalance_60F_Amount					varchar(15) = Null ,
	@OpenBalance_60M_DCMark					char(1) = Null ,
	@OpenBalance_60M_Date					varchar(6) = Null ,
	@OpenBalance_60M_CurrencyCode			varchar(3) = Null ,
	@OpenBalance_60M_Amount					varchar(15) = Null ,
	@StatmtLine_61							varchar(66) = Null ,
	@StatmtLine_61_SupplemDetails			varchar(34) = Null ,
	@ClosingBalance_62F_DCMark				char(1) = Null ,
	@ClosingBalance_62F_Date				varchar(6) = Null ,
	@ClosingBalance_62F_CurrencyCode		varchar(3) = Null ,
	@ClosingBalance_62F_Amount				varchar(15) = Null ,
	@ClosingBalance_62M_DCMark				char(1) = Null ,
	@ClosingBalance_62M_Date				varchar(6) = Null ,
	@ClosingBalance_62M_CurrencyCode		varchar(3) = Null ,
	@ClosingBalance_62M_Amount				varchar(15) = Null ,
    @ClosingAvailBalance_64_DCMark			char(1) = Null ,
	@ClosingAvailBalance_64_Date			varchar(6) = Null ,
	@ClosingAvailBalance_64_CurrencyCode	varchar(3) = Null ,
	@ClosingAvailBalance_64_Amount			varchar(15) = Null , 
	@EndTextBlock							varchar(max) = Null ,
    @MAC									varchar(8) = Null ,
	@PAC									varchar(8) = Null ,
	@CHK									varchar(12) = Null ,
	@SYS									varchar(max) = Null ,
	@TNG									varchar(max) = Null ,
    @PDE									varchar(max) = Null ,
	@DLM									varchar(max) = Null ,
	@PDM									varchar(max) = Null ,
	@MRF									varchar(max) = Null ,
	@RTV									varchar(max) = Null ,
    @AllianceTrailerData					varchar(max) = Null  
    )
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

  INSERT INTO [dbo].[SWIFT_MT950]
			( 
			[AppId]
			,[ServiceId]
			,[LTAdrs]
			,[SessionNo]
			,[SequenceNo]
			,[AppHBlckInpMsgType]
			,[AppHBlckInpDestAdrs]
			,[AppHBlckInpMsgPriority]
			,[AppHBlckInpDelivMonitoring]
			,[AppHBlckInpObslscPeriod]
			,[AppHBlckOutpMsgType]
			,[AppHBlckOutInpTime]
			,[AppHBlckOutMsgRefInpDate]
			,[AppHBlckOutMsgRefLTAdrs]
			,[AppHBlckOutMsgRefSessionNo]
			,[AppHBlckOutMsgRefSeqNo]
			,[AppHBlckOutMsgRefOutpDate]
			,[AppHBlckOutMsgRefOutpTime]
			,[AppHBlckOutMsgRefMsgPriority]
			,[FINServiceId_103]
			,[BankingPriority_113]
			,[MsgUserRef_108]
			,[ValidationFlag_119]
			,[AddresseeInfo_115]
			,[Swift_HTextBlock]
			,[TrxRefNo_20]
			,[AccountId_25]
			,[StatmtNo_28C]
			,[StatmtNoSeqNo_28C]
			,[OpenBalance_60F_DCMark]
			,[OpenBalance_60F_Date]
			,[OpenBalance_60F_CurrencyCode]
			,[OpenBalance_60F_Amount]
			,[OpenBalance_60M_DCMark]
			,[OpenBalance_60M_Date]
			,[OpenBalance_60M_CurrencyCode]
			,[OpenBalance_60M_Amount]
			,[StatmtLine_61]
			,[StatmtLine_61_SupplemDetails]
			,[ClosingBalance_62F_DCMark]
			,[ClosingBalance_62F_Date]
			,[ClosingBalance_62F_CurrencyCode]
			,[ClosingBalance_62F_Amount]
			,[ClosingBalance_62M_DCMark]
			,[ClosingBalance_62M_Date]
			,[ClosingBalance_62M_CurrencyCode]
			,[ClosingBalance_62M_Amount]
			,[ClosingAvailBalance_64_DCMark]
			,[ClosingAvailBalance_64_Date]
			,[ClosingAvailBalance_64_CurrencyCode]
			,[ClosingAvailBalance_64_Amount] 
			,[EndTextBlock] 
			,[MAC]
			,[PAC]
			,[CHK]
			,[SYS]
			,[TNG]
			,[PDE]
			,[DLM]
			,[PDM]
			,[MRF]
			,[RTV]
			,[AllianceTrailerData]
			,[FileName]
			)
    VALUES
			( 
			@AppId,
			@ServiceId,
			@LTAdrs,
			@SessionNo,
			@SequenceNo,
			@AppHBlckInpMsgType,
			@AppHBlckInpDestAdrs,
			@AppHBlckInpMsgPriority,
			@AppHBlckInpDelivMonitoring,
			@AppHBlckInpObslscPeriod,
			@AppHBlckOutpMsgType,
			@AppHBlckOutInpTime,
			@AppHBlckOutMsgRefInpDate,
			@AppHBlckOutMsgRefLTAdrs,
			@AppHBlckOutMsgRefSessionNo,
			@AppHBlckOutMsgRefSeqNo,
			@AppHBlckOutMsgRefOutpDate,
			@AppHBlckOutMsgRefOutpTime,
			@AppHBlckOutMsgRefMsgPriority,
			@FINServiceId_103,
			@BankingPriority_113,
			@MsgUserRef_108,
			@ValidationFlag_119,
			@AddresseeInfo_115,
			@Swift_HTextBlock,
			@TrxRefNo_20,
			@AccountId_25,
			@StatmtNo_28C,
			@StatmtNoSeqNo_28C,
			@OpenBalance_60F_DCMark,
			@OpenBalance_60F_Date,
			@OpenBalance_60F_CurrencyCode,
			@OpenBalance_60F_Amount,
			@OpenBalance_60M_DCMark,
			@OpenBalance_60M_Date,
			@OpenBalance_60M_CurrencyCode,
			@OpenBalance_60M_Amount,
			@StatmtLine_61,
			@StatmtLine_61_SupplemDetails,
			@ClosingBalance_62F_DCMark,
			@ClosingBalance_62F_Date,
			@ClosingBalance_62F_CurrencyCode,
			@ClosingBalance_62F_Amount,
			@ClosingBalance_62M_DCMark,
			@ClosingBalance_62M_Date,
			@ClosingBalance_62M_CurrencyCode,
			@ClosingBalance_62M_Amount,
			@ClosingAvailBalance_64_DCMark,
			@ClosingAvailBalance_64_Date,
			@ClosingAvailBalance_64_CurrencyCode,
			@ClosingAvailBalance_64_Amount, 
			@EndTextBlock,
			@MAC,
			@PAC,
			@CHK,
			@SYS,
			@TNG,
			@PDE,
			@DLM,
			@PDM,
			@MRF,
			@RTV,
			@AllianceTrailerData, 
			@FileName
			)
END
');

GO
EXECUTE ('PRINT N''Creating [admin].[Version_GetVersionSummary]''
');

GO
EXECUTE ('
CREATE PROCEDURE [admin].[Version_GetVersionSummary]
AS
BEGIN

	-- =============================================
	-- Author:		campbellg
	-- Create date: 13/01/2014
	-- Description:	Selects version details for the Help | About screen on the website.
	--
	-- Modification History
	-- 03-Jun-2014	RD	24516-adding nettiers to i-balancer
	-- =============================================

	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	SELECT v.VersionNumber AS ''Version'',
		   v.ComponentName AS ''Component Name'',
		   v.CreateDateTimeUtc AS ''Create Date'',
		   v.UpdateDateTimeUtc AS ''Update Date''
	FROM [admin].[AppVersion] v
	ORDER BY v.IsSolution DESC, v.IsAdapter ASC, v.ComponentName
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Nostro_GetQueryResults]''
');

GO
EXECUTE ('-- =============================================
-- Author:		<P. Konrad Bercea>
-- Create date: <23.03.2009>
-- Description:	<Retrieves the Query Results>
-- Revision History
--
-- Konrad 26.03.2009 Added ShortNotes and AmountFrom and AmountTo replacing the Amount input param
--
-- Konrad 3.04.2009 Replaced the inner joins for Templates with left joins
--
-- Konrad 23.04.2009 Improved the comparison on the dates values so that it supports sql performance using Indexes
-- Konrad 13.07.2009 Removed the unnecessary casts
-- 02 Sep 2009	AAJM	MBAL-12957 Fixed AmountTo and AmountFrom WHERE clauses
-- KevinP 07 Sep 2009 MBAL-11023 - Added an Enum to the Website to distuinguish Payment,Receipt and Payment AND Receipt. The enum values are as follows:
--									Payment = 0, Receipt = 1, PaymentAndReceipt = 2, therfore, @PaymentOrReceipt could have a value of 0,1 or 2
-- KevinP 07 Sep 2009 Made some changes to allow the SP to dynamically use different operators for parameters.
-- KevinP 15 Sep 2009 Made change to include the ORDER BY Clause correctly
-- KevinP	21 Sep 2009	Made changes to include a date range for when an item was last matched. This will include the 
--						GroupNumber not being null and the create date for the matching is equals, less than, greater than or is between the values.
--						Also Changed the casing of some of the SQL keywords
-- AAJM		06 Oct 2009	Add MatchCode Security MBAL-11773
-- KevinP	06 Oct 2009	Added in changes for MBAL-13199 to make the date a SARG.
-- KevinP	29 Oct 2009 Fixed issue with selecting off of TransDateand Valuedate when querying across SWIFT Loaded data. This used to assume Time portion was midnight.
-- ShilinK	30 Sep 2011	Query Results should show Automatched
-- Chalenkog 14 Dec 2011 Add firm to criteria for the query 
-- AAJM	    30 Dec 2011	Add FirmCode to the query results
-- ED		08 May 2012 MBAL 19859 - add extra logic, if matchcode selected, then ignore firm filtering
-- ED		17 May 2012 MBAL 19859 - if matchcode ALL get all matchcodes for selected firm
-- ED		18 May 2012 MBAL 19859 - reverted inner joins and change the query for matchcode ALL to do inner join instead of select in for better performance
-- =============================================
CREATE PROCEDURE [dbo].[ib_Nostro_GetQueryResults] 
	(
		@UserId uniqueidentifier,
		@MatchCodeIdOperator VARCHAR(6)=''Equals'', -- Equals, All, Or None
		@MatchCodeId VARCHAR(100)=null, -- If NULL then we select ALL, if -1 We look for records that have no match code, and a value >=0 will look for match codes like this.
		@TransDateOperator VARCHAR(12)=''Equals'', -- Equals, Less Than, Greater Than, Between
        @TransDateFrom DATETIME=null,
        @TransDateTo DATETIME=null,
		@ValueDateOperator VARCHAR(12)=''Equals'', -- Equals, Less Than, Greater Than, Between
        @ValueDateFrom DATETIME=null,
        @ValueDateTo DATETIME=null,
		@NarrativeOperator VARCHAR(11)=''Equals'', -- Equals, Starts With, Contains
        @Narrative VARCHAR(34)=null,
		@IntRefOperator VARCHAR(11)=''Equals'', -- Equals, Starts With, Contains
        @IntRef VARCHAR(100)=null,
		@ExtRefOperator VARCHAR(11)=''Equals'', -- Equals, Starts With, Contains
        @ExtRef VARCHAR(100)=null,
		@AmountOperator VARCHAR(12)=''Equals'', -- Equals, Less Than, Greater Than, Between
        @AmountFrom DECIMAL(18, 4)=null,
		@AmountTo DECIMAL(18, 4)=null,
        @PaymOrReceipt INT=2, -- We dont need an operator type here. 0 = Payment, 1 = Receipt, 2 = Payment And Receipt.
        @CurrencyId INT=null, -- we dont need an operator type here
		@TypeOperator VARCHAR(11)=''Equals'', -- Equals, Starts With, Contains
        @Type VARCHAR(100)=null,
        @DepartmentId  INT=null, -- we dont need an operator type here
		@NotesOperator VARCHAR(11)=''Equals'', -- Equals, Starts With, Contains
        @Notes VARCHAR(512)=null,
		@MatchedUnMatched INT=3, -- 0 = Matched, 1 = Unmatched, 3 = Both
		@LedgerStatement INT=3, -- 0 = Ledger, 1 = Statement, 2 = Both
		@MatchDateOperator VARCHAR(12)=''Equals'', -- Equals, Less Than, Greater Than, Between
        @MatchDateFrom DATETIME=null,
        @MatchDateTo DATETIME=null,
		@IsForExport BIT=0,
		@FirmID INT = null
    )
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    DECLARE @SQL nvarchar(4000)
	DECLARE @WHERE nvarchar(4000)
	DECLARE @SelectTopStatement VARCHAR(MAX)
	DECLARE @FROM nvarchar(4000)
	
	SET @FROM = ''FROM [ib_Nostro] n (nolock)
		INNER JOIN ib_Account a ON a.AccountId=n.AccountId
		INNER JOIN ib_Firm f ON f.FirmId=a.FirmId
		LEFT JOIN ib_TemplateCompare tc ON tc.DataSourceId=n.DataSourceId AND tc.FirmId=f.FirmId
		LEFT JOIN ib_Template t ON t.TemplateId=tc.TemplateId
		LEFT JOIN ib_Department dpt ON dpt.DepartmentId=n.DepartmentId
		LEFT JOIN ib_TemplateGroup tg ON tg.TemplateId=t.TemplateId AND tg.AccountId=n.AccountId  AND tg.CurrencyId=n.CurrencyId
        LEFT JOIN ib_MatchCode mc ON mc.MatchCode = tg.Description
		LEFT JOIN ib_NostroMatch nm ON nm.NostroId=n.NostroId
		LEFT JOIN ib_NostroMatchType nmt ON nmt.NostroMatchTypeId = nm.NostroMatchTypeId
		''
		
				
	IF @IsForExport = 0
		SET @SelectTopStatement = ''SELECT TOP 2000 ''
	ELSE
		SET @SelectTopStatement = ''SELECT ''

	SET @WHERE = '' WHERE n.NostroId IS NOT NULL '';


	--KevinP - Adding in mechanism to do dynamic comparison....
	IF @MatchCodeIdOperator = ''None'' -- We sepcifically want records that have no match code
		SET @WHERE = @WHERE + '' AND mc.MatchCodeId IS NULL''
	ELSE
		BEGIN
		
			IF @MatchCodeIdOperator  = ''Equals'' AND @MatchCodeId IS NOT NULL -- we specifically want a particular matchcode
			SET @WHERE = @WHERE + '' AND mc.MatchCodeId'' + dbo.OperatorTranslate(@MatchCodeIdOperator,@MatchCodeId, NULL, 0,0)
			ELSE
				IF @MatchCodeIdOperator = ''All'' 
					BEGIN 
						IF @FirmID IS NOT NULL
							SET @FROM = @FROM +
							 '' INNER JOIN (SELECT DISTINCT MatchCodeId FROM ib_MatchCode mc_in 
								INNER JOIN ib_TemplateGroup tg_in ON mc_in.MatchCode=tg_in.Description 
										AND  mc_in.TemplateId=tg_in.TemplateId  AND tg_in.FirmId=''+CAST(@FirmID as VARCHAR(100))+'')
										AS mc1 ON mc1.MatchCodeId = mc.MatchCodeId ''
						ELSE
						SET @WHERE = @WHERE + '' AND mc.MatchCodeId IS NOT NULL''
					END
				ELSE
					SET @WHERE = @WHERE + '' AND 0=1'' -- If we get here, and the Operator for Match code isn;t ALL(which is all it could be up till here) then we have some funny data, so don;t select anything.
	
		-- Add MatchCode Security
		SET @FROM = @FROM + '' INNER JOIN ib_UserMatchCodeAccess umca ON umca.UserId = '''''' + convert(varchar(255), @UserId) + '''''' AND umca.MatchCodeId = mc.MatchCodeId 
		INNER JOIN ib_AccessRight ar ON umca.AccessRightId = ar.AccessRightId''				
	
		SET @WHERE = @WHERE + '' AND (ar.Code = ''''ReadOnly'''' OR ar.Code = ''''Full'''') ''
		
		END				
		
    IF @TransDateFrom IS NOT NULL
		SET @WHERE = @WHERE + '' AND n.TransDate'' +dbo.OperatorTranslate(@TransDateOperator,CAST(@TransDateFrom AS VARCHAR(MAX)),CAST(@TransDateTo AS VARCHAR(MAX)),1,1)
	IF @ValueDateFrom IS NOT NULL
		SET @WHERE = @WHERE + '' AND n.ValueDate'' + dbo.OperatorTranslate(@ValueDateOperator,CAST(@ValueDateFrom AS VARCHAR(MAX)),CAST(@ValueDateTo AS VARCHAR(MAX)),1,1)
    IF @Narrative IS NOT NULL
        SET @WHERE = @WHERE + '' AND n.Narrative'' + dbo.OperatorTranslate(@NarrativeOperator, @Narrative, NULL, 1,0)
	IF @IntRef IS NOT NULL
        SET @WHERE = @WHERE + '' AND n.InternalReference'' + dbo.OperatorTranslate(@IntRefOperator,@IntRef, NULL, 1,0)
	IF @ExtRef IS NOT NULL
        SET @WHERE = @WHERE + '' AND n.ExternalReference'' + dbo.OperatorTranslate(@ExtRefOperator, @ExtRef, NULL, 1,0)
	IF @Type IS NOT NULL
        SET @WHERE = @WHERE + '' AND n.TransactionType'' + dbo.OperatorTranslate(@TypeOperator, @Type, NULL, 1,0)
	IF @Notes IS NOT NULL
        SET @WHERE = @WHERE + '' AND n.Notes'' + dbo.OperatorTranslate(@NotesOperator, @Notes, NULL, 1,0)
    IF @CurrencyId IS NOT NULL
		SET @WHERE = @WHERE + '' AND n.[CurrencyId]=''+CAST(@CurrencyId as VARCHAR(100))+'''';
	IF @DepartmentId IS NOT NULL
		SET @WHERE = @WHERE + '' AND n.[DepartmentId]=''+CAST(@DepartmentId as VARCHAR(100))+'''';
	IF @AmountFrom IS NOT NULL
		SET @WHERE = @WHERE + '' AND ABS(n.[Amount])'' + dbo.OperatorTranslate(@AmountOperator, ABS(@AmountFrom), ABS(@AmountTo), 0,0)

	--KevinP 21 Sep 2009- Added new where clause.
	-- KevinP 06 Oct 2009
	IF @MatchDateFrom IS NOT NULL
	BEGIN
		SET @WHERE = @WHERE + '' AND nm.CreateDate '' + dbo.OperatorTranslate(@MatchDateOperator,CAST(@MatchDateFrom AS VARCHAR(MAX)),CAST(@MatchDateTo AS VARCHAR(MAX)),1,1)
	END

	IF @MatchedUnMatched = 0 OR @MatchedUnMatched = 1
	BEGIN
		IF @MatchedUnMatched = 0
			SET @WHERE = @WHERE + '' AND nm.GroupNumber IS NOT NULL''
		IF @MatchedUnMatched = 1
			SET @WHERE = @WHERE + '' AND nm.GroupNumber IS NULL''
	END

	IF @LedgerStatement = 0 OR @LedgerStatement = 1
	BEGIN
		IF @LedgerStatement = 0
			SET @WHERE = @WHERE + '' AND tc.[InternalExternalCode]<>''''E''''''
		IF @LedgerStatement = 1
			SET @WHERE = @WHERE + '' AND tc.[InternalExternalCode]=''''E''''''
	END

    
    --KevinP - Changed query to treat the @PaymOrReceipt Variable as an independent clause, and not just tie it to the @AmountTo and @AmountFrom passed in.
    IF @PaymOrReceipt = 0 --Payment
		SET @WHERE = @WHERE + '' AND (ABS(n.[Amount]) != n.[Amount]) ''
	
	IF @PaymOrReceipt = 1 --Receipt
		SET @WHERE = @WHERE + '' AND (ABS(n.[Amount]) = n.[Amount]) ''
		
    --IF @PaymOrReceipt = 2 --Payment AND Receipt NB - nothing to set here, because we want to include both anyway


SET @sql = @SelectTopStatement + ''
	n.[NostroId]
	,[ValueDate]
	,[TransDate]
	,[Amount]
	,[TransactionType]
	,[InternalReference]
	,[ExternalReference]
	,[Narrative]
	,n.[AccountId]
	,n.[CurrencyId]
	,n.[DataSourceId]
	,[TempTableRecordId]
	,CASE WHEN ABS(AMOUNT)!=AMOUNT THEN ABS(AMOUNT) ELSE NULL END as Payment
	,CASE WHEN ABS(AMOUNT)=AMOUNT THEN AMOUNT ELSE NULL END as Receipt
	,n.[DepartmentId]
	,GroupNumber
	,SUBSTRING(nmt.Code,0,2) AS MatchTypeShortCode
	,CASE WHEN n.[DepartmentId] IS NOT NULL THEN dpt.[Code] ELSE '''''''' END As DepartmentCode
	,n.[Notes] As notes 
	,Substring(n.[Notes],0,20) As ShortNotes
    ,mc.[MatchCode] As MatchCode
    ,CASE WHEN tc.[InternalExternalCode] = ''''E'''' THEN ''''S'''' ELSE ''''L'''' END As LedgerOrStatement
	,nm.CreateDate AS MatchDate	
	,f.Code AS [FirmCode]
      '' + @FROM + @WHERE + ''       
        ORDER BY tc.InternalExternalCode, 
				ABS(AMOUNT) ASC,
				ValueDate ASC''

-- Execute the query
EXEC sp_executesql @sql


END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ReceiveLocation_GetByPackageSysId]''
');

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Select records from the ReceiveLocation table through an index
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[ReceiveLocation_GetByPackageSysId]
(

	@PackageSysId tinyint   
)
AS


				SELECT
					[ReceiveLocationSysId],
					[ReceiveLocationName],
					[PackageSysId],
					[FileMask],
					[InputFolder],
					[OutputFolder],
					[ErrorFolder],
					[DataSourceId],
					[Priority],
					[IsActive],
					[IsRunning],
					[CreateDateTimeUtc],
					[CreateUsername],
					[UpdateDateTimeUtc],
					[UpdateUsername],
					[DeleteDateTimeUtc],
					[DeleteUsername]
				FROM
					[dbo].[ReceiveLocation]
				WHERE
					[PackageSysId] = @PackageSysId
				SELECT @@ROWCOUNT
					
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TradeReconciliation_MarkVisited]''
');

GO
EXECUTE ('
CREATE PROCEDURE [dbo].[ib_TradeReconciliation_MarkVisited]
AS
 
--	Description: Moves the data from #visitingReportDetails to #visitedItems and
--	deletes all the record from #visitingReportDetails

--	30 Jul 2009		AAJM	Creation

SET NOCOUNT ON

-- Mark visited rows
INSERT INTO #visitedItems([TradeReconciliationDetailId])
	SELECT [TradeReconciliationDetailId] 
		FROM #visitingReportDetails
-- Clean visiting rows
DELETE FROM #visitingReportDetails
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TradeReconciliation_AddFromRule]''
');

GO
EXECUTE ('

CREATE PROCEDURE [dbo].[ib_TradeReconciliation_AddFromRule]
	@RuleType	VARCHAR(50) = ''Unknown''
AS

--	Description: Fill the #results for a generic Rule

--	30 Jul 2009		AAJM	Creation

SET NOCOUNT ON

	INSERT INTO #results([TradeReconciliationDetailId], [MatchCode])
		SELECT	[vrd].[TradeReconciliationDetailId]
				, [vrd].[MatchCode]
			FROM #visitingReportDetails vrd

	-- Mark and move visited rows
	EXEC ib_TradeReconciliation_MarkVisited
');

GO
EXECUTE ('PRINT N''Creating [dbo].[GMI_PPMF1_Purge]''
');

GO
EXECUTE ('
-- =============================================
-- Author:		Lee Manifold
-- Create date: 12 Dec 2006
-- Description:	Deletes from all GMI_PPMF11 type files where the LoadState is 0
-- =============================================
CREATE PROCEDURE [dbo].[GMI_PPMF1_Purge]
	(
	@LoadState		TINYINT = 0,
	@ImportFileId	INT,
	@RecordDate		DATETIME = NULL
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	
	--raiserror (''Lee doing specific raiserror in stored proc for testing'', 19, 1) with log
	
	IF @RecordDate IS NOT NULL 
	BEGIN
		--****Need to Add code here to factor in @RecordDate into table fields 
		DELETE FROM [dbo].[GMI_PPMF1] WHERE LoadState= @LoadState AND ImportFileId = @ImportFileId

	END
	
	IF @RecordDate IS NULL 
	BEGIN
	
		DELETE FROM [dbo].[GMI_PPMF1] WHERE LoadState= @LoadState AND ImportFileId = @ImportFileId

	END
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TemplateCompare_Delete]''
');

GO
EXECUTE (' /*
<details>
 <summary>Deletes a template compare by its id from the ib_TemplateCompare table</summary>
 <created author="Laurentiu Macovei" Date="Saturday, 9 September 2006 0:20AM GMT" /> 
</details>
*/
 create PROCEDURE [dbo].[ib_TemplateCompare_Delete]
(
	 @TemplateCompareId int
)
AS
SET NOCOUNT ON

DELETE FROM [dbo].[ib_TemplateCompare]
      WHERE TemplateCompareId = @TemplateCompareId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ReceiveLocation_GetByReceiveLocationSysId]''
');

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Select records from the ReceiveLocation table through an index
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[ReceiveLocation_GetByReceiveLocationSysId]
(

	@ReceiveLocationSysId tinyint   
)
AS


				SELECT
					[ReceiveLocationSysId],
					[ReceiveLocationName],
					[PackageSysId],
					[FileMask],
					[InputFolder],
					[OutputFolder],
					[ErrorFolder],
					[DataSourceId],
					[Priority],
					[IsActive],
					[IsRunning],
					[CreateDateTimeUtc],
					[CreateUsername],
					[UpdateDateTimeUtc],
					[UpdateUsername],
					[DeleteDateTimeUtc],
					[DeleteUsername]
				FROM
					[dbo].[ReceiveLocation]
				WHERE
					[ReceiveLocationSysId] = @ReceiveLocationSysId
				SELECT @@ROWCOUNT
					
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Exchange_GetCodeAndIdForAllExchanges]''
');

GO
EXECUTE ('  /*
<details>
 <summary>Returns code and id columns for all the exchanges</summary>
 <created author="laurentiu.macovei" date="Tue, 26 Sep 2006 12:13:27 GMT"/>
</details>
*/
create PROCEDURE [dbo].[ib_Exchange_GetCodeAndIdForAllExchanges]
AS
SET NOCOUNT ON
SELECT Code, ExchangeId 
	FROM ib_Exchange
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TradeReconciliation_GatherAdjustments]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_TradeReconciliation_GatherAdjustments]
	@ib_TradeReconciliationId INT
	, @CreateUsername VARCHAR(50)
	, @TemplateId INT
	, @TodayDate DATETIME
AS
SET NOCOUNT ON
	--	13 Aug 2010		amk		Creation (extracted from ib_TradeReconciliation_BuildReportPhase1)
	--							MBAL-16450: fix bug - don''t check excludetraderec flag on trxtype
	--  25 Jun 2014		ED		EIB 25770: logic for Unmatched Adj/Trades
	--  21 Jul 2014		ED		EIB 25771: fix StrikePrice/Price null cases
	--inserting from adjustment header - if we have any
	INSERT INTO [dbo].[ib_TradeReconciliationDetail]
			   ([TradeReconciliationId]
			   ,[AdjustmentId]
			   ,[MatchCode]
			   ,[ExchangeId]
			   ,[FirmId]
			   ,[AccountId]
			   ,[DetailAccountId]
			   ,[InstrumentId]
			   ,[ClassId] -- see task IBAL-2109
			   ,[ExpiryYear]
			   ,[ExpiryMonth]
			   ,[ExpiryDay]
			   ,[OptionTypeCode]
			   ,[CurrencyId]
			   ,[StrikePrice]
			   ,[TradePrice]
			   ,[InternalLong]
			   ,[InternalShort]
			   ,[ExternalLong]
			   ,[ExternalShort]
			   ,[InternalExternalCode]
			   ,[CreateUsername]
			   ,[DataSourceId]
			   ,[TrxDate]
			   ,[TrxTypeCode])
	SELECT @ib_TradeReconciliationId
				, a.AdjustmentId
				, mc.MatchCode
				, a.[ExchangeId]
				, a.[FirmId]
				, a.[AccountId]
				, a.[DetailAccountId]
				, a.[InstrumentId]
				, a.[ClassId]
				, a.[ExpiryYear]
				, a.[ExpiryMonth]
				, a.[ExpiryDay]
				, ISNULL(a.[OptionTypeCode],'''')
				, a.[CurrencyId]
				, ISNULL(a.[StrikePrice], 0)
				, ISNULL(a.[TradePrice], 0)
				, [InternalLong] = CASE WHEN a.[InternalExternalCode] = ''I'' THEN -- Internal
				ISNULL(a.[QuantityLong],0)
			ELSE 0 -- Not Internal
			END
				, [InternalShort] = CASE WHEN a.[InternalExternalCode] = ''I'' THEN -- Internal
				ISNULL(a.[QuantityShort],0)
			ELSE 0 -- Not Internal
			END
				, [ExternalLong] = CASE WHEN a.[InternalExternalCode] = ''E'' THEN -- Internal
				ISNULL(a.[QuantityLong],0)
			ELSE 0 -- Not External
			END
				, [ExternalShort] = CASE WHEN a.[InternalExternalCode] = ''E'' THEN -- Internal
				ISNULL(a.[QuantityShort],0)
			ELSE 0 -- Not External
			END
				, a.[InternalExternalCode]
				, [CreateUsername] = @CreateUsername
				, a.[DataSourceId]
				, a.[TradeDate]
				, ''iBal-Adj''
		FROM dbo.ib_Adjustment a
			INNER JOIN dbo.ib_MatchCode mc ON		
				mc.MatchCodeId = a.MatchCodeId 
			INNER JOIN ib_AdjustmentHeader ah ON ah.AdjustmentHeaderId = a.AdjustmentHeaderId
			INNER JOIN ib_AdjustmentType AT ON at.AdjustmentTypeId = ah.AdjustmentTypeId
			INNER JOIN ib_Exchange ex ON 
					a.ExchangeId = ex.ExchangeId 
					AND ex.RunTradeLevelReconciliation <> 0 
			LEFT JOIN ib_AdjustmentStatus [as] ON [as].AdjustmentStatusId = a.AdjustmentStatusId
		WHERE a.TemplateID = @TemplateId
				AND a.AdjustmentDate = @TodayDate 
				AND a.ReplacesAdjustmentId IS NULL
				AND at.Code IN (''TC'',''TI'',''MI'', ''UM'') -- ONLY trade related adjs
				AND ([as].Code NOT IN (''A'') OR a.AdjustmentStatusId IS NULL)
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TradeReconciliation_BuildReportPhase1]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_TradeReconciliation_BuildReportPhase1]
(
	@CreateUsername VARCHAR(50) = NULL,
	@TemplateId INT,
	@TodayDate DATETIME,
	@UserId UNIQUEIDENTIFIER,
	@@ReportId INT OUTPUT,
	@@ib_TradeReconciliationId INT OUTPUT
)
AS

--	Description: Generates the ib_TradeReconciliationDetail records for Trade Reconciliation Phase 1

--	30 Jul 2009		AAJM	Creation
--  07 Aug 2009		AAJM	Add Internal/External to help query for separate display
--  07 Aug 2009		AAJM	MBAL-12700 Move calc of long and short quantities to speed up query
--	15 Sep 2009		AAJM	Exclude trade separations (MBAL-13149)
--	07 Oct 2009		AAJM	MBAL-13400 and MBAL-13149
--							Fix transactions with no related TrxTypeCode excluded
--							and fix how filtering out Trade Separations
--	21 Oct 2009		amk		MBAL-12857: Make exclusion based on trade type table driven
--  02 Jun 2010     ED      Exclude Automatically Matched Adjustments, call SP to rollover/match adjs
--	25 Jun 2010		ED		MBAL-15949: don''t include manually matched adjustments
--	30 Jul 2010		amk		MBAL-16340: undo above change - allow manually matched adjustments back in
--	02 Aug 2010		amk		MBAL-16358: match adjustments on As Of Date, not trade date; also exclude adjustments that are result of roll forward
--	13 Aug 2010		amk		MBAL-16450: move out adjustment to new routine and fix bug on the query
--	06 Jan 2011		amk		MBAL-17237: ensure calls to add new report record carry template so site can be saved correctly
--	13 Jun 2012		ED		MBAL 20980 - add nolock for trx/position select	
--  25 Jun 2014		ED		EIB 25770: logic for Unmatched Adj/Trades
--	08 Sep 2014		ED		EIB 25958 - include unmatched on trade rec
	SET NOCOUNT ON

	IF @@ReportId IS NULL
		EXEC [dbo].[ib_Report_CreateReport] ''TradeRec'', @CreateUserName, @UserId, @@ReportId OUTPUT
			, NULL, @TemplateId

	--update the report status
	UPDATE [dbo].[ib_Report]
	SET [Stage] = ''Phase 1a: Validating''
	WHERE ReportId = @@ReportId

	--validate
	IF @TodayDate IS NULL
		RAISERROR (N''First Date cannot be NULL!'', 11, 1)

	IF @TemplateId IS NULL
		RAISERROR (N''TemplateID cannot be NULL!'', 11, 3)

	--update the report status
	UPDATE [dbo].[ib_Report]
	SET [Stage] = ''Phase 1b: Checking for matching data''
	WHERE ReportId = @@ReportId

	--try to validate the input dates, so find if there is any records matching them
	DECLARE @RowCount int
	SELECT TOP 1 @RowCount = Count(TrxId) 
	FROM [dbo].[ib_trx] (NOLOCK)
	WHERE AsOfDate = @TodayDate
	
	--fix the username
	IF (@CreateUsername IS NULL)
		SET @CreateUsername = SUSER_NAME()
	
	--update the report status
	UPDATE [dbo].[ib_Report]
	SET [Stage] = ''Phase 1c: Create the report header''
	WHERE ReportId = @@ReportId

	--create the ReportHeader
	INSERT INTO [dbo].[ib_TradeReconciliation](TemplateId, Today, CreateUsername)
	SELECT @TemplateId, @TodayDate, @CreateUsername
	FROM [dbo].ib_Template
	WHERE TemplateId = @TemplateId

	--check the creation
	IF @@RowCount = 0 
		RAISERROR (N''Specified Template with TemplateID ''''%d'''' does not exist.'', 11, 1, @TemplateId)

	--take the newly created ReportId
	SELECT @@ib_TradeReconciliationId = SCOPE_IDENTITY()

	--update the report status
	UPDATE [dbo].[ib_Report]
	SET [Stage] = ''Phase 1d: Load records from Trx for Firms''
	WHERE ReportId = @@ReportId

	INSERT INTO [dbo].[ib_TradeReconciliationDetail]
			   ([TradeReconciliationId]
			   ,[TrxId]
			   ,[MatchCode]
			   ,[ExchangeId]
			   ,[FirmId]
			   ,[AccountId]
			   ,[DetailAccountId]
			   ,[InstrumentId]
			   ,[ClassId] -- see task IBAL-2109
			   ,[ExpiryYear]
			   ,[ExpiryMonth]
			   ,[ExpiryDay]
			   ,[OptionTypeCode]
			   ,[CurrencyId]
			   ,[StrikePrice]
			   ,[TradePrice]
			   ,[InternalLong]
			   ,[InternalShort]
			   ,[ExternalLong]
			   ,[ExternalShort]
			   ,[InternalExternalCode]
			   ,[CreateUsername]
			   ,[DataSourceId]
			   ,[TrxDate]
			   ,[TrxTypeCode])
	SELECT @@ib_TradeReconciliationId
				, [trx].[TrxId]
				, '''' AS [MatchCode]
				, [trx].[ExchangeId]
				, [trx].[FirmId]
				, [trx].[AccountId]
				, [trx].[DetailAccountId]
				, [trx].[InstrumentId]
				, [trx].[ClassId]
				, [trx].[ExpiryYear]
				, [trx].[ExpiryMonth]
				, [trx].[ExpiryDay]
				, ISNULL([trx].[OptionTypeCode],'''')
				, [trx].[CurrencyId]
				, ISNULL([trx].[StrikePrice],0)
				, ISNULL([trx].[Price],0)
				, [InternalLong] = CASE WHEN [tc].[InternalExternalCode] = ''I'' THEN -- Internal
				ISNULL([trx].[QuantityLong],0)
			ELSE 0 -- Not Internal
			END
				, [InternalShort] = CASE WHEN [tc].[InternalExternalCode] = ''I'' THEN -- Internal
				ISNULL([trx].[QuantityShort],0)
			ELSE 0 -- Not Internal
			END
				, [ExternalLong] = CASE WHEN [tc].[InternalExternalCode] = ''E'' THEN -- External
				ISNULL([trx].[QuantityLong],0)
			ELSE 0 -- Not External
			END
				, [ExternalShort] = CASE WHEN [tc].[InternalExternalCode] = ''E'' THEN -- External
				ISNULL([trx].[QuantityShort],0)
			ELSE 0 -- Not External
			END
				, [tc].[InternalExternalCode]
				, [CreateUsername] = @CreateUsername
				, [trx].[DataSourceId]
				, [trx].[TrxDate]
				, [trx].[TrxTypeCode]
		FROM dbo.ib_TemplateCompare tc 
			INNER JOIN dbo.ib_Trx trx (NOLOCK) ON tc.TemplateID = @TemplateId AND trx.FirmID = tc.FirmID AND trx.DataSourceId = tc.DataSourceId AND (trx.AsOfDate = @TodayDate)
			LEFT JOIN [dbo].ib_TrxType tt ON tt.Code = trx.TrxTypeCode AND tt.DataSourceId = trx.DataSourceId 
			INNER JOIN ib_Exchange ex ON trx.ExchangeId = ex.ExchangeId AND ex.RunTradeLevelReconciliation <> 0 
		WHERE (tt.ExcludeFromTradeRec = 0 OR tt.ExcludeFromTradeRec IS NULL) 

	--update the report status
	UPDATE [dbo].[ib_Report]
	SET [Stage] = ''Phase 1e: Gathering adjustments''
	WHERE ReportId = @@ReportId

	EXEC ib_TradeReconciliation_GatherAdjustments
		@@ib_TradeReconciliationId, @CreateUsername, @TemplateId, @TodayDate
				
	--update the report status
	UPDATE [dbo].[ib_Report]
	SET [Stage] = ''Phase 1: Completed''
	WHERE ReportId = @@ReportId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[GMI_ST4F1_Add]''
');

GO
EXECUTE ('

-- =============================================
-- Author:		Lee Manifold
-- Create date: 26 Jul 2006
-- Description:	Insert into GMI_ST4F1
--
-- History
--
-- Date			Author		Description
-- 28 Feb 2007	LM			Added extra field called ImportFileId
-- =============================================
CREATE PROCEDURE [dbo].[GMI_ST4F1_Add]
		(
		   @RecordID						varchar(1),
           @FirmID							varchar(1),
           @OfficeNumber					varchar(3),
           @AccountNumber					varchar(5),
           @ContractYrMth					varchar(6),
           @SubCusip						varchar(2),
           @SecuritySubType					varchar(1),
           @StrikePrice						decimal(15,8),
           @ExpirationDate					varchar(9),
           @TradeDate						varchar(9),
           @TradePrice						decimal(15,8),
           @BuySellCode						varchar(1),
           @SpreadCode						varchar(1),
           @AccountClassCode				varchar(1),
           @SubClassCode					varchar(1),
           @Quantity						decimal(19,4),
           @ExchangeCode					varchar(2),
           @FuturesCode						varchar(2),
           @ContractTypeCode				varchar(1),
           @PrintableTradePrice				varchar(20),
           @InputExercisePrice				varchar(7),
           @InputTradePrice					varchar(12),
           @ProductCurrencySymbol			varchar(3),
           @ProductCurrencyCode				varchar(2),
           @ExecutingBroker					varchar(5),
           @OppositeFirm					varchar(5),
           @GiveInOutCode					varchar(2),
           @GiveInOutFirm					varchar(5),
           @InterExchangeExchange			varchar(2),
           @InterExchangeFirm				varchar(5),
           @CardNumber						varchar(4),
           @FuturesTradeType				varchar(1),
           @CommisionAmount					decimal(15,2),
           @ClearingFee						decimal(15,2),
           @ExchFee							decimal(15,2),
           @FeeNFA							decimal(15,2),
           @FeeExecCharge					decimal(15,2),
           @FeeAmt5Fee						decimal(15,2),
           @FeeAmount6						decimal(15,2),
           @FeeAmount7						decimal(15,2),
           @FeeAmount8						decimal(15,2),
           @FeeAmount9						decimal(15,2),
           @GiveInOutCharge					decimal(15,2),
           @BrokerageCharge					decimal(15,2),
           @OtherCharges					decimal(15,2),
           @GrossAmount						decimal(15,2),
           @BackOfficeCharge				decimal(15,2),
           @WireCharges						decimal(15,2),
           @AccountTypeCommissionPosted		varchar(2),
           @AccountTypeFee1Posted			varchar(2),
           @AccountTypeFee2Posted			varchar(2),
           @AccountTypeFee3Posted			varchar(2),
           @AccountTypeFee4Posted			varchar(2),
           @AccountTypeFee5Posted			varchar(2),
           @AccountTypeFee6Posted			varchar(2),
           @AccountTypeFee7Posted			varchar(2),
           @AccountTypeFee8Posted			varchar(2),
           @AccountTypeFee9Posted			varchar(2),
           @AccountTypeGiveInOutAmount		varchar(2),
           @AccountTypeBrockeragePosted		varchar(2),
           @AccountTypeOtherChargesPos		varchar(2),
           @PosFileSortKey					varchar(50),
           @Countrycode						varchar(2),
           @Symbol							varchar(6),
		   @ImportFileId					int	
		)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	INSERT INTO [dbo].[GMI_ST4F1]
           (
			[RecordID]
           ,[FirmID]
           ,[OfficeNumber]
           ,[AccountNumber]
           ,[ContractYrMth]
           ,[SubCusip]
           ,[SecuritySubType]
           ,[StrikePrice]
           ,[ExpirationDate]
           ,[TradeDate]
           ,[TradePrice]
           ,[BuySellCode]
           ,[SpreadCode]
           ,[AccountClassCode]
           ,[SubClassCode]
           ,[Quantity]
           ,[ExchangeCode]
           ,[FuturesCode]
           ,[ContractTypeCode]
           ,[PrintableTradePrice]
           ,[InputExercisePrice]
           ,[InputTradePrice]
           ,[ProductCurrencySymbol]
           ,[ProductCurrencyCode]
           ,[ExecutingBroker]
           ,[OppositeFirm]
           ,[GiveInOutCode]
           ,[GiveInOutFirm]
           ,[InterExchangeExchange]
           ,[InterExchangeFirm]
           ,[CardNumber]
           ,[FuturesTradeType]
           ,[CommisionAmount]
           ,[ClearingFee]
           ,[ExchFee]
           ,[FeeNFA]
           ,[FeeExecCharge]
           ,[FeeAmt5Fee]
           ,[FeeAmount6]
           ,[FeeAmount7]
           ,[FeeAmount8]
           ,[FeeAmount9]
           ,[GiveInOutCharge]
           ,[BrokerageCharge]
           ,[OtherCharges]
           ,[GrossAmount]
           ,[BackOfficeCharge]
           ,[WireCharges]
           ,[AccountTypeCommissionPosted]
           ,[AccountTypeFee1Posted]
           ,[AccountTypeFee2Posted]
           ,[AccountTypeFee3Posted]
           ,[AccountTypeFee4Posted]
           ,[AccountTypeFee5Posted]
           ,[AccountTypeFee6Posted]
           ,[AccountTypeFee7Posted]
           ,[AccountTypeFee8Posted]
           ,[AccountTypeFee9Posted]
           ,[AccountTypeGiveInOutAmount]
           ,[AccountTypeBrockeragePosted]
           ,[AccountTypeOtherChargesPos]
           ,[PosFileSortKey]
           ,[Countrycode]
           ,[Symbol]
		   ,[ImportFileId]
			)
     VALUES
           (
		   @RecordID,
           @FirmID,
           @OfficeNumber,
           @AccountNumber,
           @ContractYrMth,
           @SubCusip,
           @SecuritySubType,
           @StrikePrice,
           @ExpirationDate,
           @TradeDate,
           @TradePrice,
           @BuySellCode,
           @SpreadCode,
           @AccountClassCode,
           @SubClassCode,
           @Quantity,
           @ExchangeCode,
           @FuturesCode,
           @ContractTypeCode,
           @PrintableTradePrice,
           @InputExercisePrice,
           @InputTradePrice,
           @ProductCurrencySymbol,
           @ProductCurrencyCode,
           @ExecutingBroker,
           @OppositeFirm,
           @GiveInOutCode,
           @GiveInOutFirm,
           @InterExchangeExchange,
           @InterExchangeFirm,
           @CardNumber,
           @FuturesTradeType,
           @CommisionAmount,
           @ClearingFee,
           @ExchFee,
           @FeeNFA,
           @FeeExecCharge,
           @FeeAmt5Fee,
           @FeeAmount6,
           @FeeAmount7,
           @FeeAmount8,
           @FeeAmount9,
           @GiveInOutCharge,
           @BrokerageCharge,
           @OtherCharges,
           @GrossAmount,
           @BackOfficeCharge,
           @WireCharges,
           @AccountTypeCommissionPosted,
           @AccountTypeFee1Posted,
           @AccountTypeFee2Posted,
           @AccountTypeFee3Posted,
           @AccountTypeFee4Posted,
           @AccountTypeFee5Posted,
           @AccountTypeFee6Posted,
           @AccountTypeFee7Posted,
           @AccountTypeFee8Posted,
           @AccountTypeFee9Posted,
           @AccountTypeGiveInOutAmount,
           @AccountTypeBrockeragePosted,
           @AccountTypeOtherChargesPos,
           @PosFileSortKey,
           @Countrycode,
           @Symbol,
		   @ImportFileId	
		   )
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[_ib_DataSource_GetDataSourcesByTemplateId]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[_ib_DataSource_GetDataSourcesByTemplateId]
(
	@TemplateId INT = NULL
)
AS
SET NOCOUNT ON
--	23	May 2014  ED  EIB 25492 - created

SELECT d.DataSourceId, d.Code, d.Name
	FROM ib_DataSource d
	WHERE DataSourceId IN (SELECT distinct DataSourceId FROM ib_TemplateCompare WHERE TemplateId = @TemplateId)
	ORDER BY [Name]
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TemplateCompare_GetByInternalExternalCode]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_TemplateCompare_GetByInternalExternalCode]
	@TemplateId INT
	, @InternalExternalCode CHAR(1)
AS
BEGIN
	--	21 Sep 2009		amk		Creation

	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for procedure here
	SELECT tc.TemplateCompareId, f.Firmid
		, tc.InternalExternalCode, f.Code, f.Name
	FROM ib_TemplateCompare tc
		INNER JOIN ib_Firm f ON f.Firmid = tc.FirmId
	WHERE TemplateId = @TemplateId
		AND InternalExternalCode = @InternalExternalCode
	ORDER BY f.Name
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_SwiftStatementSeed_Get_List]''
');

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Gets all records from the ib_SwiftStatementSeed table
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[ib_SwiftStatementSeed_Get_List]

AS


				
				SELECT
					[SwiftStatementSeedId],
					[AccountId],
					[StatementNumberSeed],
					[CreateDate],
					[CreateUsername],
					[UpdateDate],
					[UpdateUsername]
				FROM
					[dbo].[ib_SwiftStatementSeed]
					
				SELECT @@ROWCOUNT
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Exchange_GetCodeForSpecificId]''
');

GO
EXECUTE ('/*
<details>
	<summary>Returns the code for a specific exchange id</summary>
	<created author="laurentiu.macovei" date="Thu, 19 Oct 2006 19:20:03 GMT"/>
</details>
*/
CREATE PROCEDURE [dbo].[ib_Exchange_GetCodeForSpecificId] 
@ExchangeId int
AS
SET NOCOUNT ON

DECLARE @FoundCode varchar(100)
SET @FoundCode = ''''
SELECT TOP 1 @FoundCode = e.Code
	FROM ib_Exchange e
	WHERE ExchangeId = @ExchangeId
SELECT @FoundCode
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TradeReconciliation_BuildReportPhase2]''
');

GO
EXECUTE ('
CREATE PROCEDURE [dbo].[ib_TradeReconciliation_BuildReportPhase2]
	@ReportId INT,
	@TradeReconciliationId INT
AS

--	Description: Starting with the data populated in the ib_TradeReconciliationDetail
--	table, the Transactions are stamped with the correct MatchCode.  
--	The transactions are then grouped appropriately and output to the
--	ib_TradeReconciliationSummary table ready for outputting to a report.

--	30 Jul 2009		AAJM	Creation
--	16 Oct 2009		amk		Re-enable the unknown bucket
--	07 Jul 2014		ED		EIB 25802 - remove house account records
--  02 Sep 2014		RD		EIB 25949 - removed HVH code from this sp - should be when matching. Modified the summary to not show HVH differences as an imbalance.
--  16 Jan 2015		ED		EIB 26413 - improve performance

SET NOCOUNT ON

--Update the report status
UPDATE [dbo].[ib_Report]
	SET [Stage] = ''Phase 2: Preparing temporary tables''
	WHERE ReportId = @ReportId


-- Create the TemplateGroup #tg Temporary table with only needed records
CREATE TABLE #tg
(	
	  [ExchangeId] INT
	, [FirmId] INT
	, [AccountId] INT
	, [InstrumentID] INT
	, [ClassId] INT
	, [MatchCode] VARCHAR(100)
	, [TemplateGroupId] INT
)

--Create the table for storing visited items
CREATE TABLE #visitedItems
(	
	[TradeReconciliationDetailId] INT
)

CREATE UNIQUE NONCLUSTERED INDEX [IX_visitedItems_TradeReconciliationDetailId] ON #visitedItems
(
[TradeReconciliationDetailId] ASC
) WITH (PAD_INDEX  = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, IGNORE_DUP_KEY = OFF, ONLINE = OFF) ON [PRIMARY]


-- Create the table for storing visiting items while processing for a particular rule
CREATE TABLE #visitingReportDetails
(	
	  [TradeReconciliationDetailId] INT NOT NULL
	, [MatchCode] VARCHAR(100) NOT NULL
)

----Indexing the #tg table
-- CREATE UNIQUE NONCLUSTERED INDEX [AK_TG] ON #TG 
-- (
-- 	[ExchangeId] ASC, 
-- 	[FirmId] ASC, 
-- 	[AccountId] ASC, 
--  [InstrumentID] ASC,
-- 	[ClassId] ASC,
-- 	[MatchCode] ASC
-- ) WITH (PAD_INDEX  = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, IGNORE_DUP_KEY = OFF, ONLINE = OFF) ON [PRIMARY]

-- Create a temporary table to collect & compare final transaction-level results
CREATE TABLE #results
( 
	  [TradeReconciliationDetailId] [int] NOT NULL 
	, [MatchCode] VARCHAR(100) NULL
)

CREATE NONCLUSTERED INDEX IX_Results_TradeReconciliationDetailId ON #results
	(
	[TradeReconciliationDetailId]
	) WITH( PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]


CREATE NONCLUSTERED INDEX IX_Results_MatchCode ON #results
	(
	[MatchCode]
	) WITH( PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]

	
--Update the report status
UPDATE [dbo].[ib_Report]
	SET [Stage] = ''Phase 2: Gathering Template Groups''
	WHERE ReportId = @ReportId


--INSERT Template Group elements for the specified TemplateID of the provided TradeReconciliationId
INSERT INTO #tg(ExchangeId, FirmId, AccountId, InstrumentID, MatchCode, TemplateGroupId, ClassId)
	SELECT tg.ExchangeId, tg.FirmId, tg.AccountId, tg.InstrumentID, tg.Description, tg.TemplateGroupId, tg.ClassId
		FROM ib_TemplateGroup tg
		INNER JOIN ib_TradeReconciliation tr ON tr.TradeReconciliationId = @TradeReconciliationId AND tg.TemplateId = tr.TemplateId

--update the report status
UPDATE [dbo].[ib_Report]
	SET [Stage] = ''Phase 2: Gathering records matching rule 1 of 5''
	WHERE ReportId = @ReportId


--MARTIN''s MATRIX RULE #1 (Firm Exchange Account Instrument)
--INSERT records that mach Martin''s rule #1 (Firm Exchange Account Instrument)
	INSERT INTO #visitingReportDetails([TradeReconciliationDetailId], [MatchCode])
		SELECT	[ird].[TradeReconciliationDetailId], [tg].[MatchCode]
			FROM [dbo].[ib_TradeReconciliationDetail] ird 
					INNER JOIN [ib_TradeReconciliation] ir ON 
						ir.TradeReconciliationId = @TradeReconciliationId 
					AND ir.TradeReconciliationId = ird.TradeReconciliationId
					INNER JOIN #tg tg ON
						[tg].[ClassId] = [ird].[ClassId] --IBAL-2109
					AND	[tg].[FirmId] = [ird].[FirmId]
					AND [tg].[ExchangeId] = [ird].[ExchangeId]
					AND [tg].[AccountId] = [ird].[AccountId]
					AND [tg].[InstrumentId] = [ird].[InstrumentId]
			WHERE NOT EXISTS (SELECT 1 FROM #visitedItems v WHERE v.TradeReconciliationDetailId=[ird].[TradeReconciliationDetailId]) --exclude previous items

	EXEC ib_TradeReconciliation_AddFromRule ''1a''

	INSERT INTO #visitingReportDetails([TradeReconciliationDetailId], [MatchCode])
			SELECT	[ird].[TradeReconciliationDetailId], [tg].[MatchCode]
				FROM [dbo].[ib_TradeReconciliationDetail] ird 
						INNER JOIN [ib_TradeReconciliation] ir ON 
							ir.TradeReconciliationId = @TradeReconciliationId 
						AND ir.TradeReconciliationId = ird.TradeReconciliationId
						INNER JOIN #tg tg ON
							[tg].[ClassId] IS NULL --IBAL-2109
						AND	[tg].[FirmId] = [ird].[FirmId]
						AND [tg].[ExchangeId] = [ird].[ExchangeId] 
						AND [tg].[AccountId] = [ird].[AccountId]
						AND [tg].[InstrumentId] = [ird].[InstrumentId]
			WHERE NOT EXISTS (SELECT 1 FROM #visitedItems v WHERE v.TradeReconciliationDetailId=[ird].[TradeReconciliationDetailId]) --exclude previous items

	EXEC [dbo].[ib_TradeReconciliation_AddFromRule] ''1b''

--update the report status
UPDATE [dbo].[ib_Report]
	SET [Stage] = ''Phase 2: Gathering records matching rule 2 of 5''
	WHERE ReportId = @ReportId

--MARTIN''s MATRIX RULE #2 (Firm Exchange Account)
--Select records that mach Martin''s rule #2 (Firm Exchange Account), BUT excluding duplicates from already existing record (rule #1)
--These will be appended to the previous records (rule #1)
	INSERT INTO #visitingReportDetails([TradeReconciliationDetailId], [MatchCode])
		SELECT	[ird].[TradeReconciliationDetailId], [tg].[MatchCode]
			FROM [dbo].[ib_TradeReconciliationDetail] ird
					INNER JOIN [ib_TradeReconciliation] ir ON
						ir.TradeReconciliationId = @TradeReconciliationId
					AND ir.TradeReconciliationId = ird.TradeReconciliationId
					INNER JOIN #tg tg ON
						[tg].[ClassId] = [ird].[ClassId] --IBAL-2109
					AND	[tg].[FirmId] = [ird].[FirmId]
					AND [tg].[ExchangeId] = [ird].[ExchangeId]
					AND [tg].[AccountId] = [ird].[AccountId]
					AND [tg].[InstrumentId] IS NULL
			WHERE NOT EXISTS (SELECT 1 FROM #visitedItems v WHERE v.TradeReconciliationDetailId=[ird].[TradeReconciliationDetailId]) --exclude previous items

	EXEC [dbo].[ib_TradeReconciliation_AddFromRule] ''2a''

	INSERT INTO #visitingReportDetails([TradeReconciliationDetailId], [MatchCode])
			SELECT	[ird].[TradeReconciliationDetailId], [tg].[MatchCode]
				FROM [dbo].[ib_TradeReconciliationDetail] ird 
						INNER JOIN [ib_TradeReconciliation] ir ON 
							ir.TradeReconciliationId = @TradeReconciliationId 
						AND ir.TradeReconciliationId = ird.TradeReconciliationId
						INNER JOIN #tg tg ON
							[tg].[ClassId] IS NULL --IBAL-2109
						AND	[tg].[FirmId] = [ird].[FirmId]
						AND [tg].[ExchangeId] = [ird].[ExchangeId]
						AND [tg].[AccountId] = [ird].[AccountId]
						AND [tg].[InstrumentId] IS NULL
			WHERE NOT EXISTS (SELECT 1 FROM #visitedItems v WHERE v.TradeReconciliationDetailId=[ird].[TradeReconciliationDetailId]) --exclude previous items

	EXEC [dbo].[ib_TradeReconciliation_AddFromRule] ''2b''

--update the report status
UPDATE [dbo].[ib_Report]
	SET [Stage] = ''Phase 2: Gathering records matching rule 3 of 5''
	WHERE ReportId = @ReportId

--MARTIN''s MATRIX RULE #3 (Firm Account)
--Select records that mach Martin''s rule #3 (Firm Account), BUT excluding duplicates from already existing record (rule #1 and rule #2)
--These will be appended to the previous records ((rule #1 UNION rule #2)''s records)
	INSERT INTO #visitingReportDetails([TradeReconciliationDetailId], [MatchCode])
		SELECT	[ird].[TradeReconciliationDetailId], [tg].[MatchCode]
			FROM [dbo].[ib_TradeReconciliationDetail] ird
					INNER JOIN [ib_TradeReconciliation] ir ON
						ir.TradeReconciliationId = @TradeReconciliationId
					AND ir.TradeReconciliationId = ird.TradeReconciliationId
					INNER JOIN #tg tg ON
						[tg].[ClassId] = [ird].[ClassId] --IBAL-2109
					AND	[tg].[FirmId] = [ird].[FirmId]
					AND [tg].[ExchangeId] IS NULL
					AND [tg].[AccountId] = [ird].[AccountId]
					AND [tg].[InstrumentId] IS NULL
			WHERE NOT EXISTS (SELECT 1 FROM #visitedItems v WHERE v.TradeReconciliationDetailId=[ird].[TradeReconciliationDetailId]) --exclude previous items

	EXEC [dbo].[ib_TradeReconciliation_AddFromRule] ''3a''

	INSERT INTO #visitingReportDetails([TradeReconciliationDetailId], [MatchCode])
			SELECT	[ird].[TradeReconciliationDetailId], [tg].[MatchCode]
				FROM [dbo].[ib_TradeReconciliationDetail] ird 
						INNER JOIN [ib_TradeReconciliation] ir ON 
							ir.TradeReconciliationId = @TradeReconciliationId 
						AND ir.TradeReconciliationId = ird.TradeReconciliationId
						INNER JOIN #tg tg ON
							[tg].[ClassId] IS NULL --IBAL-2109
						AND	[tg].[FirmId] = [ird].[FirmId]
						AND [tg].[ExchangeId] IS NULL
						AND [tg].[AccountId] = [ird].[AccountId]
						AND [tg].[InstrumentId] IS NULL
			WHERE NOT EXISTS (SELECT 1 FROM #visitedItems v WHERE v.TradeReconciliationDetailId=[ird].[TradeReconciliationDetailId]) --exclude previous items

	EXEC [dbo].[ib_TradeReconciliation_AddFromRule] ''3b''


--update the report status
UPDATE [dbo].[ib_Report]
	SET [Stage] = ''Phase 2: Gathering records matching rule 4 of 5''
	WHERE ReportId = @ReportId


--MARTIN''s MATRIX RULE #4 (Firm Exchange)
--Select records that mach Martin''s rule #4 (Firm Exchange), BUT excluding duplicates from already existing record (rule #1, rule #2 and rule #3)
--These will be appended to the previous records ((rule #1 UNION #2 UNION r3)''s records)
	INSERT INTO #visitingReportDetails([TradeReconciliationDetailId], [MatchCode])
		SELECT	[ird].[TradeReconciliationDetailId], [tg].[MatchCode]
			FROM [dbo].[ib_TradeReconciliationDetail] ird
					INNER JOIN [ib_TradeReconciliation] ir ON
						ir.TradeReconciliationId = @TradeReconciliationId
					AND ir.TradeReconciliationId = ird.TradeReconciliationId
					INNER JOIN #tg tg ON
						[tg].[ClassId] = [ird].[ClassId] --IBAL-2109
					AND	[tg].[FirmId] = [ird].[FirmId]
					AND [tg].[ExchangeId] = [ird].[ExchangeId]
					AND [tg].[AccountId] IS NULL
					AND [tg].[InstrumentId] IS NULL
			WHERE NOT EXISTS (SELECT 1 FROM #visitedItems v WHERE v.TradeReconciliationDetailId=[ird].[TradeReconciliationDetailId]) --exclude previous items

	EXEC [dbo].[ib_TradeReconciliation_AddFromRule] ''4a''

	INSERT INTO #visitingReportDetails([TradeReconciliationDetailId], [MatchCode])
			SELECT	[ird].[TradeReconciliationDetailId], [tg].[MatchCode]
				FROM [dbo].[ib_TradeReconciliationDetail] ird 
						INNER JOIN [ib_TradeReconciliation] ir ON 
							ir.TradeReconciliationId = @TradeReconciliationId 
						AND ir.TradeReconciliationId = ird.TradeReconciliationId
						INNER JOIN #tg tg ON
							[tg].[ClassId] IS NULL --IBAL-2109
						AND	[tg].[FirmId] = [ird].[FirmId]
						AND [tg].[ExchangeId] = [ird].[ExchangeId]
						AND [tg].[AccountId] IS NULL
						AND [tg].[InstrumentId] IS NULL
			WHERE NOT EXISTS (SELECT 1 FROM #visitedItems v WHERE v.TradeReconciliationDetailId=[ird].[TradeReconciliationDetailId]) --exclude previous items

	EXEC [dbo].[ib_TradeReconciliation_AddFromRule] ''4b''

--update the report status
UPDATE [dbo].[ib_Report]
	SET [Stage] = ''Phase 2: Gathering records matching rule 5 of 5''
	WHERE ReportId = @ReportId


--MARTIN''s MATRIX RULE #5 (Firm)
--Select records that mach Martin''s rule #5 (Firm), BUT excluding duplicates from already existing record (rule #1, rule #2 and rule #3 and rule #4)
--These will be appended to the previous records ((rule #1 UNION #2 UNION r3 UNION r4)''s records)
	INSERT INTO #visitingReportDetails([TradeReconciliationDetailId], [MatchCode])
		SELECT	[ird].[TradeReconciliationDetailId], [tg].[MatchCode]
			FROM [dbo].[ib_TradeReconciliationDetail] ird
					INNER JOIN [ib_TradeReconciliation] ir ON
						ir.TradeReconciliationId = @TradeReconciliationId
					AND ir.TradeReconciliationId = ird.TradeReconciliationId
					INNER JOIN #tg tg ON
						[tg].[ClassId] = [ird].[ClassId] --IBAL-2109
					AND	[tg].[FirmId] = [ird].[FirmId]
					AND [tg].[ExchangeId] IS NULL
					AND [tg].[AccountId] IS NULL
					AND [tg].[InstrumentId] IS NULL
			WHERE NOT EXISTS (SELECT 1 FROM #visitedItems v WHERE v.TradeReconciliationDetailId=[ird].[TradeReconciliationDetailId]) --exclude previous items

	EXEC [dbo].[ib_TradeReconciliation_AddFromRule] ''5a''

	INSERT INTO #visitingReportDetails([TradeReconciliationDetailId], [MatchCode])
			SELECT	[ird].[TradeReconciliationDetailId], [tg].[MatchCode]
				FROM [dbo].[ib_TradeReconciliationDetail] ird 
						INNER JOIN [ib_TradeReconciliation] ir ON 
							ir.TradeReconciliationId = @TradeReconciliationId 
						AND ir.TradeReconciliationId = ird.TradeReconciliationId
						INNER JOIN #tg tg ON
							[tg].[FirmId] = [ird].[FirmId]
				WHERE NOT EXISTS (SELECT 1 FROM #visitedItems v WHERE v.TradeReconciliationDetailId=[ird].[TradeReconciliationDetailId]) --exclude previous items
					AND [tg].[ClassId] IS NULL --IBAL-2109
					AND [tg].[ExchangeId] IS NULL
					AND [tg].[AccountId] IS NULL
					AND [tg].[InstrumentId] IS NULL

	EXEC [dbo].[ib_TradeReconciliation_AddFromRule] ''5b''


-- Update the report status
UPDATE [dbo].[ib_Report]
SET [Stage] = ''Phase 2: Gathering the remaining ungrouped through a template items''
WHERE ReportId = @ReportId


--APPEND those rows wHich don''t map to any of the MARTIN''''s MATRIX RULES, BUT excluding duplicates from already existing record (all Martin''''s matrix rules)
--These will be appended to the previous records (all of the MARTIN''''s MATRIX RULES)

	INSERT INTO #visitingReportDetails([TradeReconciliationDetailId], [MatchCode])
		SELECT	[ird].[TradeReconciliationDetailId], ''Unknown''
			FROM [dbo].[ib_TradeReconciliationDetail] ird 
						INNER JOIN [ib_TradeReconciliation] ir ON 
							ir.TradeReconciliationId = @TradeReconciliationId 
						AND ir.TradeReconciliationId = ird.TradeReconciliationId
				AND [ird].[ClassId] IS NOT NULL --IBAL-2109
			WHERE NOT EXISTS (SELECT 1 FROM #visitedItems v WHERE v.TradeReconciliationDetailId=[ird].[TradeReconciliationDetailId]) --exclude previous items

	EXEC [dbo].[ib_TradeReconciliation_AddFromRule]

	INSERT INTO #visitingReportDetails([TradeReconciliationDetailId], [MatchCode])
		SELECT	[ird].[TradeReconciliationDetailId], ''Unknown''
			FROM [dbo].[ib_TradeReconciliationDetail] ird 
						INNER JOIN [ib_TradeReconciliation] ir ON 
							ir.TradeReconciliationId = @TradeReconciliationId 
						AND ir.TradeReconciliationId = ird.TradeReconciliationId
					AND [ird].[ClassId] IS NULL --IBAL-2109
			WHERE NOT EXISTS (SELECT 1 FROM #visitedItems v WHERE v.TradeReconciliationDetailId=[ird].[TradeReconciliationDetailId]) --exclude previous items

	EXEC [dbo].[ib_TradeReconciliation_AddFromRule]


--update the report status
UPDATE [dbo].[ib_Report]
	SET [Stage] = ''Phase 2: Writing MatchCode to TradeReconciliationDetail''
	WHERE ReportId = @ReportId
	
UPDATE [dbo].[ib_TradeReconciliationDetail] 
SET [MatchCode] = [r].[MatchCode]
FROM 	[dbo].[ib_TradeReconciliationDetail] [trd] 
INNER JOIN #results [r] ON [trd].[TradeReconciliationDetailId] = [r].[TradeReconciliationDetailId]
WHERE trd.MatchCode=''''
	
--update the report status
UPDATE [dbo].[ib_Report]
	SET [Stage] = ''Phase 2: Final grouping on insert into Summary''
	WHERE ReportId = @ReportId

INSERT INTO [dbo].[ib_TradeReconciliationSummary]
	( [TradeReconciliationId]
	, [ExchangeId]
	, [MatchCode]
	, [CurrencyId]
	, [InstrumentId]
	, [ExpiryYear]
	, [ExpiryMonth]
	, [ExpiryDay]
	, [OptionTypeCode]
	, [StrikePrice]
	, [TradePrice]
	, [TotalInternalLong]
	, [TotalInternalShort]
	, [TotalExternalLong]
	, [TotalExternalShort]
	, [DifferenceLong]
	, [DifferenceShort]
	, [Exchange]
	, [Currency]
	, [Instrument]
	)
SELECT  @TradeReconciliationId
	, [trd].[ExchangeId]
	, [trd].[MatchCode]
	, [trd].[CurrencyId]
	, [trd].[InstrumentId]
	, [trd].[ExpiryYear]
	, [trd].[ExpiryMonth]
	, [trd].[ExpiryDay]
	, [trd].[OptionTypeCode]
	, [trd].[StrikePrice]
	, [trd].[TradePrice] 
	, SUM([trd].[InternalLong])
	, SUM([trd].[InternalShort])
	, SUM([trd].[ExternalLong])
	, SUM([trd].[ExternalShort])
	, 0 AS [DifferenceLong]
	, 0 AS [DifferenceShort]
	, '''' AS [Exchange]
	, '''' AS [Currency]
	, '''' AS [Instrument]
	FROM [dbo].[ib_TradeReconciliationDetail] [trd] 
	WHERE [trd].[TradeReconciliationId] = @TradeReconciliationId
	GROUP BY [ExchangeId], [MatchCode], [CurrencyId], [InstrumentId], 
			 [ExpiryMonth], [ExpiryYear], [ExpiryDay], 
			 [OptionTypeCode], [StrikePrice], [TradePrice]

--update the report status
UPDATE [dbo].[ib_Report]
	SET [Stage] = ''Phase 2: Updating exchange, currency and instrument information''
	WHERE ReportId = @ReportId
	
--UPDATE the Exchange, Currency, Instrument
UPDATE [dbo].[ib_TradeReconciliationSummary]
	SET [Exchange] = 
	(SELECT [Name]
		FROM [dbo].[ib_Exchange] e
		WHERE [e].[ExchangeId] = [trs].[ExchangeID])
	, [Currency] = 
	(SELECT [c].[Code] 
		FROM [dbo].[ib_Currency] c
		WHERE [c].[CurrencyId] = [trs].[CurrencyID])
	, [Instrument] =
	(SELECT [i].[Code] 
		FROM [dbo].[ib_Instrument] i
		WHERE [i].[InstrumentId] = [trs].[InstrumentID])
		
FROM [dbo].[ib_TradeReconciliationSummary] [trs]
WHERE [trs].[TradeReconciliationId] = @TradeReconciliationId
	

-- Update the report status
UPDATE [dbo].[ib_Report]
	SET [Stage] = ''Phase 2: Calculate Differences''
	WHERE ReportId = @ReportId

-- Calculate the differences
UPDATE [dbo].[ib_TradeReconciliationSummary]
	SET [DifferenceLong] = ([TotalInternalLong] - [TotalExternalLong])
	, [DifferenceShort] = ([TotalInternalShort] - [TotalExternalShort])
	WHERE TradeReconciliationId = @TradeReconciliationId

-- Drop temporary tables
DROP TABLE #tg
DROP TABLE #results
DROP TABLE #visitedItems
DROP TABLE #visitingReportDetails

--update the report status
UPDATE [dbo].[ib_Report]
	SET [Stage] = ''Phase 2: Completed''
	WHERE ReportId = @ReportId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[GMI_ST4F1_LoadStateChange]''
');

GO
EXECUTE ('

-- =============================================
-- Author:		Lee Manifold
-- Create date: 26 Jul 2006
-- Description:	Changes the LoadState of the GMI_ST4F1 type table
--
-- History
--
-- Date			Author			Description
-- 28 Feb 2007	lm				Added Extra field ImportFileId
-- =============================================
CREATE PROCEDURE [dbo].[GMI_ST4F1_LoadStateChange] 
	-- Add the parameters for the stored procedure here
	(
	@OldLoadState	TINYINT,
	@NewLoadState	TINYINT,
	@RecordDate		DATETIME = NULL,
	@ImportFileId	INT
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	-- Need to add code to handle RecordDate
	IF @RecordDate IS NOT NULL 
	BEGIN

		UPDATE [dbo].[GMI_ST4F1] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState AND ImportFileId = @ImportFileId

	END

	IF @RecordDate IS NULL 
	BEGIN

		UPDATE [dbo].[GMI_ST4F1] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState AND ImportFileId = @ImportFileId

	END


END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[Temporary_Look_For_Load]''
');

GO
EXECUTE ('-- =============================================
-- Author:		Petru Konrad Bercea
-- Create date: 09.02.2009
-- Description:	Test to see what data was loaded into Position Table
-- the changes to not commit.
-- =============================================
CREATE PROCEDURE [dbo].[Temporary_Look_For_Load] 
	-- Add the parameters for the stored procedure here
	(
		@RecordId	int 
	)
AS
SET NOCOUNT ON

	INSERT INTO [dbo].[Temporary_Look_For]
	(
		PositionId,
		DataSourceId,
		ExchangeId,
		FirmId,
		AccountId,
		AsOfDate,
		InstrumentId,
		Quantity,
		CurrencyId,
		MarketValue,
		ExpiryYear,
		ExpiryMonth,
		ExpiryDay,
		StrikePrice,
		TrxTypeCode,
		OptionTypeCode,
		TempTableRecordId,
		ClassId,
		LongQuantity,
		ShortQuantity,
		TradedLongQuantity,
		TradedShortQuantity,
		UseNetForCloseOut
	)
	SELECT 	
		PositionId,
		DataSourceId,
		ExchangeId,
		FirmId,
		AccountId,
		AsOfDate,
		InstrumentId,
		Quantity,
		CurrencyId,
		MarketValue,
		ExpiryYear,
		ExpiryMonth,
		ExpiryDay,
		StrikePrice,
		TrxTypeCode,
		OptionTypeCode,
		TempTableRecordId,
		ClassId,
		LongQuantity,
		ShortQuantity,
		TradedLongQuantity,
		TradedShortQuantity,
		UseNetForCloseOut
	
	FROM	[dbo].[ib_Position]
	
	WHERE	TempTableRecordId = @RecordId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[_ib_DataSource_UpdateIncDetails]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[_ib_DataSource_UpdateIncDetails]
(
 @DataSourceId INT
,@Code VARCHAR(100) = NULL
,@Name VARCHAR(100)
,@DefaultCurrencyId INT
,@ProvidesVariation BIT
,@UpdateUsername VARCHAR(50)
,@IncludeDetailAccountInTradeReconciliation BIT = NULL
,@UseTrxsForTradedOnDay BIT = NULL
)
AS 
SET NOCOUNT ON
--SET DEFAULTS FOR SINGLE UPDATE
--MADE FOR COMPATIBILITY WITH OLD VERSION
SELECT
    @Code = CASE WHEN @Code IS NULL THEN [Code]
                 ELSE @Code
            END
   ,@IncludeDetailAccountInTradeReconciliation = CASE WHEN @IncludeDetailAccountInTradeReconciliation IS NULL
                                                      THEN [IncludeDetailAccountInTradeReconciliation]
                                                      ELSE @IncludeDetailAccountInTradeReconciliation
                                                 END
   ,@UseTrxsForTradedOnDay = CASE WHEN @UseTrxsForTradedOnDay IS NULL
                                  THEN [UseTrxsForTradedOnDay]
                                  ELSE @UseTrxsForTradedOnDay
                             END
FROM
    [dbo].[ib_DataSource]
WHERE
    [DataSourceId] = @DataSourceId
	
PRINT ISNULL(@Code, -1)

UPDATE
    [dbo].[ib_DataSource]
SET 
    [Code] = @Code
   ,[Name] = @Name
   ,[DefaultCurrencyId] = @DefaultCurrencyId
   ,[ProvidesVariation] = @ProvidesVariation
   ,[UpdateUsername] = @UpdateUsername
   ,[IncludeDetailAccountInTradeReconciliation] = @IncludeDetailAccountInTradeReconciliation
   ,[UseTrxsForTradedOnDay] = @UseTrxsForTradedOnDay
WHERE
    DataSourceId = @DataSourceId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Exchange_GetExchangeById]''
');

GO
EXECUTE ('/*
--Description: get exchange by id
--17 May 2010 ED create
*/
CREATE PROCEDURE [dbo].[ib_Exchange_GetExchangeById]
(
	@ExchangeId INT
)
AS 
SET NOCOUNT ON

SELECT	e.[ExchangeId]
		,e.[Code]
		,e.[Name]
		,e.[RunBalanceReport]
		,e.[RunCloseOutReport]
		,e.RunTradeLevelReconciliation
		,e.[CreateDate]
		,e.[CreateUsername]
		,e.[UpdateDate]
		,e.[UpdateUsername]
FROM [dbo].[ib_Exchange] e
WHERE e.ExchangeId = @ExchangeId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TradeReconciliation_ReconcileAdjustments]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_TradeReconciliation_ReconcileAdjustments]
(
	@AsOfDate DATETIME
	, @TemplateId INT
)
AS
SET NOCOUNT ON

--	Description: create adjustment reconciliations
--	01 Jun 2010		ED		Created
--	15 Jun 2010		ED		MBAL-15761	Fix the join on quantity short/long
--	18 Jun 2010		ED		MBAL-15867	Some changes to matching 
--	28 Jul 2010		AAJM	MBAL-16321	Match on AccountId if available	
--	02 Aug 2010		amk		MBAL-16339	Only grab adjustments rolled forward (leaf node)
--	06 Jan 2011		amk		MBAL-17216: only rollover for one template
--  01 Jun 2012		ED		MBAL 20958: fix the sp for multiple adjustment matching multiple trx
--	13 Jun 2012		ED		MBAL 20980 - add nolock for trx/position select	
--  25 Jun 2014		ED		EIB 25770: logic for Unmatched Adj/Trades
--  21 Jul 2014		ED		EIB 25771: fix StrikePrice/Price null cases
--  16 Jan 2015		ED		EIB 26413 - improve performance
BEGIN TRY
	BEGIN TRAN

	DECLARE @AutomaticallyMatchedId INT
	
	SELECT @AutomaticallyMatchedId = AdjustmentStatusId 
	FROM ib_AdjustmentStatus 
	WHERE Code = ''A''

	DECLARE @TempReconcilePairs TABLE(AdjustmentId INT, TrxId INT)
	--reconcile part
	INSERT INTO @TempReconcilePairs(AdjustmentId, TrxId)
	--first query get all trades where adjustments has set the DetailAccountId too
	SELECT a.AdjustmentId, t.TrxId
	FROM ib_Adjustment a
		INNER JOIN ib_AdjustmentHeader ah ON ah.AdjustmentHeaderId = a.AdjustmentHeaderId
		INNER JOIN ib_AdjustmentType AT ON at.AdjustmentTypeId = ah.AdjustmentTypeId 
			AND at.Code IN (''TC'',''TI'',''MI'')
		LEFT JOIN ib_AdjustmentStatus adjStatus ON adjStatus.AdjustmentStatusId = a.AdjustmentStatusId
		INNER JOIN ib_DataSource ads ON ads.DataSourceId = a.DataSourceId
		INNER JOIN ib_Trx t (NOLOCK) ON a.AdjustmentDate = t.AsOfDate
			AND a.TradeDate = t.TrxDate
			AND a.DataSourceId = t.DataSourceId
			AND a.ExchangeId = t.ExchangeId
			AND a.AccountId = t.AccountId
			AND a.DetailAccountId = t.AccountId
			AND (a.ClassId = t.ClassId OR (a.ClassId IS NULL AND t.ClassId IS NULL))
			AND a.InstrumentId = t.InstrumentId
			AND a.ExpiryYear = t.ExpiryYear
			AND a.ExpiryMonth = t.ExpiryMonth
			AND a.ExpiryDay = t.ExpiryDay
			AND ISNULL(a.OptionTypeCode,'''') = ISNULL(t.OptionTypeCode,'''')
			AND ISNULL(a.StrikePrice,0) = ISNULL(t.StrikePrice,0)
			AND ISNULL(a.TradePrice,0) = ISNULL(t.Price,0)
			AND a.QuantityLong = t.QuantityLong 
			AND a.QuantityShort = t.QuantityShort
		INNER JOIN ib_TrxType tt ON tt.DataSourceId = t.DataSourceId 
			AND tt.Code = t.TrxTypeCode AND tt.IsAutoMatched = 1 -- only records with automatched set
	WHERE a.AdjustmentDate = @AsOfDate
		AND (adjStatus.Code NOT IN (''A'',''M'',''R'') OR a.AdjustmentStatusId IS NULL) -- not Auto/Manual Matched or Rolled Over
		AND a.ReplacesAdjustmentId IS NOT NULL
		AND a.TemplateId = @TemplateId
	UNION ALL
	--second query get all trades for the datasources where IncludeDetailAccountInTradeReconciliation (so ignore the value of adj.DetailAccountId)
	SELECT a.AdjustmentId, t.TrxId
	FROM ib_Adjustment a
		INNER JOIN ib_AdjustmentHeader ah ON ah.AdjustmentHeaderId = a.AdjustmentHeaderId
		INNER JOIN ib_AdjustmentType AT ON at.AdjustmentTypeId = ah.AdjustmentTypeId 
			AND at.Code IN (''TC'',''TI'',''MI'')
		LEFT JOIN ib_AdjustmentStatus adjStatus ON adjStatus.AdjustmentStatusId = a.AdjustmentStatusId
		INNER JOIN ib_DataSource ads ON ads.DataSourceId = a.DataSourceId AND ads.IncludeDetailAccountInTradeReconciliation = 0
		INNER JOIN ib_Trx t (NOLOCK) ON a.AdjustmentDate = t.AsOfDate
			AND a.TradeDate = t.TrxDate
			AND a.DataSourceId = t.DataSourceId
			AND a.ExchangeId = t.ExchangeId
			AND a.AccountId = t.AccountId
			AND (a.ClassId = t.ClassId OR (a.ClassId IS NULL AND t.ClassId IS NULL))
			AND a.InstrumentId = t.InstrumentId
			AND a.ExpiryYear = t.ExpiryYear
			AND a.ExpiryMonth = t.ExpiryMonth
			AND a.ExpiryDay = t.ExpiryDay
			AND ISNULL(a.OptionTypeCode,'''') = ISNULL(t.OptionTypeCode,'''')
			AND ISNULL(a.StrikePrice,0) = ISNULL(t.StrikePrice,0)
			AND ISNULL(a.TradePrice,0) = ISNULL(t.Price,0)
			AND a.QuantityLong = t.QuantityLong 
			AND a.QuantityShort = t.QuantityShort
		INNER JOIN ib_TrxType tt ON tt.DataSourceId = t.DataSourceId 
			AND tt.Code = t.TrxTypeCode AND tt.IsAutoMatched = 1 -- only records with automatched set
	WHERE a.AdjustmentDate = @AsOfDate
		AND (adjStatus.Code NOT IN (''A'',''M'',''R'') OR a.AdjustmentStatusId IS NULL) -- not Auto/Manual Matched or Rolled Over
		AND a.ReplacesAdjustmentId IS NOT NULL
		AND a.TemplateId = @TemplateId
		
	-- get only first matching trx id
	DECLARE @ReconcilePairs TABLE (AdjustmentId INT, TrxId INT)
	DECLARE @AdjustmentId INT, @TrxId INT
	
	DECLARE reconcile_cursor CURSOR FOR
	SELECT AdjustmentId, TrxId 
	FROM @TempReconcilePairs
	OPEN reconcile_cursor
	
	FETCH NEXT FROM reconcile_cursor
	INTO @AdjustmentId, @TrxId
	
	WHILE @@FETCH_STATUS = 0
		BEGIN
			IF NOT EXISTS(SELECT AdjustmentId 
							FROM @ReconcilePairs 
							WHERE AdjustmentId = @AdjustmentId
								OR TrxId = @TrxId)
					INSERT INTO @ReconcilePairs VALUES(@AdjustmentId, @TrxId)
			FETCH NEXT FROM reconcile_cursor
			INTO @AdjustmentId, @TrxId
		END
	
	CLOSE reconcile_cursor
	DEALLOCATE reconcile_cursor
	
	UPDATE ib_Adjustment 
	SET AdjustmentStatusId = @AutomaticallyMatchedId
	FROM ib_Adjustment a
		INNER JOIN @ReconcilePairs rp ON rp.AdjustmentId = a.AdjustmentId
	
	UPDATE ib_Trx
	SET MatchingAdjustmentId = rp.AdjustmentId
	FROM ib_Trx t
		INNER JOIN @ReconcilePairs rp ON rp.TrxId = t.TrxId

	COMMIT TRAN
END TRY
BEGIN CATCH
	ROLLBACK TRAN
	EXEC [dbo].[sp_RethrowError]
END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[GMI_ST4F1_Purge]''
');

GO
EXECUTE ('-- =============================================
-- Author:		Lee Manifold
-- Create date: 18 Jul 2006
-- Description:	Deletes from all is_GMI_ST4F1 type files where the LoadState is a parameter
--
-- History
--
-- Date			Author			Description
-- 28 Feb 2007	lm				Added Extra field ImportFileId
-- =============================================
CREATE PROCEDURE [dbo].[GMI_ST4F1_Purge]
	(
	@LoadState		TINYINT = 0,
	@RecordDate		DATETIME = NULL,
	@ImportFileId	INT
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	
	--raiserror (''Lee doing specific raiserror in stored proc for testing'', 19, 1) with log
	
	IF @RecordDate IS NOT NULL 
	BEGIN
		--****Need to Add code here to factor in @RecordDate into table fields 
		DELETE FROM [dbo].[GMI_ST4F1] WHERE LoadState= @LoadState AND ImportFileId = @ImportFileId

	END
	
	IF @RecordDate IS NULL 
	BEGIN
	
		DELETE FROM [dbo].[GMI_ST4F1] WHERE LoadState= @LoadState AND ImportFileId = @ImportFileId

	END
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[TryParseDDMMYYYYFromEndOfFilename]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[TryParseDDMMYYYYFromEndOfFilename]
(
	@FileName VARCHAR(512)
	, @ReturnDate DATETIME OUTPUT
)
AS
SET NOCOUNT ON
-- Description:	Return date from filename where date is last item before file extension
-- and the filename must be in format DDMMYYYY
--
-- 29 Apr 2012	AAJM	Creation


BEGIN
	
	SET @ReturnDate = NULL
	
	DECLARE @FileNameWithoutExtension VARCHAR(512)
	SET @FileNameWithoutExtension = [dbo].[GetFilenameWithoutExtension](@FileName)

	DECLARE @DateChr VARCHAR(8)
	SET @DateChr = RIGHT(@FileNameWithoutExtension, 8)

	BEGIN TRY
		
		SET @ReturnDate = (SELECT CONVERT(DATETIME, STUFF(STUFF(@DateChr,3,0,''-''),6,0,''-''), 105) )

	END TRY
	BEGIN CATCH
		-- Can''t parse, therefore return null
	END CATCH
	
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[_ib_FirmDataSource_GetFirmsByDataSourceIdTemplateId]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[_ib_FirmDataSource_GetFirmsByDataSourceIdTemplateId]
(
	@DataSourceId INT = NULL,
	@TemplateId INT = NULL
)
AS
SET NOCOUNT ON
--	23	May 2014  ED  EIB 25492 - created

	SELECT DISTINCT f.FirmId, f.Code, f.Name
		FROM ib_FirmDataSource fds
			INNER JOIN ib_Firm f ON f.FirmId = fds.FirmId
			INNER JOIN ib_TemplateCompare tc ON tc.FirmId = f.FirmId AND tc.DataSourceId = fds.DataSourceId
		WHERE fds.DataSourceId = @DataSourceId AND tc.TemplateId = @TemplateId
	ORDER BY f.Code
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TemplateCompare_GetTemplateCompareById]''
');

GO
SET ANSI_NULLS OFF

GO
EXECUTE ('     /*
<details>
 <summary> Selectes a template compare from the ib_TemplateCompare table by its id</summary>
 <created author="Laurentiu Macovei" Date="Tuesday, 12 September 2006 9:34PM GMT" /> 
</details>
*/
CREATE PROCEDURE [dbo].[ib_TemplateCompare_GetTemplateCompareById]
(
	@TemplateCompareId int
)
AS 
SET NOCOUNT ON


SELECT tc.[TemplateCompareId]
      ,tc.[TemplateId]
	  ,t.[Description] as TemplateDescription
      ,tc.[DataSourceId]
	  ,ds.[Name] as DataSourceName
	  ,ds.[Code] as DataSourceCode
      ,tc.[FirmId]
	  ,f.[Name] as FirmName
	  ,f.[Code] as FirmCode
      ,tc.[InternalExternalCode]
      ,tc.[CreateDate]
      ,tc.[CreateUsername]
      ,tc.[UpdateDate]
      ,tc.[UpdateUsername]
  FROM [dbo].[ib_TemplateCompare] tc 
INNER JOIN [dbo].[ib_Template] t ON t.[TemplateId] = tc.[TemplateId]
INNER JOIN [dbo].[ib_DataSource] ds ON ds.[DataSourceId] = tc.[DataSourceId]
INNER JOIN [dbo].[ib_Firm] f ON f.[FirmId] = tc.[FirmId]
WHERE  TemplateCompareId = @TemplateCompareId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Nostro_InsertNostroRecordForSplit]''
');

GO
SET ANSI_NULLS ON

GO
EXECUTE ('/*
Author			Date			Description
KevinP			25 Sep 2009		Created for the Nostro Split.
*/

CREATE PROC [dbo].[ib_Nostro_InsertNostroRecordForSplit]
	@OriginalNostroId INT,
	@TransDate DATETIME,
	@ValueDate DATETIME,
	@Narrative VARCHAR(34), -- Not sure why 34?! It seems to tbe the restriction on the table at the time of creation
	@InternalReference VARCHAR(16),
	@ExternalReference VARCHAR(16),
	@Amount DECIMAL(18,9),
	@TransactionType VARCHAR(4),
	@Username VARCHAR(200)
AS
SET NOCOUNT ON

INSERT INTO [dbo].[ib_Nostro]
           ([ValueDate]
           ,[TransDate]
           ,[Amount]
           ,[TransactionType]
           ,[InternalReference]
           ,[ExternalReference]
           ,[Narrative]
           ,[AccountId]
           ,[CurrencyId]
           ,[DataSourceId]
           ,[TempTableRecordId]
           ,[CreateDate]
           ,[CreateUsername]
           ,[UpdateDate]
           ,[UpdateUsername]
           ,[NostroBalancingItemId]
           ,[DepartmentId]
           ,[Notes])

SELECT		@ValueDate
           ,@TransDate
           ,@Amount
           ,@TransactionType
           ,@InternalReference
           ,@ExternalReference
           ,@Narrative
           ,[AccountId]
           ,[CurrencyId]
           ,[DataSourceId]
           ,[TempTableRecordId]
           ,GETDATE()
           ,@Username
           ,NULL
           ,NULL
           ,[NostroBalancingItemId]
           ,[DepartmentId]
           ,[Notes]
FROM ib_Nostro
WHERE NostroId = @OriginalNostroId

SELECT Scope_Identity()
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_SwiftStatementSeed_Insert]''
');

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Inserts a record into the ib_SwiftStatementSeed table
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[ib_SwiftStatementSeed_Insert]
(

	@SwiftStatementSeedId int    OUTPUT,

	@AccountId int   ,

	@StatementNumberSeed int   ,

	@CreateDate datetime   ,

	@CreateUsername varchar (50)  ,

	@UpdateDate datetime   ,

	@UpdateUsername varchar (50)  
)
AS


				
				INSERT INTO [dbo].[ib_SwiftStatementSeed]
					(
					[AccountId]
					,[StatementNumberSeed]
					,[CreateDate]
					,[CreateUsername]
					,[UpdateDate]
					,[UpdateUsername]
					)
				VALUES
					(
					@AccountId
					,@StatementNumberSeed
					,@CreateDate
					,@CreateUsername
					,@UpdateDate
					,@UpdateUsername
					)
				
				-- Get the identity value
				SET @SwiftStatementSeedId = SCOPE_IDENTITY()
									
							
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Exchange_GetExchangeCodesHintByKeyword]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Exchange_GetExchangeCodesHintByKeyword]
@ExchangeCode VARCHAR(100),
@HintByStartOnly BIT = 0,
@HintLength INT = 1
AS
SET NOCOUNT ON
-- Description: 
-- 17 May 2010	ED	Creation
DECLARE @len INT
SET @len = LEN(@ExchangeCode)
IF @HintByStartOnly = 1
BEGIN
	SELECT DISTINCT SUBSTRING ([Code], @len, @HintLength) x
		FROM [dbo].[ib_Exchange]
		WHERE [Code] LIKE @ExchangeCode+''%''
		ORDER BY x

END
ELSE
BEGIN
	SELECT DISTINCT SUBSTRING ([Code], PATINDEX(''%''+@ExchangeCode+''%'', [Code]) + @len, @HintLength) x
		FROM [dbo].[ib_Exchange]
		WHERE [Code] LIKE ''%''+@ExchangeCode+''%''
		ORDER BY x
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TradeReconciliation_ReconcileUMAdjustments]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_TradeReconciliation_ReconcileUMAdjustments]
(
	@AsOfDate DATETIME
	,@TemplateId INT
	,@TradeReconciliationId INT
)
AS
SET NOCOUNT ON

--	Description: create adjustment reconciliations for UM
--	21 Jul 2014		ED		Created ( EIB 25771)
--	09 Mar 2015		ED		EIB 26707 - add table hint for ib_adjustment
BEGIN TRY
	BEGIN TRAN

	DECLARE @AutomaticallyMatchedId INT
	
	SELECT @AutomaticallyMatchedId = AdjustmentStatusId 
	FROM ib_AdjustmentStatus 
	WHERE Code = ''A''

	DECLARE @TempReconcilePairs TABLE(AdjustmentId INT, TrxId INT)
	--reconcile part
	INSERT INTO @TempReconcilePairs(AdjustmentId, TrxId)
	SELECT a.AdjustmentId, t.TrxId
	FROM ib_Adjustment a WITH (INDEX(IX_adjustmentdate))
		INNER JOIN ib_AdjustmentHeader ah ON ah.AdjustmentHeaderId = a.AdjustmentHeaderId
		INNER JOIN ib_AdjustmentType AT ON at.AdjustmentTypeId = ah.AdjustmentTypeId AND at.Code = ''UM''
		LEFT JOIN ib_AdjustmentStatus adjStatus ON adjStatus.AdjustmentStatusId = a.AdjustmentStatusId
		INNER JOIN ib_MatchCode mc ON mc.MatchCodeId = a.MatchCodeId
		INNER JOIN ib_TradeReconciliation tr ON tr.TradeReconciliationId = @TradeReconciliationId AND tr.Today = a.AdjustmentDate
		INNER JOIN ib_TradeReconciliationDetail t (NOLOCK) ON t.TradeReconciliationId = tr.TradeReconciliationId
			AND a.TradeDate = t.TrxDate
			AND mc.MatchCode = t.MatchCode
			AND a.ExchangeId = t.ExchangeId
			AND (a.ClassId = t.ClassId OR (a.ClassId IS NULL AND t.ClassId IS NULL))
			AND a.InstrumentId = t.InstrumentId
			AND a.ExpiryYear = t.ExpiryYear
			AND a.ExpiryMonth = t.ExpiryMonth
			AND a.ExpiryDay = t.ExpiryDay
			AND ISNULL(a.OptionTypeCode,'''') = ISNULL(t.OptionTypeCode,'''')
			AND ISNULL(a.StrikePrice,0) = ISNULL(t.StrikePrice,0)
			AND ISNULL(a.TradePrice,0) = ISNULL(t.TradePrice,0)
			AND a.QuantityLong = CASE WHEN t.InternalExternalCode = ''I'' THEN t.InternalLong ELSE t.ExternalLong END
			AND a.QuantityShort = CASE WHEN t.InternalExternalCode = ''I'' THEN t.InternalShort ELSE t.ExternalShort END
		INNER JOIN ib_TrxType tt ON tt.DataSourceId = t.DataSourceId 
			AND tt.Code = t.TrxTypeCode AND tt.IsAutoMatched = 1 -- only records with automatched set
	WHERE a.AdjustmentDate = @AsOfDate
		AND (adjStatus.Code NOT IN (''A'',''M'',''R'') OR a.AdjustmentStatusId IS NULL) -- not Auto/Manual Matched or Rolled Over
		AND a.TemplateId = @TemplateId
		AND TrxId IS NOT NULL
	-- get only first matching trx id
	DECLARE @ReconcilePairs TABLE (AdjustmentId INT, TrxId INT)
	DECLARE @AdjustmentId INT, @TrxId INT
	
	DECLARE reconcile_cursor CURSOR FOR
	SELECT AdjustmentId, TrxId 
	FROM @TempReconcilePairs
	OPEN reconcile_cursor
	
	FETCH NEXT FROM reconcile_cursor
	INTO @AdjustmentId, @TrxId
	
	WHILE @@FETCH_STATUS = 0
		BEGIN
			IF NOT EXISTS(SELECT AdjustmentId 
							FROM @ReconcilePairs 
							WHERE AdjustmentId = @AdjustmentId
								OR TrxId = @TrxId)
					INSERT INTO @ReconcilePairs VALUES(@AdjustmentId, @TrxId)
			FETCH NEXT FROM reconcile_cursor
			INTO @AdjustmentId, @TrxId
		END
	
	CLOSE reconcile_cursor
	DEALLOCATE reconcile_cursor
	
	UPDATE ib_Adjustment 
	SET AdjustmentStatusId = @AutomaticallyMatchedId
	FROM ib_Adjustment a
		INNER JOIN @ReconcilePairs rp ON rp.AdjustmentId = a.AdjustmentId
	
	UPDATE ib_Trx
	SET MatchingAdjustmentId = rp.AdjustmentId
	FROM ib_Trx t
		INNER JOIN @ReconcilePairs rp ON rp.TrxId = t.TrxId

	COMMIT TRAN
END TRY
BEGIN CATCH
	ROLLBACK TRAN
	EXEC [dbo].[sp_RethrowError]
END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ReturnIdsFromCommaSeparatedStringWithPos]''
');

GO
EXECUTE ('CREATE FUNCTION [dbo].[ReturnIdsFromCommaSeparatedStringWithPos]
(
	@IdsString NVARCHAR(MAX)
)
RETURNS @returnTable TABLE 
(
	Pos INT,
	Id INT
)
AS
-- Returns a table of Ids and pos from a comma separated list
-- 30 May 2014	ED	Created
BEGIN

	DECLARE @Id VARCHAR(10), @Pos INT, @ListPos INT

	SET @IdsString = LTRIM(RTRIM(@IdsString))+ '',''
	SET @Pos = CHARINDEX('','', @IdsString, 1)
	SET @ListPos = 1
	IF REPLACE(@IdsString, '','', '''') <> ''''
	BEGIN
		WHILE @Pos > 0
		BEGIN
			SET @Id = LTRIM(RTRIM(LEFT(@IdsString, @Pos - 1)))
			IF @Id <> ''''
			BEGIN
				INSERT INTO @returnTable (Pos, Id) VALUES (@ListPos, CAST(@Id AS int)) --Use Appropriate conversion
				SET @ListPos = @ListPos + 1
			END
			SET @IdsString = RIGHT(@IdsString, LEN(@IdsString) - @Pos)
			SET @Pos = CHARINDEX('','', @IdsString, 1)

		END
	END	

	RETURN 
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[_ib_SwiftStatementSeed_Update]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[_ib_SwiftStatementSeed_Update]
	 @AccountIdCsv VARCHAR(MAX),
	 @StatementSeedCsv VARCHAR(MAX)
AS
SET NOCOUNT ON
BEGIN
-- Revision History
--
-- 13 May 2014  ED  EIB 24627 - create sp to update SwiftStatement

	DECLARE @TableOfStatementSeeds TABLE (AccountId INT, StatementSeed INT)
	INSERT INTO @TableOfStatementSeeds (AccountId, StatementSeed)
	SELECT a.Id, ss.Id
		FROM  dbo.ReturnIdsFromCommaSeparatedStringWithPos(@AccountIdCsv) a
			INNER JOIN 	dbo.ReturnIdsFromCommaSeparatedStringWithPos(@StatementSeedCsv) ss ON a.Pos = ss.Pos
			LEFT JOIN ib_SwiftStatementSeed sss ON sss.AccountId = a.Id
		WHERE sss.AccountId IS NULL OR sss.StatementNumberSeed != ss.Id

	MERGE INTO 
		ib_SwiftStatementSeed target
	USING 
		(SELECT AccountId, StatementSeed FROM @TableOfStatementSeeds WHERE StatementSeed != 0) source
	ON
		source.AccountId = target.AccountId
	WHEN matched THEN update
		SET target.StatementNumberSeed = source.StatementSeed, target.UpdateDate = GETDATE(), target.UpdateUsername = SUSER_SNAME()
	WHEN NOT matched THEN insert
		(AccountId, StatementNumberSeed) VALUES (source.AccountId, source.StatementSeed);

	DELETE FROM ib_SwiftStatementSeed 
		WHERE AccountId IN 
			(SELECT AccountId FROM @TableOfStatementSeeds WHERE StatementSeed = 0)
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Nostro_IsAccountValidInternalExternal]''
');

GO
EXECUTE ('/*
Author			Date			Description
Krip			13 Oct 2009		Created
*/

CREATE PROCEDURE [dbo].[ib_Nostro_IsAccountValidInternalExternal]
      @AccountId  INT
      , @InternalExternalCode VARCHAR(1)
AS
SET NOCOUNT ON
BEGIN
      IF EXISTS (SELECT *
      FROM ib_template t
            JOIN ib_templatecompare tc on tc.templateid = t.templateid
            JOIN ib_firm f on f.firmid = tc.firmid
            JOIN ib_account a on a.firmid = f.firmid
      WHERE t.typecode = ''Nostro Rec''
            AND a.accountid = @AccountId
            AND tc.internalexternalcode = @InternalExternalCode)
            SELECT 1
      ELSE
            SELECT 0
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_SwiftStatementSeed_Update]''
');

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Updates a record in the ib_SwiftStatementSeed table
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[ib_SwiftStatementSeed_Update]
(

	@SwiftStatementSeedId int   ,

	@AccountId int   ,

	@StatementNumberSeed int   ,

	@CreateDate datetime   ,

	@CreateUsername varchar (50)  ,

	@UpdateDate datetime   ,

	@UpdateUsername varchar (50)  
)
AS


				
				
				-- Modify the updatable columns
				UPDATE
					[dbo].[ib_SwiftStatementSeed]
				SET
					[AccountId] = @AccountId
					,[StatementNumberSeed] = @StatementNumberSeed
					,[CreateDate] = @CreateDate
					,[CreateUsername] = @CreateUsername
					,[UpdateDate] = @UpdateDate
					,[UpdateUsername] = @UpdateUsername
				WHERE
[SwiftStatementSeedId] = @SwiftStatementSeedId 
				
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Exchange_GetExchangeNamesHintByKeyword]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Exchange_GetExchangeNamesHintByKeyword]
@ExchangeName VARCHAR(100),
@HintByStartOnly BIT = 0,
@HintLength INT = 1
AS
SET NOCOUNT ON
-- Description: 
-- 17 May 2010	ED	Creation
 
DECLARE @len INT
SET @len = LEN(@ExchangeName)
IF @HintByStartOnly = 1
BEGIN
	SELECT DISTINCT SUBSTRING ([Name], @len, @HintLength) x
		FROM [dbo].[ib_Exchange]
		WHERE [Name] LIKE @ExchangeName+''%''
		ORDER BY x DESC

END
ELSE
BEGIN
	SELECT DISTINCT SUBSTRING ([Name], PATINDEX(''%''+@ExchangeName+''%'', [Name]) + @len, @HintLength) x
		FROM [dbo].[ib_Exchange]
		WHERE [Name] LIKE ''%''+@ExchangeName+''%''
		ORDER BY x DESC
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[HKFE_TP001_Header_Add]''
');

GO
EXECUTE ('



-- =============================================
-- Author:		Lee Manifold
-- Create date: 21 Sep 2006
-- Description:	Insert into HKFE_TP001_Header
-- =============================================
CREATE PROCEDURE [dbo].[HKFE_TP001_Header_Add]
		(
		@RecordType				varchar(2),
		@FileId					varchar(5),
		@Source					varchar(5),
		@BusinessDate			varchar(8),
		@CreationDateTime		varchar(14),
		@ClearingHouse			varchar(50),
		@NoOfDetailRecordTypes	varchar(2)
		)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
INSERT INTO [dbo].[HKFE_TP001_Header]
           (
			[RecordType],
			[FileId],
			[Source],
			[BusinessDate],
			[CreationDateTime],
			[ClearingHouse],
			[NoOfDetailRecordTypes]
			)
     VALUES
           (
			@RecordType,
			@FileId,
			@Source,
			@BusinessDate,
			@CreationDateTime,
			@ClearingHouse,
			@NoOfDetailRecordTypes
			)
END
');

GO
EXECUTE ('PRINT N''Creating [security].[_Feature_HasUserAccess]''
');

GO
EXECUTE ('CREATE PROCEDURE [security].[_Feature_HasUserAccess]
	 @ApplicationName  NVARCHAR(256),
     @UserName         NVARCHAR(256),
     @FeatureCode      NVARCHAR(256)
AS
BEGIN
-- Revision history
-- 16 May 2014  ED  EIB 25501 - add sp to check if user has access to a feature

	SET NOCOUNT ON
    DECLARE @ApplicationId UNIQUEIDENTIFIER
    SET  @ApplicationId = (SELECT ApplicationId FROM aspnet_Applications WHERE LOWER(@ApplicationName) = LoweredApplicationName)
    IF (@ApplicationId IS NULL)
	BEGIN
        SELECT 2
		RETURN
	END
    DECLARE @UserId UNIQUEIDENTIFIER
    SET @UserId = (SELECT UserId FROM    dbo.aspnet_Users WHERE   LoweredUserName = LOWER(@UserName) AND ApplicationId = @ApplicationId)
    IF (@UserId IS NULL)
    BEGIN
        SELECT 2
		RETURN
	END

	DECLARE @FeatureId INT
    SET  @FeatureId = (SELECT FeatureId FROM security.Feature WHERE FeatureCode = @FeatureCode)
	IF (@FeatureId IS NULL)
    BEGIN
        SELECT 2
		RETURN
	END
    
	IF (EXISTS( SELECT 1 FROM security.RoleFeature rf 
				INNER JOIN aspnet_UsersInRoles ur ON ur.RoleId = rf.RoleId WHERE ur.UserId = @UserId AND rf.FeatureId = @FeatureId))
       SELECT 1
    ELSE
        SELECT 0
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[_Package_GetByIsActive]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[_Package_GetByIsActive]
	@IsActive BIT = NULL
AS
-- Revision History:
-- 20 May 2014  ED  EIB 25641 - created

	SET NOCOUNT ON
	
	SELECT * FROM Package WHERE (@IsActive IS NULL OR IsActive = @IsActive) ORDER BY PackageName
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Nostro_MatchCodeBalances_BuildReport]''
');

GO
SET ANSI_NULLS OFF

GO
EXECUTE ('-- =============================================
-- Author:		Petru Konrad Bercea
-- Create date: 11.03.2009
-- Description:	Creates the Report of the Nostro MatchCode Balances per requested day. 
--
-- Revision History
--
-- Konrad 12.03.2009 Select Account for Ledger and Statement
-- Konrad 16.03.2009 Fixed bug when having more than one record resulting from Selects that are used as an expression.
-- Konrad 17.03.2009 Filtering on BalanceDate equal to the input Date or previous and closest to the input Date.
--                   Filtering on TemplateId.
-- AAJM	  05.10.2009 Apply new Nostro MatchCode permission by UserId MBAL-11773
-- =============================================

CREATE PROCEDURE [dbo].[ib_Nostro_MatchCodeBalances_BuildReport]
(
	@UserId uniqueidentifier,
	@Date DATETIME,
    @TemplateIdSpecific int
)	
AS
SET NOCOUNT ON
BEGIN

	SELECT mc.MatchCode MatchCode
			,(SELECT TOP 1 cu.Code 
					FROM [ib_TemplateGroup] tg 
							INNER JOIN ib_Currency cu ON cu.CurrencyId=tg.CurrencyId
					WHERE tg.Description=mc.MatchCode AND tg.TemplateId=@TemplateIdSpecific
				) Currency
			,(SELECT TOP 1 f.Code 
					FROM [ib_TemplateGroup] tg 
							INNER JOIN ib_Account a ON a.AccountId=tg.AccountId
							INNER JOIN ib_Firm f ON f.FirmId=tg.FirmId
							INNER JOIN ib_Currency cu ON cu.CurrencyId=tg.CurrencyId
							INNER JOIN ib_TemplateCompare tc ON tc.TemplateId = tg.TemplateId AND tc.FirmId = tg.FirmId
					WHERE tg.Description=mc.MatchCode AND tc.InternalExternalCode=''I'' AND tg.TemplateId=@TemplateIdSpecific
				) LedgerFirm
			,(SELECT TOP 1 a.Code 
					FROM [ib_TemplateGroup] tg 
							INNER JOIN ib_Account a ON a.AccountId=tg.AccountId
							INNER JOIN ib_Firm f ON f.FirmId=tg.FirmId
							INNER JOIN ib_Currency cu ON cu.CurrencyId=tg.CurrencyId
							INNER JOIN ib_TemplateCompare tc ON tc.TemplateId = tg.TemplateId AND tc.FirmId = tg.FirmId
					WHERE tg.Description=mc.MatchCode AND tc.InternalExternalCode=''I'' AND tg.TemplateId=@TemplateIdSpecific
				) LedgerAC
			,nb.InternalBalance LedgerBal
			,(SELECT TOP 1 a.Code 
					FROM [ib_TemplateGroup] tg 
							INNER JOIN ib_Account a ON a.AccountId=tg.AccountId
							INNER JOIN ib_Firm f ON f.FirmId=tg.FirmId
							INNER JOIN ib_Currency cu ON cu.CurrencyId=tg.CurrencyId
							INNER JOIN ib_TemplateCompare tc ON tc.TemplateId = tg.TemplateId AND tc.FirmId = tg.FirmId
					WHERE tg.Description=mc.MatchCode AND tc.InternalExternalCode=''E'' AND tg.TemplateId=@TemplateIdSpecific
				) StatementAC
			,nb.ExternalBalance StatementBal 

		FROM [ib_NostroBalance] nb (nolock)
				INNER JOIN ib_MatchCode mc ON mc.MatchCodeId = nb.MatchCodeId
				INNER JOIN ib_UserMatchCodeAccess umca ON umca.UserId = @UserId AND umca.MatchCodeId = mc.MatchCodeId 
	INNER JOIN ib_AccessRight ar ON umca.AccessRightId = ar.AccessRightId
				
		WHERE convert(varchar(10),nb.BalanceDate,111)=convert(varchar(10),

							(SELECT MAX(BalanceDate) 
								FROM ib_NostroBalance nb1
								WHERE nb1.MatchCodeId = mc.MatchCodeId AND
                                      CAST(nb1.BalanceDate as float) <= CAST(@Date as float)
							) 

							,111) AND mc.TemplateId=@TemplateIdSpecific
							AND (ar.Code = ''ReadOnly'' OR ar.Code = ''Full'')

	
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_SwiftStatementSeed_Delete]''
');

GO
SET ANSI_NULLS ON

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Deletes a record in the ib_SwiftStatementSeed table
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[ib_SwiftStatementSeed_Delete]
(

	@SwiftStatementSeedId int   
)
AS


				DELETE FROM [dbo].[ib_SwiftStatementSeed] WITH (ROWLOCK) 
				WHERE
					[SwiftStatementSeedId] = @SwiftStatementSeedId
					
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[HKFE_TP001_LoadStateChange]''
');

GO
EXECUTE ('


-- =============================================
-- Author:		Lee Manifold
-- Create date: 21 Sep 2006
-- Description:	Changes the LoadState of the HKFE_TP001 type tables
-- =============================================
CREATE PROCEDURE [dbo].[HKFE_TP001_LoadStateChange] 
	-- Add the parameters for the stored procedure here
	(
	@OldLoadState	TINYINT,
	@NewLoadState	TINYINT,
	@RecordDate		DATETIME = NULL
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	-- Need to add code to handle RecordDate
	IF @RecordDate IS NOT NULL 
	BEGIN

		UPDATE [dbo].[HKFE_TP001_Header] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState
		UPDATE [dbo].[HKFE_TP001_Type01] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState
		UPDATE [dbo].[HKFE_TP001_Type02] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState

	END

	IF @RecordDate IS NULL 
	BEGIN

		UPDATE [dbo].[HKFE_TP001_Header] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState
		UPDATE [dbo].[HKFE_TP001_Type01] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState
		UPDATE [dbo].[HKFE_TP001_Type02] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState

	END


END
');

GO
EXECUTE ('PRINT N''Creating [security].[_Feature_UserFeatureAccessList]''
');

GO
EXECUTE ('CREATE PROCEDURE [security].[_Feature_UserFeatureAccessList]
	 @ApplicationName  NVARCHAR(256),
     @UserName         NVARCHAR(256)
AS
BEGIN
-- Revision history
-- 02 Jun 2014  ED  EIB 25501 - add sp to get all features for a user

	SET NOCOUNT ON
    DECLARE @ApplicationId UNIQUEIDENTIFIER
    SET  @ApplicationId = (SELECT ApplicationId FROM aspnet_Applications WHERE LOWER(@ApplicationName) = LoweredApplicationName)
    IF (@ApplicationId IS NULL)
	BEGIN
        SELECT ''''
		RETURN
	END
    DECLARE @UserId UNIQUEIDENTIFIER
    SET @UserId = (SELECT UserId FROM    dbo.aspnet_Users WHERE   LoweredUserName = LOWER(@UserName) AND ApplicationId = @ApplicationId)
    IF (@UserId IS NULL)
    BEGIN
        SELECT ''''
		RETURN
	END

    SELECT FeatureCode FROM security.Feature f
		INNER JOIN security.RoleFeature rf ON rf.FeatureId = f.FeatureId
		INNER JOIN aspnet_UsersInRoles ur ON ur.RoleId = rf.RoleId 
		INNER JOIN aspnet_Users u ON ur.UserId = u.UserId
		INNER JOIN aspnet_Applications a ON a.ApplicationId = u.ApplicationId
		WHERE u.LoweredUserName = LOWER(@UserName) AND a.LoweredApplicationName = LOWER(@ApplicationName)
	
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[_ReceiveLocation_GetReceiveLocationById]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[_ReceiveLocation_GetReceiveLocationById]
	@ReceiveLocationSysId INT
AS 
-- Revision History:
-- 20 May 2014  ED  EIB 25641 - created

SET NOCOUNT ON

SELECT
    rl.ReceiveLocationSysId, rl.ReceiveLocationName, p.PackageName, p.PackageSysId, ds.Name AS DataSourceName, ds.DataSourceId,
	rl.FileMask, rl.InputFolder, rl.OutputFolder, rl.ErrorFolder, rl.IsActive, rl.CreateDateTimeUtc, rl.CreateUsername,
	rl.UpdateDateTimeUtc, rl.UpdateUsername
FROM ReceiveLocation rl
	INNER JOIN dbo.ib_DataSource ds ON  ds.DataSourceId = rl.DataSourceId
	INNER JOIN Package p ON p.PackageSysId = rl.PackageSysId
WHERE
    ReceiveLocationSysId = @ReceiveLocationSysId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Nostro_NotesHistory_GetByNostroId]''
');

GO
EXECUTE ('
CREATE PROCEDURE [dbo].[ib_Nostro_NotesHistory_GetByNostroId]
	@NostroId	INT
AS

--	Description: Return all entries by NostroId
--	04 Sep 2009		AAJM	Creation MBAL-11772

BEGIN

	SET NOCOUNT ON

	SELECT nh.[CreateDate], nh.[CreateUsername], d.[Code], nh.[Notes]
	FROM [dbo].[ib_Nostro_NotesHistory] nh
    LEFT JOIN [dbo].[ib_Department] d ON d.DepartmentId = nh.DepartmentId 
	WHERE nh.NostroId = @NostroId
	ORDER BY [nh].[CreateDate] DESC

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_SwiftStatementSeed_GetByAccountId]''
');

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Select records from the ib_SwiftStatementSeed table through an index
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[ib_SwiftStatementSeed_GetByAccountId]
(

	@AccountId int   
)
AS


				SELECT
					[SwiftStatementSeedId],
					[AccountId],
					[StatementNumberSeed],
					[CreateDate],
					[CreateUsername],
					[UpdateDate],
					[UpdateUsername]
				FROM
					[dbo].[ib_SwiftStatementSeed]
				WHERE
					[AccountId] = @AccountId
				SELECT @@ROWCOUNT
					
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[HKFE_TP001_Purge]''
');

GO
EXECUTE ('





-- =============================================
-- Author:		Lee Manifold
-- Create date: 20 Sept 2006
-- Description:	Deletes from all HKFE_TP001 type  files where the LoadState is the parameter @LoadState
-- =============================================
CREATE PROCEDURE [dbo].[HKFE_TP001_Purge]
	(
	@LoadState		TINYINT = 0,
	@FileName       VARCHAR (512)= NULL
	)
AS
BEGIN

	SET NOCOUNT ON;
	
	--raiserror (''Lee doing specific raiserror in stored proc for testing'', 19, 1) with log
	DELETE FROM [dbo].[HKFE_TP001_Type01] WHERE LoadState = @LoadState AND [FileName] = Coalesce(@FileName, [FileName])
	DELETE FROM [dbo].[HKFE_TP001_Type02] WHERE LoadState = @LoadState AND [FileName] = Coalesce(@FileName, [FileName])
	DELETE FROM [dbo].[HKFE_TP001_Header] WHERE LoadState = @LoadState

END
');

GO
EXECUTE ('PRINT N''Creating [stage].[BmfPosition_LoadStateChange]''
');

GO
EXECUTE ('CREATE PROCEDURE [stage].[BmfPosition_LoadStateChange]
	(
		@OldLoadState	TINYINT,
		@NewLoadState	TINYINT,
		@FileName       VARCHAR (512)= NULL
	)
AS

-- Description: Changes the LoadState of the stage.BmfPosition type table

-- 25 Mar 2016	ED	EIB 38652 - Creation

BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	UPDATE stage.BmfPosition SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState AND [FileName] = Coalesce(@FileName, [FileName])

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[_ReceiveLocation_GetReceiveLocationsForSSIS]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[_ReceiveLocation_GetReceiveLocationsForSSIS]
AS
BEGIN
-- Revision history
-- 13 Jun 2014  ED  EIB 25716 - Created
	
	SET NOCOUNT ON
	
	SELECT rl.ReceiveLocationName, rl.InputFolder, rl.FileMask, p.PackageName, p.SSISPackagePath
		FROM ReceiveLocation rl
			INNER JOIN Package p ON rl.PackageSysId = p.PackageSysId
			WHERE p.IsActive = 1 AND rl.IsActive = 1
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TemplateGroup_Delete]''
');

GO
EXECUTE (' /*
<details>
 <summary>Deletes a template group by its id from the ib_TemplateGroup table</summary>
 <created author="Laurentiu Macovei" Date="Saturday, 9 September 2006 0:20AM GMT" /> 
</details>
*/
 create PROCEDURE [dbo].[ib_TemplateGroup_Delete]
(
	@TemplateGroupId int
)
AS
SET NOCOUNT ON

DELETE FROM [dbo].[ib_TemplateGroup]
      WHERE TemplateGroupId = @TemplateGroupId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Nostro_UpdateDepartmentAndNotes]''
');

GO
EXECUTE ('-- =============================================
-- Author:		<Konrad>
-- Create date: <18.03.2009>
-- Description:	<Updates the DepartmentId and Notes fields on the ib_Nostro record>
--
-- Revision History
-- Konrad 19.03.2009 Modified conditions from IS NULL to IS NOT NULL
-- Konrad 23.03.2009 Added UpdateUsername and UpdateDate
-- Konrad 26.03.2009 Removed conditions so that the data is fully updated 
-- =============================================
CREATE PROCEDURE [dbo].[ib_Nostro_UpdateDepartmentAndNotes]
	(
		@NostroId int, 
        @DepartmentId int=NULL,
        @Notes varchar(512)=NULL,
		@UpdateUsername varchar(50) 
	)
AS
SET NOCOUNT ON
BEGIN

UPDATE [dbo].[ib_Nostro]

	SET [Notes] = @Notes,
		[DepartmentId] = @DepartmentId,
        [UpdateUsername] = @UpdateUsername,
        [UpdateDate] = getdate()
	WHERE NostroId=@NostroId 

SELECT 1
    
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_SwiftStatementSeed_GetBySwiftStatementSeedId]''
');

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Select records from the ib_SwiftStatementSeed table through an index
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[ib_SwiftStatementSeed_GetBySwiftStatementSeedId]
(

	@SwiftStatementSeedId int   
)
AS


				SELECT
					[SwiftStatementSeedId],
					[AccountId],
					[StatementNumberSeed],
					[CreateDate],
					[CreateUsername],
					[UpdateDate],
					[UpdateUsername]
				FROM
					[dbo].[ib_SwiftStatementSeed]
				WHERE
					[SwiftStatementSeedId] = @SwiftStatementSeedId
				SELECT @@ROWCOUNT
					
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Exchange_GetIdForSpecificCode]''
');

GO
EXECUTE ('/*
<details>
	<summary>Returns the id for a specific exchange code</summary>
	<created author="laurentiu.macovei" date="Thu, 19 Oct 2006 19:16:03 GMT"/>
</details>
*/
CREATE PROCEDURE [dbo].[ib_Exchange_GetIdForSpecificCode] 
@Code varchar(100)
AS
SET NOCOUNT ON

DECLARE @FoundId int
SET @FoundId = -1
SELECT TOP 1 @FoundId = e.ExchangeId
	FROM ib_Exchange e
	WHERE Code = @Code
SELECT @FoundId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[HKFE_TP001_Type01_Add]''
');

GO
EXECUTE ('




-- =============================================
-- Author:		Lee Manifold
-- Create date: 21 Sep 2006
-- Description:	Insert into HKFE_TP001_Type01
--KevinP - 22 Feb 2010 - Added FileName
-- =============================================
CREATE PROCEDURE [dbo].[HKFE_TP001_Type01_Add]
		(
		@FileName            VARCHAR (512) = NULL,
		@BusinessDate				Datetime,
		@RecordType					varchar(2),
	    @ParticipantCode			varchar(5),
	    @AccountID					varchar(50),
	    @SeriesName					varchar(15),
	    @ParticipantName			varchar(32),
	    @Market						varchar(5),
	    @MarketName					varchar(32),
	    @Underlying					varchar(6),
	    @UnderlyingName				varchar(32),
	    @Currency					varchar(3),
	    @PrevPositionLong			varchar(8),
	    @PrevPositionShort			varchar(8),
	    @PrevSettlementPrice		varchar(12),
	    @PrevVariationAdjustment	varchar(19),
	    @CurrentPositionLong		varchar(8),
	    @CurrentPositionShort		varchar(8),
	    @CurrentSettlementPrice		varchar(12)
		)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
INSERT INTO [dbo].[HKFE_TP001_Type01]
           (
			[BusinessDate]
		   ,[RecordType]
           ,[ParticipantCode]
           ,[AccountID]
           ,[SeriesName]
           ,[ParticipantName]
           ,[Market]
           ,[MarketName]
           ,[Underlying]
           ,[UnderlyingName]
           ,[Currency]
           ,[PrevPositionLong]
           ,[PrevPositionShort]
           ,[PrevSettlementPrice]
           ,[PrevVariationAdjustment]
           ,[CurrentPositionLong]
           ,[CurrentPositionShort]
           ,[CurrentSettlementPrice]
           ,[FileName]
			)
     VALUES
           (
			@BusinessDate,
			@RecordType,
		    @ParticipantCode,
		    @AccountID,
		    @SeriesName,
		    @ParticipantName,
		    @Market,
		    @MarketName,
		    @Underlying,
		    @UnderlyingName,
		    @Currency,
		    @PrevPositionLong,
		    @PrevPositionShort,
		    @PrevSettlementPrice,
		    @PrevVariationAdjustment,
		    @CurrentPositionLong,
		    @CurrentPositionShort,
		    @CurrentSettlementPrice,
		    @FileName

			)
END
');

GO
EXECUTE ('PRINT N''Creating [stage].[BmfPosition_Purge]''
');

GO
EXECUTE ('CREATE PROCEDURE [stage].[BmfPosition_Purge]
	(
		@LoadState		TINYINT = 0,
		@FileName       VARCHAR (512)= NULL
	)
AS
-- Description: Deletes from stage.BmfPosition table all the records where the LoadState is 0

-- 25 Mar 2016	ED	EIB 38652 - Creation

-- History:

BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
	DELETE FROM stage.BmfPosition WHERE LoadState= @LoadState AND [FileName] = Coalesce(@FileName, [FileName])

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TemplateGroup_GetAvailableTemplatesForUserId]''
');

GO
EXECUTE ('
/*
<details>
	<summary> Gets the template groups for a specific user /summary>
	<created author="Laurentiu Macovei" Date="Thursday, 10 August 2006 13:31 GMT" /> 
	<updated author="Laurentiu Macovei" Date="Thursday, 23 August 2006 23:31 GMT" /> 
	<updated author="Anil Kripalani" Date="8 Dec 2006"> 
		BUG FIX: Only return 1 row per Match Code (Description)
	</updated>
 <tasks>
	<task id="IBAL-2049">
	Match Code is just items from ib_TemplateGroup table where Template matches selected Template 
	and (TG.Exchange matches selected Exchange or TG.Exchange Is Null) 
	and (TG.Instrument matches selected Instrument or TG.Instrument is Null)
	</task>
 </tasks>
</details>
*/
CREATE PROCEDURE [dbo].[ib_TemplateGroup_GetAvailableTemplatesForUserId]
@UserId uniqueidentifier,
@TemplateId int,
@ExchangeId int = NULL,
@InstrumentId int = NULL

AS
SET NOCOUNT ON
SELECT tg.TemplateGroupId, tg.Description 
INTO #tg
FROM ib_TemplateGroup tg 
	INNER JOIN ib_Template t ON tg.TemplateId = t.TemplateId
	INNER JOIN ib_SiteTemplate st ON t.TemplateId = st.TemplateId
	INNER JOIN ib_SiteUser su ON su.UserId = @UserId AND su.SiteId = st.SiteId
WHERE tg.templateId = @templateId 
	 AND (TG.ExchangeId = @exchangeId OR TG.ExchangeId IS NULL)
	 AND (TG.InstrumentId = @instrumentId OR TG.InstrumentId IS NULL)

SELECT tg1.TemplateGroupId, tg1.Description 
FROM #tg tg1
WHERE tg1.TemplateGroupId =
	(SELECT TOP 1 tg2.TemplateGroupId
		FROM #tg tg2
		WHERE tg1.Description = tg2.Description
		ORDER BY tg2.TemplateGroupId)
ORDER BY tg1.Description

DROP TABLE #tg
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_NostroAutoMatch_GetMatchCodesAndRules]''
');

GO
EXECUTE ('--
/*
	Updated By: Kirill Shilin
	Update On: 17.10.2011
	Issue: MBAL-19117 When rule disabled, automatching is still running the rule.
	Changes: Rule.IsEnabled condition added; Rule related fields moved to second query
	
	Issue: 19118 When Rule set to Account Tolerance with zero figure it does not use Account tolderance
	
	Issue: 19110 Should be able to delete a Rule
*/

CREATE PROCEDURE [dbo].[ib_NostroAutoMatch_GetMatchCodesAndRules]
	@templateId int
AS
SET NOCOUNT ON
	SELECT  
		RMC.RuleId
		,RMC.MatchCodeId
		,CASE TT.Code WHEN ''A'' THEN R.Tolerance ELSE ISNULL(MCT.Tolerance,0) END AS Tolerance
	FROM 
		ib_MatchCode MC 
	LEFT OUTER JOIN
		ib_MatchCodeTolerance MCT ON MCT.MatchCode = MC.MatchCode
	INNER JOIN	
		ib_RuleMatchCode RMC ON RMC.MatchCodeId = MC.MatchCodeId 
	INNER JOIN
		ib_Rule R ON RMC.RuleId=  R.RuleId AND R.IsEnabled = 1 AND R.IsActive = 1
	INNER JOIN
		ib_ToleranceType TT ON R.ToleranceTypeId = TT.ToleranceTypeId
    WHERE mc.TemplateId = @templateId
	ORDER BY 
		MC.MatchCode,
		RMC.SequenceNumber
    
    SELECT DISTINCT  
		RMC.RuleId,
		R.Name AS RuleName
		--,RMC.MatchCodeId
		,RuleConditionId
		--,Tolerance
		,MCT.Code AS MatchCountTypeCode
		,O.Code AS OperatorCode
		,F.Code AS FieldCode
		,RC.Value
		,RC.InternalExternalCode AS InternalExternalCode
		,AF.Code AS AnotherFieldCode
	FROM 
		ib_MatchCode MC 
	INNER JOIN	
		ib_RuleMatchCode RMC ON RMC.MatchCodeId = MC.MatchCodeId 
	INNER JOIN
		ib_Rule R ON RMC.RuleId=  R.RuleId AND R.IsEnabled = 1 AND R.IsActive = 1
	INNER JOIN
		ib_MatchCountType MCT ON MCT.MatchCountTypeId = R.MatchCountTypeId
	LEFT OUTER JOIN
		ib_RuleCondition RC ON RC.RuleId = R.RuleId
	INNER JOIN
		ib_Operator O ON O.OperatorId = RC.OperatorId
	INNER JOIN
		ib_Field F ON RC.Field1Id = F.FieldId
	LEFT OUTER JOIN
		ib_Field AF ON AF.FieldId = RC.Field2Id
    WHERE mc.TemplateId = @templateId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_FirmDataSource_Get_List]''
');

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Gets all records from the ib_FirmDataSource table
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[ib_FirmDataSource_Get_List]

AS


				
				SELECT
					[FirmDataSourceId],
					[FirmId],
					[DataSourceId],
					[DataSourceFirmCode],
					[CreateDate],
					[CreateUsername],
					[UpdateDate],
					[UpdateUsername]
				FROM
					[dbo].[ib_FirmDataSource]
					
				SELECT @@ROWCOUNT
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_ExchangeHeader_Select]''
');

GO
EXECUTE ('/*
Created By:  McQuien
Date:  2006-11-21

Purpose:  Selects records into equity header in order to construct the equity reports.

Modifications:
*/


CREATE PROC [dbo].[ib_ExchangeHeader_Select]
@AsOfDate datetime,
@SiteId int

as
SET NOCOUNT ON

SELECT e.exchange,e.accountid,c.description,b.section1signoffdate,section2signoffdate,section2signoffdate
FROM ib_Currency c 
INNER JOIN ib_EquityHeader b on
c.currencyid = b.currencyid
INNER JOIN ib_SiteTemplate d on
b.templateid = d.templateid
INNER JOIN TemplateGroupId e on
b.TemplateId = e.templateid
and b.templategroupdescription = e.description
WHERE b.AsOfDate = @AsOfDate
and d.siteid = @SiteId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[HKFE_TP001_Type02_Add]''
');

GO
EXECUTE ('
-- =============================================
-- Author:		Lee Manifold
-- Create date: 21 Sep 2006
-- Description:	Insert into HKFE_TP001_Type02
--KevinP - 22 Feb 2010 - Added FileName
-- =============================================
CREATE PROCEDURE [dbo].[HKFE_TP001_Type02_Add]
		(
		@FileName            VARCHAR (512) = NULL,
		@RecordType				varchar(2),
		@ParticipantCode		varchar(5),
		@AccountID				varchar(50),
		@SeriesName				varchar(15),
		@TradeNumber			varchar(50),
		@OrigTradeNumber		varchar(50),
		@TradeAccount			varchar(10),
		@Movement				varchar(15),
		@BuySell				varchar(1),
		@OpenClose				varchar(1),
		@Long					varchar(8),
		@Short					varchar(8),
		@TradePrice				varchar(12),
		@Premium				varchar(15),
		@VariationAdjustment	varchar(19),
		@BusinessDate			datetime,
		@Market					varchar(5),
		@Currency				varchar(3)
		)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	INSERT INTO [dbo].[HKFE_TP001_Type02]
           (
			[RecordType]
           ,[ParticipantCode]
           ,[AccountID]
           ,[SeriesName]
           ,[TradeNumber]
           ,[OrigTradeNumber]
		   ,[TradeAccount]	
           ,[Movement]
           ,[BuySell]
           ,[OpenClose]
           ,[Long]
           ,[Short]
           ,[TradePrice]
           ,[Premium]
           ,[VariationAdjustment]
		   ,[BusinessDate]
		   ,[Market]
		   ,[Currency]
		   ,[FileName]	 	
			)
     VALUES
           (
			@RecordType,
			@ParticipantCode,
			@AccountID,
			@SeriesName,
			@TradeNumber,
			@OrigTradeNumber,
			@TradeAccount,
			@Movement,
			@BuySell,
			@OpenClose ,
			@Long,
			@Short,
			@TradePrice,
			@Premium,
			@VariationAdjustment,
			@BusinessDate,
			@Market,
			@Currency,
			@FileName
			)
END
');

GO
EXECUTE ('PRINT N''Creating [stage].[BmfPositionsRealisedCash_LoadStateChange]''
');

GO
EXECUTE ('CREATE PROCEDURE [stage].[BmfPositionsRealisedCash_LoadStateChange]
	(
		@OldLoadState	TINYINT,
		@NewLoadState	TINYINT,
		@FileName       VARCHAR (512)= NULL
	)
AS

-- Description: Changes the LoadState of the stage.BmfPositionsRealisedCash type table

-- 01 Jul 2014	ED	EIB 25781 - Creation

BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	UPDATE stage.BmfPositionsRealisedCash SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState AND [FileName] = Coalesce(@FileName, [FileName])

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Nostro_GetSortableAndPaginable]''
');

GO
SET ANSI_NULLS OFF

GO
EXECUTE ('/*
----------------------------------------------------------------------------------------------------

-- 12 Feb 09 : ED created
-- Purpose: Get the nostro records paginable
--
-- Revision History
-- 13.03.2009 Konrad, Passed Receipt and Payment values as NULL if equal to 0
-- 18 March 2009 - Konrad - Added DepartmentId and Notes as output fields
-- 19 March 2009 - Konrad - Added DepartmentCode as output field
-- 20 March 2009 - Konrad - Fixed bug of data not being fetched.
-- 24 March 2009 - Konrad - Added ShortNotes field = first 20 chars from Notes.
*/
--EXEC [ib_Nostro_GetSortableAndPaginable] ''MFL NONSEG JP Morgan Ldn (32761416) HUF'',null,''I''
--select * from ib_matchCode
CREATE PROCEDURE [dbo].[ib_Nostro_GetSortableAndPaginable]
(
	@MatchCode varchar(100),
	@TemplateId int = null,
	@InternalExternalCode char(1),
	@WhatView varchar(255) = null,
	@@OrderBy varchar(100) = NULL,
	@@StartRowIndex int = NULL,
	@@MaximumRows int = NULL
	
)
AS
SET NOCOUNT ON
BEGIN
			--fix orderby
IF (ISNULL(@@OrderBy, '''')='''')
	SET @@OrderBy = ''TransDate DESC'' 
IF (ISNULL(@WhatView, '''')='''')
	SET @WhatView = ''Outstanding''
 
	--fix the top
IF IsNull(@@MaximumRows, 0) <= 0
	SET @@MaximumRows = 0
IF IsNull(@@StartRowIndex, -1) <= -1 OR @@MaximumRows = 0 
	SET @@StartRowIndex = 0

DECLARE @SQL nvarchar(4000)
DECLARE @WHERE nvarchar(4000)

SET @WHERE = ''WHERE (1=1) ''
SET @WHERE = '' WHERE tg.[Description]=''''''+@MatchCode+'''''' AND InternalExternalCode=''''''+@InternalExternalCode+''''''''

IF @TemplateId IS NOT NULL
	SET @WHERE = @WHERE + '' AND tg.TemplateId = '' + cast(@TemplateId as varchar(100))
	
IF (@WhatView = ''Outstanding'')
	SET @WHERE = @WHERE + '' AND NOT EXISTS(SELECT 1 FROM ib_NostroMatch WHERE NostroId=n.NostroId) ''
ELSE
IF (@WhatView = ''Matching'')
	SET @WHERE = @WHERE + '' AND EXISTS(SELECT 1 FROM ib_NostroMatch WHERE NostroId=n.NostroId AND convert(varchar(10),CreateDate,111)=convert(varchar(10),getdate(),111))'' 
	
IF (@WhatView=''All'')
 	SET @WHERE = @WHERE + '' AND 
		(
		EXISTS(SELECT 1 FROM ib_NostroMatch WHERE NostroId=n.NostroId AND convert(varchar(10),CreateDate,111)=convert(varchar(10),getdate(),111))
		OR NOT EXISTS(SELECT 1 FROM ib_NostroMatch WHERE NostroId=n.NostroId))''
		 

IF @@MaximumRows >0
	SET @sql = ''SELECT  [NostroId],[ValueDate],[TransDate],[Amount],[TransactionType],[InternalReference],[ExternalReference]
      ,[Narrative],[AccountId],[CurrencyId],[DataSourceId],[TempTableRecordId],
	  Payment,Receipt,DepartmentId,GroupNumber
	  ,CASE WHEN n.[DepartmentId] IS NOT NULL THEN dpt.[Code] ELSE '''''''' END As DepartmentCode 
	  ,n.[Notes] As Notes
      ,Substring(Notes,0,20) As ShortNotes 
	 FROM
	   (SELECT TOP('' + CONVERT(nvarchar(10), @@StartRowIndex + @@MaximumRows) + '')''
ELSE SET @sql = ''SELECT''

--build the query
SET @sql = @sql + '' DISTINCT --tg.[Description],InternalExternalCode, t.TemplateId, 
		n.[NostroId],[ValueDate],[TransDate],[Amount],[TransactionType],[InternalReference],[ExternalReference]
      ,[Narrative],n.[AccountId],n.[CurrencyId],n.[DataSourceId],[TempTableRecordId],
	  CASE WHEN ABS(AMOUNT)!=AMOUNT THEN ABS(AMOUNT)
		ELSE NULL END as Payment,
	CASE WHEN ABS(AMOUNT)=AMOUNT THEN AMOUNT
		ELSE NULL END as Receipt
		,n.[DepartmentId]
    ,GroupNumber
    ,CASE WHEN n.[DepartmentId] IS NOT NULL THEN dpt.[Code] ELSE '''''''' END As DepartmentCode
    ,n.[Notes] As Notes,Substring(n.[Notes],0,20) As ShortNotes''

IF @@MaximumRows >0
	SET @sql = @sql+'', ROW_NUMBER() OVER(ORDER BY '' + @@OrderBy + '') as RowNum''
ELSE SET @Sql = @sql + ''''
SET @sql = @sql + ''
 FROM [ib_Nostro] n (nolock)
	INNER JOIN ib_Account a ON a.AccountId=n.AccountId
	INNER JOIN ib_Firm f ON f.FirmId=a.FirmId
	INNER JOIN ib_TemplateCompare tc ON tc.DataSourceId=n.DataSourceId AND tc.FirmId=f.FirmId
	INNER JOIN ib_Template t ON t.TemplateId=tc.TemplateId
	LEFT JOIN ib_Department dpt ON dpt.DepartmentId=n.DepartmentId
	INNER JOIN ib_TemplateGroup tg ON tg.TemplateId=t.TemplateId AND tg.AccountId=n.AccountId  AND tg.CurrencyId=n.CurrencyId
	LEFT JOIN ib_NostroMatch nm ON nm.NostroId=n.NostroId 
      '' + @where 

IF @@MaximumRows = 0
	SET @sql = @sql+''
 ORDER BY '' + @@OrderBy 

IF @@MaximumRows >0
	SET @sql = @sql +  '') as x
WHERE RowNum > '' + CONVERT(nvarchar(10), @@StartRowIndex) + '' ORDER BY RowNum''
PRINT @sql
-- Execute the query
EXEC sp_executesql @sql


END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_NostroAutoMatch_GetNostroCache]''
');

GO
SET ANSI_NULLS ON

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_NostroAutoMatch_GetNostroCache]
	@matchCodeId int,
	@ieCode char(1),
	@templateId int
AS
SET NOCOUNT ON
	DECLARE @matchCode NVARCHAR(MAX)
	
	SELECT @matchCode = 
		MatchCode 
	FROM 
		ib_MatchCode 
	WHERE 
		MatchCodeId = @matchCodeId
		
	EXEC ib_Nostro_GetSortableAndPaginable @matchCode, @templateId, @ieCode, ''Outstanding''
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_ExchangePurge]''
');

GO
EXECUTE ('CREATE proc [dbo].[ib_ExchangePurge]
@ExchangeCode varchar(25),
@Date  datetime=null
/*
Date:  06/30/2006
Programmer:  Bruce McQuien

Description:  This proc deletes records out of ib_Position and ib_Trx
based upon the Exchange code passed.  You can optionally supply a date
value which will delete them only for the specified date based upon the
CreateDate in these 2 tables.  
*/

as
SET NOCOUNT ON

declare @ExchangeId int

select @ExchangeId = ExchangeId 
from ib_Exchange
where code = @ExchangeCode

if @Date is null
begin
	delete from ib_Trx
	where ExchangeId = @ExchangeId
	
	delete from ib_Position
	where ExchangeId = @ExchangeId
end
else
begin
	delete from ib_Trx
	where ExchangeId = @ExchangeId
	and cast(left(CreateDate,11)as datetime) = @Date 

	delete from ib_Position
	where ExchangeId = @ExchangeId
	and cast(left(CreateDate,11)as datetime) = @Date 
end
');

GO
EXECUTE ('PRINT N''Creating [dbo].[sch_Reschedule]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[sch_Reschedule]
	@updateUsername nvarchar(50) = NULL
AS	
SET NOCOUNT ON
	PRINT ''[sch_Reschedule]''
	SELECT @updateUsername = COALESCE(@updateUsername, USER_NAME())

	--getting scheduling task id
	DECLARE @@targetTaskId INT 
	DECLARE @statusId INT
	SELECT TOP 1 @@targetTaskId = ST.ScheduledTaskId FROM ib_ScheduledTask ST
	INNER JOIN ib_TaskType TT ON TT.TaskTypeId = ST.TaskTypeId AND TT.Code = ''SCHD''
	
	SELECT 
		@statusId = 
		QueueStatusId 
	FROM 
		ib_QueueStatus 
	WHERE 
		Code = ''StandBy''

	--getting existing queueItem
	DECLARE @@queueItemId INT
	SELECT 
		@@queueItemId = QueueItemId
	FROM
		ib_QueueItem
	WHERE
		ScheduledTaskId = @@targetTaskId
		AND
		StatusId = @statusId
		
	IF ISNULL(@@queueItemId,-1) = -1
	BEGIN
		PRINT ''sch_CreateQueueItem''
		--inserting scheduling queueitem to reschedule all the tasks
		EXEC sch_CreateQueueItem 
			@scheduledTaskId = @@targetTaskId,
			@createUsername = @updateUsername
	END
	ELSE
	BEGIN
		PRINT ''sch_UpdateQueueItem''
		DECLARE @@now DATETIME
		SET @@now = getdate()
		EXEC sch_UpdateQueueItem @queueItemId = @@queueItemId, @scheduledStart = @@now, @statusId = @statusId, @updateUsername = @updateUsername
	END
');

GO
EXECUTE ('PRINT N''Creating [stage].[BmfPositionsRealisedCash_Purge]''
');

GO
EXECUTE ('CREATE PROCEDURE [stage].[BmfPositionsRealisedCash_Purge]
	(
		@LoadState		TINYINT = 0,
		@FileName       VARCHAR (512)= NULL
	)
AS
-- Description: Deletes from stage.BmfPositionsRealisedCash table all the records where the LoadState is 0

-- 01 Jul 2014	ED	EIB 25781 - Creation

-- History:

BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
	DELETE FROM stage.BmfPositionsRealisedCash WHERE LoadState= @LoadState AND [FileName] = Coalesce(@FileName, [FileName])

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[account_add]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[account_add]
	@LedgerCode VARCHAR(100)
	, @ActiveAccount VARCHAR(100)
	, @LedgerName VARCHAR(100)
	, @SalesCode VARCHAR(100)
	, @Class VARCHAR(100)
	, @BusinessType VARCHAR(100)
	, @FileName VARCHAR(100)
	, @FamilyCode VARCHAR(100)
AS
	--	24 Feb 2010		amk		Creation
	--	05 May 2012		ED		Add FamilyCode

	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	SET @FamilyCode = RTRIM(LTRIM(@FamilyCode))
	IF (@FamilyCode = '''')
		SET @FamilyCode = NULL
	
	INSERT INTO account (LedgerCode, ActiveAccount, LedgerName, SalesCode, Class, BusinessType, FileName, FamilyCode)
	VALUES (@LedgerCode, @ActiveAccount, @LedgerName, @SalesCode, @Class, @BusinessType, @FileName, @FamilyCode)
RETURN 0
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TemplateGroup_GetTemplateGroupById]''
');

GO
EXECUTE ('

     /*
<details>
 <summary> Selectes a template group from the ib_TemplateGroup table by its id</summary>
 <created author="Laurentiu Macovei" Date="Tuesday, 12 September 2006 9:34PM GMT" /> 
 <updated author="Emilian Damian" Date="Friday, 9 february 2007 9:34PM GMT" />
 <updated author="Petru Konrad Bercea" Date="Monday, 23 february 2009 9:34PM GMT">
     Added Currency
 </updated>
<updated author="Petru Konrad Bercea" Date="Wednesday, 11 march 2009 9:34PM GMT">
     Added MatchCodeId and Changed the output ''TemplateDescription'' field name to ''MatchCode''
 </updated>
</details>
*/
CREATE PROCEDURE [dbo].[ib_TemplateGroup_GetTemplateGroupById]
(
	@TemplateGroupId int
)
AS 
SET NOCOUNT ON


 SELECT tg.[TemplateGroupId]
      ,tg.[TemplateId]
	  ,tg.[Description] as MatchCode
	  ,mc.[MatchCodeId] as MatchCodeId
      ,tg.[ExchangeId]
	  ,e.[Name] as ExchangeName
	  ,e.[Code] as ExchangeCode
      ,tg.[FirmId]
	  ,f.[Name] as FirmName
	  ,f.[Code] as FirmCode
      ,tg.[ClassId]
	  ,c.[Code] as ClassCode
	  ,tg.[CurrencyId]
	  ,crrcy.[Code] as CurrencyCode
      ,tg.[AccountId]
	  ,a.[Name] as AccountName
	  ,a.[Code] as AccountCode
	, f_ac.[Code] as FirmAccountCode
      ,tg.[InstrumentId]
	  ,i.[Name] as InstrumentName
	  ,i.[Code] as InstrumentCode
      ,tg.[Description]
      ,tg.[CreateDate]
      ,tg.[CreateUsername]
      ,tg.[UpdateDate]
      ,tg.[UpdateUsername]
  FROM [dbo].[ib_TemplateGroup] tg
LEFT JOIN [dbo].[ib_Exchange] e ON e.[ExchangeId] = tg.[ExchangeId]
LEFT JOIN [dbo].[ib_Firm] f ON f.[FirmId] = tg.[FirmId]
LEFT JOIN [dbo].[ib_Class] c ON c.[ClassId] = tg.[ClassId]
LEFT JOIN [dbo].[ib_Currency] crrcy ON crrcy.[CurrencyId] = tg.[CurrencyId]
LEFT JOIN [dbo].[ib_Account] a ON a.[AccountId] = tg.[AccountId]
LEFT JOIN [dbo].[ib_Instrument] i ON i.[InstrumentId] = tg.[InstrumentId]
INNER JOIN [dbo].[ib_Template] t ON t.[TemplateId] = tg.[TemplateId]
INNER JOIN [dbo].[ib_MatchCode] mc ON mc.[MatchCode] = tg.[Description]
LEFT JOIN [dbo].[ib_Firm] f_ac ON f_ac.[FirmId] = a.[FirmId]
WHERE TemplateGroupId = @TemplateGroupId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_NostroAutoMatch_GetPeopleSoftFiles]''
');

GO
EXECUTE ('/*
	Created By: Kirill Shilin
	Create On: 03.10.2011
	Issue: MBAL-18277 Code Routine to Verify Go Ahead for Scheduled Auto-Match (sub-task)
	Purpose: Returns People Soft Files list for checking within automatch start requirements verification procedure
	
	Updated By: Kirill Shilin
	Update On: 04.10.2011
	Issue: MBAL-18277 Code Routine to Verify Go Ahead for Scheduled Auto-Match (sub-task)
	Changes: code review, bug with test date, single record returned

*/
CREATE PROCEDURE [dbo].[ib_NostroAutoMatch_GetPeopleSoftFiles]
	@targetDate DATETIME = NULL
AS
SET NOCOUNT ON
	SELECT @targetDate = COALESCE(@targetDate, GETDATE())
	DECLARE @recordCount INT
	
		SELECT TOP 1 PeopleSoftBalancesLogId, CreateDate
		FROM	
			ib_PeopleSoftBalancesLog
		WHERE 
			DATEPART(YEAR, CreateDate) = DATEPART(YEAR,@targetDate)
			AND
			DATEPART(MONTH, CreateDate) = DATEPART(MONTH,@targetDate)
			AND
			DATEPART(DAY, CreateDate) = DATEPART(DAY,@targetDate)
		ORDER BY
			CreateDate DESC
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_FirmDataSource_Insert]''
');

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Inserts a record into the ib_FirmDataSource table
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[ib_FirmDataSource_Insert]
(

	@FirmDataSourceId int    OUTPUT,

	@FirmId int   ,

	@DataSourceId int   ,

	@DataSourceFirmCode varchar (100)  ,

	@CreateDate datetime   ,

	@CreateUsername varchar (50)  ,

	@UpdateDate datetime   ,

	@UpdateUsername varchar (50)  
)
AS


				
				INSERT INTO [dbo].[ib_FirmDataSource]
					(
					[FirmId]
					,[DataSourceId]
					,[DataSourceFirmCode]
					,[CreateDate]
					,[CreateUsername]
					,[UpdateDate]
					,[UpdateUsername]
					)
				VALUES
					(
					@FirmId
					,@DataSourceId
					,@DataSourceFirmCode
					,@CreateDate
					,@CreateUsername
					,@UpdateDate
					,@UpdateUsername
					)
				
				-- Get the identity value
				SET @FirmDataSourceId = SCOPE_IDENTITY()
									
							
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_FeeType_GetByCode]''
');

GO
EXECUTE ('
-- =============================================
-- Author:		Lee Manifold
-- Create date: 24 Nov 2006
-- Description:	Retrieve ib_FeeTypeID
-- =============================================
CREATE PROC [dbo].[ib_FeeType_GetByCode]
	(
	@FeeTypeCode	VARCHAR(25),
	@FeeTypId		INT OUTPUT
	)

AS
SET NOCOUNT ON

	SELECT	@FeeTypId = [FeeTypeId] 
	
	FROM	[dbo].[ib_FeeType]
	
	WHERE	[Code] = @FeeTypeCode
');

GO
EXECUTE ('PRINT N''Creating [dbo].[eib_Load_Begin]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[eib_Load_Begin]
(
	@LocationPath VARCHAR(100),
	@DataSourceCode VARCHAR(100)
)

AS

SET NOCOUNT ON
--  09 Jan 2014     ED      EIB 25004 - remove importLog table and use Log table
-- Get data source ID and default currency ID
DECLARE @DataSourceId INT
DECLARE @DefaultCurrencyId INT
EXEC [_ib_DataSource_GetByCodeForOutput] @DataSourceCode, @DataSourceId OUTPUT, @DefaultCurrencyId OUTPUT	

-- Duplicate file check										
DECLARE @IsFileAlreadyLoaded INT
EXEC @IsFileAlreadyLoaded = HasFileBeenLoaded @LocationPath, @DataSourceId

-- Get import file ID?
DECLARE @ImportFileId INT
IF (@IsFileAlreadyLoaded != 1)
BEGIN
	EXEC ib_ImportFile_Add @DataSourceId, @LocationPath, @ImportFileId OUTPUT
END

-- Return results
SELECT
	@IsFileAlreadyLoaded AS IsFileAlreadyLoaded,
	ISNULL(@ImportFileId, 0) AS ImportFileId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_AccessRight_Update]''
');

GO
EXECUTE ('
CREATE PROCEDURE [dbo].[ib_AccessRight_Update]
(
	@UserId			uniqueidentifier
	, @MatchCodeId	int
	, @AccessRightCode	varchar(100)
	, @UpdateUsername  nvarchar(256)
)
AS

--	Description: Insert or Update User MatchCode Access
--	02 Oct 2009		AAJM	Creation MBAL-11773

BEGIN
   	
	SET NOCOUNT ON

	DECLARE @AccessRightId INT
	SELECT @AccessRightId = ar.AccessRightId FROM [dbo].[ib_AccessRight] ar WHERE ar.Code = @AccessRightCode
			
	IF EXISTS(SELECT 1 FROM [dbo].[ib_UserMatchCodeAccess] umca WHERE umca.UserId = @UserId AND umca.MatchCodeId = @MatchCodeId)
		BEGIN
		
			UPDATE [dbo].[ib_UserMatchCodeAccess]
			SET AccessRightId = @AccessRightId, UpdateUsername = @UpdateUsername
			WHERE UserId = @UserId AND MatchCodeId = @MatchCodeId

		END	
	ELSE
		BEGIN
		
			INSERT INTO [dbo].[ib_UserMatchCodeAccess]
           ([UserId]
           ,[MatchCodeId]
           ,[AccessRightId]
           ,[CreateDate]
           ,[CreateUsername]
			)
     VALUES
           (@UserId
           ,@MatchCodeId
           ,@AccessRightId
           ,GETDATE()
           ,@UpdateUsername
			)
		
		END

END
');

GO
EXECUTE ('PRINT N''Creating [stage].[BmfTrade_LoadStateChange]''
');

GO
EXECUTE ('CREATE PROCEDURE [stage].[BmfTrade_LoadStateChange]
	(
		@OldLoadState	TINYINT,
		@NewLoadState	TINYINT,
		@FileName       VARCHAR (512)= NULL
	)
AS

-- Description: Changes the LoadState of the stage.BmfTrade type table

-- 25 Mar 2016	ED	EIB 38652 - Creation

BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	UPDATE stage.BmfTrade SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState AND [FileName] = Coalesce(@FileName, [FileName])

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[aspnet_AnyDataInTables]''
');

GO
SET QUOTED_IDENTIFIER OFF

GO
EXECUTE ('CREATE PROCEDURE [dbo].[aspnet_AnyDataInTables]
    @TablesToCheck int
AS
SET NOCOUNT ON
BEGIN
    -- Check Membership table if (@TablesToCheck & 1) is set
    IF ((@TablesToCheck & 1) <> 0 AND
        (EXISTS (SELECT name FROM sysobjects WHERE (name = N''vw_aspnet_MembershipUsers'') AND (type = ''V''))))
    BEGIN
        IF (EXISTS(SELECT TOP 1 UserId FROM dbo.aspnet_Membership))
        BEGIN
            SELECT N''aspnet_Membership''
            RETURN
        END
    END

    -- Check aspnet_Roles table if (@TablesToCheck & 2) is set
    IF ((@TablesToCheck & 2) <> 0  AND
        (EXISTS (SELECT name FROM sysobjects WHERE (name = N''vw_aspnet_Roles'') AND (type = ''V''))) )
    BEGIN
        IF (EXISTS(SELECT TOP 1 RoleId FROM dbo.aspnet_Roles))
        BEGIN
            SELECT N''aspnet_Roles''
            RETURN
        END
    END

    -- Check aspnet_Profile table if (@TablesToCheck & 4) is set
    IF ((@TablesToCheck & 4) <> 0  AND
        (EXISTS (SELECT name FROM sysobjects WHERE (name = N''vw_aspnet_Profiles'') AND (type = ''V''))) )
    BEGIN
        IF (EXISTS(SELECT TOP 1 UserId FROM dbo.aspnet_Profile))
        BEGIN
            SELECT N''aspnet_Profile''
            RETURN
        END
    END

    -- Check aspnet_PersonalizationPerUser table if (@TablesToCheck & 8) is set
    IF ((@TablesToCheck & 8) <> 0  AND
        (EXISTS (SELECT name FROM sysobjects WHERE (name = N''vw_aspnet_WebPartState_User'') AND (type = ''V''))) )
    BEGIN
        IF (EXISTS(SELECT TOP 1 UserId FROM dbo.aspnet_PersonalizationPerUser))
        BEGIN
            SELECT N''aspnet_PersonalizationPerUser''
            RETURN
        END
    END

    -- Check aspnet_PersonalizationPerUser table if (@TablesToCheck & 16) is set
    IF ((@TablesToCheck & 16) <> 0  AND
        (EXISTS (SELECT name FROM sysobjects WHERE (name = N''aspnet_WebEvent_LogEvent'') AND (type = ''P''))) )
    BEGIN
        IF (EXISTS(SELECT TOP 1 * FROM dbo.aspnet_WebEvent_Events))
        BEGIN
            SELECT N''aspnet_WebEvent_Events''
            RETURN
        END
    END

    -- Check aspnet_Users table if (@TablesToCheck & 1,2,4 & 8) are all set
    IF ((@TablesToCheck & 1) <> 0 AND
        (@TablesToCheck & 2) <> 0 AND
        (@TablesToCheck & 4) <> 0 AND
        (@TablesToCheck & 8) <> 0 AND
        (@TablesToCheck & 32) <> 0 AND
        (@TablesToCheck & 128) <> 0 AND
        (@TablesToCheck & 256) <> 0 AND
        (@TablesToCheck & 512) <> 0 AND
        (@TablesToCheck & 1024) <> 0)
    BEGIN
        IF (EXISTS(SELECT TOP 1 UserId FROM dbo.aspnet_Users))
        BEGIN
            SELECT N''aspnet_Users''
            RETURN
        END
        IF (EXISTS(SELECT TOP 1 ApplicationId FROM dbo.aspnet_Applications))
        BEGIN
            SELECT N''aspnet_Applications''
            RETURN
        END
    END
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_NostroAutoMatch_GetRule]''
');

GO
SET QUOTED_IDENTIFIER ON

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_NostroAutoMatch_GetRule]
	@RuleId int
AS
SET NOCOUNT ON
	SELECT
		R.RuleId
		,Tolerance
		,MCT.Code AS MatchCountTypeCode
	FROM
		ib_Rule R
	INNER JOIN
		ib_MatchCountType MCT ON MCT.MatchCountTypeId = R.MatchCountTypeId
	WHERE
		RuleId = @RuleId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_FirmDataSource_Update]''
');

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Updates a record in the ib_FirmDataSource table
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[ib_FirmDataSource_Update]
(

	@FirmDataSourceId int   ,

	@FirmId int   ,

	@DataSourceId int   ,

	@DataSourceFirmCode varchar (100)  ,

	@CreateDate datetime   ,

	@CreateUsername varchar (50)  ,

	@UpdateDate datetime   ,

	@UpdateUsername varchar (50)  
)
AS


				
				
				-- Modify the updatable columns
				UPDATE
					[dbo].[ib_FirmDataSource]
				SET
					[FirmId] = @FirmId
					,[DataSourceId] = @DataSourceId
					,[DataSourceFirmCode] = @DataSourceFirmCode
					,[CreateDate] = @CreateDate
					,[CreateUsername] = @CreateUsername
					,[UpdateDate] = @UpdateDate
					,[UpdateUsername] = @UpdateUsername
				WHERE
[FirmDataSourceId] = @FirmDataSourceId 
				
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Firm_GetByCode]''
');

GO
EXECUTE ('CREATE PROC [dbo].[ib_Firm_GetByCode]
	(
		@FirmCode VARCHAR(100)
		, @FirmId INT OUTPUT
	)

AS
SET NOCOUNT ON

	--	25 Feb 2010		amk		Creation

	SELECT @FirmId = FirmId
	FROM ib_Firm
	WHERE Code = @FirmCode
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Account_Update]''
');

GO
EXECUTE ('create proc [dbo].[ib_Account_Update]
(
	@AccountId			int,
	@FirmId				int			= NULL,
	@ClassId            int         = NULL,
	@Code				varchar(25) = NULL,
	@Name				varchar(50) = NULL,
	@IsApproved			bit			= NULL,
	@UpdateUsername		varchar(50),
	@ParentAccountId	int			= NULL,
	@IsImported			bit			= NULL,
	@FamilyCode			varchar(100)= NULL,
	@IsOmnibus          BIT         = NULL
)
AS
SET NOCOUNT ON

	-- 26.01.2007	LM		Updates the ib_Account table
	-- 05.02.2007	LM		Took out the ISNULL statement in the SET command
	--						to allow NULL values into the ParentAccountId
	-- 11.06.2009	Konrad	Added ClassId and UpdateUsername to the update fields
	-- 15.06.2009	Konrad	Fixed the Update of ClassId
	-- 08.07.2009	Konrad	Fixed updating ClassId on Position and Transaction. 
	-- 25.02.2010	amk		Only update class on pos/trx if it changed (completed half-finished code!)
    -- 27.04.2010	AAJM	MBAL-15315 Add IsImported flag
    -- 01.05.2012	ed		MBAL-20400 add FamilyCode and IsOmnibus
    
	DECLARE @UpdateClass BIT
	DECLARE @OldClassId INT

	SET @UpdateClass = 0

	SELECT @OldClassId = ClassId 
	FROM ib_Account 
	WHERE AccountId = @AccountId

	IF @ClassId <> @OldClassId
		OR (@ClassId IS NULL AND @OldClassId IS NOT NULL)
		OR (@ClassId IS NOT NULL AND @OldClassId IS NULL)
		SET @UpdateClass = 1 

	BEGIN
	TRY
		UPDATE	[dbo].[ib_Account] 
		SET
			[FirmId]			= ISNULL(@FirmId,[FirmId]),
            [ClassId]			= @ClassId,
			[Code]				= ISNULL(@Code,[Code]),
			[Name]				= ISNULL(@Name,[Name]),
			[Isapproved]		= ISNULL(@IsApproved,[Isapproved]),
			[ParentAccountId]	= ISNULL(@ParentAccountId,[ParentAccountId]),
			[UpdateUsername]	= @UpdateUsername,
			[UpdateDate]		= GetDate(),
			[IsImported]        = ISNULL(@IsImported,[IsImported]),
			[FamilyCode]        = @FamilyCode,
			[IsOmnibus]         = ISNULL(@IsOmnibus,[IsOmnibus])
		WHERE	[AccountId]			= @AccountId

		IF @UpdateClass = 1
		BEGIN
			UPDATE	[dbo].[ib_Position] 
			SET
				[ClassId]			= @ClassId,
				[UpdateUsername]	= @UpdateUsername,
				[UpdateDate]		= GetDate()
			WHERE	[AccountId]			= @AccountId

			UPDATE	[dbo].[ib_Trx] 
			SET
				[ClassId]			= @ClassId,
				[UpdateUsername]	= @UpdateUsername,
				[UpdateDate]		= GetDate()
			WHERE	[AccountId]			= @AccountId
			
			UPDATE	[dbo].[ib_Adjustment] 
			SET
				[ClassId]			= @ClassId,
				[UpdateUsername]	= @UpdateUsername,
				[UpdateDate]		= GetDate()
			WHERE	[AccountId]			= @AccountId
		END
	END TRY
	BEGIN CATCH
		EXEC [dbo].[sp_RethrowError]
	END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Account_Load]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Account_Load] 
	(
		 @LocationPath VARCHAR(100)
		,@ReceiveLocationSysId INT = NULL
		,@RunId INT = NULL
	)
AS
SET NOCOUNT ON
	--	25 Feb 2010		amk		Creation (MBAL-12851)
	--	13 May 2010		amk		BUG FIX: reported by Marc to Jeff: new accounts should have new IsImported flag set on, not off
	--	20 May 2010		amk		MBAL-15566: move import log add to outside transaction to avoid deadlocks
	--	13 Aug 2010		amk		MBAL-16454: update class on existing account even if not yet set (null comparison bug)
	--	25 Aug 2010		amk		MBAL-16525: Bug fix: reset classid & don''t report class warning for inactive accounts
	--  29 Dec 2011		AAJM	MBAL-19618: Update to Class field
	--	09 Jan 2014		ED		EIB 25004 - remove importLog table and use Log table

	DECLARE @DataSourceCd  AS VARCHAR(100)
	SET @DataSourceCd = ''RolfeNolan''
	DECLARE @DataSourceId INT
	DECLARE @DefaultCurrencyId INT
	EXEC [_ib_DataSource_GetByCodeForOutput] @DataSourceCd, @DataSourceId output, @DefaultCurrencyId output
	
	-- There really isn''t any need for orchestration to call a LoadStateChange anymore
	-- since we only process rows for single file now
	-- but to keep consistent with other loaders - we''ll update to LoadState 1 at 
	-- start of this Load stored procedure
	UPDATE Account
	SET LoadState = 1
	WHERE LoadState = 0
		AND Filename = @LocationPath

	BEGIN TRANSACTION T1

	-- BizTalk''s SQL Adapter uses more restrictive read serializable
	-- so this is necessary to relax it to something that is default
	-- and perfectly acceptable!
	SET TRANSACTION ISOLATION LEVEL READ COMMITTED

	-- Now proceed with load

	DECLARE @Message VARCHAR(1024)

	-- first find the firm
	DECLARE @FirmCode VARCHAR(100)
	DECLARE @FirmId INT
	SET @FirmCode = ''Marex (R&N)''
	EXEC ib_Firm_GetByCode @FirmCode, @FirmId OUTPUT
	IF @FirmId IS NULL
	BEGIN
		SET @Message = ''Firm with code '' + @FirmCode 
			+ '' not found in i-Balancer; account not synced''
		RAISERROR(@Message, 15, 1)
	END

	DECLARE @AddCount INT
	DECLARE @UpdateCount INT
	DECLARE @SkipCount INT
	SET @AddCount = 0
	SET @UpdateCount = 0
	SET @SkipCount = 0

	DECLARE @AccountID INT
	DECLARE @ActiveAccount VARCHAR(100)
	DECLARE @BusinessType VARCHAR(100)
	DECLARE @Class VARCHAR(100)
	DECLARE @LedgerCode VARCHAR(100)
	DECLARE @LedgerName VARCHAR(100)
	DECLARE @SalesCode VARCHAR(100)
	DECLARE @FamilyCode VARCHAR(100)

	CREATE TABLE #temp1
	(
		AccountID INT
		, ActiveAccount VARCHAR(100)
		, BusinessType VARCHAR(100)
		, Class VARCHAR(100)
		, LedgerCode VARCHAR(100)
		, LedgerName VARCHAR(100)
		, SalesCode VARCHAR(100)
		, FamilyCode VARCHAR(100)
	)

	INSERT INTO #temp1
		(AccountId, ActiveAccount, BusinessType, Class, LedgerCode, LedgerName, SalesCode, FamilyCode)
	SELECT AccountId, ActiveAccount, BusinessType, Class, LedgerCode, LedgerName, SalesCode, FamilyCode
	FROM Account a
	WHERE a.LoadState = 1
		AND a.Filename = @LocationPath

	DECLARE pos_cursor CURSOR FOR
	SELECT AccountId, ActiveAccount, BusinessType, Class, LedgerCode, LedgerName, SalesCode, FamilyCode
	FROM #temp1

	OPEN pos_cursor

	FETCH NEXT FROM pos_cursor
	INTO @AccountId, @ActiveAccount, @BusinessType, @Class, @LedgerCode, @LedgerName, @SalesCode, @FamilyCode

	DECLARE @CurrentAccountName VARCHAR(100)
	DECLARE @CurrentAccountClassId INT
	DECLARE @DestinationAccountId INT
	DECLARE @CurrentIsApproved BIT
	DECLARE @CurrentFamilyCode VARCHAR(100)

	DECLARE @ClassId INT
	DECLARE @IsActive BIT

	-- Check @@FETCH_STATUS to see IF there are any more rows to fetch.
	WHILE @@FETCH_STATUS = 0
	BEGIN
		-- check for account record
		SET @CurrentAccountName = NULL
		SET @CurrentAccountClassId = NULL
		SET @DestinationAccountId = NULL
		SET @CurrentIsApproved = NULL
		SET @CurrentFamilyCode = NULL

		SELECT @CurrentAccountName = a.Name
			, @CurrentAccountClassId = a.ClassId
			, @DestinationAccountId = a.AccountId
			, @CurrentIsApproved = a.IsApproved
			, @CurrentFamilyCode = a.FamilyCode
		FROM ib_Account a
		WHERE a.Code = @LedgerCode
			AND a.FirmId = @FirmId

		IF UPPER(RTRIM(LTRIM(@ActiveAccount))) = ''N''
			SET @IsActive = 0
		ELSE
			SET @IsActive = 1

		-- Update the Class code from the file to add ''M'' at the front
		SET @Class = ''M'' + @Class
		
		-- check if class exists
		SET @ClassId = NULL
		EXEC ib_Class_GetByCode @Class, @ClassId OUTPUT
		IF @ClassId IS NULL AND @IsActive = 1
		BEGIN
			-- log message but proceed as we may want to deactivate the account
			SET @Message = ''Class '' + @Class + '' for account '' + @LedgerCode 
				+ '' not found in i-Balancer; account not synced''
			EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @Message, ''Success'', '''', @RunId
		END
		
		DECLARE @UpdateUsername VARCHAR(50)
		SET @UpdateUsername = SUSER_SNAME()

		IF @IsActive = 0
			-- make sure approved flag in destination is off
			IF @DestinationAccountId IS NOT NULL AND @CurrentIsApproved = 1
			BEGIN
				-- flip the approved bit
				EXEC ib_Account_Update @DestinationAccountId, @FirmId, @ClassId
					, @LedgerCode, @LedgerName, 0, @UpdateUsername
				SET @UpdateCount = @UpdateCount + 1
			END
			ELSE
				SET @SkipCount = @SkipCount + 1
		ELSE
		BEGIN
			-- add or update account as necessary
			IF @DestinationAccountId IS NULL
			BEGIN
				-- do add
				EXEC ib_Account_Add @FirmId, @LedgerCode, @LedgerName, 1, @ClassId, @IsImported=1, @FamilyCode = @FamilyCode
				SET @AddCount = @AddCount + 1
			END
			ELSE
			BEGIN
				IF @ClassId <> @CurrentAccountClassId
					OR (@ClassId IS NULL and @CurrentAccountClassId IS NOT NULL)
					OR (@ClassId IS NOT NULL and @CurrentAccountClassId IS NULL)
					OR @LedgerName <> @CurrentAccountName
					OR @CurrentIsApproved = 0
					OR ISNULL(@FamilyCode,'''') <> ISNULL(@CurrentFamilyCode,'''')
				BEGIN
					-- do update
					EXEC ib_Account_Update @DestinationAccountId, @FirmId, @ClassId
						, @LedgerCode, @LedgerName, 1, @UpdateUsername, NULL, NULL, @FamilyCode
					SET @UpdateCount = @UpdateCount + 1
				END
				ELSE
					SET @SkipCount = @SkipCount + 1
			END
		END

 		--flip processed flag in source table.
		UPDATE Account
		WITH (ROWLOCK)
		SET LoadState = 2
		WHERE AccountID = @AccountID
			AND LoadState = 1

		FETCH NEXT FROM pos_cursor
		INTO @AccountId, @ActiveAccount, @BusinessType, @Class, @LedgerCode, @LedgerName, @SalesCode, @FamilyCode
	END
			
	CLOSE pos_cursor
	DEALLOCATE pos_cursor
	
	SET @Message = ''Accounts loader ended ('' 
		+ CONVERT(VARCHAR(10), @AddCount) + '' added; '' 
		+ CONVERT(VARCHAR(10), @UpdateCount) + '' updated; '' 
		+ CONVERT(VARCHAR(10), @SkipCount) + '' skipped)''
	EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @Message, ''Success'', '''', @RunId

	DROP TABLE #temp1
	
	COMMIT TRANSACTION T1
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Account_GetAccountById]''
');

GO
EXECUTE ('

CREATE PROCEDURE [dbo].[ib_Account_GetAccountById]
(
	@AccountId int
)
AS
SET NOCOUNT ON

/*
<details>
 <summary> Selectes an Account from the ib_Account table by its id</summary>
 <created author="Laurentiu Macovei" Date="Tuesday, 12 September 2006 9:34PM GMT" /> 
<updated author="Emilian Damian" Date="9 Feb 2007 9:34PM GMT" /> 
added firm code for an account
</details>
*/
-- Revision History
--
-- 11.06.2009 Konrad Added ClassId and ClassCode to the output fields
-- 28.04.2010 AAJM	 MBAL-15315 Return IsImported
-- 01.05.2012	ed		MBAL-20400 add FamilyCode and IsOmnibus
-- 02.07.2014	ed		EIB-24627 - add StatementNumberSeed
SELECT i.[AccountId]
      ,i.[FirmId]
	  ,it.[Code] as FirmCode
	  ,i.[Code]
      ,i.[Name]
      ,i.[IsApproved]
	  ,i.[ClassId]
      ,cl.[Code] as ClassCode	
      ,i.[CreateDate]
      ,i.[CreateUsername]
      ,i.[UpdateDate]
      ,i.[UpdateUsername]
      ,i.[IsImported]
      ,i.[FamilyCode]
      ,i.[IsOmnibus]
      , sss.StatementNumberSeed
  FROM [dbo].[ib_Account] i
LEFT OUTER JOIN [dbo].[ib_Firm] it on i.[FirmId]=it.[FirmId]
LEFT OUTER JOIN [dbo].[ib_Class] cl on i.[ClassId]=cl.[ClassId]
LEFT OUTER JOIN ib_SwiftStatementSeed sss ON sss.AccountId = i.AccountId
WHERE i.AccountId = @AccountId
');

GO
EXECUTE ('PRINT N''Creating [stage].[BmfTrade_Purge]''
');

GO
EXECUTE ('CREATE PROCEDURE [stage].[BmfTrade_Purge]
	(
		@LoadState		TINYINT = 0,
		@FileName       VARCHAR (512)= NULL
	)
AS
-- Description: Deletes from stage.BmfTrade_ table all the records where the LoadState is 0

-- 25 Mar 2016	ED	EIB 38652 - Creation

-- History:

BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
	DELETE FROM stage.BmfTrade WHERE LoadState= @LoadState AND [FileName] = Coalesce(@FileName, [FileName])

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_NostroAutoMatch_GetRuleConditions]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_NostroAutoMatch_GetRuleConditions]
	@RuleId int
AS
SET NOCOUNT ON
	SELECT 
		RuleConditionId
		,O.Code AS OperatorCode
		,F.Code AS FieldCode
		,RC.Value
		,CAST ( RC.InternalExternalCode AS CHAR(1))
	FROM
		ib_RuleCondition RC
	INNER JOIN
		ib_Operator O ON O.OperatorId = RC.OperatorId
	INNER JOIN
		ib_Field F ON RC.Field1Id = F.FieldId
	WHERE
		RC.IsEnabled = 1
		AND
		RC.RuleId = @RuleId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_FirmDataSource_Delete]''
');

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Deletes a record in the ib_FirmDataSource table
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[ib_FirmDataSource_Delete]
(

	@FirmDataSourceId int   
)
AS


				DELETE FROM [dbo].[ib_FirmDataSource] WITH (ROWLOCK) 
				WHERE
					[FirmDataSourceId] = @FirmDataSourceId
					
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Firm_GetAll]''
');

GO
EXECUTE ('
  /*
<details>
 <summary>Returns all the firms</summary>
 <created author="anil.kripalani" date="18 Oct 2006"/>
</details>
*/
--
-- Revision History
-- 
-- 19.05.2009 Konrad Added extra field which concatenates Code and Name values
--
CREATE PROCEDURE [dbo].[ib_Firm_GetAll]
AS
SET NOCOUNT ON
SELECT FirmId, Code, [Name], Code+'' - ''+[Name] as [CodeName]
	FROM ib_Firm
	WHERE Name NOT LIKE ''AutoGenerated%''
	ORDER BY [Name]
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Adjustment_DeleteGroup]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Adjustment_DeleteGroup]
(
	@AdjustmentId INT
	, @UpdateUsername VARCHAR(50)
)
AS
SET NOCOUNT ON
/*	
	-- delete adjustmentd
	-- 26 May 2010	ED		Created
	-- 27 May 2010	ED		MBAL 15666 - fix the matched adjustment, too(if any)
	-- 27 Jul 2010	AAJM	MBAL-16297 - Fix problem deleting adjustment related
	--									 to adjustments that have already been matched
	-- 30 Jul 2010	amk		MBAL-16333 - don''t allow delete for rolled forward adjustments
	-- 17 Nov 2010	amk		MBAL-16341 - unpoke imbalance report
	-- 09 Sep 2014	ED		EIB 25958 - delete also UM adjs
*/

BEGIN TRY
	BEGIN TRAN
	DECLARE @AdjustmentHeaderId INT
	SELECT @AdjustmentHeaderId = a.AdjustmentHeaderId
		FROM ib_Adjustment a 
		WHERE a.AdjustmentId = @AdjustmentId

	--break link
	UPDATE ib_TradeReconciliationDetail 
		SET AdjustmentId = NULL 
		WHERE AdjustmentId IN 
			(SELECT AdjustmentId 
				FROM ib_Adjustment 
				WHERE AdjustmentHeaderId = @AdjustmentHeaderId)

	DECLARE @Notes VARCHAR(255)
	SET @Notes = ''Matched partner deleted (''+@UpdateUsername+'', ''+CONVERT(CHAR(10), CURRENT_TIMESTAMP, 103)+'' ''+CONVERT(CHAR(5), CURRENT_TIMESTAMP, 114)+'') ''

	UPDATE ib_Adjustment
		SET MatchingAdjustmentId = NULL
			, AdjustmentStatusId = NULL
			, Description = @Notes + Description
		WHERE MatchingAdjustmentId IN (SELECT AdjustmentId FROM ib_Adjustment WHERE AdjustmentHeaderId=@AdjustmentHeaderId)

	IF EXISTS (SELECT * 
				FROM ib_Adjustment a
					LEFT OUTER JOIN ib_AdjustmentStatus s ON a.AdjustmentStatusId = s.AdjustmentStatusId
					JOIN ib_AdjustmentHeader h ON h.AdjustmentHeaderId = a.AdjustmentHeaderId
					JOIN ib_AdjustmentType t ON t.AdjustmentTypeId = h.AdjustmentTypeId
				WHERE a.AdjustmentHeaderId = @AdjustmentHeaderId
					AND (s.Code = ''R'' OR (a.ReplacesAdjustmentId IS NOT NULL AND t.Code <> ''CQ''))
				)
		RAISERROR (''One or more adjustments in the group have been rolled forward.  Cannot delete.'', 11, 1)

	IF EXISTS (SELECT 1
				FROM ib_AdjustmentHeader h 
					JOIN ib_AdjustmentType t ON t.AdjustmentTypeId = h.AdjustmentTypeId
				WHERE h.AdjustmentHeaderId = @AdjustmentHeaderId
					AND t.Code = ''UM''
				)
		UPDATE ib_Trx SET MatchingAdjustmentId = NULL WHERE IsUnmatched = 1 AND MatchingAdjustmentId IN (SELECT AdjustmentId 
				FROM ib_Adjustment 
				WHERE AdjustmentHeaderId = @AdjustmentHeaderId)

	-- this must be called BEFORE the adjustments are deleted
	EXEC ib_Adjustment_UnpokeImbalanceReport @AdjustmentHeaderId

	DELETE 
		FROM ib_Adjustment 
		WHERE AdjustmentId IN 
			(SELECT AdjustmentId 
				FROM ib_Adjustment 
				WHERE AdjustmentHeaderId = @AdjustmentHeaderId)

	DELETE FROM ib_AdjustmentHeader 
	WHERE AdjustmentHeaderId = @AdjustmentHeaderId

	COMMIT TRAN
END TRY
BEGIN CATCH
	ROLLBACK TRAN
	EXEC [dbo].[sp_RethrowError]
END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Account_GetAccountCodesHintByKeyword]''
');

GO
EXECUTE ('

/*
<details>
 <summary> Returns the Accounts hint for a specific code /summary>
 <created author="Emilian Damian" Date="7 Feb 2007" />  
 <tasks>
 </tasks>
</details>
*/
CREATE PROCEDURE [dbo].[ib_Account_GetAccountCodesHintByKeyword]
@AccountCode varchar(100),
@HintByStartOnly bit = 0,
@HintLength int = 1
AS
SET NOCOUNT ON

DECLARE @len int
SET @len = LEN(@AccountCode)
IF @HintByStartOnly = 1
BEGIN
	SELECT DISTINCT SUBSTRING ([Code], @len, @HintLength) x
		FROM [dbo].[ib_Account]
		WHERE [Code] LIKE @AccountCode+''%''
		ORDER BY x

END
ELSE
BEGIN
	SELECT DISTINCT SUBSTRING ([Code], PATINDEX(''%''+@AccountCode+''%'', [Code]) + @len, @HintLength) x
		FROM [dbo].[ib_Account]
		WHERE [Code] LIKE ''%''+@AccountCode+''%''
		ORDER BY x
END
');

GO
EXECUTE ('PRINT N''Creating [stage].[Europower_Add]''
');

GO
EXECUTE ('CREATE PROCEDURE [stage].[Europower_Add] 
			(
			@FileName           VARCHAR (512) = NULL,
			@membClgIdCod		VARCHAR(5) = NULL,
			@membExchIdCod		VARCHAR(5) = NULL,
			@currTypCod			VARCHAR(3) = NULL,
			@accTypGrp			VARCHAR(32) = NULL,
			@prodTypId			VARCHAR(4) = NULL,
			@prodId				VARCHAR(4) = NULL,
			@secuTrdUntNo		VARCHAR(12)=NULL,--decimal(8,4) = NULL,
			@ticSiz				VARCHAR(12)=NULL,--decimal(6,5) = NULL,
			@ticVal				VARCHAR(12)=NULL,--decimal(8,4) = NULL,
			@cntrClasCod		VARCHAR(1) = NULL,
			@cntrExpMthDat		INT = NULL,
			@cntrExpYrDat		INT = NULL,
			@cntrExerPrc		DECIMAL(19,6) = NULL,
			@cntrVersNo			INT = NULL,
			@lstSetlmtPrc		VARCHAR(12)=NULL,--decimal(8,5) = NULL,
			@currSetlmtPrc		VARCHAR(12)=NULL,--decimal(8,5) = NULL,
			@trnIdNo			VARCHAR(6) = NULL, -- INT
			@trnIDSfxNo			INT = NULL,
			@trnAdjStsCod		VARCHAR(1) = NULL,
			@trnHistAdjInd		VARCHAR(1) = NULL,
			@ordrTypCod			VARCHAR(1) = NULL,
			@ordrCmbTypCod		VARCHAR(1) = NULL,
			@buyCod				VARCHAR(1) = NULL,
			@opnClsCod			VARCHAR(1) = NULL,
			@trdTyp				VARCHAR(1) = NULL,
			@trnLngQty			INT = 0,
			@trnShtQty			INT = 0,
			@netQty				INT = NULL,
			@trdMtchPrc			VARCHAR(20)=NULL,--decimal(9,5) = NULL,
			@mkToMktTick		VARCHAR(20)=NULL,--decimal(7,2) = NULL,
			@prmVmarAmnt		VARCHAR(20)=NULL,--decimal(10,2) = NULL,
			@feeByUnt			VARCHAR(20)=NULL,--decimal(9,2) = NULL,
			@trnFeeAmnt			VARCHAR(20)=NULL,--decimal(7,2) = NULL,
			@partIDCod			VARCHAR(6) = NULL,
			@trnTyp				VARCHAR(3) = NULL,
			@trnIDSfxNoPnt		INT = NULL,
			@custText			VARCHAR(36) = NULL,
			@userOrdrNum		VARCHAR(12) = NULL,
			@text				VARCHAR(36) = NULL,
			@origExchId			VARCHAR(4) = NULL,
			@origTrnId			VARCHAR(9) = NULL, --INT
			@origTrnDat			DATETIME = NULL,
			@origOrdrNo			VARCHAR(12) = NULL,
			@origTrnTim			DATETIME = NULL,
			@origTrnDatCet		DATETIME = NULL,
			@origTrnTimCet		DATETIME = NULL,
			@membExchIdCodObo	VARCHAR(5) = NULL,
			@sumTrnLngQty		INT = NULL,
			@sumTrnShtQty		INT = NULL,
			@sumCntrPrmVmarAmnt VARCHAR(20)=NULL,--decimal(12,2) = NULL,
			@sumCntrTrnFeeAmnt	VARCHAR(20)=NULL,--decimal(8,2) = NULL,
			@sumProdPrmVmarAmnt VARCHAR(20)=NULL,--decimal(12,2) = NULL,
			@sumProdTrnFeeAmnt	VARCHAR(20)=NULL,--decimal(8,2) = NULL,
			@sumAcctPrmVmarAmnt VARCHAR(20)=NULL,--decimal(12,2) = NULL,
			@sumAccTrnFeeAmnt	VARCHAR(20)=NULL, --decimal(8,2) = NULL
			@exchNam			VARCHAR(5)=NULL,	
			@envText			VARCHAR(1)=NULL,	
			@rptCod				VARCHAR(5)=NULL,	
			@rptNam				VARCHAR(30)=NULL,	
			@rptFlexKey			VARCHAR(14)=NULL,	
			@membId				VARCHAR(5)=NULL,	
			@membLglNam			VARCHAR(40)=NULL,	
			@rptPrntEffDat		DATETIME=NULL,	
			@rptPrntEffTim		DATETIME=NULL,	
			@rptPrntRunDat		DATETIME=NULL	
			)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- Interfering with SELECT statements.
	SET NOCOUNT ON;

	DECLARE @origTrnDatTim		DATETIME
	DECLARE @origTrnDatTimCet	DATETIME	

	SET @origTrnDatTim = CONVERT(DATETIME,CONVERT(VARCHAR(12), CONVERT(DATETIME,@origTrnDat,112)) + '' '' + CONVERT(VARCHAR(8),RIGHT(@origTrnTim,8)))
	SET @origTrnDatTimCet = CONVERT(DATETIME,CONVERT(VARCHAR(12), CONVERT(DATETIME,@origTrnDatCet,112)) + '' '' + CONVERT(VARCHAR(8),RIGHT(@origTrnTimCet,8)))

INSERT INTO stage.Europower
		   (
			[membClgIdCod]
		   ,[membExchIdCod]
		   ,[currTypCod]
		   ,[accTypGrp]
		   ,[prodTypId]
		   ,[prodId]
		   ,[secuTrdUntNo]
		   ,[ticSiz]
		   ,[ticVal]
		   ,[cntrClasCod]
		   ,[cntrExpMthDat]
		   ,[cntrExpYrDat]
		   ,[cntrExerPrc]
		   ,[cntrVersNo]
		   ,[lstSetlmtPrc]
		   ,[currSetlmtPrc]
		   ,[trnIdNo]
		   ,[trnIDSfxNo]
		   ,[trnAdjStsCod]
		   ,[trnHistAdjInd]
		   ,[ordrTypCod]
		   ,[ordrCmbTypCod]
		   ,[buyCod]
		   ,[opnClsCod]
		   ,[trdTyp]
		   ,[trnLngQty]
		   ,[trnShtQty]
		   ,[netQty]
		   ,[trdMtchPrc]
		   ,[mkToMktTick]
		   ,[prmVmarAmnt]
		   ,[feeByUnt]
		   ,[trnFeeAmnt]
		   ,[partIDCod]
		   ,[trnTyp]
		   ,[trnIDSfxNoPnt]
		   ,[custText]
		   ,[userOrdrNum]
		   ,[text]
		   ,[origExchId]
		   ,[origTrnId]
		   ,[origTrnDat]
		   ,[origOrdrNo]
		   ,[origTrnTim]
		   ,[origTrnDatTim]	
		   ,[origTrnDatCet]
		   ,[origTrnTimCet]
		   ,[origTrnDatTimCet]	
		   ,[membExchIdCodObo]
		   ,[sumTrnLngQty]
		   ,[sumTrnShtQty]
		   ,[sumCntrPrmVmarAmnt]
		   ,[sumCntrTrnFeeAmnt]
		   ,[sumProdPrmVmarAmnt]
		   ,[sumProdTrnFeeAmnt]
		   ,[sumAcctPrmVmarAmnt]
		   ,[sumAccTrnFeeAmnt]
		   ,[envText]
		   ,[rptCod]
		   ,[rptNam]
		   ,[rptFlexKey]
		   ,[membId]
		   ,[membLglNam]
		   ,[rptPrntEffDat]
		   ,[rptPrntEffTim]
		   ,[rptPrntRunDat]
		   ,[exchNam]
		   ,[FileName]
			)
	 VALUES
		   (
			@membClgIdCod		,
			@membExchIdCod		,
			@currTypCod			,
			@accTypGrp			,
			@prodTypId			,
			@prodId				,
			@secuTrdUntNo		,
			@ticSiz				,
			@ticVal				,
			@cntrClasCod		,
			@cntrExpMthDat		,
			@cntrExpYrDat		,
			@cntrExerPrc		,
			@cntrVersNo			,
			@lstSetlmtPrc		,
			@currSetlmtPrc		,
			@trnIdNo			,
			@trnIDSfxNo			,
			@trnAdjStsCod		,
			@trnHistAdjInd		,
			@ordrTypCod			,
			@ordrCmbTypCod		,
			@buyCod				,
			@opnClsCod			,
			@trdTyp				,
			@trnLngQty			,
			@trnShtQty			,
			@netQty				,
			@trdMtchPrc			,
			@mkToMktTick		,
			@prmVmarAmnt		,
			@feeByUnt			,
			@trnFeeAmnt			,
			@partIDCod			,
			@trnTyp				,
			@trnIDSfxNoPnt		,
			@custText			,
			@userOrdrNum		,
			@text				,
			@origExchId			,
			@origTrnId			,
			@origTrnDat			,
			@origOrdrNo			,
			@origTrnTim			,
			@origTrnDatTim		,
			@origTrnDatCet		,
			@origTrnTimCet		,
			@origTrnDatTimCet	,
			@membExchIdCodObo	,
			@sumTrnLngQty		,
			@sumTrnShtQty		,
			@sumCntrPrmVmarAmnt ,
			@sumCntrTrnFeeAmnt	,
			@sumProdPrmVmarAmnt ,
			@sumProdTrnFeeAmnt	,
			@sumAcctPrmVmarAmnt ,
			@sumAccTrnFeeAmnt	,
			@envText			,
			@rptCod				,
			@rptNam				,
			@rptFlexKey			,
			@membId				,
			@membLglNam			,	
			@rptPrntEffDat		,
			@rptPrntEffTim		,
			@rptPrntRunDat		,
			@exchNam			,
			@FileName
			)
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[aspnet_SchemaVersions]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[aspnet_SchemaVersions]
(
[Feature] [nvarchar] (128) NOT NULL,
[CompatibleSchemaVersion] [nvarchar] (128) NOT NULL,
[IsCurrentVersion] [bit] NOT NULL
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK__aspnet_SchemaVer__5A254709] on [dbo].[aspnet_SchemaVersions]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[aspnet_SchemaVersions] ADD CONSTRAINT [PK__aspnet_SchemaVer__5A254709] PRIMARY KEY CLUSTERED  ([Feature], [CompatibleSchemaVersion])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[aspnet_CheckSchemaVersion]''
');

GO
SET QUOTED_IDENTIFIER OFF

GO
EXECUTE ('
CREATE PROCEDURE [dbo].[aspnet_CheckSchemaVersion]
    @Feature                   nvarchar(128),
    @CompatibleSchemaVersion   nvarchar(128)
AS
SET NOCOUNT ON
BEGIN
    IF (EXISTS( SELECT  *
                FROM    dbo.aspnet_SchemaVersions
                WHERE   Feature = LOWER( @Feature ) AND
                        CompatibleSchemaVersion = @CompatibleSchemaVersion ))
        RETURN 0

    RETURN 1
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TemplateGroup_GetTemplateIdById]''
');

GO
SET QUOTED_IDENTIFIER ON

GO
EXECUTE ('/*
<details>
	<summary>Returns templateId for a template group</summary>
	<created author="Laurentiu Macovei" Date="Wednesday, 30 august 2006, 11:50 PM GMT" />		
</details>
*/

CREATE PROCEDURE [dbo].[ib_TemplateGroup_GetTemplateIdById]
@TemplateGroupId int
AS
SET NOCOUNT ON

SELECT TemplateId 
	FROM ib_TemplateGroup 
	WHERE TemplateGroupId = @TemplateGroupId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_NostroAutoMatch_GetSites]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_NostroAutoMatch_GetSites]
AS
SET NOCOUNT ON
	SELECT 
		Code
		,SiteId
	FROM
		ib_Site
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_FirmDataSource_GetByFirmId]''
');

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Select records from the ib_FirmDataSource table through a foreign key
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[ib_FirmDataSource_GetByFirmId]
(

	@FirmId int   
)
AS


				SET ANSI_NULLS ON
				
				SELECT
					[FirmDataSourceId],
					[FirmId],
					[DataSourceId],
					[DataSourceFirmCode],
					[CreateDate],
					[CreateUsername],
					[UpdateDate],
					[UpdateUsername]
				FROM
					[dbo].[ib_FirmDataSource]
				WHERE
					[FirmId] = @FirmId
				
				SELECT @@ROWCOUNT
				SET ANSI_NULLS ON
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Adjustment_GenerateForUnmatchedTrades]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Adjustment_GenerateForUnmatchedTrades]
(
	@AsOfDate DATETIME
	, @TemplateId INT
)
AS
--	Description: create adjustment for unmatched trades
--	24 Jun 2014		ED		EIB 25769 - Created
--	08 Sep 2014		ED		EIB 25958 - change logic to insert for LME
--	11 Sep 2014		ED		EIB 25997 - change logic to get settlement price using r&n data and also put positive Quantity
--	19 Sep 2014		ED		EIB 26029 - filter also by template using templateCompare
--	30 Sep 2014		ED		EIB 26042 - fix value formula for Premium instruments

SET NOCOUNT ON
BEGIN TRY
	BEGIN TRAN
	
	DECLARE @PremiumInstrumentTypeId INT
	SET @PremiumInstrumentTypeId = (SELECT InstrumentTypeId FROM ib_InstrumentType WHERE Code = ''P'')

	DECLARE @TrxId INT
	DECLARE @TradeDate DATETIME
	DECLARE @DataSourceId INT
	DECLARE @FirmId INT
	DECLARE @MatchCodeId INT
	DECLARE @ExchangeId INT
	DECLARE @AccountId INT
	DECLARE @DetailAccountId INT
	DECLARE @CurrencyId INT
	DECLARE @InstrumentId INT
	DECLARE @ExpiryDay INT
	DECLARE @ExpiryMonth INT
	DECLARE @ExpiryYear INT
	DECLARE @OptionTypeCode VARCHAR(25)
	DECLARE @StrikePrice DECIMAL(24,10) 
	DECLARE @TradePrice DECIMAL(24,10) 
	DECLARE @TrxTypeCode       VARCHAR (25) 
	DECLARE @QuantityLong INT
	DECLARE @QuantityShort INT
	DECLARE @Quantity INT
	
	DECLARE @AdjustmentHeaderId INT
	DECLARE @InternalExternalCode VARCHAR(1)
	DECLARE adj_cursor CURSOR FOR
	SELECT 
			TrxId,
			ExchangeId,
			InstrumentId, 
			TrxDate, 
			-1*QuantityLong, 
			-1*QuantityShort,
			-1*Quantity,
			CurrencyId,
			ExpiryYear,
			ExpiryMonth,
			ExpiryDay,
			ISNULL(StrikePrice, 0),
			Price,
			OptionTypeCode,
			t.DataSourceId,
			t.FirmId,
			AccountId,
			DetailAccountId,
			TrxTypeCode
		FROM ib_Trx t (NOLOCK)
			-- get only rows where there is a template compare for current template and row datasource and firm
			INNER JOIN ib_TemplateCompare tc ON tc.DataSourceId = t.DataSourceId AND tc.FirmId = t.FirmId AND tc.TemplateId = @TemplateId
		WHERE t.AsOfDate = @AsOfDate AND IsUnmatched = 1 AND MatchingAdjustmentId IS NULL

	OPEN adj_cursor
	FETCH NEXT FROM adj_cursor
	INTO
				@TrxId,
				@ExchangeId,
				@InstrumentId, 
				@TradeDate, 
				@QuantityLong, 
				@QuantityShort,
				@Quantity,
				@CurrencyId,
				@ExpiryYear,
				@ExpiryMonth,
				@ExpiryDay,
				@StrikePrice,
				@TradePrice,
				@OptionTypeCode,
				@DataSourceId,
				@FirmId,
				@AccountId,
				@DetailAccountId,
				@TrxTypeCode

	WHILE @@FETCH_STATUS = 0
	BEGIN

		SET @MatchCodeId = dbo.GetMatchCodeIdForAdjustmentsInsert(
		(SELECT Code FROM ib_Account WHERE AccountId = @AccountId), 
		(SELECT Code FROM ib_Exchange WHERE ExchangeId = @ExchangeId), 
		(SELECT Code FROM ib_Firm WHERE FirmId = @FirmId), 
		@TemplateId)
		
		SET @InternalExternalCode = (SELECT InternalExternalCode FROM ib_TemplateCompare WHERE TemplateId = @TemplateId AND DataSourceId = @DataSourceId AND FirmId = @FirmId)
	
		
		DECLARE @AdjustmentId INT
		--today
		DECLARE @SettlementPrice DECIMAL(24,10)
		SET @SettlementPrice = [dbo].[GetSettlementPriceByAlternateKey](@AsOfDate, @DataSourceId, @ExchangeId, @InstrumentId, @CurrencyId, 
						@ExpiryYear, @ExpiryMonth, @ExpiryDay, @StrikePrice, @OptionTypeCode)
		DECLARE @Tick DECIMAL(24, 10), @Value DECIMAL(24,10), @InstrumentTypeId INT
		SET @Tick = NULL
		SET @InstrumentTypeId = NULL
		SELECT @Tick = ISNULL(TickSize, 1), @InstrumentTypeId = InstrumentTypeId FROM ib_Instrument i WHERE i.InstrumentId = @InstrumentId
		IF (@Tick = 0 OR @Tick IS NULL) SET @Tick = 1
		
		IF @TrxTypeCode IN (''002'', ''004'', ''006'', ''013'', ''012'')
			BEGIN
				SET @Quantity = @Quantity * -1
			END

		IF (@InstrumentTypeId = @PremiumInstrumentTypeId)
			SET @Value = -1 * @TradePrice * @Tick * @Quantity
		ELSE
			SET @Value = (@SettlementPrice - @TradePrice) * @Tick * @Quantity
		
		DECLARE @IsBuy BIT = CASE WHEN @QuantityLong != 0 THEN 1 ELSE 0 END

		EXEC ib_Adjustment_Load ''UM'', @TemplateId, @ExchangeId, @InstrumentId, @InternalExternalCode, @TradeDate, @AsOfDate, @Quantity, @QuantityLong, @QuantityShort
				, @CurrencyId, @ExpiryYear, @ExpiryMonth, @ExpiryDay, @StrikePrice, @TradePrice, @SettlementPrice, @OptionTypeCode, @Value/*@Value*/, @IsBuy, @MatchCodeId
				, @DataSourceId, @FirmId, @AccountId, @DetailAccountId, @TrxTypeCode, @AdjustmentId OUTPUT
		
		UPDATE ib_Trx SET MatchingAdjustmentId = @AdjustmentId WHERE TrxId = @TrxId
	
	FETCH NEXT FROM adj_cursor
			INTO 
				@TrxId,
				@ExchangeId,
				@InstrumentId, 
				@TradeDate, 
				@QuantityLong, 
				@QuantityShort,
				@Quantity,
				@CurrencyId,
				@ExpiryYear,
				@ExpiryMonth,
				@ExpiryDay,
				@StrikePrice,
				@TradePrice,
				@OptionTypeCode,
				@DataSourceId,
				@FirmId,
				@AccountId,
				@DetailAccountId,
				@TrxTypeCode
					
		END
			
		CLOSE adj_cursor
		DEALLOCATE adj_cursor

COMMIT TRAN
END TRY
BEGIN CATCH
	ROLLBACK TRAN
	EXEC [dbo].[sp_RethrowError]
END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Account_GetAccountFirms]''
');

GO
EXECUTE ('




/*
<details>
 <summary> Returns the firms for using it in accounts dropdownlist /summary>
 <created author="Emilian Damian" Date="Friday, 9 February 2007 9:00 AM" /> 
 <tasks>
 </tasks>
</details>
*/
CREATE PROCEDURE [dbo].[ib_Account_GetAccountFirms]
AS
SET NOCOUNT ON

	SELECT f.[Code] as FirmAccountCode, f.[FirmId] as FirmAccountId
		FROM [dbo].[ib_Firm] f
	WHERE f.[FirmId] IN (SELECT [FirmId] from [ib_Account])
		ORDER BY f.[Code]
');

GO
EXECUTE ('PRINT N''Creating [stage].[Europower_LoadStateChange]''
');

GO
EXECUTE ('CREATE PROCEDURE [stage].[Europower_LoadStateChange] 
(
	@OldLoadState	TINYINT,
	@NewLoadState	TINYINT,
	@FileName       VARCHAR (512)= NULL
)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	UPDATE stage.Europower SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState AND [FileName] = Coalesce(@FileName, [FileName])

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[aspnet_Membership_ChangePasswordQuestionAndAnswer]''
');

GO
SET QUOTED_IDENTIFIER OFF

GO
EXECUTE ('CREATE PROCEDURE [dbo].[aspnet_Membership_ChangePasswordQuestionAndAnswer]
    @ApplicationName       nvarchar(256),
    @UserName              nvarchar(256),
    @NewPasswordQuestion   nvarchar(256),
    @NewPasswordAnswer     nvarchar(128)
AS
SET NOCOUNT ON
BEGIN
    DECLARE @UserId uniqueidentifier
    SELECT  @UserId = NULL
    SELECT  @UserId = u.UserId
    FROM    dbo.aspnet_Membership m, dbo.aspnet_Users u, dbo.aspnet_Applications a
    WHERE   LoweredUserName = LOWER(@UserName) AND
            u.ApplicationId = a.ApplicationId  AND
            LOWER(@ApplicationName) = a.LoweredApplicationName AND
            u.UserId = m.UserId
    IF (@UserId IS NULL)
    BEGIN
        RETURN(1)
    END

    UPDATE dbo.aspnet_Membership
    SET    PasswordQuestion = @NewPasswordQuestion, PasswordAnswer = @NewPasswordAnswer
    WHERE  UserId=@UserId
    RETURN(0)
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_NostroAutoMatch_GetSiteTemplates]''
');

GO
SET QUOTED_IDENTIFIER ON

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_NostroAutoMatch_GetSiteTemplates]
	@siteId int
AS
SET NOCOUNT ON
	SELECT
		T.TemplateId
		,T.TypeCode
		,T.Description 
	FROM
		ib_Template T
	INNER JOIN	
		ib_SiteTemplate ST ON T.TemplateId = ST.TemplateId AND ST.SiteId = @siteId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_FirmDataSource_GetByDataSourceId]''
');

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Select records from the ib_FirmDataSource table through a foreign key
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[ib_FirmDataSource_GetByDataSourceId]
(

	@DataSourceId int   
)
AS


				SET ANSI_NULLS ON
				
				SELECT
					[FirmDataSourceId],
					[FirmId],
					[DataSourceId],
					[DataSourceFirmCode],
					[CreateDate],
					[CreateUsername],
					[UpdateDate],
					[UpdateUsername]
				FROM
					[dbo].[ib_FirmDataSource]
				WHERE
					[DataSourceId] = @DataSourceId
				
				SELECT @@ROWCOUNT
				SET ANSI_NULLS ON
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Firm_GetCodeAndIdForAllFirms]''
');

GO
EXECUTE ('   /*
<details>
 <summary>Returns code and id columns for all the Firms</summary>
 <created author="laurentiu.macovei" date="Tue, 26 Sep 2006 12:23:01 GMT"/>
</details>
*/
CREATE PROCEDURE [dbo].[ib_Firm_GetCodeAndIdForAllFirms]
AS
SET NOCOUNT ON
SELECT Code, FirmId 
	FROM ib_Firm
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Account_GetAccountIdByCode]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Account_GetAccountIdByCode]
@AccountCode varchar(100)
AS
SET NOCOUNT ON
--Description:Returns the account id for a specific name+account code+firm code</summary>
--created author="Emilian Damian" Date="13 May 2010" 
	
	SELECT AccountId 
	FROM ib_Account 
	WHERE Code = @AccountCode
');

GO
EXECUTE ('PRINT N''Creating [stage].[Europower_Purge]''
');

GO
EXECUTE ('-- =============================================
CREATE PROCEDURE [stage].[Europower_Purge]
	(
	@LoadState		TINYINT = 0,
	@FileName       VARCHAR (512)= NULL
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
	DELETE FROM [stage].[Europower] WHERE LoadState= @LoadState AND [FileName] = Coalesce(@FileName, [FileName])
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[aspnet_Membership_FindUsersByEmail]''
');

GO
SET QUOTED_IDENTIFIER OFF

GO
EXECUTE ('CREATE PROCEDURE [dbo].[aspnet_Membership_FindUsersByEmail]
    @ApplicationName       nvarchar(256),
    @EmailToMatch          nvarchar(256),
    @PageIndex             int,
    @PageSize              int
AS
SET NOCOUNT ON
BEGIN
    DECLARE @ApplicationId uniqueidentifier
    SELECT  @ApplicationId = NULL
    SELECT  @ApplicationId = ApplicationId FROM dbo.aspnet_Applications WHERE LOWER(@ApplicationName) = LoweredApplicationName
    IF (@ApplicationId IS NULL)
        RETURN 0

    -- Set the page bounds
    DECLARE @PageLowerBound int
    DECLARE @PageUpperBound int
    DECLARE @TotalRecords   int
    SET @PageLowerBound = @PageSize * @PageIndex
    SET @PageUpperBound = @PageSize - 1 + @PageLowerBound

    -- Create a temp table TO store the select results
    CREATE TABLE #PageIndexForUsers
    (
        IndexId int IDENTITY (0, 1) NOT NULL,
        UserId uniqueidentifier
    )

    -- Insert into our temp table
    IF( @EmailToMatch IS NULL )
        INSERT INTO #PageIndexForUsers (UserId)
            SELECT u.UserId
            FROM   dbo.aspnet_Users u, dbo.aspnet_Membership m
            WHERE  u.ApplicationId = @ApplicationId AND m.UserId = u.UserId AND m.Email IS NULL
            ORDER BY m.LoweredEmail
    ELSE
        INSERT INTO #PageIndexForUsers (UserId)
            SELECT u.UserId
            FROM   dbo.aspnet_Users u, dbo.aspnet_Membership m
            WHERE  u.ApplicationId = @ApplicationId AND m.UserId = u.UserId AND m.LoweredEmail LIKE LOWER(@EmailToMatch)
            ORDER BY m.LoweredEmail

    SELECT  u.UserName, m.Email, m.PasswordQuestion, m.Comment, m.IsApproved,
            m.CreateDate,
            m.LastLoginDate,
            u.LastActivityDate,
            m.LastPasswordChangedDate,
            u.UserId, m.IsLockedOut,
            m.LastLockoutDate
    FROM   dbo.aspnet_Membership m, dbo.aspnet_Users u, #PageIndexForUsers p
    WHERE  u.UserId = p.UserId AND u.UserId = m.UserId AND
           p.IndexId >= @PageLowerBound AND p.IndexId <= @PageUpperBound
    ORDER BY m.LoweredEmail

    SELECT  @TotalRecords = COUNT(*)
    FROM    #PageIndexForUsers
    RETURN @TotalRecords
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TemplateTypeClass_GetCodeAndIdForAllTemplateTypeClasses]''
');

GO
SET QUOTED_IDENTIFIER ON

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_TemplateTypeClass_GetCodeAndIdForAllTemplateTypeClasses]
	AS
SET NOCOUNT ON
	
/*
<details>
	<summary>Returns all Template Type Classes</summary>
	<created author="Alister McLeod" Date="Monday, 29 March 2010, 14:45" />		
</details>
*/

	SELECT [Code] AS [TemplateTypeClassCode], [TemplateTypeClassId]
	FROM ib_TemplateTypeClass
	WHERE IsActive = 1
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_NostroAutoMatch_GetSWIFT]''
');

GO
EXECUTE ('/*
	Created By: Kirill Shilin
	Create On: 03.10.2011
	Issue: MBAL-18277 Code Routine to Verify Go Ahead for Scheduled Auto-Match (sub-task)
	Purpose: Returns Swift Files list for checking within automatch start requirements verification procedure
	
	Updated By: Kirill Shilin
	Update On: 04.10.2011
	Issue: MBAL-18277 Code Routine to Verify Go Ahead for Scheduled Auto-Match (sub-task)
	Changes: renamed, code review, bug with test date, single record returned

*/

CREATE PROCEDURE [dbo].[ib_NostroAutoMatch_GetSWIFT]
	@targetDate DATETIME = NULL
AS
SET NOCOUNT ON
	SELECT @targetDate = COALESCE(@targetDate, GETDATE())
	DECLARE @recordCount INT
	
		SELECT TOP 1 SwiftStatementId, CreateDate
		FROM	
			ib_SwiftStatement
		WHERE 
			DATEPART(YEAR, CreateDate) = DATEPART(YEAR,@targetDate)
			AND
			DATEPART(MONTH, CreateDate) = DATEPART(MONTH,@targetDate)
			AND
			DATEPART(DAY, CreateDate) = DATEPART(DAY,@targetDate)
		ORDER BY
			CreateDate DESC
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_FirmDataSource_GetByDataSourceIdDataSourceFirmCode]''
');

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Select records from the ib_FirmDataSource table through an index
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[ib_FirmDataSource_GetByDataSourceIdDataSourceFirmCode]
(

	@DataSourceId int   ,

	@DataSourceFirmCode varchar (100)  
)
AS


				SELECT
					[FirmDataSourceId],
					[FirmId],
					[DataSourceId],
					[DataSourceFirmCode],
					[CreateDate],
					[CreateUsername],
					[UpdateDate],
					[UpdateUsername]
				FROM
					[dbo].[ib_FirmDataSource]
				WHERE
					[DataSourceId] = @DataSourceId
					AND [DataSourceFirmCode] = @DataSourceFirmCode
				SELECT @@ROWCOUNT
					
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Firm_GetFirmById]''
');

GO
EXECUTE (' /*
<details>
 <summary> Selectes a firm from the ib_Firm table by its id</summary>
 <created author="Laurentiu Macovei" Date="Tuesday, 12 September 2006 9:33PM GMT" /> 
</details>
*/
CREATE PROCEDURE [dbo].[ib_Firm_GetFirmById]
(
	@FirmId int
)
AS 
SET NOCOUNT ON


SELECT [FirmId]
      ,[Code]
      ,[Name]
      ,[IsApproved]
      ,[CreateDate]
      ,[CreateUsername]
      ,[UpdateDate]
      ,[UpdateUsername]
  FROM [dbo].[ib_Firm]
  WHERE FirmId = @FirmId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Account_GetAccountIdByName]''
');

GO
EXECUTE ('



/*
<details>
	<summary>Returns the account id for a specific name+account code+firm code</summary>
	<created author="Emilian Damian" Date="7 Feb 2007" /> 	
</details>
*/
CREATE PROCEDURE [dbo].[ib_Account_GetAccountIdByName]
@AccountName varchar(100)
AS
SET NOCOUNT ON
/*
SELECT AccountId 
	FROM ib_Account 
	WHERE Name = @AccountName
*/
DECLARE @Name nvarchar(1000)
DECLARE @Code nvarchar(1000)
DECLARE @FirmCode nvarchar(1000)
DECLARE @TEMP nvarchar(1000)

if CHARINDEX(''['',@AccountName)>0
BEGIN
SET @Name = SUBSTRING(@AccountName,0, CHARINDEX(''['',@AccountName)-1)
SET @TEMP = SUBSTRING(@AccountName,CHARINDEX(''['',@AccountName)+2, 
			LEN(@AccountName)-CHARINDEX(''['',@AccountName)-1)

SET @Code = SUBSTRING(@TEMP,0, CHARINDEX(''~'',@TEMP)-1)
SET @FirmCode = SUBSTRING(@TEMP,CHARINDEX(''~'',@TEMP)+2, 
			LEN(@TEMP)-CHARINDEX(''~'',@TEMP)-2)

SELECT AccountId 
	FROM ib_Account a
LEFT JOIN [dbo].[ib_Firm] f on a.[FirmId] = f.[FirmId]
	WHERE 	ltrim(rtrim(a.[Name])) = @Name
	AND		ltrim(rtrim(f.[Code])) = @FirmCode
	AND		ltrim(rtrim(a.[Code])) = @Code
--print @Name
--print @Code
--print @FirmCode 
--print @Temp
END
ELSE
	SELECT AccountId 
	FROM ib_Account 
	WHERE Name = @AccountName
');

GO
EXECUTE ('PRINT N''Creating [stage].[LmePosition_LoadStateChange]''
');

GO
EXECUTE ('CREATE PROCEDURE [stage].[LmePosition_LoadStateChange]
	(
		@OldLoadState	TINYINT,
		@NewLoadState	TINYINT,
		@FileName       VARCHAR (512)= NULL
	)
AS

-- Description: Changes the LoadState of the stage.LmePosition type table

-- 23 Jun 2014	ED	EIB 25760 - Creation

BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	UPDATE stage.LmePosition SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState AND [FileName] = Coalesce(@FileName, [FileName])

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[aspnet_Membership_FindUsersByName]''
');

GO
SET QUOTED_IDENTIFIER OFF

GO
EXECUTE ('CREATE PROCEDURE [dbo].[aspnet_Membership_FindUsersByName]
    @ApplicationName       nvarchar(256),
    @UserNameToMatch       nvarchar(256),
    @PageIndex             int,
    @PageSize              int
AS
SET NOCOUNT ON
BEGIN
    DECLARE @ApplicationId uniqueidentifier
    SELECT  @ApplicationId = NULL
    SELECT  @ApplicationId = ApplicationId FROM dbo.aspnet_Applications WHERE LOWER(@ApplicationName) = LoweredApplicationName
    IF (@ApplicationId IS NULL)
        RETURN 0

    -- Set the page bounds
    DECLARE @PageLowerBound int
    DECLARE @PageUpperBound int
    DECLARE @TotalRecords   int
    SET @PageLowerBound = @PageSize * @PageIndex
    SET @PageUpperBound = @PageSize - 1 + @PageLowerBound

    -- Create a temp table TO store the select results
    CREATE TABLE #PageIndexForUsers
    (
        IndexId int IDENTITY (0, 1) NOT NULL,
        UserId uniqueidentifier
    )

    -- Insert into our temp table
    INSERT INTO #PageIndexForUsers (UserId)
        SELECT u.UserId
        FROM   dbo.aspnet_Users u, dbo.aspnet_Membership m
        WHERE  u.ApplicationId = @ApplicationId AND m.UserId = u.UserId AND u.LoweredUserName LIKE LOWER(@UserNameToMatch)
        ORDER BY u.UserName


    SELECT  u.UserName, m.Email, m.PasswordQuestion, m.Comment, m.IsApproved,
            m.CreateDate,
            m.LastLoginDate,
            u.LastActivityDate,
            m.LastPasswordChangedDate,
            u.UserId, m.IsLockedOut,
            m.LastLockoutDate
    FROM   dbo.aspnet_Membership m, dbo.aspnet_Users u, #PageIndexForUsers p
    WHERE  u.UserId = p.UserId AND u.UserId = m.UserId AND
           p.IndexId >= @PageLowerBound AND p.IndexId <= @PageUpperBound
    ORDER BY u.UserName

    SELECT  @TotalRecords = COUNT(*)
    FROM    #PageIndexForUsers
    RETURN @TotalRecords
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TradeReconciliation_BuildReportPhase2a]''
');

GO
SET QUOTED_IDENTIFIER ON

GO
EXECUTE ('
CREATE PROCEDURE [dbo].[ib_TradeReconciliation_BuildReportPhase2a]
	@ReportId INT,
	@TradeReconciliationId INT
AS

--	Description: Starting with the data populated in the ib_TradeReconciliationDetail
--	pre-populated with MatchCodes, perform an automated matching process
--	OF the TRADE TRANSFERS.  Find negative amounts on external side and match off against
--	positive amounts in same column (long/short) on same side (E) for trxtype''s
--	that have IsCancellation flag set.

--	29 Oct 2009		amk		Creation
--  04 Mar 2010		KevinP	Added Check against Datasource to see if we need to include the Detail AccountId in the matching.
--	09 APr 2010		amk		MBAL-15181: bug fix, when joining trxtype take data source into consideration too
--  23 Apr 2010		AAJM	MBAL-15416 Increase size of Price/TradePrice fields
--	13 Jun 2012		ED		MBAL 20980 - add nolock for trx/position select	
--	30 Jun 2014		ED		EIB 25759 - fix compare for DetailAccountId when NULL
SET NOCOUNT ON

--Update the report status
UPDATE [dbo].[ib_Report]
	SET [Stage] = ''Phase 2a: Performing Matching of Cancellations''
	WHERE ReportId = @ReportId

DECLARE @MatchingTradeReconciliationDetailId INT

CREATE TABLE #SelectFrom
(
TradeReconciliationDetailId INT
, ExchangeId INT
, MatchCode VARCHAR(100)
, CurrencyId INT
, InstrumentId INT
, DetailAccountId INT
, ExpiryYear SMALLINT
, ExpiryMonth SMALLINT
, ExpiryDay SMALLINT
, OptionTypeCode VARCHAR(25)
, StrikePrice DECIMAL(19,4)
, TradePrice DECIMAL(24,10)
, InternalLong INT
, InternalShort INT
, ExternalLong INT
, ExternalShort INT
)

CREATE UNIQUE NONCLUSTERED INDEX [IX_SelectFrom_TradeReconciliationDetailId] ON #SelectFrom
(
TradeReconciliationDetailId ASC
) WITH (PAD_INDEX  = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, IGNORE_DUP_KEY = OFF, ONLINE = OFF) ON [PRIMARY]
	
CREATE NONCLUSTERED INDEX [IX_SelectFrom_Selecting] ON #SelectFrom
(
 ExchangeId 
, MatchCode 
, CurrencyId 
, InstrumentId 
, DetailAccountId
, ExpiryYear 
, ExpiryMonth
, ExpiryDay 
, OptionTypeCode 
, StrikePrice 
, TradePrice
, InternalLong
, InternalShort
, ExternalLong 
, ExternalShort 
) WITH (PAD_INDEX  = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, IGNORE_DUP_KEY = OFF, ONLINE = OFF) ON [PRIMARY]
	
INSERT INTO #SelectFrom
SELECT trd.[TradeReconciliationDetailId]
, trd.[ExchangeId]
, trd.[MatchCode]
, trd.[CurrencyId]
, trd.[InstrumentId]
, trd.[DetailAccountId]
, trd.[ExpiryYear]
, trd.[ExpiryMonth]
, trd.[ExpiryDay]
, trd.[OptionTypeCode]
, trd.[StrikePrice]
, trd.[TradePrice]
, trd.[InternalLong]
, trd.[InternalShort]
, trd.[ExternalLong]
, trd.[ExternalShort]
FROM [dbo].[ib_TradeReconciliationDetail] trd
	JOIN ib_Trx t (NOLOCK) ON t.TrxId = trd.TrxId
	JOIN ib_TrxType tt ON tt.Code = t.TrxTypeCode AND tt.DataSourceId = t.DataSourceId
WHERE trd.TradeReconciliationId = @TradeReconciliationId
	AND (trd.IsMatched IS NULL OR trd.IsMatched = 0)
	AND tt.IsTrade = 1
	AND trd.InternalExternalCode = ''E''

DECLARE @TradeReconciliationDetailId INT
, @ExchangeId INT
, @MatchCode VARCHAR(100)
, @CurrencyId INT
, @InstrumentId INT
, @DetailAccountId INT
, @ExpiryYear SMALLINT
, @ExpiryMonth SMALLINT
, @ExpiryDay SMALLINT
, @OptionTypeCode VARCHAR(25)
, @StrikePrice DECIMAL(19,4)
, @TradePrice DECIMAL(24,10)
, @InternalLong INT
, @InternalShort INT
, @ExternalLong INT
, @ExternalShort INT
, @IsMatched BIT
, @IncludeDetailAccountIdInMatch BIT -- KevinP [01 Mar 2010] - MBAL-12862

DECLARE detail_cursor CURSOR LOCAL FORWARD_ONLY 
FOR
SELECT [TradeReconciliationDetailId]
, trd.[ExchangeId]
, trd.[MatchCode]
, trd.[CurrencyId]
, trd.[InstrumentId]
, trd.[DetailAccountId]
, trd.[ExpiryYear]
, trd.[ExpiryMonth]
, trd.[ExpiryDay]
, trd.[OptionTypeCode]
, trd.[StrikePrice]
, trd.[TradePrice]
, trd.[InternalLong]
, trd.[InternalShort]
, trd.[ExternalLong]
, trd.[ExternalShort]
, trd.[IsMatched]
, source.[IncludeDetailAccountInTradeReconciliation]
--, [ClassId] ?
FROM [dbo].[ib_TradeReconciliationDetail] trd
	JOIN ib_Trx t (NOLOCK) ON t.TrxId = trd.TrxId
	JOIN ib_TrxType tt ON tt.Code = t.TrxTypeCode AND tt.DataSourceId = t.DataSourceId
	INNER JOIN [dbo].[ib_DataSource] source ON t.DataSourceId = source.DataSourceId
WHERE [TradeReconciliationId] = @TradeReconciliationId
	AND (IsMatched IS NULL OR IsMatched = 0)
	AND tt.IsCancellation = 1
	AND trd.InternalExternalCode = ''E''
	AND (trd.ExternalLong < 0 OR trd.ExternalShort < 0)
FOR UPDATE OF IsMatched, MatchingTradeReconciliationDetailId

OPEN detail_cursor

FETCH NEXT FROM detail_cursor
INTO
	@TradeReconciliationDetailId 
	, @ExchangeId 
	, @MatchCode 
	, @CurrencyId 
	, @InstrumentId 
	, @DetailAccountId
	, @ExpiryYear 
	, @ExpiryMonth 
	, @ExpiryDay
	, @OptionTypeCode
	, @StrikePrice
	, @TradePrice 
	, @InternalLong 
	, @InternalShort 
	, @ExternalLong
	, @ExternalShort
	, @IsMatched
	, @IncludeDetailAccountIdInMatch

WHILE @@FETCH_STATUS = 0
BEGIN

	SET @MatchingTradeReconciliationDetailId = NULL
	
	IF (@IsMatched IS NULL OR @IsMatched = 0)
	BEGIN

	-- Take away this Detail from the select options
	DELETE FROM #SelectFrom WHERE TradeReconciliationDetailId = @TradeReconciliationDetailId
	
	-- Now check for normal trade
		
		IF (@MatchingTradeReconciliationDetailId IS NULL)
			BEGIN
			
				--KevinP - Adding ability to turn matching at detail accountId driven by table...
				IF (@IncludeDetailAccountIdInMatch = 1)
				BEGIN
					SET @MatchingTradeReconciliationDetailId = (SELECT TOP (1) TradeReconciliationDetailId
					FROM #SelectFrom
					WHERE ExchangeId = @ExchangeId
					AND CurrencyId = @CurrencyId
					AND InstrumentId = @InstrumentId
					AND (DetailAccountId = @DetailAccountId OR (DetailAccountId IS NULL AND @DetailAccountId IS NULL))
					AND ExpiryYear = @ExpiryYear
					AND ExpiryMonth = @ExpiryMonth
					AND ExpiryDay = @ExpiryDay
					AND (OptionTypeCode = @OptionTypeCode OR (OptionTypeCode IS NULL AND @OptionTypeCode IS NULL))
					AND (StrikePrice = @StrikePrice OR (StrikePrice IS NULL AND @StrikePrice IS NULL))
					AND (TradePrice = @TradePrice OR (TradePrice IS NULL AND @TradePrice IS NULL))
					AND ((ExternalLong = @ExternalLong * -1)
						OR (ExternalShort = @ExternalShort * -1))
					AND MatchCode = @MatchCode)
				END
				ELSE
				BEGIN
					SET @MatchingTradeReconciliationDetailId = (SELECT TOP (1) TradeReconciliationDetailId
					FROM #SelectFrom
					WHERE ExchangeId = @ExchangeId
					AND CurrencyId = @CurrencyId
					AND InstrumentId = @InstrumentId
					-- Removed below line as this is the only difference from the statement above...
					--AND DetailAccountId = @DetailAccountId
					AND ExpiryYear = @ExpiryYear
					AND ExpiryMonth = @ExpiryMonth
					AND ExpiryDay = @ExpiryDay
					AND (OptionTypeCode = @OptionTypeCode OR (OptionTypeCode IS NULL AND @OptionTypeCode IS NULL))
					AND (StrikePrice = @StrikePrice OR (StrikePrice IS NULL AND @StrikePrice IS NULL))
					AND (TradePrice = @TradePrice OR (TradePrice IS NULL AND @TradePrice IS NULL))
					AND ((ExternalLong = @ExternalLong * -1)
						OR (ExternalShort = @ExternalShort * -1))
					AND MatchCode = @MatchCode)
				END
			END
	
		IF (@MatchingTradeReconciliationDetailId IS NOT NULL)
		BEGIN
		
			UPDATE [dbo].[ib_TradeReconciliationDetail]
			SET IsMatched = 1, MatchingTradeReconciliationDetailId = @TradeReconciliationDetailId
			WHERE TradeReconciliationDetailId = @MatchingTradeReconciliationDetailId
			
			UPDATE [dbo].[ib_TradeReconciliationDetail]
			SET IsMatched = 1, MatchingTradeReconciliationDetailId = @MatchingTradeReconciliationDetailId
			WHERE TradeReconciliationDetailId = @TradeReconciliationDetailId
			
			DELETE FROM #SelectFrom WHERE TradeReconciliationDetailId = @MatchingTradeReconciliationDetailId
		END
				
	END

	FETCH NEXT FROM detail_cursor
	INTO
		@TradeReconciliationDetailId 
		, @ExchangeId 
		, @MatchCode 
		, @CurrencyId 
		, @InstrumentId 
		, @DetailAccountId
		, @ExpiryYear 
		, @ExpiryMonth 
		, @ExpiryDay
		, @OptionTypeCode
		, @StrikePrice
		, @TradePrice 
		, @InternalLong 
		, @InternalShort 
		, @ExternalLong
		, @ExternalShort
		, @IsMatched
		, @IncludeDetailAccountIdInMatch

END

CLOSE detail_cursor
DEALLOCATE detail_cursor

DROP TABLE #SelectFrom

--update the report status
UPDATE [dbo].[ib_Report]
	SET [Stage] = ''Phase 2a: Completed''
	WHERE ReportId = @ReportId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_FirmDataSource_GetByFirmDataSourceId]''
');

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Select records from the ib_FirmDataSource table through an index
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[ib_FirmDataSource_GetByFirmDataSourceId]
(

	@FirmDataSourceId int   
)
AS


				SELECT
					[FirmDataSourceId],
					[FirmId],
					[DataSourceId],
					[DataSourceFirmCode],
					[CreateDate],
					[CreateUsername],
					[UpdateDate],
					[UpdateUsername]
				FROM
					[dbo].[ib_FirmDataSource]
				WHERE
					[FirmDataSourceId] = @FirmDataSourceId
				SELECT @@ROWCOUNT
					
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Account_GetAccountNamesHintByKeyword]''
');

GO
EXECUTE ('

/*
<details>
 <summary> Returns the Accounts hint for a specific code /summary>
 <created author="Emilian Damian" Date="7 Feb 2007" />  
 <tasks>
 </tasks>
</details>
*/
CREATE PROCEDURE [dbo].[ib_Account_GetAccountNamesHintByKeyword]
@AccountName varchar(100),
@HintByStartOnly bit = 0,
@HintLength int = 1
AS
SET NOCOUNT ON

DECLARE @len int
SET @len = LEN(@AccountName)
IF @HintByStartOnly = 1
BEGIN
	SELECT DISTINCT SUBSTRING ([Name], @len, @HintLength) x
		FROM [dbo].[ib_Account]
		WHERE [Name] LIKE @AccountName+''%''
		ORDER BY x DESC

END
ELSE
BEGIN
	SELECT DISTINCT SUBSTRING ([Name], PATINDEX(''%''+@AccountName+''%'', [Name]) + @len, @HintLength) x
		FROM [dbo].[ib_Account]
		WHERE [Name] LIKE ''%''+@AccountName+''%''
		ORDER BY x DESC
END
');

GO
EXECUTE ('PRINT N''Creating [stage].[LmePosition_Purge]''
');

GO
EXECUTE ('CREATE PROCEDURE [stage].[LmePosition_Purge]
	(
		@LoadState		TINYINT = 0,
		@FileName       VARCHAR (512)= NULL
	)
AS
-- Description: Deletes from stage.LmePosition table all the records where the LoadState is 0

-- 23 Jun 2014	ED	EIB 25760 - Creation

-- History:

BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
	DELETE FROM stage.LmePosition WHERE LoadState= @LoadState AND [FileName] = Coalesce(@FileName, [FileName])

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[aspnet_Membership_GetAllUsers]''
');

GO
SET QUOTED_IDENTIFIER OFF

GO
EXECUTE ('CREATE PROCEDURE [dbo].[aspnet_Membership_GetAllUsers]
    @ApplicationName       nvarchar(256),
    @PageIndex             int,
    @PageSize              int
AS
SET NOCOUNT ON
BEGIN
    DECLARE @ApplicationId uniqueidentifier
    SELECT  @ApplicationId = NULL
    SELECT  @ApplicationId = ApplicationId FROM dbo.aspnet_Applications WHERE LOWER(@ApplicationName) = LoweredApplicationName
    IF (@ApplicationId IS NULL)
        RETURN 0


    -- Set the page bounds
    DECLARE @PageLowerBound int
    DECLARE @PageUpperBound int
    DECLARE @TotalRecords   int
    SET @PageLowerBound = @PageSize * @PageIndex
    SET @PageUpperBound = @PageSize - 1 + @PageLowerBound

    -- Create a temp table TO store the select results
    CREATE TABLE #PageIndexForUsers
    (
        IndexId int IDENTITY (0, 1) NOT NULL,
        UserId uniqueidentifier
    )

    -- Insert into our temp table
    INSERT INTO #PageIndexForUsers (UserId)
    SELECT u.UserId
    FROM   dbo.aspnet_Membership m, dbo.aspnet_Users u
    WHERE  u.ApplicationId = @ApplicationId AND u.UserId = m.UserId
    ORDER BY u.UserName

    SELECT @TotalRecords = @@ROWCOUNT

    SELECT u.UserName, m.Email, m.PasswordQuestion, m.Comment, m.IsApproved,
            m.CreateDate,
            m.LastLoginDate,
            u.LastActivityDate,
            m.LastPasswordChangedDate,
            u.UserId, m.IsLockedOut,
            m.LastLockoutDate
    FROM   dbo.aspnet_Membership m, dbo.aspnet_Users u, #PageIndexForUsers p
    WHERE  u.UserId = p.UserId AND u.UserId = m.UserId AND
           p.IndexId >= @PageLowerBound AND p.IndexId <= @PageUpperBound
    ORDER BY u.UserName
    RETURN @TotalRecords
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TradeReconciliation_BuildReportPhase3]''
');

GO
SET QUOTED_IDENTIFIER ON

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_TradeReconciliation_BuildReportPhase3]
	@ReportId INT,
	@TradeReconciliationId INT
AS

--	Description: Starting with the data populated in the ib_TradeReconciliationDetail
--	pre-populated with MatchCodes, perform an automated matching process.

--	06 Aug 2009		AAJM	Creation
--  28 Aug 2009		AAJM	Add DetailAccountId to matching criteria
--  07 Oct 2009		AAJM	Remove commented old Trade Separation matching code
--  04 Mar 2010		KevinP	Added Check against Datasource to see if we need to include the Detail AccountId in the matching.
--  23 Apr 2010		AAJM	MBAL-15416 Increase size of Price/TradePrice fields
--	13 Jun 2012		ED		MBAL 20980 - add nolock for trx/position select	
--	30 Jun 2014		ED		EIB 25759 - fix compare for DetailAccountId when NULL
--  02 Sep 2014     RD		EIB 25949 - HVH matching should be done between internal HVH trades. Update the summary to remove any HVH differences.
--  16 Jan 2015		ED		EIB 26413 - improve performance

SET NOCOUNT ON

--Update the report status
UPDATE [dbo].[ib_Report]
	SET [Stage] = ''Phase 3: Performing Matching''
	WHERE ReportId = @ReportId

DECLARE @MatchingTradeReconciliationDetailId INT
DECLARE @LmeExchangeId INT
SET @LmeExchangeId = (SELECT TOP 1 ExchangeId FROM ib_Exchange WHERE Code  =''LME'')
CREATE TABLE  #Matches(Id1 INT, Id2 INT)
CREATE NONCLUSTERED INDEX [IX_Matches_1] ON #Matches
(Id1)WITH (PAD_INDEX  = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, IGNORE_DUP_KEY = OFF, ONLINE = OFF) ON [PRIMARY]
 CREATE NONCLUSTERED INDEX [IX_Matches_2] ON #Matches
(Id2)WITH (PAD_INDEX  = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, IGNORE_DUP_KEY = OFF, ONLINE = OFF) ON [PRIMARY]
CREATE TABLE #SelectFrom
(
TradeReconciliationDetailId INT
, ExchangeId INT
, MatchCode VARCHAR(100)
, CurrencyId INT
, InstrumentId INT
, DetailAccountId INT
, ExpiryYear SMALLINT
, ExpiryMonth SMALLINT
, ExpiryDay SMALLINT
, OptionTypeCode VARCHAR(25)
, StrikePrice DECIMAL(19,4)
, TradePrice DECIMAL(24,10)
, InternalLong INT
, InternalShort INT
, ExternalLong INT
, ExternalShort INT
, IsHvh BIT
)

CREATE UNIQUE NONCLUSTERED INDEX [IX_SelectFrom_TradeReconciliationDetailId] ON #SelectFrom
(
TradeReconciliationDetailId ASC
) WITH (PAD_INDEX  = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, IGNORE_DUP_KEY = OFF, ONLINE = OFF) ON [PRIMARY]
	

CREATE NONCLUSTERED INDEX [IX_SelectFrom_Selecting] ON #SelectFrom
(
 ExchangeId 
, MatchCode 
, CurrencyId 
, InstrumentId 
, DetailAccountId
, ExpiryYear 
, ExpiryMonth
, ExpiryDay 
, OptionTypeCode 
, StrikePrice 
, TradePrice
, InternalLong
, InternalShort
, ExternalLong 
, ExternalShort 
, IsHvh
) WITH (PAD_INDEX  = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, IGNORE_DUP_KEY = OFF, ONLINE = OFF) ON [PRIMARY]
	
--RD EIB 25949- don''t include HVH trades
INSERT INTO #SelectFrom
SELECT	  detail.[TradeReconciliationDetailId]
		, detail.[ExchangeId]
		, detail.[MatchCode]
		, detail.[CurrencyId]
		, detail.[InstrumentId]
		, detail.[DetailAccountId]
		, detail.[ExpiryYear]
		, detail.[ExpiryMonth]
		, detail.[ExpiryDay]
		, detail.[OptionTypeCode]
		, detail.[StrikePrice]
		, detail.[TradePrice]
		, detail.[InternalLong]
		, detail.[InternalShort]
		, detail.[ExternalLong]
		, detail.[ExternalShort]
		, CASE WHEN SUBSTRING(ISNULL(t.UTI, ''''), 19, 3) = ''HVH'' AND detail.InternalExternalCode = ''I'' AND detail.ExchangeId = @LmeExchangeId THEN 1 ELSE 0 END AS IsHvh
FROM [dbo].[ib_TradeReconciliationDetail] detail
LEFT JOIN [dbo].[ib_Trx] t (NOLOCK) ON detail.TrxId = t.TrxId
WHERE detail.TradeReconciliationId = @TradeReconciliationId
  AND (detail.IsMatched IS NULL OR detail.IsMatched = 0)
  
CREATE TABLE #trd
(
	TradeReconciliationDetailId INT,
	ExchangeId INT,
	MatchCode VARCHAR(100),
	CurrencyId INT,
	InstrumentId INT,
	DetailAccountId INT,
	ExpiryYear SMALLINT,
	ExpiryMonth SMALLINT,
	ExpiryDay SMALLINT,
	OptionTypeCode VARCHAR(25),
	StrikePrice decimal,
	TradePrice decimal,
	InternalLong INT,
	InternalShort INT,
	ExternalLong INT,
	ExternalShort INT,
	IsMatched BIT,
	IncludeDetailAccountId BIT, 
	IsHvh BIT,
)

CREATE NONCLUSTERED INDEX [IX_trd_IncludeDetailAccountId_IsHvh] ON #trd
(
	IncludeDetailAccountId,IsHvh
) WITH (PAD_INDEX  = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, IGNORE_DUP_KEY = OFF, ONLINE = OFF) ON [PRIMARY]

INSERT INTO #trd
SELECT [TradeReconciliationDetailId]
	, trd.[ExchangeId]
	, trd.[MatchCode]
	, trd.[CurrencyId]
	, trd.[InstrumentId]
	, trd.[DetailAccountId]
	, trd.[ExpiryYear]
	, trd.[ExpiryMonth]
	, trd.[ExpiryDay]
	, trd.[OptionTypeCode]
	, trd.[StrikePrice]
	, trd.[TradePrice]
	, trd.[InternalLong]
	, trd.[InternalShort]
	, trd.[ExternalLong]
	, trd.[ExternalShort]
	, trd.[IsMatched]
	--, [ClassId] ?
	, source.[IncludeDetailAccountInTradeReconciliation]
	, CASE WHEN SUBSTRING(ISNULL(transactions.UTI, ''''), 19, 3) = ''HVH'' AND trd.InternalExternalCode = ''I'' AND trd.ExchangeId = @LmeExchangeId THEN 1 ELSE 0 END AS IsHvh
FROM [dbo].[ib_TradeReconciliationDetail] trd
	INNER JOIN [dbo].[ib_Trx] transactions (NOLOCK) ON trd.TrxId = transactions.TrxId
	INNER JOIN [dbo].[ib_DataSource] source ON transactions.DataSourceId = source.DataSourceId
WHERE 
	trd.TradeReconciliationId = @TradeReconciliationId
	AND (trd.IsMatched IS NULL OR trd.IsMatched = 0)

INSERT INTO #Matches
SELECT t.TradeReconciliationDetailId, sf.TradeReconciliationDetailId
FROM #trd T
JOIN #selectFrom SF ON 
     SF.ExchangeId = T.ExchangeId 
	 AND SF.CurrencyId = T.ExchangeId
	 AND SF.InstrumentId = T.ExchangeId
	 AND SF.ExchangeId = T.ExchangeId
	 AND (SF.DetailAccountId = T.DetailAccountId OR (SF.DetailAccountId IS NULL AND T.DetailAccountId IS NULL))
	 AND SF.ExpiryYear = T.ExpiryYear
	 AND SF.ExpiryMonth = T.ExpiryMonth
	 AND SF.ExpiryDay = T.ExpiryDay
	 AND (SF.OptionTypeCode = T.OptionTypeCode OR (SF.OptionTypeCode IS NULL AND T.OptionTypeCode IS NULL))
	 AND (SF.StrikePrice = T.StrikePrice OR (SF.StrikePrice IS NULL AND T.StrikePrice IS NULL))
	 AND (SF.TradePrice = T.TradePrice OR (SF.TradePrice IS NULL AND T.TradePrice IS NULL))
	 AND (SF.InternalLong = T.ExternalLong)
	 AND (SF.InternalShort = T.ExternalShort)
	 AND (SF.ExternalLong = T.InternalLong)
	 AND (SF.ExternalShort = T.InternalShort)
	 AND SF.MatchCode = T.MatchCode
--LEFT JOIN #Matches M ON M.Id1 != SF.TradeReconciliationDetailId AND M.Id2 != SF.TradeReconciliationDetailId
LEFT JOIN #Matches m ON M.Id1 = SF.TradeReconciliationDetailId OR M.Id2 = SF.TradeReconciliationDetailId 
WHERE t.IncludeDetailAccountId = 1 AND t.IsHvh = 0 AND M.Id1 IS NULL

UNION

SELECT t.TradeReconciliationDetailId, sf.TradeReconciliationDetailId
FROM #trd T
JOIN #selectFrom SF ON 
         SF.ExchangeId = T.ExchangeId
	 AND SF.CurrencyId = T.CurrencyId
	 AND SF.InstrumentId = T.InstrumentId
	 AND (SF.DetailAccountId = T.DetailAccountId OR (SF.DetailAccountId IS NULL AND T.DetailAccountId IS NULL))
	 AND SF.ExpiryYear = T.ExpiryYear
	 AND SF.ExpiryMonth = T.ExpiryMonth
	 AND SF.ExpiryDay = T.ExpiryDay
	 AND (SF.OptionTypeCode = T.OptionTypeCode OR (SF.OptionTypeCode IS NULL AND T.OptionTypeCode IS NULL))
	 AND (SF.StrikePrice = T.StrikePrice OR (SF.StrikePrice IS NULL AND T.StrikePrice IS NULL))
	 AND (SF.TradePrice = T.TradePrice OR (SF.TradePrice IS NULL AND T.TradePrice IS NULL))
	 AND (SF.InternalLong = T.InternalShort) --HVH (House vs House so matching on internal trades)
	 AND (SF.InternalShort = T.InternalLong)
	 AND SF.MatchCode = T.MatchCode
	 AND SF.IsHvh = T.IsHvh
LEFT JOIN #Matches m ON M.Id1 = SF.TradeReconciliationDetailId OR M.Id2 = SF.TradeReconciliationDetailId 
-- WHERE M.Id1 IS NULL
-- LEFT JOIN #Matches M ON M.Id1 != SF.TradeReconciliationDetailId AND M.Id2 != SF.TradeReconciliationDetailId
WHERE t.IncludeDetailAccountId = 1 AND t.IsHvh != 0 AND M.Id1 IS NULL

UNION

SELECT t.TradeReconciliationDetailId, sf.TradeReconciliationDetailId
FROM #trd T
JOIN #selectFrom SF ON 
		 SF.ExchangeId = T.ExchangeId
	 AND SF.CurrencyId = T.CurrencyId
	 -- Removed below line as this is the only difference from the statement above...
	 --AND DetailAccountId = @DetailAccountId
	 AND SF.ExpiryYear = T.ExpiryYear
	 AND SF.ExpiryMonth = T.ExpiryMonth
	 AND SF.ExpiryDay = T.ExpiryDay
	 AND (SF.OptionTypeCode = T.OptionTypeCode OR (SF.OptionTypeCode IS NULL AND T.OptionTypeCode IS NULL))
	 AND (SF.StrikePrice = T.StrikePrice OR (SF.StrikePrice IS NULL AND T.StrikePrice IS NULL))
	 AND (SF.TradePrice = T.TradePrice OR (SF.TradePrice IS NULL AND T.TradePrice IS NULL))
	 AND (SF.InternalLong = T.ExternalLong)
	 AND (SF.InternalShort = T.ExternalShort)
	 AND (SF.ExternalLong = T.InternalLong)
	 AND (SF.ExternalShort = T.InternalShort)
	 AND SF.MatchCode = T.MatchCode
--LEFT JOIN #Matches M ON M.Id1 != SF.TradeReconciliationDetailId AND M.Id2 != SF.TradeReconciliationDetailId
LEFT JOIN #Matches m ON M.Id1 = SF.TradeReconciliationDetailId OR M.Id2 = SF.TradeReconciliationDetailId 
WHERE t.IncludeDetailAccountId != 1 AND t.IsHvh = 0 AND M.Id1 IS NULL

UNION

SELECT t.TradeReconciliationDetailId, sf.TradeReconciliationDetailId
FROM #trd T
JOIN #selectFrom SF ON 
	     SF.ExchangeId = T.ExchangeId
	 AND SF.CurrencyId = T.CurrencyId
	 AND SF.ExpiryYear = T.ExpiryYear
	 AND SF.ExpiryMonth = T.ExpiryMonth
	 AND SF.ExpiryDay = T.ExpiryDay
	 AND (SF.OptionTypeCode = T.OptionTypeCode OR (SF.OptionTypeCode IS NULL AND T.OptionTypeCode IS NULL))
	 AND (SF.StrikePrice = T.StrikePrice OR (SF.StrikePrice IS NULL AND T.StrikePrice IS NULL))
	 AND (SF.TradePrice = T.TradePrice OR (SF.TradePrice IS NULL AND T.TradePrice IS NULL))
	 AND (SF.InternalLong = T.InternalShort) --HVH (House vs House so matching on internal trades)
	 AND (SF.InternalShort = T.InternalLong)
	 AND SF.MatchCode = T.MatchCode
--LEFT JOIN #Matches M ON M.Id1 != SF.TradeReconciliationDetailId AND M.Id2 != SF.TradeReconciliationDetailId
LEFT JOIN #Matches m ON M.Id1 = SF.TradeReconciliationDetailId OR M.Id2 = SF.TradeReconciliationDetailId 
WHERE t.IncludeDetailAccountId != 1 AND t.IsHvh != 0 AND M.Id1 IS NULL


DROP TABLE #SelectFrom
DROP TABLE #trd
UPDATE trd
	SET IsMatched = 1, MatchingTradeReconciliationDetailId = Id1
	FROM [dbo].[ib_TradeReconciliationDetail] trd
	INNER JOIN #Matches m ON m.Id2 = TradeReconciliationDetailId
UPDATE trd
	SET IsMatched = 1, MatchingTradeReconciliationDetailId = Id2
	FROM [dbo].[ib_TradeReconciliationDetail] trd
	INNER JOIN #Matches m ON m.Id1 = TradeReconciliationDetailId			

DROP TABLE #Matches
--update the report status
UPDATE [dbo].[ib_Report]
	SET [Stage] = ''Phase 3: Completed''
	WHERE ReportId = @ReportId


--work out if any of the differences on the summary are because of HVH trades
UPDATE summary
	SET TotalInternalLong = TotalInternalLong - InternalMatches.NumberInternalMatched
	, TotalInternalShort = TotalInternalShort - InternalMatches.NumberInternalMatched
FROM ib_TradeReconciliationSummary summary INNER JOIN

(
select trs.TradeReconciliationSummaryId, SUM(trd.InternalLong) AS NumberInternalMatched 
from 
	ib_TradeReconciliationSummary trs 
	INNER JOIN ib_TradeReconciliationDetail trd ON 
		trs.TradeReconciliationId = trd.TradeReconciliationId
		AND trs.ExchangeId = trd.ExchangeId
		AND trs.MatchCode = trd.MatchCode
		AND trd.IsMatched = 1
		AND trs.CurrencyId = trd.CurrencyId
		AND trs.InstrumentId = trd.InstrumentId
		AND trs.ExpiryYear = trd.ExpiryYear
		AND trs.ExpiryMonth = trd.ExpiryMonth
		AND trs.ExpiryDay = trd.ExpiryDay
		AND trs.OptionTypeCode = trd.OptionTypeCode
		AND trs.TradePrice = trd.TradePrice
		AND trs.StrikePrice = trd.StrikePrice
	INNER JOIN ib_TradeReconciliationDetail  trd2 on trd.MatchingTradeReconciliationDetailId = trd2.TradeReconciliationDetailId
WHERE 
	trd.TradeReconciliationId = @TradeReconciliationId
	AND trd.InternalExternalCode = trd2.InternalExternalCode
	AND trd.InternalExternalCode = ''I''
	AND trs.DifferenceLong = trs.DifferenceShort AND DifferenceLong <> 0
	AND trs.ExchangeId = @LmeExchangeId
GROUP BY 
	trs.TradeReconciliationSummaryId
HAVING 
	SUM(trd.InternalLong) = SUM(trd.InternalShort)
	AND
	SUM(trd.InternalShort) = SUM(trd2.InternalLong)
	AND 
	SUM(trd2.InternalLong) = SUM(trd2.InternalShort) )InternalMatches
	ON summary.TradeReconciliationSummaryId = InternalMatches.TradeReconciliationSummaryId

--update the differences on the trade reconciliation summary (not the internal HVH trades have been matched)
UPDATE [dbo].[ib_TradeReconciliationSummary]
	SET [DifferenceLong] = ([TotalInternalLong] - [TotalExternalLong])
	, [DifferenceShort] = ([TotalInternalShort] - [TotalExternalShort])
	WHERE TradeReconciliationId = @TradeReconciliationId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_NostroBalance_Delete]''
');

GO
EXECUTE ('/*
----------------------------------------------------------------------------------------------------

-- 26 Feb 09 : ED created
-- Purpose: delete balance
*/

CREATE PROCEDURE [dbo].[ib_NostroBalance_Delete]
(
	@NostroBalanceId int
)
AS
SET NOCOUNT ON
BEGIN
DELETE FROM ib_NostroBalance WHERE NostroBalanceId=@NostroBalanceId
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Adjustment_Get_List]''
');

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Gets all records from the ib_Adjustment table
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[ib_Adjustment_Get_List]

AS


				
				SELECT
					[AdjustmentId],
					[TemplateId],
					[ExchangeId],
					[InstrumentId],
					[InternalExternalCode],
					[TradeDate],
					[AdjustmentDate],
					[Quantity],
					[CurrencyId],
					[ExpiryYear],
					[ExpiryMonth],
					[ExpiryDay],
					[StrikePrice],
					[TradePrice],
					[SettlementPrice],
					[OptionTypeCode],
					[Value],
					[PremiumValue],
					[OptionValue],
					[Description],
					[TemplateGroupId],
					[CreateDate],
					[CreateUsername],
					[UpdateDate],
					[UpdateUsername],
					[IsBuy],
					[MatchCodeId],
					[AdjustmentHeaderId],
					[DataSourceId],
					[FirmId],
					[QuantityLong],
					[QuantityShort],
					[DetailAccountId],
					[AccountId],
					[ClassId],
					[AdjustmentStatusId],
					[AdjustmentReasonId],
					[TrxTypeCode],
					[AdjustmentUserStatusId],
					[MatchingAdjustmentId],
					[ReplacesAdjustmentId]
				FROM
					[dbo].[ib_Adjustment]
					
				SELECT @@ROWCOUNT
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Account_GetAccountsByKeyword]''
');

GO
EXECUTE ('




/*
<details>
 <summary> Filter the account by a specific name, code and firm code /summary>
 <created author="Emilian Damian" Date="7 Feb 2007" /> 
 <tasks>
 </tasks>
</details>
*/
CREATE PROCEDURE [dbo].[ib_Account_GetAccountsByKeyword]
@Account varchar(100),
@FilterByStartOnly bit=0,
@Top int = 10
AS
SET NOCOUNT ON
/*
IF @FilterByStartOnly = 1 
BEGIN
	SELECT TOP (@Top) [Name],[AccountId] 
	FROM [dbo].[ib_Account]
	WHERE [Name] LIKE @Account + ''%''
	ORDER BY [Name]
END
ELSE 
BEGIN
	SELECT TOP (@Top) [Name],[AccountId] 
	FROM [dbo].[ib_Account]
	WHERE [Name] LIKE ''%''+@Account + ''%''
	ORDER BY [Name]
END
*/

IF @FilterByStartOnly = 1 
BEGIN
	SELECT TOP (@Top) a.[Name] + '' [ '' + a.[Code] + '' ~ '' +f.[Code] + '' ]'' as Name,a.[AccountId] 
	FROM [dbo].[ib_Account] a
	LEFT JOIN [dbo].[ib_Firm] f on a.[FirmId] = f.[FirmId]
	WHERE a.[Name] LIKE @Account + ''%'' or a.[Code] like @Account + ''%'' or f.[Code] like @Account + ''%''
	ORDER BY a.[Name]
END
ELSE 
BEGIN
	SELECT TOP (@Top) a.[Name] + '' [ '' + a.[Code] + '' ~ '' +f.[Code] + '' ]'' as Name,a.[AccountId] 
	FROM [dbo].[ib_Account] a
	LEFT JOIN [dbo].[ib_Firm] f on a.[FirmId] = f.[FirmId]
	WHERE a.[Name] LIKE ''%''+@Account + ''%'' or a.[Code] LIKE ''%''+@Account + ''%'' or f.[Code] LIKE ''%''+@Account + ''%''
	ORDER BY a.[Name]
END
');

GO
EXECUTE ('PRINT N''Creating [stage].[LmePositionsRealisedCash_LoadStateChange]''
');

GO
EXECUTE ('CREATE PROCEDURE [stage].[LmePositionsRealisedCash_LoadStateChange]
	(
		@OldLoadState	TINYINT,
		@NewLoadState	TINYINT,
		@FileName       VARCHAR (512)= NULL
	)
AS

-- Description: Changes the LoadState of the stage.LmePositionsRealisedCash type table

-- 01 Jul 2014	ED	EIB 25781 - Creation

BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	UPDATE stage.LmePositionsRealisedCash SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState AND [FileName] = Coalesce(@FileName, [FileName])

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[aspnet_Membership_GetNumberOfUsersOnline]''
');

GO
SET QUOTED_IDENTIFIER OFF

GO
EXECUTE ('CREATE PROCEDURE [dbo].[aspnet_Membership_GetNumberOfUsersOnline]
    @ApplicationName            nvarchar(256),
    @MinutesSinceLastInActive   int,
    @CurrentTimeUtc             datetime
AS
SET NOCOUNT ON
BEGIN
    DECLARE @DateActive datetime
    SELECT  @DateActive = DATEADD(minute,  -(@MinutesSinceLastInActive), @CurrentTimeUtc)

    DECLARE @NumOnline int
    SELECT  @NumOnline = COUNT(*)
    FROM    dbo.aspnet_Users u(NOLOCK),
            dbo.aspnet_Applications a(NOLOCK),
            dbo.aspnet_Membership m(NOLOCK)
    WHERE   u.ApplicationId = a.ApplicationId                  AND
            LastActivityDate > @DateActive                     AND
            a.LoweredApplicationName = LOWER(@ApplicationName) AND
            u.UserId = m.UserId
    RETURN(@NumOnline)
END
');

GO
EXECUTE ('PRINT N''Creating [stage].[LmePositionsRealisedCash_Purge]''
');

GO
SET QUOTED_IDENTIFIER ON

GO
EXECUTE ('CREATE PROCEDURE [stage].[LmePositionsRealisedCash_Purge]
	(
		@LoadState		TINYINT = 0,
		@FileName       VARCHAR (512)= NULL
	)
AS
-- Description: Deletes from stage.LmePositionsRealisedCash table all the records where the LoadState is 0

-- 01 Jul 2014	ED	EIB 25781 - Creation

-- History:

BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
	DELETE FROM stage.LmePositionsRealisedCash WHERE LoadState= @LoadState AND [FileName] = Coalesce(@FileName, [FileName])

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[aspnet_Membership_GetPassword]''
');

GO
SET QUOTED_IDENTIFIER OFF

GO
EXECUTE ('CREATE PROCEDURE [dbo].[aspnet_Membership_GetPassword]
    @ApplicationName                nvarchar(256),
    @UserName                       nvarchar(256),
    @MaxInvalidPasswordAttempts     int,
    @PasswordAttemptWindow          int,
    @CurrentTimeUtc                 datetime,
    @PasswordAnswer                 nvarchar(128) = NULL
AS
SET NOCOUNT ON
BEGIN
    DECLARE @UserId                                 uniqueidentifier
    DECLARE @PasswordFormat                         int
    DECLARE @Password                               nvarchar(128)
    DECLARE @passAns                                nvarchar(128)
    DECLARE @IsLockedOut                            bit
    DECLARE @LastLockoutDate                        datetime
    DECLARE @FailedPasswordAttemptCount             int
    DECLARE @FailedPasswordAttemptWindowStart       datetime
    DECLARE @FailedPasswordAnswerAttemptCount       int
    DECLARE @FailedPasswordAnswerAttemptWindowStart datetime

    DECLARE @ErrorCode     int
    SET @ErrorCode = 0

    DECLARE @TranStarted   bit
    SET @TranStarted = 0

    IF( @@TRANCOUNT = 0 )
    BEGIN
	    BEGIN TRANSACTION
	    SET @TranStarted = 1
    END
    ELSE
    	SET @TranStarted = 0

    SELECT  @UserId = u.UserId,
            @Password = m.Password,
            @passAns = m.PasswordAnswer,
            @PasswordFormat = m.PasswordFormat,
            @IsLockedOut = m.IsLockedOut,
            @LastLockoutDate = m.LastLockoutDate,
            @FailedPasswordAttemptCount = m.FailedPasswordAttemptCount,
            @FailedPasswordAttemptWindowStart = m.FailedPasswordAttemptWindowStart,
            @FailedPasswordAnswerAttemptCount = m.FailedPasswordAnswerAttemptCount,
            @FailedPasswordAnswerAttemptWindowStart = m.FailedPasswordAnswerAttemptWindowStart
    FROM    dbo.aspnet_Applications a, dbo.aspnet_Users u, dbo.aspnet_Membership m WITH ( UPDLOCK )
    WHERE   LOWER(@ApplicationName) = a.LoweredApplicationName AND
            u.ApplicationId = a.ApplicationId    AND
            u.UserId = m.UserId AND
            LOWER(@UserName) = u.LoweredUserName

    IF ( @@rowcount = 0 )
    BEGIN
        SET @ErrorCode = 1
        GOTO Cleanup
    END

    IF( @IsLockedOut = 1 )
    BEGIN
        SET @ErrorCode = 99
        GOTO Cleanup
    END

    IF ( NOT( @PasswordAnswer IS NULL ) )
    BEGIN
        IF( ( @passAns IS NULL ) OR ( LOWER( @passAns ) <> LOWER( @PasswordAnswer ) ) )
        BEGIN
            IF( @CurrentTimeUtc > DATEADD( minute, @PasswordAttemptWindow, @FailedPasswordAnswerAttemptWindowStart ) )
            BEGIN
                SET @FailedPasswordAnswerAttemptWindowStart = @CurrentTimeUtc
                SET @FailedPasswordAnswerAttemptCount = 1
            END
            ELSE
            BEGIN
                SET @FailedPasswordAnswerAttemptCount = @FailedPasswordAnswerAttemptCount + 1
                SET @FailedPasswordAnswerAttemptWindowStart = @CurrentTimeUtc
            END

            BEGIN
                IF( @FailedPasswordAnswerAttemptCount >= @MaxInvalidPasswordAttempts )
                BEGIN
                    SET @IsLockedOut = 1
                    SET @LastLockoutDate = @CurrentTimeUtc
                END
            END

            SET @ErrorCode = 3
        END
        ELSE
        BEGIN
            IF( @FailedPasswordAnswerAttemptCount > 0 )
            BEGIN
                SET @FailedPasswordAnswerAttemptCount = 0
                SET @FailedPasswordAnswerAttemptWindowStart = CONVERT( datetime, ''17540101'', 112 )
            END
        END

        UPDATE dbo.aspnet_Membership
        SET IsLockedOut = @IsLockedOut, LastLockoutDate = @LastLockoutDate,
            FailedPasswordAttemptCount = @FailedPasswordAttemptCount,
            FailedPasswordAttemptWindowStart = @FailedPasswordAttemptWindowStart,
            FailedPasswordAnswerAttemptCount = @FailedPasswordAnswerAttemptCount,
            FailedPasswordAnswerAttemptWindowStart = @FailedPasswordAnswerAttemptWindowStart
        WHERE @UserId = UserId

        IF( @@ERROR <> 0 )
        BEGIN
            SET @ErrorCode = -1
            GOTO Cleanup
        END
    END

    IF( @TranStarted = 1 )
    BEGIN
	SET @TranStarted = 0
	COMMIT TRANSACTION
    END

    IF( @ErrorCode = 0 )
        SELECT @Password, @PasswordFormat

    RETURN @ErrorCode

Cleanup:

    IF( @TranStarted = 1 )
    BEGIN
        SET @TranStarted = 0
    	ROLLBACK TRANSACTION
    END

    RETURN @ErrorCode

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TradeReconciliation_GetDataForChart]''
');

GO
SET QUOTED_IDENTIFIER ON

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_TradeReconciliation_GetDataForChart]
AS
SET NOCOUNT ON

	--	17 Aug 2010		amk		Creation
	
	DECLARE @TRid INT

	SET @TRid = (SELECT TOP 1 tradereconciliationid 
	FROM ib_tradereconciliation
	ORDER BY today DESC, createdate DESC)

	SELECT today, e.code AS exchange, matchcode
		, SUM(ABS(differenceshort)) + SUM(ABS(differencelong)) AS lots_out
	FROM ib_tradereconciliationsummary s
		JOIN ib_tradereconciliation r ON r.tradereconciliationid = s.tradereconciliationid
		JOIN ib_exchange e ON e.exchangeid = s.exchangeid
	WHERE (differenceshort <> 0 OR differencelong <> 0)
		AND r.tradereconciliationid = @TRid
	GROUP BY r.today, e.code, s.matchcode
	ORDER BY lots_out DESC
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_NostroBalance_GetNostroBalanceById]''
');

GO
EXECUTE ('/*
----------------------------------------------------------------------------------------------------

-- 26 Feb 09 : ED created
-- Purpose: get by id
*/

CREATE PROCEDURE [dbo].[ib_NostroBalance_GetNostroBalanceById]
(
	@NostroBalanceId int
)
AS
SET NOCOUNT ON
BEGIN
SELECT nb.[NostroBalanceId]
      ,nb.[MatchCodeId]
      ,nb.[BalanceDate]
      ,nb.[InternalBalance]
      ,nb.[ExternalBalance]
      ,nb.[CreateDate]
      ,nb.[CreateUsername]
      ,nb.[UpdateDate]
      ,nb.[UpdateUsername]
	  ,Description
	  ,MatchCode
  FROM [dbo].[ib_NostroBalance] nb
INNER JOIN ib_MatchCode mc ON mc.MatchCodeId=nb.MatchCodeId
INNER JOIN ib_Template t ON t.TemplateId=mc.TemplateId
 WHERE NostroBalanceId=@NostroBalanceId
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Adjustment_Insert]''
');

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Inserts a record into the ib_Adjustment table
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[ib_Adjustment_Insert]
(

	@AdjustmentId int    OUTPUT,

	@TemplateId int   ,

	@ExchangeId int   ,

	@InstrumentId int   ,

	@InternalExternalCode char (1)  ,

	@TradeDate datetime   ,

	@AdjustmentDate datetime   ,

	@Quantity decimal (19, 4)  ,

	@CurrencyId int   ,

	@ExpiryYear smallint   ,

	@ExpiryMonth smallint   ,

	@ExpiryDay smallint   ,

	@StrikePrice decimal (19, 4)  ,

	@TradePrice decimal (24, 10)  ,

	@SettlementPrice decimal (24, 10)  ,

	@OptionTypeCode varchar (25)  ,

	@Value decimal (19, 4)  ,

	@PremiumValue decimal (19, 6)  ,

	@OptionValue decimal (19, 6)  ,

	@Description varchar (255)  ,

	@TemplateGroupId int   ,

	@CreateDate datetime   ,

	@CreateUsername varchar (50)  ,

	@UpdateDate datetime   ,

	@UpdateUsername varchar (50)  ,

	@IsBuy bit   ,

	@MatchCodeId int   ,

	@AdjustmentHeaderId int   ,

	@DataSourceId int   ,

	@FirmId int   ,

	@QuantityLong int   ,

	@QuantityShort int   ,

	@DetailAccountId int   ,

	@AccountId int   ,

	@ClassId int   ,

	@AdjustmentStatusId int   ,

	@AdjustmentReasonId int   ,

	@TrxTypeCode varchar (25)  ,

	@AdjustmentUserStatusId int   ,

	@MatchingAdjustmentId int   ,

	@ReplacesAdjustmentId int   
)
AS


				
				INSERT INTO [dbo].[ib_Adjustment]
					(
					[TemplateId]
					,[ExchangeId]
					,[InstrumentId]
					,[InternalExternalCode]
					,[TradeDate]
					,[AdjustmentDate]
					,[Quantity]
					,[CurrencyId]
					,[ExpiryYear]
					,[ExpiryMonth]
					,[ExpiryDay]
					,[StrikePrice]
					,[TradePrice]
					,[SettlementPrice]
					,[OptionTypeCode]
					,[Value]
					,[PremiumValue]
					,[OptionValue]
					,[Description]
					,[TemplateGroupId]
					,[CreateDate]
					,[CreateUsername]
					,[UpdateDate]
					,[UpdateUsername]
					,[IsBuy]
					,[MatchCodeId]
					,[AdjustmentHeaderId]
					,[DataSourceId]
					,[FirmId]
					,[QuantityLong]
					,[QuantityShort]
					,[DetailAccountId]
					,[AccountId]
					,[ClassId]
					,[AdjustmentStatusId]
					,[AdjustmentReasonId]
					,[TrxTypeCode]
					,[AdjustmentUserStatusId]
					,[MatchingAdjustmentId]
					,[ReplacesAdjustmentId]
					)
				VALUES
					(
					@TemplateId
					,@ExchangeId
					,@InstrumentId
					,@InternalExternalCode
					,@TradeDate
					,@AdjustmentDate
					,@Quantity
					,@CurrencyId
					,@ExpiryYear
					,@ExpiryMonth
					,@ExpiryDay
					,@StrikePrice
					,@TradePrice
					,@SettlementPrice
					,@OptionTypeCode
					,@Value
					,@PremiumValue
					,@OptionValue
					,@Description
					,@TemplateGroupId
					,@CreateDate
					,@CreateUsername
					,@UpdateDate
					,@UpdateUsername
					,@IsBuy
					,@MatchCodeId
					,@AdjustmentHeaderId
					,@DataSourceId
					,@FirmId
					,@QuantityLong
					,@QuantityShort
					,@DetailAccountId
					,@AccountId
					,@ClassId
					,@AdjustmentStatusId
					,@AdjustmentReasonId
					,@TrxTypeCode
					,@AdjustmentUserStatusId
					,@MatchingAdjustmentId
					,@ReplacesAdjustmentId
					)
				
				-- Get the identity value
				SET @AdjustmentId = SCOPE_IDENTITY()
									
							
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Money_Load]''
');

GO
EXECUTE ('/*
Programmer:		Lee Manifold
Date:			23/11/2006

Purpose:  This stored proc will accept the parameters passed to it from any 
datasource, perform the necessary lookups, and then insert a record in the #
ib_Money table.

Revision History:
-- 09 Jan 2014		ED			EIB 25004 - remove importLog table and use Log table
*/
CREATE proc [dbo].[ib_Money_Load]
	(
	@DataSourceId			int,
	@AsofDate				datetime,
	@FirmCd					varchar(1),
	@OfficeNumber			varchar(3),
	@AccountCd				varchar(6),
	@CurrencyCd				varchar(2),
	@LngOptMktValue			decimal(19,6),
	@ShtOptMktValue			decimal(19,6),
	@FuturesInitialMargin	decimal(19,6),
	@EquitiesInitialMargin	decimal(19,6),
	@MarginCollateralValue	decimal(19,6),
	@PreviousAccountBalance	decimal(19,6)
	)
AS
SET NOCOUNT ON
	DECLARE @ReturnValue	int
	DECLARE @FirmID			int
	DECLARE @AccountID		int
	DECLARE @CurrencyID		int
	DECLARE @MoneyId		int
	
	--Get FirmID
	EXEC @ReturnValue= [ib_Firm_AddAsNeeded] @DataSourceId,@FirmCd,@FirmId output	

	--Get AccountID
	EXEC @ReturnValue= [ib_Account_AddAsNeeded] @AccountCd,@FirmId,@AccountId output	

	--Get CurrencyID
	IF @CurrencyCd is not Null
		EXEC @ReturnValue = [ib_Currency_AddAsNeeded] @DataSourceId, @CurrencyCd, @CurrencyId output
	

	--INSERT INTO ib_Money 
	EXEC @ReturnValue=ib_Money_Add  @DataSourceId,
									@AsOfDate,
									@FirmId,
									@OfficeNumber,
									@AccountId,
									@CurrencyId,
									@LngOptMktValue,
									@ShtOptMktValue,
									@FuturesInitialMargin,
									@EquitiesInitialMargin,
									@MarginCollateralValue,
									@PreviousAccountBalance,
									@MoneyId Output
');

GO
EXECUTE ('PRINT N''Creating [dbo].[udf_NostroBalanceVariation_GetByMatchCodeId]''
');

GO
EXECUTE ('-- =============================================
-- Author:		Konrad
-- Create date: 26.02.09
-- Description:	Returns Variation
-- =============================================
CREATE FUNCTION [dbo].[udf_NostroBalanceVariation_GetByMatchCodeId] 
(
	@MatchCodeId int
)
RETURNS DECIMAL(18,4)
AS
BEGIN

	DECLARE @ClosingStatementBalance decimal(18,4) 
    DECLARE @ClosingLedgerBalance decimal(18,4)
    DECLARE @LessOpenStatementReceipts decimal(18,4)
    DECLARE @PlusOpenStatementPayments decimal(18,4)
	DECLARE @LessOpenLedgerPayments decimal(18,4) 
    DECLARE @PlusOpenLedgerReceipts decimal(18,4)
	DECLARE @ReconciliationLedgerBalance decimal(18,4)
	DECLARE @Variation decimal(18,4) 
    DECLARE @LatestBalanceDate datetime			
	
	SELECT @ClosingLedgerBalance = nb.InternalBalance, @ClosingStatementBalance = nb.ExternalBalance
    FROM [ib_NostroBalance] nb
    WHERE nb.[MatchCodeId] = @MatchCodeId
    AND nb.[BalanceDate] = (SELECT MAX(BalanceDate) AS LatestBalanceDate FROM [ib_NostroBalance] nb1 WHERE nb1.[MatchCodeId] = @MatchCodeId)

	SELECT 
		@LessOpenStatementReceipts = SUM(CASE WHEN tc.InternalExternalCode=''I'' THEN 0 
			ELSE CASE WHEN Amount<0 THEN 0 ELSE ABS(Amount) END END),

		@PlusOpenStatementPayments = SUM(CASE WHEN tc.InternalExternalCode=''I'' THEN 0 
			ELSE CASE WHEN Amount>0 THEN 0 ELSE ABS(Amount) END END),

		@LessOpenLedgerPayments = SUM(CASE WHEN tc.InternalExternalCode=''E'' THEN 0 
			ELSE CASE WHEN Amount>0 THEN 0 ELSE ABS(Amount) END END),

		@PlusOpenLedgerReceipts = SUM(CASE WHEN tc.InternalExternalCode=''E'' THEN 0 
			ELSE CASE WHEN Amount<0 THEN 0 ELSE ABS(Amount) END END)

	FROM [ib_Nostro] n
	INNER JOIN ib_MatchCode mc ON mc.MatchCodeId = @MatchCodeId
	INNER JOIN ib_Account a ON a.AccountId=n.AccountId
	INNER JOIN ib_Firm f ON f.FirmId=a.FirmId 
	INNER JOIN ib_TemplateCompare tc ON tc.DataSourceId=n.DataSourceId AND tc.FirmId=f.FirmId AND tc.TemplateId = mc.TemplateId
	INNER JOIN ib_TemplateGroup tg ON tg.TemplateId=mc.TemplateId AND tg.AccountId=n.AccountId  AND tg.CurrencyId=n.CurrencyId and tg.description = mc.matchcode
	WHERE n.NostroId NOT IN (SELECT NostroId FROM ib_NostroMatch)

	
	SET @ReconciliationLedgerBalance = @ClosingStatementBalance - @LessOpenStatementReceipts + @PlusOpenStatementPayments - @LessOpenLedgerPayments + @PlusOpenLedgerReceipts 

	SET @Variation = @ReconciliationLedgerBalance - @ClosingLedgerBalance 

	RETURN @Variation

END
');

GO
EXECUTE ('PRINT N''Creating [stage].[LmeTrade_LoadStateChange]''
');

GO
EXECUTE ('CREATE PROCEDURE [stage].[LmeTrade_LoadStateChange]
	(
		@OldLoadState	TINYINT,
		@NewLoadState	TINYINT,
		@FileName       VARCHAR (512)= NULL
	)
AS

-- Description: Changes the LoadState of the stage.LmeTrade type table

-- 20 Jun 2014	ED	EIB 25759 - Creation

BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	UPDATE stage.LmeTrade SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState AND [FileName] = Coalesce(@FileName, [FileName])

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[aspnet_Membership_GetPasswordWithFormat]''
');

GO
SET QUOTED_IDENTIFIER OFF

GO
EXECUTE ('CREATE PROCEDURE [dbo].[aspnet_Membership_GetPasswordWithFormat]
    @ApplicationName                nvarchar(256),
    @UserName                       nvarchar(256),
    @UpdateLastLoginActivityDate    bit,
    @CurrentTimeUtc                 datetime
AS
SET NOCOUNT ON
BEGIN
    DECLARE @IsLockedOut                        bit
    DECLARE @UserId                             uniqueidentifier
    DECLARE @Password                           nvarchar(128)
    DECLARE @PasswordSalt                       nvarchar(128)
    DECLARE @PasswordFormat                     int
    DECLARE @FailedPasswordAttemptCount         int
    DECLARE @FailedPasswordAnswerAttemptCount   int
    DECLARE @IsApproved                         bit
    DECLARE @LastActivityDate                   datetime
    DECLARE @LastLoginDate                      datetime

    SELECT  @UserId          = NULL

    SELECT  @UserId = u.UserId, @IsLockedOut = m.IsLockedOut, @Password=Password, @PasswordFormat=PasswordFormat,
            @PasswordSalt=PasswordSalt, @FailedPasswordAttemptCount=FailedPasswordAttemptCount,
		    @FailedPasswordAnswerAttemptCount=FailedPasswordAnswerAttemptCount, @IsApproved=IsApproved,
            @LastActivityDate = LastActivityDate, @LastLoginDate = LastLoginDate
    FROM    dbo.aspnet_Applications a, dbo.aspnet_Users u, dbo.aspnet_Membership m
    WHERE   LOWER(@ApplicationName) = a.LoweredApplicationName AND
            u.ApplicationId = a.ApplicationId    AND
            u.UserId = m.UserId AND
            LOWER(@UserName) = u.LoweredUserName

    IF (@UserId IS NULL)
        RETURN 1

    IF (@IsLockedOut = 1)
        RETURN 99

    SELECT   @Password, @PasswordFormat, @PasswordSalt, @FailedPasswordAttemptCount,
             @FailedPasswordAnswerAttemptCount, @IsApproved, @LastLoginDate, @LastActivityDate

    IF (@UpdateLastLoginActivityDate = 1 AND @IsApproved = 1)
    BEGIN
        UPDATE  dbo.aspnet_Membership
        SET     LastLoginDate = @CurrentTimeUtc
        WHERE   UserId = @UserId

        UPDATE  dbo.aspnet_Users
        SET     LastActivityDate = @CurrentTimeUtc
        WHERE   @UserId = UserId
    END


    RETURN 0
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Adjustment_Update]''
');

GO
SET QUOTED_IDENTIFIER ON

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Updates a record in the ib_Adjustment table
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[ib_Adjustment_Update]
(

	@AdjustmentId int   ,

	@TemplateId int   ,

	@ExchangeId int   ,

	@InstrumentId int   ,

	@InternalExternalCode char (1)  ,

	@TradeDate datetime   ,

	@AdjustmentDate datetime   ,

	@Quantity decimal (19, 4)  ,

	@CurrencyId int   ,

	@ExpiryYear smallint   ,

	@ExpiryMonth smallint   ,

	@ExpiryDay smallint   ,

	@StrikePrice decimal (19, 4)  ,

	@TradePrice decimal (24, 10)  ,

	@SettlementPrice decimal (24, 10)  ,

	@OptionTypeCode varchar (25)  ,

	@Value decimal (19, 4)  ,

	@PremiumValue decimal (19, 6)  ,

	@OptionValue decimal (19, 6)  ,

	@Description varchar (255)  ,

	@TemplateGroupId int   ,

	@CreateDate datetime   ,

	@CreateUsername varchar (50)  ,

	@UpdateDate datetime   ,

	@UpdateUsername varchar (50)  ,

	@IsBuy bit   ,

	@MatchCodeId int   ,

	@AdjustmentHeaderId int   ,

	@DataSourceId int   ,

	@FirmId int   ,

	@QuantityLong int   ,

	@QuantityShort int   ,

	@DetailAccountId int   ,

	@AccountId int   ,

	@ClassId int   ,

	@AdjustmentStatusId int   ,

	@AdjustmentReasonId int   ,

	@TrxTypeCode varchar (25)  ,

	@AdjustmentUserStatusId int   ,

	@MatchingAdjustmentId int   ,

	@ReplacesAdjustmentId int   
)
AS


				
				
				-- Modify the updatable columns
				UPDATE
					[dbo].[ib_Adjustment]
				SET
					[TemplateId] = @TemplateId
					,[ExchangeId] = @ExchangeId
					,[InstrumentId] = @InstrumentId
					,[InternalExternalCode] = @InternalExternalCode
					,[TradeDate] = @TradeDate
					,[AdjustmentDate] = @AdjustmentDate
					,[Quantity] = @Quantity
					,[CurrencyId] = @CurrencyId
					,[ExpiryYear] = @ExpiryYear
					,[ExpiryMonth] = @ExpiryMonth
					,[ExpiryDay] = @ExpiryDay
					,[StrikePrice] = @StrikePrice
					,[TradePrice] = @TradePrice
					,[SettlementPrice] = @SettlementPrice
					,[OptionTypeCode] = @OptionTypeCode
					,[Value] = @Value
					,[PremiumValue] = @PremiumValue
					,[OptionValue] = @OptionValue
					,[Description] = @Description
					,[TemplateGroupId] = @TemplateGroupId
					,[CreateDate] = @CreateDate
					,[CreateUsername] = @CreateUsername
					,[UpdateDate] = @UpdateDate
					,[UpdateUsername] = @UpdateUsername
					,[IsBuy] = @IsBuy
					,[MatchCodeId] = @MatchCodeId
					,[AdjustmentHeaderId] = @AdjustmentHeaderId
					,[DataSourceId] = @DataSourceId
					,[FirmId] = @FirmId
					,[QuantityLong] = @QuantityLong
					,[QuantityShort] = @QuantityShort
					,[DetailAccountId] = @DetailAccountId
					,[AccountId] = @AccountId
					,[ClassId] = @ClassId
					,[AdjustmentStatusId] = @AdjustmentStatusId
					,[AdjustmentReasonId] = @AdjustmentReasonId
					,[TrxTypeCode] = @TrxTypeCode
					,[AdjustmentUserStatusId] = @AdjustmentUserStatusId
					,[MatchingAdjustmentId] = @MatchingAdjustmentId
					,[ReplacesAdjustmentId] = @ReplacesAdjustmentId
				WHERE
[AdjustmentId] = @AdjustmentId 
				
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Nostro_Add_Manual]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Nostro_Add_Manual] 
	(
		@NostroId				INT OUTPUT
		, @InternalExternalCode	CHAR(1)
		, @ValueDate			DATETIME
		, @TransDate			DATETIME
		, @Amount				DECIMAL(18, 4)
		, @TransactionType	 	VARCHAR(4)
		, @InternalReference	VARCHAR(16)
		, @ExternalReference	VARCHAR(16)
		, @Narrative			VARCHAR(max)
		, @AccountId			INT
		, @CurrencyId			INT
		, @CreateUsername		VARCHAR(50)
	)
AS
SET NOCOUNT ON

	--	28 Sep 2009		amk		Creation
	--	29 Sep 2009		amk		Update balance too

	DECLARE @DataSourceId INT
	DECLARE @DataSourceCode VARCHAR(100)

	IF @InternalExternalCode = ''I''
		SET @DataSourceCode = ''Peoplesoft''
	ELSE
		SET @DataSourceCode = ''SWIFT''

	SELECT @DataSourceId = DataSourceID
	FROM ib_DataSource
	WHERE Code = @DataSourceCode

	BEGIN TRANSACTION

	INSERT INTO ib_Nostro
			(
				DataSourceId
				, ValueDate
				, TransDate
				, Amount
				, TransactionType
				, InternalReference
				, ExternalReference
				, Narrative
				, AccountId
				, CurrencyId
				, TempTableRecordId
				, CreateUsername
			)
	VALUES
			(
				@DataSourceId
				, @ValueDate
				, @TransDate
				, @Amount
				, @TransactionType
				, @InternalReference
				, @ExternalReference
				, @Narrative
				, @AccountId
				, @CurrencyId
				, -1
				, @CreateUsername
			)

	SELECT @NostroId = SCOPE_IDENTITY()

	DECLARE @ReturnValue INT
	EXEC @ReturnValue = ib_NostroBalanceAddOrUpdate @NostroId, @DataSourceId, @Amount, @AccountId
		, @CurrencyId, @CreateUsername

	COMMIT TRANSACTION
');

GO
EXECUTE ('PRINT N''Creating [stage].[LmeTrade_Purge]''
');

GO
EXECUTE ('CREATE PROCEDURE [stage].[LmeTrade_Purge]
	(
		@LoadState		TINYINT = 0,
		@FileName       VARCHAR (512)= NULL
	)
AS
-- Description: Deletes from stage.LmeTrade_ table all the records where the LoadState is 0

-- 20 Jun 2014	ED	EIB 25759 - Creation

-- History:

BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
	DELETE FROM stage.LmeTrade WHERE LoadState= @LoadState AND [FileName] = Coalesce(@FileName, [FileName])

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[aspnet_Membership_GetUserByEmail]''
');

GO
SET QUOTED_IDENTIFIER OFF

GO
EXECUTE ('CREATE PROCEDURE [dbo].[aspnet_Membership_GetUserByEmail]
    @ApplicationName  nvarchar(256),
    @Email            nvarchar(256)
AS
SET NOCOUNT ON
BEGIN
    IF( @Email IS NULL )
        SELECT  u.UserName
        FROM    dbo.aspnet_Applications a, dbo.aspnet_Users u, dbo.aspnet_Membership m
        WHERE   LOWER(@ApplicationName) = a.LoweredApplicationName AND
                u.ApplicationId = a.ApplicationId    AND
                u.UserId = m.UserId AND
                m.LoweredEmail IS NULL
    ELSE
        SELECT  u.UserName
        FROM    dbo.aspnet_Applications a, dbo.aspnet_Users u, dbo.aspnet_Membership m
        WHERE   LOWER(@ApplicationName) = a.LoweredApplicationName AND
                u.ApplicationId = a.ApplicationId    AND
                u.UserId = m.UserId AND
                LOWER(@Email) = m.LoweredEmail

    IF (@@rowcount = 0)
        RETURN(1)
    RETURN(0)
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TradeReconciliationSummary_GetDetailsHeader]''
');

GO
SET QUOTED_IDENTIFIER ON

GO
EXECUTE ('
CREATE Procedure [dbo].[ib_TradeReconciliationSummary_GetDetailsHeader]
(
		@TradeReconciliationSummaryId int
)
AS
SET NOCOUNT ON
-- Description: Get the header values for a Summary Record</summary>

-- History:
-- 04 Aug 2009	AAJM	Creation
-- 06 Apr 2010	AAJM	MBAL-15150 Return InstrumentId for drilldown

SELECT t.Description TemplateDescription,
	[ExpiryYear],[ExpiryMonth], [ExpiryDay], [OptionTypeCode],
	[CurrencyId], [StrikePrice], [TradePrice], trs.[MatchCode], [Exchange], [Currency], [Instrument], [Today], [InstrumentId]
FROM [dbo].[ib_TradeReconciliationSummary] trs
INNER JOIN ib_TradeReconciliation tr ON tr.TradeReconciliationId=trs.TradeReconciliationId
INNER JOIN ib_Template t ON t.TemplateId=tr.TemplateId
WHERE TradeReconciliationSummaryId=@TradeReconciliationSummaryId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_NostroBalance_GetNostroBalancesSortableAndPaginateCount]''
');

GO
EXECUTE ('/*
----------------------------------------------------------------------------------------------------

-- 26 Feb 09	ED		Created
-- Purpose: get list count

-- History:
-- 06 Oct 09	AAJM	Applied MatchCode Security based on UserId MBAL-11773
*/

CREATE PROCEDURE [dbo].[ib_NostroBalance_GetNostroBalancesSortableAndPaginateCount]
(
	@TemplateId int,
	@UserId uniqueidentifier,
	@StartDate datetime
)
AS
SET NOCOUNT ON
BEGIN
SELECT COUNT(NostroBalanceId) FROM ib_NostroBalance nb
INNER JOIN ib_MatchCode mc ON mc.MatchCodeId=nb.MatchCodeId
INNER JOIN ib_UserMatchCodeAccess umca ON umca.UserId = @UserId AND umca.MatchCodeId = mc.MatchCodeId 
INNER JOIN ib_AccessRight ar ON umca.AccessRightId = ar.AccessRightId
WHERE BalanceDate>@StartDate AND TemplateId=@TemplateId AND (ar.Code = ''ReadOnly'' OR ar.Code = ''Full'')
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Adjustment_Delete]''
');

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Deletes a record in the ib_Adjustment table
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[ib_Adjustment_Delete]
(

	@AdjustmentId int   
)
AS


				DELETE FROM [dbo].[ib_Adjustment] WITH (ROWLOCK) 
				WHERE
					[AdjustmentId] = @AdjustmentId
					
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Account_GetCodeAndIdForAllAccounts]''
');

GO
EXECUTE ('  /*
<details>
 <summary>Returns code and id columns for all the Accounts</summary>
 <created author="laurentiu.macovei" date="Tue, 26 Sep 2006 12:19:41 GMT"/>
 <updated author="anil.kripalani" date="30 Nov 2006">
	add sort order
 </updated>
 <updated author="anil.kripalani" date="07 Feb 2006">
	show firm name too
 </updated>
</details>
*/
CREATE PROCEDURE [dbo].[ib_Account_GetCodeAndIdForAllAccounts]
AS
SET NOCOUNT ON
SELECT a.Code + '' ('' + f.Code + '')'' AS Code, AccountId 
	FROM ib_Account a
		JOIN ib_Firm f ON f.FirmId = a.FirmId
ORDER BY a.Code
');

GO
EXECUTE ('PRINT N''Creating [stage].[MacquariePosition_LoadStateChange]''
');

GO
EXECUTE ('CREATE PROCEDURE [stage].[MacquariePosition_LoadStateChange]
	(
		@OldLoadState	TINYINT,
		@NewLoadState	TINYINT,
		@FileName       VARCHAR (512)= NULL
	)
AS

-- Description: Changes the LoadState of the stage.MacquariePosition type table

-- 23 Jun 2014	ED	EIB 25760 - Creation

BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	UPDATE stage.MacquariePosition SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState AND [FileName] = Coalesce(@FileName, [FileName])

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[aspnet_Membership_GetUserByName]''
');

GO
SET QUOTED_IDENTIFIER OFF

GO
EXECUTE ('CREATE PROCEDURE [dbo].[aspnet_Membership_GetUserByName]
    @ApplicationName      nvarchar(256),
    @UserName             nvarchar(256),
    @CurrentTimeUtc       datetime,
    @UpdateLastActivity   bit = 0
AS
SET NOCOUNT ON
BEGIN
    DECLARE @UserId uniqueidentifier

    IF (@UpdateLastActivity = 1)
    BEGIN
        SELECT TOP 1 m.Email, m.PasswordQuestion, m.Comment, m.IsApproved,
                m.CreateDate, m.LastLoginDate, @CurrentTimeUtc, m.LastPasswordChangedDate,
                u.UserId, m.IsLockedOut,m.LastLockoutDate
        FROM    dbo.aspnet_Applications a, dbo.aspnet_Users u, dbo.aspnet_Membership m
        WHERE    LOWER(@ApplicationName) = a.LoweredApplicationName AND
                u.ApplicationId = a.ApplicationId    AND
                LOWER(@UserName) = u.LoweredUserName AND u.UserId = m.UserId

        IF (@@ROWCOUNT = 0) -- Username not found
            RETURN -1

        UPDATE   dbo.aspnet_Users
        SET      LastActivityDate = @CurrentTimeUtc
        WHERE    @UserId = UserId
    END
    ELSE
    BEGIN
        SELECT TOP 1 m.Email, m.PasswordQuestion, m.Comment, m.IsApproved,
                m.CreateDate, m.LastLoginDate, u.LastActivityDate, m.LastPasswordChangedDate,
                u.UserId, m.IsLockedOut,m.LastLockoutDate
        FROM    dbo.aspnet_Applications a, dbo.aspnet_Users u, dbo.aspnet_Membership m
        WHERE    LOWER(@ApplicationName) = a.LoweredApplicationName AND
                u.ApplicationId = a.ApplicationId    AND
                LOWER(@UserName) = u.LoweredUserName AND u.UserId = m.UserId

        IF (@@ROWCOUNT = 0) -- Username not found
            RETURN -1
    END

    RETURN 0
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_NostroBalanceAndVariation_GetByMatchCode]''
');

GO
SET QUOTED_IDENTIFIER ON

GO
EXECUTE ('/*
<details>
 <summary>Computes and Returns the Statement and Ledger Closing Balance, the Less Open Statement receipts, the Plus open statement payments
          the Plus open Ledger receipts, the Less open Ledger payments, the Reconciliation Ledger balance and the Variation</summary>
 <created author="Petru K. Bercea" Date="Friday, 26 Feb 2009 10:02PM GMT" /> 
</details>

-- KevinP	11 Sep 2009		Added in extra selects mainly for issue MBAL-12843 - Reconciliation Statement. Changes include returning 
--							the match code descrioption, account numbers for Internal and External, and also including counts for Ledger & Statement Payments and Receipts.
*/
CREATE PROCEDURE [dbo].[ib_NostroBalanceAndVariation_GetByMatchCode]
(
	 @MatchCodeId int
)
AS
SET NOCOUNT ON
BEGIN

	DECLARE @ClosingStatementBalance decimal(18,4) 
    DECLARE @ClosingLedgerBalance decimal(18,4)
    DECLARE @LessOpenStatementReceipts decimal(18,4)
    DECLARE @PlusOpenStatementPayments decimal(18,4)
	DECLARE @LessOpenLedgerPayments decimal(18,4) 
    DECLARE @PlusOpenLedgerReceipts decimal(18,4)
	DECLARE @ReconciliationLedgerBalance decimal(18,4)
	DECLARE @Variation decimal(18,4) 
    DECLARE @LatestBalanceDate datetime		

	--KevinP 11 Sep 2009 - Adding Counts and CurrencyCode and Date This SP was Run
	DECLARE @StatementReceiptsCount INT	
	DECLARE @StatementPaymentsCount	INT
	DECLARE @LedgerPaymentsCount INT
	DECLARE @LedgerReceiptsCount INT
	DECLARE @CurrencyCode VARCHAR(10)
	DECLARE @CheckpointDate DATETIME
	DECLARE @InternalAccountNumbers VARCHAR(MAX)
	DECLARE @ExternalAccountNumbers VARCHAR(MAX)
	DECLARE @MatchCode VARCHAR(MAX)

	--Get MatchCode Description
	SELECT @MatchCode = MatchCode FROM ib_MatchCode
	WHERE MatchCodeId=@MatchCodeId
	IF (@MatchCode IS NULL)
		SET @MatchCode = ''''''''

	-- Get the Ledger and Statement Closing Balance for MatchCode.
	SELECT @ClosingLedgerBalance = nb.InternalBalance, @ClosingStatementBalance = nb.ExternalBalance
    FROM [ib_NostroBalance] nb
    WHERE nb.[MatchCodeId] = @MatchCodeId
    AND nb.[BalanceDate] = (SELECT MAX(BalanceDate) AS LatestBalanceDate 
							FROM [ib_NostroBalance] nb1 
							WHERE nb1.MatchCodeId = @MatchCodeId)

	-- Because the Match Codes could be for a number of Accounts, then lets get the Account Numbers in  a comma seperated list....
	SELECT @InternalAccountNumbers = CASE WHEN CHARINDEX(a.[Code],ISNULL(@InternalAccountNumbers,'''')) = 0  THEN coalesce(@InternalAccountNumbers + '', '', '''') + a.[Code] ELSE @InternalAccountNumbers END
	FROM [ib_Nostro] n
	INNER JOIN ib_MatchCode mc ON mc.MatchCodeId = @MatchCodeId
	INNER JOIN ib_Account a ON a.AccountId=n.AccountId
	INNER JOIN ib_Firm f ON f.FirmId=a.FirmId 
	INNER JOIN ib_TemplateCompare tc ON tc.DataSourceId=n.DataSourceId AND tc.FirmId=f.FirmId AND tc.TemplateId = mc.TemplateId
	LEFT JOIN ib_NostroMatch nm ON nm.NostroId=n.NostroId
	INNER JOIN ib_TemplateGroup tg ON tg.TemplateId=mc.TemplateId AND tg.AccountId=n.AccountId  AND tg.CurrencyId=n.CurrencyId AND tg.Description = mc.MatchCode
	WHERE  tc.InternalExternalCode=''I''

	SELECT @ExternalAccountNumbers = CASE WHEN CHARINDEX(a.[Code],ISNULL(@ExternalAccountNumbers,'''')) = 0  THEN coalesce(@ExternalAccountNumbers + '', '', '''') + a.[Code] ELSE @ExternalAccountNumbers END
	FROM [ib_Nostro] n
	INNER JOIN ib_MatchCode mc ON mc.MatchCodeId = @MatchCodeId 
	INNER JOIN ib_Account a ON a.AccountId=n.AccountId
	INNER JOIN ib_Firm f ON f.FirmId=a.FirmId 
	INNER JOIN ib_TemplateCompare tc ON tc.DataSourceId=n.DataSourceId AND tc.FirmId=f.FirmId AND tc.TemplateId = mc.TemplateId
	LEFT JOIN ib_NostroMatch nm ON nm.NostroId=n.NostroId
	INNER JOIN ib_TemplateGroup tg ON tg.TemplateId=mc.TemplateId AND tg.AccountId=n.AccountId  AND tg.CurrencyId=n.CurrencyId AND tg.Description = mc.MatchCode
	WHERE tc.InternalExternalCode=''E''


	-- Now lets get the data 
	SELECT 

		@LessOpenStatementReceipts = SUM(CASE WHEN nm.NostroMatchId IS NOT NULL THEN 0
											ELSE CASE WHEN tc.InternalExternalCode=''I'' THEN 0 
												ELSE CASE WHEN Amount<0 THEN 0 
													ELSE ABS(Amount) 
												END 
											END 
										END),

		@PlusOpenStatementPayments = SUM(CASE WHEN nm.NostroMatchId IS NOT NULL THEN 0
											ELSE CASE WHEN tc.InternalExternalCode=''I'' THEN 0	
												ELSE CASE WHEN Amount>0 THEN 0 
													ELSE ABS(Amount) 
												END 
											END 
										END),

		@LessOpenLedgerPayments = SUM(CASE WHEN nm.NostroMatchId IS NOT NULL THEN 0
										ELSE CASE WHEN tc.InternalExternalCode=''E'' THEN 0	
											ELSE CASE WHEN Amount>0 THEN 0 
												ELSE ABS(Amount) 
											END 
										END 
									END),

		@PlusOpenLedgerReceipts = SUM(CASE WHEN nm.NostroMatchId IS NOT NULL THEN 0
										ELSE CASE WHEN tc.InternalExternalCode=''E'' THEN 0 
											ELSE CASE WHEN Amount<0 THEN 0 
												ELSE ABS(Amount) 
											END 
										END 
									END),

		--KevinP - Adding Counts for Internal Payments & Receipts, as well as External Payments and Receipts
		@StatementReceiptsCount = COUNT(CASE WHEN nm.NostroMatchId IS NOT NULL THEN null
											ELSE CASE WHEN tc.InternalExternalCode=''I'' THEN null
												ELSE CASE WHEN Amount<0 THEN null
													ELSE 1
												END 
											END 
										END),

		@StatementPaymentsCount = COUNT(CASE WHEN nm.NostroMatchId IS NOT NULL THEN null
											ELSE CASE WHEN tc.InternalExternalCode=''I'' THEN null	
												ELSE CASE WHEN Amount>0 THEN null 
													ELSE 1 
												END 
											END 
										END),

		@LedgerPaymentsCount = COUNT(CASE WHEN nm.NostroMatchId IS NOT NULL THEN null
										ELSE CASE WHEN tc.InternalExternalCode=''E'' THEN null	
											ELSE CASE WHEN Amount>0 THEN null 
												ELSE 1
											END 
										END 
									END),

		@LedgerReceiptsCount = COUNT(CASE WHEN nm.NostroMatchId IS NOT NULL THEN null
										ELSE CASE WHEN tc.InternalExternalCode=''E'' THEN null
											ELSE CASE WHEN Amount<0 THEN null
												ELSE 1
											END 
										END 
									END),
		@CurrencyCode = MIN(cur.[Code]),
		@CheckpointDate = MAX(n.CreateDate)
	FROM [ib_Nostro] n
	INNER JOIN ib_MatchCode mc ON mc.MatchCodeId = @MatchCodeId
	INNER JOIN ib_Account a ON a.AccountId=n.AccountId
	INNER JOIN ib_Firm f ON f.FirmId=a.FirmId 
	INNER JOIN ib_TemplateCompare tc ON tc.DataSourceId=n.DataSourceId AND tc.FirmId=f.FirmId AND tc.TemplateId = mc.TemplateId
	LEFT JOIN ib_NostroMatch nm ON nm.NostroId=n.NostroId
	INNER JOIN ib_TemplateGroup tg ON tg.TemplateId=mc.TemplateId AND tg.AccountId=n.AccountId  AND tg.CurrencyId=n.CurrencyId AND tg.Description = mc.MatchCode
	INNER JOIN ib_Currency cur ON tg.CurrencyId = cur.CurrencyId

	SET @ReconciliationLedgerBalance = @ClosingStatementBalance - @LessOpenStatementReceipts + @PlusOpenStatementPayments - @LessOpenLedgerPayments + @PlusOpenLedgerReceipts 
	SET @Variation = @ReconciliationLedgerBalance - @ClosingLedgerBalance 

	SELECT @ClosingStatementBalance ClosingStatementBalance, @LessOpenStatementReceipts LessOpenStatementReceipts, 
	@PlusOpenStatementPayments PlusOpenStatementPayments, @PlusOpenLedgerReceipts PlusOpenLedgerReceipts,  
	@LessOpenLedgerPayments LessOpenLedgerPayments, @ReconciliationLedgerBalance ReconciliationLedgerBalance, 
	@ClosingLedgerBalance ClosingLedgerBalance, @Variation Variation, 
	@StatementReceiptsCount StatementReceiptsCount,
	@StatementPaymentsCount	StatementPaymentsCount,
	@LedgerPaymentsCount LedgerPaymentsCount,
	@LedgerReceiptsCount LedgerReceiptsCount,
	@CurrencyCode AS CurrencyCode,
	@InternalAccountNumbers AS InternalAccountNumbers,
	@ExternalAccountNumbers AS ExternalAccountNumbers,
	@CheckpointDate CheckPointDate

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Adjustment_GetByMatchCodeId]''
');

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Select records from the ib_Adjustment table through a foreign key
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[ib_Adjustment_GetByMatchCodeId]
(

	@MatchCodeId int   
)
AS


				SET ANSI_NULLS ON
				
				SELECT
					[AdjustmentId],
					[TemplateId],
					[ExchangeId],
					[InstrumentId],
					[InternalExternalCode],
					[TradeDate],
					[AdjustmentDate],
					[Quantity],
					[CurrencyId],
					[ExpiryYear],
					[ExpiryMonth],
					[ExpiryDay],
					[StrikePrice],
					[TradePrice],
					[SettlementPrice],
					[OptionTypeCode],
					[Value],
					[PremiumValue],
					[OptionValue],
					[Description],
					[TemplateGroupId],
					[CreateDate],
					[CreateUsername],
					[UpdateDate],
					[UpdateUsername],
					[IsBuy],
					[MatchCodeId],
					[AdjustmentHeaderId],
					[DataSourceId],
					[FirmId],
					[QuantityLong],
					[QuantityShort],
					[DetailAccountId],
					[AccountId],
					[ClassId],
					[AdjustmentStatusId],
					[AdjustmentReasonId],
					[TrxTypeCode],
					[AdjustmentUserStatusId],
					[MatchingAdjustmentId],
					[ReplacesAdjustmentId]
				FROM
					[dbo].[ib_Adjustment]
				WHERE
					[MatchCodeId] = @MatchCodeId
				
				SELECT @@ROWCOUNT
				SET ANSI_NULLS ON
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_FirmDataSource_GetFirmDataSourceById]''
');

GO
EXECUTE ('  /*
<details>
 <summary> Selectes a firm data source from the ib_FirmDataSource table by its id</summary>
 <created author="Laurentiu Macovei" Date="Tuesday, 12 September 2006 9:34PM GMT" /> 
 <updated author="laurentiu.macovei" date="Sun, 24 Sep 2006 17:30:29 GMT">
   Added DadataSourceCode to output.
 </updated>
 <updated author="laurentiu.macovei" date="Mon, 9 Oct 2006 12:11:29 GMT">
	Added FirmCode to Output
 </updated>	
</details>
*/
CREATE PROCEDURE [dbo].[ib_FirmDataSource_GetFirmDataSourceById]
(
	@FirmDataSourceId int
)
AS 
SET NOCOUNT ON


SELECT fds.[FirmDataSourceId]
      ,fds.[FirmId]
      ,fds.[DataSourceId]
	  ,ds.[Name] as DataSourceName
	  ,ds.[Code] as DataSourceCode
	  ,f.[Code] as FirmCode
      ,fds.[DataSourceFirmCode]
      ,fds.[CreateDate]
      ,fds.[CreateUsername]
      ,fds.[UpdateDate]
      ,fds.[UpdateUsername]
  FROM [dbo].[ib_FirmDataSource] fds
INNER JOIN [dbo].[ib_DataSource] ds ON ds.[DataSourceId] = fds.[DataSourceId]
INNER JOIN [dbo].[ib_Firm] f ON f.[FirmId] = fds.[FirmId]
WHERE FirmDataSourceId = @FirmDataSourceId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Account_GetFamilyCodesHintByKeyword]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Account_GetFamilyCodesHintByKeyword]
@FamilyCode varchar(100),
@HintByStartOnly bit = 0,
@HintLength int = 1
AS
SET NOCOUNT ON
--	22 May 2012	ED MBAL 20398 - add filter for family code
DECLARE @len int
SET @len = LEN(@FamilyCode)
IF @HintByStartOnly = 1
BEGIN
	SELECT DISTINCT SUBSTRING (FamilyCode, @len, @HintLength) x
		FROM [dbo].[ib_Account]
		WHERE FamilyCode LIKE @FamilyCode+''%''
		ORDER BY x

END
ELSE
BEGIN
	SELECT DISTINCT SUBSTRING (FamilyCode, PATINDEX(''%''+@FamilyCode+''%'', FamilyCode) + @len, @HintLength) x
		FROM [dbo].[ib_Account]
		WHERE FamilyCode LIKE ''%''+@FamilyCode+''%''
		ORDER BY x
END
');

GO
EXECUTE ('PRINT N''Creating [stage].[MacquariePosition_Purge]''
');

GO
EXECUTE ('CREATE PROCEDURE [stage].[MacquariePosition_Purge]
	(
		@LoadState		TINYINT = 0,
		@FileName       VARCHAR (512)= NULL
	)
AS
-- Description: Deletes from stage.MacquariePosition table all the records where the LoadState is 0

-- 23 Jun 2014	ED	EIB 25760 - Creation

-- History:

BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
	DELETE FROM stage.MacquariePosition WHERE LoadState= @LoadState AND [FileName] = Coalesce(@FileName, [FileName])

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[aspnet_Membership_GetUserByUserId]''
');

GO
SET QUOTED_IDENTIFIER OFF

GO
EXECUTE ('CREATE PROCEDURE [dbo].[aspnet_Membership_GetUserByUserId]
    @UserId               uniqueidentifier,
    @CurrentTimeUtc       datetime,
    @UpdateLastActivity   bit = 0
AS
SET NOCOUNT ON
BEGIN
    IF ( @UpdateLastActivity = 1 )
    BEGIN
        UPDATE   dbo.aspnet_Users
        SET      LastActivityDate = @CurrentTimeUtc
        FROM     dbo.aspnet_Users
        WHERE    @UserId = UserId

        IF ( @@ROWCOUNT = 0 ) -- User ID not found
            RETURN -1
    END

    SELECT  m.Email, m.PasswordQuestion, m.Comment, m.IsApproved,
            m.CreateDate, m.LastLoginDate, u.LastActivityDate,
            m.LastPasswordChangedDate, u.UserName, m.IsLockedOut,
            m.LastLockoutDate
    FROM    dbo.aspnet_Users u, dbo.aspnet_Membership m
    WHERE   @UserId = u.UserId AND u.UserId = m.UserId

    IF ( @@ROWCOUNT = 0 ) -- User ID not found
       RETURN -1

    RETURN 0
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TradeReconciliationSummary_GetSettlementPriceAndMessage]''
');

GO
SET QUOTED_IDENTIFIER ON

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_TradeReconciliationSummary_GetSettlementPriceAndMessage]
	@TradeReconciliationSummaryId INT,
	@IsMulti BIT = 0,
	@Message VARCHAR(4000) OUTPUT,
	@SettlementPrice DECIMAL (24,10) = NULL OUTPUT
AS
SET NOCOUNT ON
/*
--	get settlement price and message(if any)
--	Created 24 Jun 2010 ED
--  24 Jun 2010 ED MBAL 15712 - Improved logic for SettlementPrice
--	10 Jul 2012 ED MBAL 21151 - Try to get ignoring datasource
*/
BEGIN
DECLARE @ExchangeId INT
DECLARE @TemplateId INT
DECLARE @MatchCode VARCHAR(100)
DECLARE @CurrencyId INT
DECLARE @TradeReconciliationId INT
DECLARE @RepTradRecSummaryId INT

DECLARE		@AsOfDate DATETIME
DECLARE     @DataSourceId INT, @OtherDataSourceId INT
DECLARE     @InstrumentId INT
DECLARE     @ExpiryYear SMALLINT
DECLARE     @ExpiryMonth SMALLINT
DECLARE     @ExpiryDay SMALLINT
DECLARE     @StrikePrice MONEY
DECLARE     @OptionTypeCode VARCHAR(25)
SET @Message = ''''
--get all needed data
SELECT @ExchangeId = ExchangeId, @MatchCode = MatchCode, @CurrencyId=CurrencyId, @TradeReconciliationId = TradeReconciliationId
	FROM ib_TradeReconciliationSummary 
	WHERE TradeReconciliationSummaryId = @TradeReconciliationSummaryId

	DECLARE group_cursor CURSOR FOR
	SELECT TradeReconciliationSummaryId FROM ib_TradeReconciliationSummary
		WHERE 
			ExchangeId = @ExchangeId 
			AND MatchCode = @MatchCode 
			AND CurrencyId=@CurrencyId 
			AND TradeReconciliationId = @TradeReconciliationId
			AND (DifferenceLong != 0 OR DifferenceShort != 0)
			AND (@IsMulti=1 OR TradeReconciliationSummaryId = @TradeReconciliationSummaryId) -- if not multi, get all
	
	OPEN group_cursor
	
	FETCH NEXT FROM group_cursor
	INTO @RepTradRecSummaryId
		
	-- Check @@FETCH_STATUS to see IF there are any more rows to fetch.
	WHILE @@FETCH_STATUS = 0
	BEGIN
	
		 SET @SettlementPrice = NULL
		 SELECT @AsOfDate = Today, @InstrumentId = InstrumentId,  @ExpiryYear = ExpiryYear, @ExpiryMonth = ExpiryMonth,
				@ExpiryDay = ExpiryDay, @StrikePrice = StrikePrice, @OptionTypeCode = OptionTypeCode, @TemplateId = TemplateId, @MatchCode = MatchCode
		 FROM ib_TradeReconciliationSummary trs 
			INNER JOIN ib_TradeReconciliation tr ON tr.TradeReconciliationId = trs.TradeReconciliationId
			WHERE TradeReconciliationSummaryId = @RepTradRecSummaryId
		 --do it only for IF @InstrumentTypeCode = ''F'' OR @InstrumentTypeCode = ''O'' 
		 DECLARE @InstrumentTypeCode VARCHAR(50)

		--get instrument type

		 SET @InstrumentTypeCode = (SELECT it.Code FROM ib_InstrumentType it INNER JOIN ib_Instrument i ON i.InstrumentTypeId=it.InstrumentTypeId WHERE InstrumentId = @InstrumentId)
		 
		 IF @InstrumentTypeCode = ''F'' OR @InstrumentTypeCode = ''O'' 
			 BEGIN
				 SET @DataSourceId = (SELECT [dbo].[GetDataSourceIdForTradeAdjustments]( @TemplateId,@InstrumentId,@ExchangeId ,@MatchCode,''I''))
				 SET @OtherDataSourceId = (SELECT [dbo].[GetDataSourceIdForTradeAdjustments]( @TemplateId,@InstrumentId,@ExchangeId ,@MatchCode,''E''))
				 
				 --set @DataSourceId, @OtherDataSourceId based on what insert will we do(internal and/or external)
				 --check for internal one
				 SET @SettlementPrice = (SELECT dbo.GetSettlementPriceByAlternateKey(@AsOfDate, @DataSourceId,
											@ExchangeId, @InstrumentId, @CurrencyId, 
											@ExpiryYear, @ExpiryMonth, @ExpiryDay, @StrikePrice, @OptionTypeCode))
				--not found as we expected, so we need to do extra cases and warn/confirm
				IF @SettlementPrice IS NULL
				BEGIN
					DECLARE @InfoTable TABLE(SettlementPrice DECIMAL(24,10), AsOfDate DATETIME, DataSourceId INT)
					DELETE FROM @InfoTable WHERE 1=1
					
					SET @SettlementPrice = (SELECT dbo.GetSettlementPriceByAlternateKey(@AsOfDate, @OtherDataSourceId,
											@ExchangeId, @InstrumentId, @CurrencyId, 
											@ExpiryYear, @ExpiryMonth, @ExpiryDay, @StrikePrice, @OptionTypeCode))
				
					IF @SettlementPrice IS NOT NULL
						INSERT INTO @InfoTable(SettlementPrice, AsOfDate, DataSourceId)
								VALUES(@SettlementPrice, @AsOfDate, @OtherDataSourceId)
					ELSE	
						INSERT INTO @InfoTable(SettlementPrice, AsOfDate, DataSourceId)
							EXEC ib_Price_GetPreviousByAlternateKey @AsOfDate,@DataSourceId, @OtherDataSourceId, @ExchangeId,@InstrumentId,@CurrencyId,@ExpiryYear
								,@ExpiryMonth,@ExpiryDay,@StrikePrice,@OptionTypeCode, @SettlementPrice OUTPUT
						
					DECLARE @InstrumentCode VARCHAR(100), @DataSourceCode VARCHAR(100),@ExpiryMonthCode VARCHAR(3), @StrikePriceFormat VARCHAR(100), @AsOfDateCode VARCHAR(20)
					SET @InstrumentCode = (SELECT Code FROM ib_Instrument WHERE InstrumentId = @InstrumentId)
					SET @DataSourceCode = (SELECT [Name] FROM ib_DataSource ds INNER JOIN @InfoTable it ON it.DataSourceId = ds.DataSourceId)
					SET @ExpiryMonthCode = CONVERT(VARCHAR(3),CAST(''2010-''+CONVERT(VARCHAR,@ExpiryMonth)+''-01'' AS DATETIME),107)
					SET @StrikePriceFormat = CONVERT(VARCHAR, CONVERT(DECIMAL(24,4),@StrikePrice))
					SET @AsOfDateCode =  (SELECT CONVERT(VARCHAR,AsOfDate,103) FROM @InfoTable)
					IF @SettlementPrice = 0
						SET @Message = @Message + ''Zero settlement price has been used for '' + @InstrumentCode + '' '' + @ExpiryMonthCode + '' '' + CONVERT(VARCHAR,@ExpiryYear) + '' '' + @OptionTypeCode + '' '' + @StrikePriceFormat + ''. ''
					ELSE
						SET @Message = @Message + ''Settlement Price from ''+ @DataSourceCode + '' As Of ''+ @AsOfDateCode + '' has been used for '' + @InstrumentCode + '' '' + @ExpiryMonthCode + '' '' + CONVERT(VARCHAR,@ExpiryYear) + '' '' + @OptionTypeCode + '' '' + @StrikePriceFormat + ''. ''
				END	--end find other one
			END --end instrument type
		FETCH NEXT FROM group_cursor
		INTO @RepTradRecSummaryId
	END
						
	CLOSE group_cursor
	DEALLOCATE group_cursor
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_NostroMatch_DeleteMatchGroup]''
');

GO
SET ANSI_NULLS OFF

GO
EXECUTE ('/*
----------------------------------------------------------------------------------------------------

-- 16 Feb 09 : ED created
-- 20 Oct 09 : amk : MBAL-13528 - No need to delete any nostro records as two equal and opposite items were created
-- 21 Oct 09 : amk : MBAL-13528 - continue work on above item
-- 02 Jul 12: ED	MBAL 20233 - create a new column for NostroMatch
-- Purpose: delete nostro match group and balancing item
*/


CREATE PROCEDURE [dbo].[ib_NostroMatch_DeleteMatchGroup]
(
	@GroupNumber INT
	, @Username VARCHAR(50)
)
AS
SET NOCOUNT ON
BEGIN

	BEGIN TRANSACTION t1

	DECLARE @NostroBalancingItemId INT
	SELECT @NostroBalancingItemId = NostroBalancingItemId
	FROM ib_NostroBalancingItem
	WHERE GroupNumber = @GroupNumber

	UPDATE ib_Nostro
	SET NostroBalancingItemId = NULL
		, UpdateUsername = @Username
		, UpdateDate = GETDATE()
	WHERE NostroBalancingItemId = @NostroBalancingItemId

	UPDATE ib_Nostro
	SET ib_Nostro.NostroMatchId = NULL
		, ib_Nostro.UpdateUsername = @Username
		, ib_Nostro.UpdateDate = GETDATE()
	FROM ib_Nostro n INNER JOIN ib_NostroMatch nm ON n.NostroId=nm.NostroId
	WHERE GroupNumber = @GroupNumber

	DELETE FROM ib_NostroBalancingItem 
	WHERE GroupNumber = @GroupNumber

	DELETE FROM ib_NostroMatch 
	WHERE GroupNumber = @GroupNumber

	COMMIT TRANSACTION t1

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Adjustment_GetByReplacesAdjustmentId]''
');

GO
SET ANSI_NULLS ON

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Select records from the ib_Adjustment table through a foreign key
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[ib_Adjustment_GetByReplacesAdjustmentId]
(

	@ReplacesAdjustmentId int   
)
AS


				SET ANSI_NULLS ON
				
				SELECT
					[AdjustmentId],
					[TemplateId],
					[ExchangeId],
					[InstrumentId],
					[InternalExternalCode],
					[TradeDate],
					[AdjustmentDate],
					[Quantity],
					[CurrencyId],
					[ExpiryYear],
					[ExpiryMonth],
					[ExpiryDay],
					[StrikePrice],
					[TradePrice],
					[SettlementPrice],
					[OptionTypeCode],
					[Value],
					[PremiumValue],
					[OptionValue],
					[Description],
					[TemplateGroupId],
					[CreateDate],
					[CreateUsername],
					[UpdateDate],
					[UpdateUsername],
					[IsBuy],
					[MatchCodeId],
					[AdjustmentHeaderId],
					[DataSourceId],
					[FirmId],
					[QuantityLong],
					[QuantityShort],
					[DetailAccountId],
					[AccountId],
					[ClassId],
					[AdjustmentStatusId],
					[AdjustmentReasonId],
					[TrxTypeCode],
					[AdjustmentUserStatusId],
					[MatchingAdjustmentId],
					[ReplacesAdjustmentId]
				FROM
					[dbo].[ib_Adjustment]
				WHERE
					[ReplacesAdjustmentId] = @ReplacesAdjustmentId
				
				SELECT @@ROWCOUNT
				SET ANSI_NULLS ON
			

');

GO
EXECUTE ('PRINT N''Creating [stage].[MacquarieTrade_LoadStateChange]''
');

GO
EXECUTE ('CREATE PROCEDURE [stage].[MacquarieTrade_LoadStateChange]
	(
		@OldLoadState	TINYINT,
		@NewLoadState	TINYINT,
		@FileName       VARCHAR (512)= NULL
	)
AS

-- Description: Changes the LoadState of the stage.MacquarieTrade type table

-- 20 Jun 2014	ED	EIB 25759 - Creation

BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	UPDATE stage.MacquarieTrade SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState AND [FileName] = Coalesce(@FileName, [FileName])

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[aspnet_Membership_ResetPassword]''
');

GO
SET QUOTED_IDENTIFIER OFF

GO
EXECUTE ('CREATE PROCEDURE [dbo].[aspnet_Membership_ResetPassword]
    @ApplicationName             nvarchar(256),
    @UserName                    nvarchar(256),
    @NewPassword                 nvarchar(128),
    @MaxInvalidPasswordAttempts  int,
    @PasswordAttemptWindow       int,
    @PasswordSalt                nvarchar(128),
    @CurrentTimeUtc              datetime,
    @PasswordFormat              int = 0,
    @PasswordAnswer              nvarchar(128) = NULL
AS
SET NOCOUNT ON
BEGIN
    DECLARE @IsLockedOut                            bit
    DECLARE @LastLockoutDate                        datetime
    DECLARE @FailedPasswordAttemptCount             int
    DECLARE @FailedPasswordAttemptWindowStart       datetime
    DECLARE @FailedPasswordAnswerAttemptCount       int
    DECLARE @FailedPasswordAnswerAttemptWindowStart datetime

    DECLARE @UserId                                 uniqueidentifier
    SET     @UserId = NULL

    DECLARE @ErrorCode     int
    SET @ErrorCode = 0

    DECLARE @TranStarted   bit
    SET @TranStarted = 0

    IF( @@TRANCOUNT = 0 )
    BEGIN
	    BEGIN TRANSACTION
	    SET @TranStarted = 1
    END
    ELSE
    	SET @TranStarted = 0

    SELECT  @UserId = u.UserId
    FROM    dbo.aspnet_Users u, dbo.aspnet_Applications a, dbo.aspnet_Membership m
    WHERE   LoweredUserName = LOWER(@UserName) AND
            u.ApplicationId = a.ApplicationId  AND
            LOWER(@ApplicationName) = a.LoweredApplicationName AND
            u.UserId = m.UserId

    IF ( @UserId IS NULL )
    BEGIN
        SET @ErrorCode = 1
        GOTO Cleanup
    END

    SELECT @IsLockedOut = IsLockedOut,
           @LastLockoutDate = LastLockoutDate,
           @FailedPasswordAttemptCount = FailedPasswordAttemptCount,
           @FailedPasswordAttemptWindowStart = FailedPasswordAttemptWindowStart,
           @FailedPasswordAnswerAttemptCount = FailedPasswordAnswerAttemptCount,
           @FailedPasswordAnswerAttemptWindowStart = FailedPasswordAnswerAttemptWindowStart
    FROM dbo.aspnet_Membership WITH ( UPDLOCK )
    WHERE @UserId = UserId

    IF( @IsLockedOut = 1 )
    BEGIN
        SET @ErrorCode = 99
        GOTO Cleanup
    END

    UPDATE dbo.aspnet_Membership
    SET    Password = @NewPassword,
           LastPasswordChangedDate = @CurrentTimeUtc,
           PasswordFormat = @PasswordFormat,
           PasswordSalt = @PasswordSalt
    WHERE  @UserId = UserId AND
           ( ( @PasswordAnswer IS NULL ) OR ( LOWER( PasswordAnswer ) = LOWER( @PasswordAnswer ) ) )

    IF ( @@ROWCOUNT = 0 )
        BEGIN
            IF( @CurrentTimeUtc > DATEADD( minute, @PasswordAttemptWindow, @FailedPasswordAnswerAttemptWindowStart ) )
            BEGIN
                SET @FailedPasswordAnswerAttemptWindowStart = @CurrentTimeUtc
                SET @FailedPasswordAnswerAttemptCount = 1
            END
            ELSE
            BEGIN
                SET @FailedPasswordAnswerAttemptWindowStart = @CurrentTimeUtc
                SET @FailedPasswordAnswerAttemptCount = @FailedPasswordAnswerAttemptCount + 1
            END

            BEGIN
                IF( @FailedPasswordAnswerAttemptCount >= @MaxInvalidPasswordAttempts )
                BEGIN
                    SET @IsLockedOut = 1
                    SET @LastLockoutDate = @CurrentTimeUtc
                END
            END

            SET @ErrorCode = 3
        END
    ELSE
        BEGIN
            IF( @FailedPasswordAnswerAttemptCount > 0 )
            BEGIN
                SET @FailedPasswordAnswerAttemptCount = 0
                SET @FailedPasswordAnswerAttemptWindowStart = CONVERT( datetime, ''17540101'', 112 )
            END
        END

    IF( NOT ( @PasswordAnswer IS NULL ) )
    BEGIN
        UPDATE dbo.aspnet_Membership
        SET IsLockedOut = @IsLockedOut, LastLockoutDate = @LastLockoutDate,
            FailedPasswordAttemptCount = @FailedPasswordAttemptCount,
            FailedPasswordAttemptWindowStart = @FailedPasswordAttemptWindowStart,
            FailedPasswordAnswerAttemptCount = @FailedPasswordAnswerAttemptCount,
            FailedPasswordAnswerAttemptWindowStart = @FailedPasswordAnswerAttemptWindowStart
        WHERE @UserId = UserId

        IF( @@ERROR <> 0 )
        BEGIN
            SET @ErrorCode = -1
            GOTO Cleanup
        END
    END

    IF( @TranStarted = 1 )
    BEGIN
	SET @TranStarted = 0
	COMMIT TRANSACTION
    END

    RETURN @ErrorCode

Cleanup:

    IF( @TranStarted = 1 )
    BEGIN
        SET @TranStarted = 0
    	ROLLBACK TRANSACTION
    END

    RETURN @ErrorCode

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_NostroMatch_SplitNostro]''
');

GO
SET QUOTED_IDENTIFIER ON

GO
EXECUTE ('/*
----------------------------------------------------------------------------------------------------

-- 17 Feb 09 : ED created
-- Purpose: split nostro record into multiple nostro records
-- 27 Feb 09: Fix for negative values
*/

CREATE PROCEDURE [dbo].[ib_NostroMatch_SplitNostro]
(
	@NostroId int
	,@SplitValue decimal(15,2)
	,@NoItems int
	,@RemainingValue decimal(15,2)
	,@Narrative varchar(2000)
)	
AS
SET NOCOUNT ON
BEGIN
	DECLARE @INDEX int
	DECLARE @Modificator INT
	
	DECLARE @SplitAmount decimal(15,2)
	SET @SplitAmount = @SplitValue/@NoItems
	SELECT @Modificator=(CASE WHEN Amount>=0 THEN 1 ELSE -1 END) FROM ib_nostro WHERE NostroId=@NostroId
	SET @INDEX = 1
	
	WHILE @INDEX<=@NoItems
	BEGIN
		DECLARE @SplitNarrative varchar(2000)
		SET @SplitNarrative = @Narrative+'' ''+cast(@INDEX as Varchar)
		INSERT INTO ib_Nostro([ValueDate],[TransDate],[Amount],[TransactionType],[InternalReference],[ExternalReference]
           ,[Narrative],[AccountId],[CurrencyId],[DataSourceId],[TempTableRecordId])
		SELECT [ValueDate],[TransDate],@SplitAmount*@Modificator,[TransactionType],[InternalReference],[ExternalReference]
           ,@SplitNarrative,[AccountId],[CurrencyId],[DataSourceId],[TempTableRecordId]
		FROM ib_Nostro WHERE NostroId=@NostroId
		SET @INDEX = @INDEX + 1
	END
	UPDATE ib_Nostro SET Amount=@RemainingValue*@Modificator WHERE NostroId=@NostroId
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Adjustment_GetByExchangeId]''
');

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Select records from the ib_Adjustment table through a foreign key
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[ib_Adjustment_GetByExchangeId]
(

	@ExchangeId int   
)
AS


				SET ANSI_NULLS ON
				
				SELECT
					[AdjustmentId],
					[TemplateId],
					[ExchangeId],
					[InstrumentId],
					[InternalExternalCode],
					[TradeDate],
					[AdjustmentDate],
					[Quantity],
					[CurrencyId],
					[ExpiryYear],
					[ExpiryMonth],
					[ExpiryDay],
					[StrikePrice],
					[TradePrice],
					[SettlementPrice],
					[OptionTypeCode],
					[Value],
					[PremiumValue],
					[OptionValue],
					[Description],
					[TemplateGroupId],
					[CreateDate],
					[CreateUsername],
					[UpdateDate],
					[UpdateUsername],
					[IsBuy],
					[MatchCodeId],
					[AdjustmentHeaderId],
					[DataSourceId],
					[FirmId],
					[QuantityLong],
					[QuantityShort],
					[DetailAccountId],
					[AccountId],
					[ClassId],
					[AdjustmentStatusId],
					[AdjustmentReasonId],
					[TrxTypeCode],
					[AdjustmentUserStatusId],
					[MatchingAdjustmentId],
					[ReplacesAdjustmentId]
				FROM
					[dbo].[ib_Adjustment]
				WHERE
					[ExchangeId] = @ExchangeId
				
				SELECT @@ROWCOUNT
				SET ANSI_NULLS ON
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Adjustment_Add]''
');

GO
EXECUTE ('
/*
<details>
 <summary> Inserts an instrument in the ib_Intrument table</summary>
 <created author="Laurentiu Macovei" Date="Thursday, 20 August 2006 14:28 GMT" /> 
 <updated author="Laurentiu Macovei" Date="Monday, 23 October 2006 12:43 GMT"> 
	Changed SettlementPrice and TradePrice to 19,6
 </updated>
 <updated author="Laurentiu Macovei" Date="Tuesday, 1 November 2006 12:29 GMT"> 
	Added templateId
 </updated>
 <updated author="Anil Kripalani" Date="28 November 2006"> 
	Added premium value and option value
 </updated>
   <updated author="Alister McLeod" Date="09 February 2010"> 
	Added IsBuy
 </updated>
    <updated author="Alister McLeod" Date="23 April 2010"> 
	MBAL-15416 Increase size of SettlementPrice and TradePrice field
 </updated>
</details>
*/
CREATE PROCEDURE [dbo].[ib_Adjustment_Add]
@ExchangeId int,
@TemplateId int,
@InstrumentId int, 
@InternalExternalCode char(1), 
@TradeDate datetime, 
@AdjustmentDate datetime, 
@Quantity decimal(19,4), 
@CurrencyId int, 
@ExpiryYear smallint,
@ExpiryMonth smallint,
@ExpiryDay smallint,
@StrikePrice decimal(19,4), 
@TradePrice decimal(24,10), 
@SettlementPrice decimal(24,10), 
@OptionTypeCode varchar(25), 
@Value decimal(19,4), 
@Description varchar(255), 
@TemplateGroupId int, 
@CreateUsername varchar(50),
@AdjustmentID int OUTPUT,
@PremiumValue decimal(19,6),
@OptionValue decimal(19,6),
@IsBuy bit
AS
SET NOCOUNT ON

INSERT INTO [dbo].[ib_Adjustment]
           ([ExchangeId]
		   ,[TemplateId]
           ,[InstrumentId]
           ,[InternalExternalCode]
           ,[TradeDate]
           ,[AdjustmentDate]
           ,[Quantity]
           ,[CurrencyId]
           ,[ExpiryYear]
           ,[ExpiryMonth]
           ,[ExpiryDay]
           ,[StrikePrice]
           ,[TradePrice]
           ,[SettlementPrice]
           ,[OptionTypeCode]
           ,[Value]
           ,[Description]
           ,[TemplateGroupId]
           ,[CreateUsername]
           ,[PremiumValue]
           ,[OptionValue]
           ,[IsBuy]
			)
     VALUES
           (@ExchangeId, 
		   @TemplateId,
           @InstrumentId, 
           @InternalExternalCode, 
           @TradeDate, 
           @AdjustmentDate, 
           @Quantity, 
           @CurrencyId, 
           @ExpiryYear, 
           @ExpiryMonth,
           @ExpiryDay, 
           @StrikePrice, 
           @TradePrice, 
           @SettlementPrice, 
           @OptionTypeCode, 
           @Value, 
           @Description, 
           @TemplateGroupId,
           @CreateUsername,
           @PremiumValue, 
           @OptionValue,
           @IsBuy
			)
SELECT @AdjustmentId = Scope_Identity()
');

GO
EXECUTE ('PRINT N''Creating [stage].[MacquarieTrade_Purge]''
');

GO
EXECUTE ('CREATE PROCEDURE [stage].[MacquarieTrade_Purge]
	(
		@LoadState		TINYINT = 0,
		@FileName       VARCHAR (512)= NULL
	)
AS
-- Description: Deletes from stage.MacquarieTrade_ table all the records where the LoadState is 0

-- 20 Jun 2014	ED	EIB 25759 - Creation

-- History:

BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
	DELETE FROM stage.MacquarieTrade WHERE LoadState= @LoadState AND [FileName] = Coalesce(@FileName, [FileName])

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[aspnet_Membership_SetPassword]''
');

GO
SET QUOTED_IDENTIFIER OFF

GO
EXECUTE ('CREATE PROCEDURE [dbo].[aspnet_Membership_SetPassword]
    @ApplicationName  nvarchar(256),
    @UserName         nvarchar(256),
    @NewPassword      nvarchar(128),
    @PasswordSalt     nvarchar(128),
    @CurrentTimeUtc   datetime,
    @PasswordFormat   int = 0
AS
SET NOCOUNT ON
BEGIN
    DECLARE @UserId uniqueidentifier
    SELECT  @UserId = NULL
    SELECT  @UserId = u.UserId
    FROM    dbo.aspnet_Users u, dbo.aspnet_Applications a, dbo.aspnet_Membership m
    WHERE   LoweredUserName = LOWER(@UserName) AND
            u.ApplicationId = a.ApplicationId  AND
            LOWER(@ApplicationName) = a.LoweredApplicationName AND
            u.UserId = m.UserId

    IF (@UserId IS NULL)
        RETURN(1)

    UPDATE dbo.aspnet_Membership
    SET Password = @NewPassword, PasswordFormat = @PasswordFormat, PasswordSalt = @PasswordSalt,
        LastPasswordChangedDate = @CurrentTimeUtc
    WHERE @UserId = UserId
    RETURN(0)
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Trx_GetQueryResults]''
');

GO
SET QUOTED_IDENTIFIER ON

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Trx_GetQueryResults]
(
		@UserId UNIQUEIDENTIFIER,
		@ExchangeId INT=NULL,
		@DataSourceId INT=NULL,
		@FirmId INT=NULL,
		@AsOfDateOperator VARCHAR(12)=''Equals'', -- Equals, Less Than, Greater Than, Between
        @AsOfDateFrom DATETIME=NULL,
        @AsOfDateTo DATETIME=NULL,
		@InstrumentId INT=NULL,
		@StrikePriceOperator VARCHAR(12)=''Equals'', -- Equals, Less Than, Greater Than, Between
        @StrikePriceFrom DECIMAL(24, 10)=NULL,
		@StrikePriceTo DECIMAL(24, 10)=NULL,
		@ExpiryDay INT=NULL,
		@ExpiryMonth INT=NULL,
		@ExpiryYear INT=NULL,
		@TradeType INT=2, -- 0 = Future, 1 = Option, 2 = All.
		@OptionType INT=2, -- 0 = Call, 1 = Put, 2 = All.
		@QuantityOperator VARCHAR(12)=''Equals'', -- Equals, Less Than, Greater Than, Between
        @QuantityFrom DECIMAL(24, 10)=NULL,
		@QuantityTo DECIMAL(24, 10)=NULL,
		@AccountOperator VARCHAR(11)=''Equals'', -- Equals, Starts With, Contains
        @Account VARCHAR(100)=NULL,
		@ClassId INT=NULL,
		@MarketValueOperator VARCHAR(12)=''Equals'', -- Equals, Less Than, Greater Than, Between
        @MarketValueFrom DECIMAL(24, 10)=NULL,
		@MarketValueTo DECIMAL(24, 10)=NULL,
		@PriceOperator VARCHAR(12)=''Equals'', -- Equals, Less Than, Greater Than, Between
        @PriceFrom DECIMAL(24, 10)=NULL,
		@PriceTo DECIMAL(24, 10)=NULL,
		@TrxDateOperator VARCHAR(12)=''Equals'', -- Equals, Less Than, Greater Than, Between
        @TrxDateFrom DATETIME=NULL,
        @TrxDateTo DATETIME=NULL,
        @TrxTypeId INT=NULL,
		@IsForExport BIT=0,
		@FamilyCodeOperator VARCHAR(11)=''Equals'', -- Equals, Starts With, Contains
        @FamilyCode VARCHAR(100)=NULL
    )
AS
BEGIN
--Description: get the query result for transactions

--	14 May 2010 ED		Creation
--	02 Jul 2010 ED		MBAL 16035 get quantity long and quantity short
--	28 Jul 2010	AAJM	MBAL-16318 Return ''M'' indicating Trx Matched
--	11 Aug 2010	amk		MBAL-16429 show trade type even if not on master list
--	22 Apr 2014 ED		EIB 25502  - Add FamilyCode filtering
--	25 Jun 2014 ED		EIB 25775  - Display UTI
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    DECLARE @SQL NVARCHAR(4000)
	DECLARE @WHERE NVARCHAR(4000)
	DECLARE @SelectTopStatement VARCHAR(MAX)
	DECLARE @FROM NVARCHAR(4000)
	
	SET @FROM = '' FROM			[dbo].[ib_Trx] t (nolock)
	JOIN ib_DataSource ds ON ds.DataSourceId = t.DataSourceId
	JOIN ib_Exchange e ON e.ExchangeId = t.ExchangeId
	JOIN ib_Firm f ON f.FirmId = t.FirmId
	LEFT OUTER JOIN ib_Account a ON a.AccountId = t.AccountId
	JOIN ib_Instrument i ON i.InstrumentId = t.InstrumentId
	JOIN ib_InstrumentType it ON it.InstrumentTypeId=i.InstrumentTypeId
	LEFT OUTER JOIN ib_Class c ON c.ClassId = t.ClassId
	JOIN ib_Currency cur ON cur.CurrencyId = t.CurrencyId
	LEFT OUTER JOIN ib_TrxType tt ON tt.Code=t.TrxTypeCode AND tt.DataSourceId=t.DataSourceId
	''
		
	IF @IsForExport = 0
		SET @SelectTopStatement = ''SELECT TOP 1000 ''
	ELSE
		SET @SelectTopStatement = ''SELECT ''

	
	SET @WHERE = '' WHERE t.TrxId IS NOT NULL ''
--ids
	IF @ExchangeId IS NOT NULL
		SET @WHERE = @WHERE + '' AND t.ExchangeId=''+CAST(@ExchangeId AS VARCHAR(MAX))
	IF @DataSourceId IS NOT NULL
		SET @WHERE = @WHERE + '' AND t.DataSourceId='' +CAST(@DataSourceId AS VARCHAR(MAX))
	IF @FirmId IS NOT NULL
		SET @WHERE = @WHERE + '' AND t.FirmId='' +CAST(@FirmId AS VARCHAR(MAX))
	IF @InstrumentId IS NOT NULL
		SET @WHERE = @WHERE + '' AND t.InstrumentId=''+CAST(@InstrumentId AS VARCHAR(MAX))
	IF @ClassId IS NOT NULL
		SET @WHERE = @WHERE + '' AND t.ClassId='' +CAST(@ClassId AS VARCHAR(MAX))
	IF @TrxTypeId IS NOT NULL
		SET @WHERE = @WHERE + '' AND tt.trxTypeId='' +CAST(@TrxTypeId AS VARCHAR(MAX))
--expiry
	IF @ExpiryDay IS NOT NULL
		SET @WHERE = @WHERE + '' AND t.ExpiryDay='' +CAST(@ExpiryDay AS VARCHAR(MAX))
	IF @ExpiryMonth IS NOT NULL
		SET @WHERE = @WHERE + '' AND t.ExpiryMonth='' +CAST(@ExpiryMonth AS VARCHAR(MAX))
	IF @ExpiryYear IS NOT NULL
		SET @WHERE = @WHERE + '' AND t.ExpiryYear='' +CAST(@ExpiryYear AS VARCHAR(MAX))
--
--datetime
	IF @AsOfDateFrom IS NOT NULL
		SET @WHERE = @WHERE + '' AND t.AsOfDate'' +dbo.OperatorTranslate(@AsOfDateOperator,CAST(@AsOfDateFrom AS VARCHAR(MAX)),CAST(@AsOfDateTo AS VARCHAR(MAX)),1,1)
	IF @TrxDateFrom IS NOT NULL
		SET @WHERE = @WHERE + '' AND t.TrxDate'' +dbo.OperatorTranslate(@TrxDateOperator,CAST(@TrxDateFrom AS VARCHAR(MAX)),CAST(@TrxDateTo AS VARCHAR(MAX)),1,1)
--decimal
	IF @StrikePriceFrom IS NOT NULL
		SET @WHERE = @WHERE + '' AND t.StrikePrice'' + dbo.OperatorTranslate(@StrikePriceOperator, @StrikePriceFrom, @StrikePriceTo, 0,0)
	IF @QuantityFrom IS NOT NULL
		SET @WHERE = @WHERE + '' AND t.Quantity'' + dbo.OperatorTranslate(@QuantityOperator, @QuantityFrom, @QuantityTo, 0,0)
	IF @MarketValueFrom IS NOT NULL
		SET @WHERE = @WHERE + '' AND t.MarketValue'' + dbo.OperatorTranslate(@MarketValueOperator, @MarketValueFrom, @MarketValueTo, 0,0)
	IF @PriceFrom IS NOT NULL
		SET @WHERE = @WHERE + '' AND t.Price'' + dbo.OperatorTranslate(@PriceOperator, @PriceFrom, @PriceTo, 0,0)	
		
    IF @Account IS NOT NULL
        SET @WHERE = @WHERE + '' AND a.Code'' + dbo.OperatorTranslate(@AccountOperator, @Account, NULL, 1,0)
	
	IF @FamilyCode IS NOT NULL
		SET @WHERE = @WHERE + '' AND a.FamilyCode '' + dbo.OperatorTranslate(@FamilyCodeOperator, @FamilyCode, NULL, 1, 0)

	IF @TradeType = 0 --Future
		SET @WHERE = @WHERE + '' AND it.Code=''''F'''' ''
	
	IF @TradeType = 1 --Option
		SET @WHERE = @WHERE + '' AND (it.Code=''''O'''' OR it.Code=''''P'''') ''
		
	IF @OptionType = 0 --Call
		SET @WHERE = @WHERE + '' AND t.OptionTypeCode=''''C'''' ''
	
	IF @OptionType = 1 --Put
		SET @WHERE = @WHERE + '' AND t.OptionTypeCode=''''P'''' ''
    


SET @sql = @SelectTopStatement + ''
					e.Code AS Exchange 
					,ds.Code AS [DataSource]
					,i.Code AS [Instrument]
					,t.Quantity
					,t.QuantityLong
					,t.QuantityShort
					,t.AsOfDate
					,t.ExpiryYear
					,t.ExpiryMonth
					,t.ExpiryDay
					,t.StrikePrice AS [StrikePrice]
					, cur.Code AS [Currency]
					,t.OptionTypeCode AS [OptionType]
					,f.Code AS [Firm]
					, a.Code AS [Account]
					, c.Code AS [Class]
					,t.MarketValue AS [MarketValue]
					,it.Code InstrumentType
					,t.Price
					,t.TrxDate
					,ISNULL(tt.Description, t.TrxTypeCode) AS [TrxType]
					, CASE WHEN t.MatchingAdjustmentId IS NOT NULL THEN ''''M'''' ELSE '''''''' END  AS [IsMatched]
					, a.FamilyCode
					, t.UTI 
      '' + @FROM + @WHERE + ''
        ORDER BY	i.code,
				t.ExpiryYear,
				t.ExpiryMonth,
				t.ExpiryDay,
				t.OptionTypeCode,
				t.StrikePrice,
				e.code,
				ds.code,
				f.code,
				c.code,
				a.code,
				cur.code''

-- Execute the query
EXEC sp_executesql @sql


END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_NostroReport_BuildReport]''
');

GO
SET ANSI_NULLS OFF

GO
EXECUTE ('/*
----------------------------------------------------------------------------------------------------

-- 18 Feb 09 : ED created
-- Purpose: split nostro record into multiple nostro records
*/

CREATE PROCEDURE [dbo].[ib_NostroReport_BuildReport]
(
	@@ReportId int
	,@TemplateId INT
	,@UserId uniqueidentifier=NULL
	,@MatchCode varchar(100)
	,@Date DATETIME
	,@IsDaily BIT
	,@IsDetailed BIT
	,@CreateUserName VARCHAR(100)
	,@@NostroReportId INT OUT
)	
AS
SET NOCOUNT ON
BEGIN
	IF (@IsDaily = 1)
	BEGIN
		SELECT @MatchCode MatchCode, convert(varchar(11),@Date,106) ReportDate, 1 IsMatch,GroupNumber,
		InternalExternalCode IntExtCode,TransDate TDate,ValueDate VDate,Narrative,InternalReference IntReference,ExternalReference ExtReference
		,CASE WHEN ABS(AMOUNT)!=AMOUNT THEN ABS(AMOUNT)
			ELSE 0 END as Payments
		,CASE WHEN ABS(AMOUNT)=AMOUNT THEN AMOUNT
			ELSE 0 END as Receipts
		,TransactionType Type
			FROM [ib_Nostro] n (nolock)
				INNER JOIN ib_Account a ON a.AccountId=n.AccountId
				INNER JOIN ib_Firm f ON f.FirmId=a.FirmId
				INNER JOIN ib_TemplateCompare tc ON tc.DataSourceId=n.DataSourceId AND tc.FirmId=f.FirmId
				INNER JOIN ib_Template t ON t.TemplateId=tc.TemplateId
				INNER JOIN ib_TemplateGroup tg ON tg.TemplateId=t.TemplateId AND tg.AccountId=n.AccountId AND tg.CurrencyId=n.CurrencyId
				INNER JOIN ib_NostroMatch nm ON nm.NostroId=n.NostroId
			WHERE t.TemplateId=@TemplateId AND tg.Description=@MatchCode AND convert(varchar(10),nm.CreateDate,111)=convert(varchar(10),@Date,111)
		UNION
		SELECT @MatchCode MatchCode, convert(varchar(11),@Date,106) ReportDate, 1 IsMatch,bi.GroupNumber,
		''O'' IntExtCode,getdate() TDate,getdate() VDate,'''' Narrative,'''' IntReference,'''' ExtReference
		,AmountPayments Payments
		,AmountReceipts Receipts
		,'''' Type
			FROM [ib_NostroBalancingItem] bi (nolock)
				INNER JOIN ib_NostroMatch nm ON nm.GroupNumber=bi.GroupNumber
				INNER JOIN ib_Nostro n ON nm.NostroId=n.NostroId
				INNER JOIN ib_Account a ON a.AccountId=n.AccountId
				INNER JOIN ib_Firm f ON f.FirmId=a.FirmId
				INNER JOIN ib_TemplateCompare tc ON tc.DataSourceId=n.DataSourceId AND tc.FirmId=f.FirmId
				INNER JOIN ib_Template t ON t.TemplateId=tc.TemplateId
				INNER JOIN ib_TemplateGroup tg ON tg.TemplateId=t.TemplateId AND tg.AccountId=n.AccountId  AND tg.CurrencyId=n.CurrencyId
			WHERE t.TemplateId=@TemplateId AND tg.Description=@MatchCode AND convert(varchar(10),nm.CreateDate,111)=convert(varchar(10),@Date,111)
		UNION
		SELECT @MatchCode MatchCode, convert(varchar(11),@Date,106) ReportDate, 0 IsMatch,0,
		InternalExternalCode IntExtCode,TransDate TDate,ValueDate VDate,Narrative,InternalReference IntReference,ExternalReference ExtReference
		,CASE WHEN ABS(AMOUNT)!=AMOUNT THEN ABS(AMOUNT)
			ELSE 0 END as Payments
		,CASE WHEN ABS(AMOUNT)=AMOUNT THEN AMOUNT
			ELSE 0 END as Receipts
		,TransactionType Type
			FROM [ib_Nostro] n (nolock)
				INNER JOIN ib_Account a ON a.AccountId=n.AccountId
				INNER JOIN ib_Firm f ON f.FirmId=a.FirmId
				INNER JOIN ib_TemplateCompare tc ON tc.DataSourceId=n.DataSourceId AND tc.FirmId=f.FirmId
				INNER JOIN ib_Template t ON t.TemplateId=tc.TemplateId
				INNER JOIN ib_TemplateGroup tg ON tg.TemplateId=t.TemplateId AND tg.AccountId=n.AccountId  AND tg.CurrencyId=n.CurrencyId
			WHERE t.TemplateId=@TemplateId AND tg.Description=@MatchCode AND NOT EXISTS(SELECT 1 FROM ib_NostroMatch WHERE NostroId=n.NostroId)
	END
ELSE
	BEGIN
	SELECT @MatchCode MatchCode, substring(convert(varchar(11),@Date,106),3,9) ReportDate, 1 IsMatch,GroupNumber,
		InternalExternalCode IntExtCode,TransDate TDate,ValueDate VDate,Narrative,InternalReference IntReference,ExternalReference ExtReference
		,CASE WHEN ABS(AMOUNT)!=AMOUNT THEN ABS(AMOUNT)
			ELSE 0 END as Payments
		,CASE WHEN ABS(AMOUNT)=AMOUNT THEN AMOUNT
			ELSE 0 END as Receipts
		,TransactionType Type
			FROM [ib_Nostro] n (nolock)
				INNER JOIN ib_Account a ON a.AccountId=n.AccountId
				INNER JOIN ib_Firm f ON f.FirmId=a.FirmId
				INNER JOIN ib_TemplateCompare tc ON tc.DataSourceId=n.DataSourceId AND tc.FirmId=f.FirmId
				INNER JOIN ib_Template t ON t.TemplateId=tc.TemplateId
				INNER JOIN ib_TemplateGroup tg ON tg.TemplateId=t.TemplateId AND tg.AccountId=n.AccountId AND tg.CurrencyId=n.CurrencyId
				INNER JOIN ib_NostroMatch nm ON nm.NostroId=n.NostroId
			WHERE t.TemplateId=@TemplateId AND tg.Description=@MatchCode AND convert(varchar(7),ValueDate,111)=convert(varchar(7),@Date,111)
		UNION
		SELECT @MatchCode MatchCode, substring(convert(varchar(11),@Date,106),3,9) ReportDate, 1 IsMatch,bi.GroupNumber,
		''O'' IntExtCode,getdate() TDate,getdate() VDate,'''' Narrative,'''' IntReference,'''' ExtReference
		,AmountPayments Payments
		,AmountReceipts Receipts
		,'''' Type
			FROM [ib_NostroBalancingItem] bi (nolock)
				INNER JOIN ib_NostroMatch nm ON nm.GroupNumber=bi.GroupNumber
				INNER JOIN ib_Nostro n ON nm.NostroId=n.NostroId
				INNER JOIN ib_Account a ON a.AccountId=n.AccountId
				INNER JOIN ib_Firm f ON f.FirmId=a.FirmId
				INNER JOIN ib_TemplateCompare tc ON tc.DataSourceId=n.DataSourceId AND tc.FirmId=f.FirmId
				INNER JOIN ib_Template t ON t.TemplateId=tc.TemplateId
				INNER JOIN ib_TemplateGroup tg ON tg.TemplateId=t.TemplateId AND tg.AccountId=n.AccountId AND tg.CurrencyId=n.CurrencyId
			WHERE t.TemplateId=@TemplateId AND tg.Description=@MatchCode AND convert(varchar(7),ValueDate,111)=convert(varchar(7),@Date,111)
		UNION
		SELECT @MatchCode MatchCode, substring(convert(varchar(11),@Date,106),3,9) ReportDate, 0 IsMatch,0,
		InternalExternalCode IntExtCode,TransDate TDate,ValueDate VDate,Narrative,InternalReference IntReference,ExternalReference ExtReference
		,CASE WHEN ABS(AMOUNT)!=AMOUNT THEN ABS(AMOUNT)
			ELSE 0 END as Payments
		,CASE WHEN ABS(AMOUNT)=AMOUNT THEN AMOUNT
			ELSE 0 END as Receipts
		,TransactionType Type
			FROM [ib_Nostro] n (nolock)
				INNER JOIN ib_Account a ON a.AccountId=n.AccountId
				INNER JOIN ib_Firm f ON f.FirmId=a.FirmId
				INNER JOIN ib_TemplateCompare tc ON tc.DataSourceId=n.DataSourceId AND tc.FirmId=f.FirmId
				INNER JOIN ib_Template t ON t.TemplateId=tc.TemplateId
				INNER JOIN ib_TemplateGroup tg ON tg.TemplateId=t.TemplateId AND tg.AccountId=n.AccountId AND tg.CurrencyId=n.CurrencyId
			WHERE t.TemplateId=@TemplateId AND tg.Description=@MatchCode AND NOT EXISTS(SELECT 1 FROM ib_NostroMatch WHERE NostroId=n.NostroId)
				AND convert(varchar(7),ValueDate,111)=convert(varchar(7),@Date,111)
END
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Adjustment_GetByTemplateGroupId]''
');

GO
SET ANSI_NULLS ON

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Select records from the ib_Adjustment table through a foreign key
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[ib_Adjustment_GetByTemplateGroupId]
(

	@TemplateGroupId int   
)
AS


				SET ANSI_NULLS ON
				
				SELECT
					[AdjustmentId],
					[TemplateId],
					[ExchangeId],
					[InstrumentId],
					[InternalExternalCode],
					[TradeDate],
					[AdjustmentDate],
					[Quantity],
					[CurrencyId],
					[ExpiryYear],
					[ExpiryMonth],
					[ExpiryDay],
					[StrikePrice],
					[TradePrice],
					[SettlementPrice],
					[OptionTypeCode],
					[Value],
					[PremiumValue],
					[OptionValue],
					[Description],
					[TemplateGroupId],
					[CreateDate],
					[CreateUsername],
					[UpdateDate],
					[UpdateUsername],
					[IsBuy],
					[MatchCodeId],
					[AdjustmentHeaderId],
					[DataSourceId],
					[FirmId],
					[QuantityLong],
					[QuantityShort],
					[DetailAccountId],
					[AccountId],
					[ClassId],
					[AdjustmentStatusId],
					[AdjustmentReasonId],
					[TrxTypeCode],
					[AdjustmentUserStatusId],
					[MatchingAdjustmentId],
					[ReplacesAdjustmentId]
				FROM
					[dbo].[ib_Adjustment]
				WHERE
					[TemplateGroupId] = @TemplateGroupId
				
				SELECT @@ROWCOUNT
				SET ANSI_NULLS ON
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_FirmDataSource_GetFirmsByDataSourceId]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_FirmDataSource_GetFirmsByDataSourceId]
(
	@DataSourceId INT=NULL
)
AS
SET NOCOUNT ON
--	24	May 2010 ED 		Creation
BEGIN
	SELECT f.FirmId, f.Code, f.Name
	FROM ib_FirmDataSource fds
	INNER JOIN ib_Firm f ON f.FirmId=fds.FirmId
	WHERE fds.DataSourceId=@DataSourceId
	ORDER BY f.Code

END
');

GO
EXECUTE ('PRINT N''Creating [stage].[MGEPosition_LoadStateChange]''
');

GO
EXECUTE ('CREATE PROCEDURE [stage].[MGEPosition_LoadStateChange] 
	-- Add the parameters for the stored procedure here
	(
		@OldLoadState	TINYINT,
		@NewLoadState	TINYINT
	)
AS
-- =============================================
-- Author:		KIR
-- Create date: 16 Jan 2019
-- Description:	Changes the LoadState of the MGEPosition type table
-- =============================================
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

		UPDATE [stage].[MGEPosition] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[aspnet_Membership_UnlockUser]''
');

GO
SET QUOTED_IDENTIFIER OFF

GO
EXECUTE ('CREATE PROCEDURE [dbo].[aspnet_Membership_UnlockUser]
    @ApplicationName                         nvarchar(256),
    @UserName                                nvarchar(256)
AS
SET NOCOUNT ON
BEGIN
    DECLARE @UserId uniqueidentifier
    SELECT  @UserId = NULL
    SELECT  @UserId = u.UserId
    FROM    dbo.aspnet_Users u, dbo.aspnet_Applications a, dbo.aspnet_Membership m
    WHERE   LoweredUserName = LOWER(@UserName) AND
            u.ApplicationId = a.ApplicationId  AND
            LOWER(@ApplicationName) = a.LoweredApplicationName AND
            u.UserId = m.UserId

    IF ( @UserId IS NULL )
        RETURN 1

    UPDATE dbo.aspnet_Membership
    SET IsLockedOut = 0,
        FailedPasswordAttemptCount = 0,
        FailedPasswordAttemptWindowStart = CONVERT( datetime, ''17540101'', 112 ),
        FailedPasswordAnswerAttemptCount = 0,
        FailedPasswordAnswerAttemptWindowStart = CONVERT( datetime, ''17540101'', 112 ),
        LastLockoutDate = CONVERT( datetime, ''17540101'', 112 )
    WHERE @UserId = UserId

    RETURN 0
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Trx_GetSelected]''
');

GO
SET QUOTED_IDENTIFIER ON

GO
EXECUTE ('
  /*
<details>
 <summary>Returns selected positions</summary>
 <created author="anil.kripalani" date="17 Oct 2006"/>
 <updated author="anil.kripalani" date="19 Oct 2006" commens="new instr code parameter" />
</details>
 Version	Date			Author		Description
 1.1		31 Jan 2007		LM			Added extra parameters
			07 Feb 2007		amk			Bug Fix: Catch null optiontypecode in data
*/
CREATE PROCEDURE [dbo].[ib_Trx_GetSelected]
	  @AsOfDate			DATETIME
	, @ExchangeCode		VARCHAR(25)		= ''%''
	, @DataSourceCode	VARCHAR(100)	= ''%''
	, @FirmCode			VARCHAR(100)	= ''%''
	, @InstrumentCode	VARCHAR(100)	= ''%''
	, @StrikePrice		MONEY			= NULL
	, @ExpiryDay		SMALLINT		= NULL
	, @ExpiryMonth		SMALLINT		= NULL
	, @ExpiryYear		SMALLINT		= NULL
	, @OptionTypeCode	VARCHAR(1)		= ''%''	
AS
SET NOCOUNT ON
		
	IF @StrikePrice		= -99 SET @StrikePrice = NULL
	IF @ExpiryDay		= -99 SET @ExpiryDay = NULL
	IF @ExpiryMonth		= -99 SET @ExpiryMonth = NULL
	IF @ExpiryYear		= -99 SET @ExpiryYear = NULL


	SELECT	TOP 1000 e.Code AS Exchange, 
					ds.Code AS [Data Source],
					i.Code AS [Instrument],
					t.Quantity,
					CONVERT(VARCHAR(10), t.AsOfDate, 111) AS [As Of],
					CONVERT(VARCHAR(4), t.ExpiryYear) + ''/'' + CONVERT(VARCHAR(2), t.ExpiryMonth) + CASE WHEN t.ExpiryDay IS NULL THEN '''' ELSE ''/'' + CONVERT(VARCHAR(2), t.ExpiryDay) END AS Expiry,
					t.StrikePrice AS [Strike Price], cur.Code AS [Currency],
					t.OptionTypeCode AS [Opt Type],
					f.Code AS [Firm], a.Code AS [Account], c.Code AS [Class],
					t.MarketValue AS [Market Value], t.Price,
					t.TrxTypeCode AS [Trx Type]

	FROM			[dbo].[ib_Trx] t

	JOIN ib_DataSource ds ON ds.DataSourceId = t.DataSourceId
	JOIN ib_Exchange e ON e.ExchangeId = t.ExchangeId
	JOIN ib_Firm f ON f.FirmId = t.FirmId
	LEFT OUTER JOIN ib_Account a ON a.AccountId = t.AccountId
	JOIN ib_Instrument i ON i.InstrumentId = t.InstrumentId
	LEFT OUTER JOIN ib_Class c ON c.ClassId = t.ClassId
	JOIN ib_Currency cur ON cur.CurrencyId = t.CurrencyId
	
	WHERE	e.Code LIKE @ExchangeCode
	AND		ds.Code LIKE @DataSourceCode
	AND		f.Code LIKE @FirmCode
	AND		t.AsOfDate = @AsOfDate
	AND		i.Code LIKE @InstrumentCode
	AND		(t.StrikePrice = @StrikePrice OR @StrikePrice IS NULL)
	AND		(t.ExpiryDay = @ExpiryDay OR @ExpiryDay Is NULL) 
	AND		(t.ExpiryMonth = @ExpiryMonth  OR @ExpiryMonth IS NULL)
	AND		(t.ExpiryYear = @ExpiryYear OR @ExpiryYear IS NULL)
	AND		(t.OptionTypeCode LIKE @OptionTypeCode OR (@OptionTypeCode = ''%''))
	
	ORDER BY	i.code,
				t.ExpiryYear,
				t.ExpiryMonth,
				t.ExpiryDay,
				t.OptionTypeCode,
				t.StrikePrice,
				e.code,
				ds.code,
				f.code,
				c.code,
				a.code,
				cur.code
');

GO
EXECUTE ('PRINT N''Creating [dbo].[vw_aspnet_Applications]''
');

GO
SET QUOTED_IDENTIFIER OFF

GO
EXECUTE ('
  CREATE VIEW [dbo].[vw_aspnet_Applications]
  AS SELECT [dbo].[aspnet_Applications].[ApplicationName], [dbo].[aspnet_Applications].[LoweredApplicationName], [dbo].[aspnet_Applications].[ApplicationId], [dbo].[aspnet_Applications].[Description]
  FROM [dbo].[aspnet_Applications]
  
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Adjustment_GetByAdjustmentDate]''
');

GO
SET QUOTED_IDENTIFIER ON

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Select records from the ib_Adjustment table through an index
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[ib_Adjustment_GetByAdjustmentDate]
(

	@AdjustmentDate datetime   
)
AS


				SELECT
					[AdjustmentId],
					[TemplateId],
					[ExchangeId],
					[InstrumentId],
					[InternalExternalCode],
					[TradeDate],
					[AdjustmentDate],
					[Quantity],
					[CurrencyId],
					[ExpiryYear],
					[ExpiryMonth],
					[ExpiryDay],
					[StrikePrice],
					[TradePrice],
					[SettlementPrice],
					[OptionTypeCode],
					[Value],
					[PremiumValue],
					[OptionValue],
					[Description],
					[TemplateGroupId],
					[CreateDate],
					[CreateUsername],
					[UpdateDate],
					[UpdateUsername],
					[IsBuy],
					[MatchCodeId],
					[AdjustmentHeaderId],
					[DataSourceId],
					[FirmId],
					[QuantityLong],
					[QuantityShort],
					[DetailAccountId],
					[AccountId],
					[ClassId],
					[AdjustmentStatusId],
					[AdjustmentReasonId],
					[TrxTypeCode],
					[AdjustmentUserStatusId],
					[MatchingAdjustmentId],
					[ReplacesAdjustmentId]
				FROM
					[dbo].[ib_Adjustment]
				WHERE
					[AdjustmentDate] = @AdjustmentDate
				SELECT @@ROWCOUNT
					
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_RBC_Position_Load]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_RBC_Position_Load] 
	(
		@LocationPath		VARCHAR(512)
		,@ReceiveLocationSysId INT
		,@RunId INT
	)
AS
SET NOCOUNT ON

-- 23 Apr 2014  ED  EIB 25559
-- Description:	This stored procedure pulls data from the RBC_Position temp
-- table and inserts it into ib_Position
-- Whilst iterating through the records in RBC_Position, all 
-- of these inserts are wrapped in a transaction so that any failure causes
-- the changes to not commit.
--
--
-- Revision History
-- 25 Apr 2014	ED		EIB 25473 - raise error if file is too old and mark temp records as LoadState=3
-- 29 Apr 2014	ED		EIB 25573 - use @MarketCode for Instrument
DECLARE @DefaultStrikePriceDivisor DECIMAL(19,4)
DECLARE @DataSourceCd VARCHAR(100)
DECLARE @ReturnValue INT, @Output INT, @Output2 int
DECLARE @DataSourceId INT
DECLARE @FirmCd VARCHAR(100)

SET @DataSourceCd = ''RBC''
SET @FirmCd = ''RBC''

IF @LocationPath IS NULL SET @LocationPath = @DataSourceCd
					
EXEC @ReturnValue= [_ib_DataSource_GetByCodeForOutput] @DataSourceCd, @OutPut OUTPUT, @Output2 OUTPUT
SET @DataSourceId = @Output

DECLARE		@AsOfDate				datetime
EXEC [dbo].[TryParseYYYYMMDDFromEndOfFilename] @LocationPath, @AsOfDate OUTPUT
--- END AS OF DATE COMPUTATION
			
--rd - make sure the As Of Date is not older than acceptable
DECLARE @IsAcceptable bit
EXECUTE [dbo].[Load_IsFileTooOld] @DataSourceId,@LocationPath,@AsOfDate,@IsAcceptable OUTPUT, @ReceiveLocationSysId, @RunId
IF (@IsAcceptable = 0)
BEGIN
	UPDATE RBC_Position SET [LoadState] = 3 WHERE [Filename] = @LocationPath
	RAISERROR (''File is too old.'', 18, 0)
	RETURN
END									

--Gets the defaultStrikePriceDivisor
SET @DefaultStrikePriceDivisor = [dbo].[udf_GetDefaultStrikePriceDivisor](@DataSourceId, NULL)

-- Duplicate file check										
DECLARE @IsFileAlreadyLoaded INT
EXEC @IsFileALreadyLoaded = HasFileBeenLoaded @LocationPath, @DataSourceId

IF @IsFileAlreadyLoaded = 1
BEGIN
	UPDATE [RBC_Position]
	SET [LoadState] = 3
	WHERE [LoadState] = 1
		AND [Filename] = @LocationPath
	
	RETURN
END
										
-- Store ImportFile record to be associated with Settlement Price load
DECLARE @ImportFileId INT
EXEC ib_ImportFile_Add @DataSourceId, @LocationPath, @ImportFileId OUTPUT
DECLARE @SelectedAsOfDate DATETIME
-- There really isn''t any need for orchestration to call a LoadStateChange anymore
-- since we only process rows for single file now
-- but to keep consistent with other loaders - we''ll update to LoadState 1 at 
-- start of this Load stored procedure
UPDATE [RBC_Position]
SET LoadState = 1
WHERE LoadState = 0
	AND Filename = @LocationPath

CREATE TABLE #temp1
	(
		RBC_PositionID		int,
		Ledger						varchar(7),
		HostCurrency				varchar(21),
		Market						varchar(5),
		MarketCode					varchar(5),
		HostInstrument				varchar(21),
		PromptDate					varchar(8),
		TradeType					varchar(4),
		Series						varchar(6),
		Lots						varchar(21),
		PremiumRate					varchar(21),
		Price						varchar(21),
		MarketRate					varchar(21),
		[Filename]					varchar(512),
		Margin						varchar(21),
		Strike						varchar(7)
	)

	INSERT INTO #temp1
	(
		RBC_PositionID,
		Ledger,
		HostCurrency,
		Market,
		MarketCode,
		HostInstrument,
		PromptDate,
		TradeType,
		Series,
		Lots,
		PremiumRate,
		Price,
		MarketRate,
		[Filename],
		Margin,
		Strike
	)
	SELECT 	
		RBC_PositionID,
		Ledger,
		HostCurrency,
		Market,
		MarketCode,
		HostInstrument,
		PromptDate,
		TradeType,
		Series,
		Lots,
		PremiumRate,
		Price,
		MarketRate,
		[Filename],
		Margin,
		Strike
	FROM [dbo].[RBC_Position]
	WHERE LoadState = 1
		AND [Filename] = @LocationPath

	BEGIN TRAN T1

			-- BizTalk''s SQL Adapter uses more restrictive read serializable
			-- so this is necessary to relax it to something that is default
			-- and perfectly acceptable!
			SET TRANSACTION ISOLATION LEVEL READ COMMITTED

			DECLARE @RBC_PositionID		int
			DECLARE @Ledger						varchar(7)
			DECLARE @HostCurrency				varchar(21)
			DECLARE @Market						varchar(5)
			DECLARE @MarketCode					varchar(5)
			DECLARE @HostInstrument				varchar(21)
			DECLARE @PromptDate					varchar(8)
			DECLARE @TradeType					varchar(4)
			DECLARE @Series						varchar(6)
			DECLARE @Lots						varchar(21)
			DECLARE @PremiumRate				varchar(21)
			DECLARE @Price						varchar(21)
			DECLARE @MarketRate					varchar(21)
			DECLARE @Margin						varchar(21)
			DECLARE @Filename					varchar(512)
			DECLARE @StrikeChr					varchar(7)

			DECLARE pos_cursor CURSOR FOR
			SELECT	RBC_PositionID,
					Ledger,
					HostCurrency,
					Market,
					MarketCode,
					HostInstrument,
					PromptDate,
					TradeType,
					Series,
					Lots,
					PremiumRate,
					Price,
					MarketRate,
					[Filename],
					Margin,
					Strike
			FROM	#temp1

			OPEN pos_cursor

			FETCH NEXT FROM pos_cursor
			INTO 
					@RBC_PositionID,
					@Ledger,
					@HostCurrency,
					@Market,
					@MarketCode,
					@HostInstrument,
					@PromptDate,
					@TradeType,
					@Series,
					@Lots,
					@PremiumRate,
					@Price,
					@MarketRate,
					@Filename,
					@Margin,
					@StrikeChr

				-- Check @@FETCH_STATUS to see IF there are any more rows to fetch.
				WHILE @@FETCH_STATUS = 0
				BEGIN
					DECLARE		@AccountCd				varchar(100)
					DECLARE		@ExchangeCd				varchar(25)
					DECLARE		@InstrumentCd			varchar(100)
					DECLARE		@Quantity				decimal(19,4)
					DECLARE		@ShortQuantity			decimal(19,4)
					DECLARE		@LongQuantity			decimal(19,4)
					DECLARE		@MarketValue			decimal(19,4)
					DECLARE		@ExpYr					smallint
					DECLARE		@ExpMth					smallint
					DECLARE		@ExpDay					smallint
					DECLARE		@PriceDivisor			DECIMAL(19,4)
					DECLARE		@StrikePrice			decimal(19,4)
					DECLARE		@StrikePriceDivisor		decimal(19,4)
					DECLARE		@TrxTypeCd				varchar(25)
					DECLARE		@OptionTypeCd			varchar(25)
					DECLARE		@TrxDate				datetime
					DECLARE		@InstrumentTypeCd		varchar(100)
					DECLARE     @ErrorMessageForRecord	varchar(1024)

					-- Temporary variables
                    DECLARE     @TempDate datetime
					DECLARE 	@Code varchar(100), @Code2 varchar(100)
					
			SET @AccountCd = @Ledger
			SET @StrikePrice = NULL
			SET	@ExchangeCd = @Market

			-- PromptDate can be 99999999

			IF @PromptDate = ''99999999''
                BEGIN
					SET @ExpYr = 9999
					SET @ExpMth = 99
					SET @ExpDay = 99
				END

			-- ExpiryDate = PromptDate, PromptDate is in yyyymmdd ISO 112 format
			ELSE IF @PromptDate <> ''99999999''
			BEGIN TRY
				SET @TempDate = CONVERT(datetime, @PromptDate, 112)
				SET @ExpYr = DATEPART(yyyy, @TempDate)
				SET @ExpMth = DATEPART(mm, @TempDate)			
				SET @ExpDay = DATEPART(dd, @TempDate)
			END TRY
			BEGIN CATCH
				SET @ErrorMessageForRecord = ERROR_MESSAGE()
				EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @ErrorMessageForRecord, ''Success'', @RBC_PositionID, @RunId
			END CATCH
				
			
			-- Set the OptionTypeCode - From Trade Type (FT=Future, TP=Put TC=Call)
			IF @TradeType = ''FT'' 
			   BEGIN
					SET @OptionTypeCd = ''Future''
					-- InstrumentTypeCd
					SET @InstrumentTypeCd = ''F''			
			   END
			ELSE IF @TradeType <> ''FT''
				BEGIN
					-- StrikePrice = Series, Series have a value only for TP and TC Trade types.
					IF ISNUMERIC(@StrikeChr) > 0 
						BEGIN
							SET @StrikePrice = CONVERT(decimal(19,4), @StrikeChr)
						END
                        
					-- The InstrumentTypeCd value is based on the TradeType value
					-- We want to make sure that only in the case the TradeType value is correct we also set the InstrumentTypeCd value
					IF @TradeType = ''TP''
						BEGIN		
							SET @OptionTypeCd = ''P''
							SET @InstrumentTypeCd = ''O''
						END
					ELSE IF @TradeType = ''TC''
						BEGIN	
							SET @OptionTypeCd = ''C''
							SET @InstrumentTypeCd = ''O''
						END
				END
			
			-- We prefix the Instruments with the IntrumentTypeCode
			SET @InstrumentCd = @InstrumentTypeCd + ''_'' + @Market + ''_'' + @MarketCode

			DECLARE @Base INT
			DECLARE @BaseId INT
			SET @Base = NULL
			SET @BaseId = NULL
			
			SELECT @StrikePriceDivisor = ids.StrikePriceDivisor
				, @PriceDivisor = ids.PriceDivisor
				, @Base = b.Base
				, @BaseId = b.BaseId
			FROM [dbo].[ib_InstrumentDataSource] ids
				LEFT OUTER JOIN ib_Base b ON b.BaseId = ids.BaseId
			WHERE ids.DataSourceId = @DataSourceId
				AND ids.DataSourceInstrumentCode = @InstrumentCd 	
				
			IF @StrikePrice IS NOT NULL
			BEGIN
				
				IF @StrikePriceDivisor IS NULL
					BEGIN
						SET @StrikePrice		= @StrikePrice / @DefaultStrikePriceDivisor
					END
				ELSE
					BEGIN
						SET @StrikePrice		= @StrikePrice / @StrikePriceDivisor
					END		
			END

			-- Set Settlement Price				
			IF @PriceDivisor IS NULL 
				SET @PriceDivisor = 1
					
			DECLARE @SettlementPrice DECIMAL(24,10)
			SET @SettlementPrice = CONVERT(DECIMAL(24,10), @MarketRate) 
			--fix 3-4, 5-6 dps
			SET @SettlementPrice = dbo.PerformCorrections(@SettlementPrice, @BaseId)
			
			SET @SettlementPrice = @SettlementPrice / @PriceDivisor
				
			-- Quantity = Lots
			SET @Quantity = 0
			IF ISNUMERIC(@Lots) > 0 
				SET @Quantity = CONVERT(decimal(19,4), @Lots)

			SET	@ShortQuantity = 0	
			SET	@LongQuantity = 0

			IF @Quantity > 0
				SET @LongQuantity = @Quantity

			IF @Quantity < 0
				SET @ShortQuantity = (-1) * @Quantity

			-- MarketValue = Lots * Price
			IF ISNUMERIC(@Margin) > 0
					SET @MarketValue = CONVERT(decimal(19,4), @Margin)

			SET @TrxTypeCd = ''POSITION''

			-- TrxDate
			SET @TrxDate = GETDATE()

			
			
			SET @SelectedAsOfDate = @AsOfDate
			
			DECLARE @PositionId INT
			SET @PositionId = NULL
						
			EXEC [ib_Position_Load]
			@DataSourceCd,			
			@ExchangeCd,				
			@FirmCd,					
			@AccountCd,				
			@AsOfDate,				
			@InstrumentCd,			
			@Quantity,				
			@MarketValue,			
			@ExpYr,					
			@ExpMth,					
			@ExpDay,					
			@StrikePrice,			
			@TrxTypeCd,				
			@OptionTypeCd,			
			@TrxDate,				
			0,		-- This value is not used in the ib_Position_Load Stored Procedure, should be removed ?			
			@RBC_PositionID,
			@InstrumentTypeCd,		
			@LocationPath,
			@HostCurrency,
			@LongQuantity,
			@ShortQuantity,		
			@PositionId = @PositionId output, 
			@ReceiveLocationSysId = @ReceiveLocationSysId,
			@RunId = @RunId
										
			-- Add Settlement Price											
			EXEC ib_Price_AddFromPositionLoad
				@PositionId
				, @ImportFileId
				, @SettlementPrice
				, @Base
						
			--flip processed flag in source table.
			UPDATE [RBC_Position]
			SET [LoadState] = 2
			WHERE [RBC_PositionID] = @RBC_PositionID
				AND [LoadState] = 1

			FETCH NEXT FROM pos_cursor
			INTO 
					@RBC_PositionID,
					@Ledger,
					@HostCurrency,
					@Market,
					@MarketCode,
					@HostInstrument,
					@PromptDate,
					@TradeType,
					@Series,
					@Lots,
					@PremiumRate,
					@Price,
					@MarketRate,
					@Filename,
					@Margin,
					@StrikeChr

		END
			
			CLOSE pos_cursor
			DEALLOCATE pos_cursor

			UPDATE ib_ImportFile 
			SET AsOfDate = CAST(CONVERT(CHAR(10), @SelectedAsOfDate, 101) AS DATETIME)  
			WHERE ImportFileId = @ImportFileId
			
		COMMIT TRAN T1

	DROP TABLE #temp1
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Adjustment_GetAdjustmentsCountNoAccountOrUnapproved]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Adjustment_GetAdjustmentsCountNoAccountOrUnapproved]
	@AsOfDate DATETIME
AS
SET NOCOUNT ON

	--	01 Jul 2010		AAJM		Creation
	--  05 Jul 2010		AAJM		Fix erroneous JOINs
	
BEGIN

	DECLARE @RolfeNolanDataSourceId INT
	SELECT @RolfeNolanDataSourceId = DataSourceId FROM ib_DataSource WHERE Code = ''RolfeNolan''

	SELECT COUNT(1)
	FROM ib_Adjustment a
	INNER JOIN ib_AdjustmentHeader ah ON ah.AdjustmentHeaderId=a.AdjustmentHeaderId
	INNER JOIN ib_AdjustmentType at ON at.AdjustmentTypeId=ah.AdjustmentTypeId
	INNER JOIN ib_InstrumentDataSource ids ON a.InstrumentId = ids.InstrumentId AND ids.DataSourceId = @RolfeNolanDataSourceId
	LEFT OUTER JOIN ib_Account ac ON a.AccountId = ac.AccountId
	LEFT OUTER JOIN ib_Base b ON b.BaseId = ids.BaseId
	WHERE a.AdjustmentDate = @AsOfDate
		AND a.InternalExternalCode = ''I'' AND at.Code = ''TI''
		AND (a.AccountId IS NULL OR (a.AccountId IS NOT NULL AND ac.IsApproved = 0))

END
');

GO
EXECUTE ('PRINT N''Creating [stage].[MGEPosition_Purge]''
');

GO
EXECUTE ('CREATE PROCEDURE [stage].[MGEPosition_Purge] 
	(
		@LoadState		TINYINT = 0,
		@FileName       VARCHAR (512)= NULL
	)
AS

-- =============================================
-- Description:	Deletes from MGEPosition table all the records where the LoadState is 0
-- =============================================
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
		DELETE FROM [stage].[MGEPosition] WHERE LoadState = @LoadState AND [FileName] = COALESCE(@FileName, [FileName])

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[aspnet_Membership_UpdateUser]''
');

GO
SET QUOTED_IDENTIFIER OFF

GO
EXECUTE ('CREATE PROCEDURE [dbo].[aspnet_Membership_UpdateUser]
    @ApplicationName      nvarchar(256),
    @UserName             nvarchar(256),
    @Email                nvarchar(256),
    @Comment              ntext,
    @IsApproved           bit,
    @LastLoginDate        datetime,
    @LastActivityDate     datetime,
    @UniqueEmail          int,
    @CurrentTimeUtc       datetime
AS
SET NOCOUNT ON
BEGIN
    DECLARE @UserId uniqueidentifier
    DECLARE @ApplicationId uniqueidentifier
    SELECT  @UserId = NULL
    SELECT  @UserId = u.UserId, @ApplicationId = a.ApplicationId
    FROM    dbo.aspnet_Users u, dbo.aspnet_Applications a, dbo.aspnet_Membership m
    WHERE   LoweredUserName = LOWER(@UserName) AND
            u.ApplicationId = a.ApplicationId  AND
            LOWER(@ApplicationName) = a.LoweredApplicationName AND
            u.UserId = m.UserId

    IF (@UserId IS NULL)
        RETURN(1)

    IF (@UniqueEmail = 1)
    BEGIN
        IF (EXISTS (SELECT *
                    FROM  dbo.aspnet_Membership WITH (UPDLOCK, HOLDLOCK)
                    WHERE ApplicationId = @ApplicationId  AND @UserId <> UserId AND LoweredEmail = LOWER(@Email)))
        BEGIN
            RETURN(7)
        END
    END

    DECLARE @TranStarted   bit
    SET @TranStarted = 0

    IF( @@TRANCOUNT = 0 )
    BEGIN
	    BEGIN TRANSACTION
	    SET @TranStarted = 1
    END
    ELSE
	SET @TranStarted = 0

    UPDATE dbo.aspnet_Users WITH (ROWLOCK)
    SET
         LastActivityDate = @LastActivityDate
    WHERE
       @UserId = UserId

    IF( @@ERROR <> 0 )
        GOTO Cleanup

    UPDATE dbo.aspnet_Membership WITH (ROWLOCK)
    SET
         Email            = @Email,
         LoweredEmail     = LOWER(@Email),
         Comment          = @Comment,
         IsApproved       = @IsApproved,
         LastLoginDate    = @LastLoginDate
    WHERE
       @UserId = UserId

    IF( @@ERROR <> 0 )
        GOTO Cleanup

    IF( @TranStarted = 1 )
    BEGIN
	SET @TranStarted = 0
	COMMIT TRANSACTION
    END

    RETURN 0

Cleanup:

    IF( @TranStarted = 1 )
    BEGIN
        SET @TranStarted = 0
    	ROLLBACK TRANSACTION
    END

    RETURN -1
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[vw_aspnet_Users]''
');

GO
EXECUTE ('
  CREATE VIEW [dbo].[vw_aspnet_Users]
  AS SELECT [dbo].[aspnet_Users].[ApplicationId], [dbo].[aspnet_Users].[UserId], [dbo].[aspnet_Users].[UserName], [dbo].[aspnet_Users].[LoweredUserName], [dbo].[aspnet_Users].[MobileAlias], [dbo].[aspnet_Users].[IsAnonymous], [dbo].[aspnet_Users].[LastActivityDate]
  FROM [dbo].[aspnet_Users]
  
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Peoplesoft_CheckDataIntegrity]''
');

GO
SET QUOTED_IDENTIFIER ON

GO
EXECUTE ('
CREATE PROCEDURE [dbo].[ib_Peoplesoft_CheckDataIntegrity] 
	(
		@PeriodId int=2
    )
AS

-- =============================================
-- Author:		<P. Konrad Bercea>
-- Create date: <08.04.2009>
-- Description:	<Retrieves the Peoplesoft Data Integrity Check Result>
-- 
-- Revision History
--
-- Konrad, 09.04.2009 Handled the chosen Period and the Calculations as expected
-- Konrad, 15.04.2009 Fixed bug of not having an empty selection
-- Konrad, 17.04.2009 Added TransactionDate to the Selected fields
-- Konrad, 18.04.2009 Changed TransactionDate to From and To Transaction Date Selected from the Query
-- Konrad, 06.07.2009 Provides the Nostro Closing Balance held for a certain Account and Currency
-- Konrad, 07.07.2009 Added the records not loaded
-- AAJM	   31.07.2009 Changed references to TransactionDate to ''floored'' CreateDate
-- AAJM	   03.09.2009 Ensure distinct rows returned from ib_Nostro for TempTableRecordId
-- amk	   26.08.2009 The second temp table is no longer used
--					  check for loadstate = 0 now on main temp table
-- =============================================

BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    DECLARE @minDateForPeriod DATETIME

    IF @PeriodId = 1 SET @minDateForPeriod = DATEADD(DAY, -1, GETDATE())
	IF @PeriodId = 2 SET @minDateForPeriod = DATEADD(DAY, -7, GETDATE())
	IF @PeriodId = 3 SET @minDateForPeriod = DATEADD(MONTH, -1, GETDATE())
	IF @PeriodId = 4 SET @minDateForPeriod = DATEADD(MONTH, -3, GETDATE())
	IF @PeriodId = 5 SET @minDateForPeriod = DATEADD(MONTH, -6, GETDATE())
	IF @PeriodId = 6 SET @minDateForPeriod = DATEADD(YEAR, -1, GETDATE())
	IF @PeriodId = 7 SET @minDateForPeriod = CONVERT(datetime, ''01/01/1900'', 103)

	IF @PeriodId > 0 
	BEGIN

		CREATE TABLE temp_Concatenated_Peoplesoft_Loaded_And_Unloaded
          (
				[FileName]					varchar(512),
				AccountNumber				varchar(35) COLLATE Latin1_General_CI_AS,
				FromTrDate					datetime,
				ToTrDate					datetime,
				min_OpeningBalance			money,
				tot_receipts				money,
				tot_payments				money,
				min_closingbalance			money,
				calculated_closingbalance	money,
				nostro_closing_balance		money,
				is_loaded					bit
		  )

		INSERT INTO temp_Concatenated_Peoplesoft_Loaded_And_Unloaded
		(
				[FileName],
				AccountNumber,
				FromTrDate,
				ToTrDate,
				min_OpeningBalance,
				tot_receipts,
				tot_payments,
				min_closingbalance,
				calculated_closingbalance,
				nostro_closing_balance,
				is_loaded
		)
		SELECT p.[FileName], AccountNumber
			, MIN(dbo.udf_GetDatePart(p.[CreateDate])) AS FromTrDate
			, MAX(dbo.udf_GetDatePart(p.[CreateDate])) AS ToTrDate
			, min(convert(money, p.[OpeningBalance])) AS min_OpeningBalance
			, sum(convert(money, p.[ReceiptAmount])) AS tot_receipts
			, sum(convert(money, p.[PaymentAmount])) AS tot_payments
			, min(convert(money, p.[ClosingBalance])) AS min_closingbalance
			, (min(convert(money, p.[OpeningBalance])) + sum(convert(money, p.[ReceiptAmount]))            
				- sum(convert(money, p.[PaymentAmount]))) AS calculated_closingbalance
			, plsf_log.[NostroBalance] AS nostro_closing_balance
			, 1
		FROM dbo.[Peoplesoft] p
			LEFT JOIN (SELECT DISTINCT AccountId, CurrencyId, TempTableRecordId FROM ib_Nostro) nos on p.[PeoplesoftId] = nos.[TempTableRecordId] 
			LEFT JOIN ib_PeoplesoftBalancesLog plsf_log on plsf_log.[FileName] = p.[FileName] and plsf_log.[AccountId] = nos.[AccountId] and plsf_log.[CurrencyId] = nos.[CurrencyId] 
		WHERE p.[CreateDate] >= @minDateForPeriod
			AND LoadState = 2
		GROUP BY AccountNumber, p.[FileName], plsf_log.[NostroBalance] 
		
		INSERT INTO temp_Concatenated_Peoplesoft_Loaded_And_Unloaded
		(
				[FileName],
				AccountNumber,
				FromTrDate,
				ToTrDate,
				min_OpeningBalance,
				tot_receipts,
				tot_payments,
				min_closingbalance,
				calculated_closingbalance,
				nostro_closing_balance,
				is_loaded
		)
		SELECT p_unl.[FileName], AccountNumber
			, MIN(dbo.udf_GetDatePart(p_unl.[CreateDate])) AS FromTrDate
			, MAX(dbo.udf_GetDatePart(p_unl.[CreateDate])) AS ToTrDate
			, min(convert(money, p_unl.[OpeningBalance])) AS min_OpeningBalance
			, sum(convert(money, p_unl.[ReceiptAmount])) AS tot_receipts
			, sum(convert(money, p_unl.[PaymentAmount])) AS tot_payments
			, min(convert(money, p_unl.[ClosingBalance])) AS min_closingbalance
			, (min(convert(money, p_unl.[OpeningBalance])) + sum(convert(money, p_unl.[ReceiptAmount]))            
				- sum(convert(money, p_unl.[PaymentAmount]))) AS calculated_closingbalance
			, null
			, 0 
		FROM dbo.[Peoplesoft] p_unl
		WHERE p_unl.[CreateDate] >= @minDateForPeriod
			AND LoadState = 3
		GROUP BY AccountNumber, p_unl.[FileName]

		SELECT * 
		FROM temp_Concatenated_Peoplesoft_Loaded_And_Unloaded
		ORDER BY FileName, AccountNumber

		DROP TABLE temp_Concatenated_Peoplesoft_Loaded_And_Unloaded
	END

	ELSE IF @PeriodId < 0 
	BEGIN
		SELECT DISTINCT p.[FileName], AccountNumber
			, 0 AS min_OpeningBalance
	        , 0 AS tot_receipts
	        , 0 AS tot_payments
	        , 0 AS min_closingbalance
	        , 0 AS calculated_closingbalance
	        , 0 AS nostro_closing_balance
			, 1 AS is_loaded
		FROM dbo.[Peoplesoft] p
		WHERE p.[PeoplesoftId] < 0
	END

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Adjustment_GetByAdjustmentHeaderId]''
');

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Select records from the ib_Adjustment table through an index
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[ib_Adjustment_GetByAdjustmentHeaderId]
(

	@AdjustmentHeaderId int   
)
AS


				SELECT
					[AdjustmentId],
					[TemplateId],
					[ExchangeId],
					[InstrumentId],
					[InternalExternalCode],
					[TradeDate],
					[AdjustmentDate],
					[Quantity],
					[CurrencyId],
					[ExpiryYear],
					[ExpiryMonth],
					[ExpiryDay],
					[StrikePrice],
					[TradePrice],
					[SettlementPrice],
					[OptionTypeCode],
					[Value],
					[PremiumValue],
					[OptionValue],
					[Description],
					[TemplateGroupId],
					[CreateDate],
					[CreateUsername],
					[UpdateDate],
					[UpdateUsername],
					[IsBuy],
					[MatchCodeId],
					[AdjustmentHeaderId],
					[DataSourceId],
					[FirmId],
					[QuantityLong],
					[QuantityShort],
					[DetailAccountId],
					[AccountId],
					[ClassId],
					[AdjustmentStatusId],
					[AdjustmentReasonId],
					[TrxTypeCode],
					[AdjustmentUserStatusId],
					[MatchingAdjustmentId],
					[ReplacesAdjustmentId]
				FROM
					[dbo].[ib_Adjustment]
				WHERE
					[AdjustmentHeaderId] = @AdjustmentHeaderId
				SELECT @@ROWCOUNT
					
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_RBC_Transaction_Load]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_RBC_Transaction_Load] 
	(
		@LocationPath		VARCHAR(100)
		,@ReceiveLocationSysId INT
		,@RunId INT
	)
AS
SET NOCOUNT ON

-- 23 Apr 2014  ED  EIB 25559
-- Description:	This stored procedure pulls data from the RBC_Transaction temp
-- table and inserts it into ib_Trx
-- Whilst iterating through the records in RBC_Transaction, all 
-- of these inserts are wrapped in a transaction so that any failure causes
-- the changes to not commit.
--
--
-- Revision History
-- 25 Apr 2014	ED		EIB 25473 - raise error if file is too old and mark temp records as LoadState=3

DECLARE @DefaultStrikePriceDivisor DECIMAL(19,4)
DECLARE @DataSourceCd VARCHAR(100)
DECLARE @ReturnValue INT, @Output INT, @Output2 INT
DECLARE @DefaultCurrencyId INT
DECLARE @DataSourceId INT
DECLARE @FirmCd VARCHAR(100)

SET @DataSourceCd = ''RBC''
SET @FirmCd = ''RBC''

IF @LocationPath IS NULL SET @LocationPath = @DataSourceCd
					
EXEC @ReturnValue= [_ib_DataSource_GetByCodeForOutput] @DataSourceCd, @OutPut OUTPUT, @Output2 OUTPUT
SET @DataSourceId = @Output
SET @DefaultCurrencyId = @Output2	

--Gets the defaultStrikePriceDivisor
SET @DefaultStrikePriceDivisor = [dbo].[udf_GetDefaultStrikePriceDivisor](@DataSourceId, NULL)

-- Duplicate file check										
DECLARE @IsFileAlreadyLoaded INT
EXEC @IsFileALreadyLoaded = HasFileBeenLoaded @LocationPath, @DataSourceId

IF @IsFileAlreadyLoaded = 1
BEGIN
	UPDATE [RBC_Transaction]
	SET [LoadState] = 3
	WHERE [LoadState] = 1
		AND [Filename] = @LocationPath
	
	RETURN
END

-- Store ImportFile record to be associated with Settlement Price load
DECLARE @ImportFileId INT
EXEC ib_ImportFile_Add @DataSourceId, @LocationPath, @ImportFileId OUTPUT
DECLARE @SelectedAsOfDate DATETIME

CREATE TABLE #temp1
	(
		RBC_TransactionID		int,
		[Type]						varchar(3),
		Ledger						varchar(7),
		Currency					varchar(3),
		Market						varchar(5),
		MarketCode					varchar(5),
		RunDate						varchar(8),
		PromptDate					varchar(8),
		Strike						varchar(21),
		PutCall						varchar(2),
		Lots						varchar(21),
		Price						varchar(21),
		OpenClose					varchar(1),
		PostingAmount				VARCHAR(20),
		Premium						VARCHAR(20),
		Serial2						VARCHAR(10)
	)

	INSERT INTO #temp1
	(
		RBC_TransactionID,
		[Type],
		Ledger,
		Currency,
		Market,
		MarketCode,
		RunDate,
		PromptDate,
		Strike,
		PutCall,
		Lots,
		Price,
		OpenClose,
		PostingAmount,
		Premium,
		Serial2
	)
	SELECT 	
		RBC_TransactionID,
		[Type],
		Ledger,
		Currency,
		Market,
		MarketCode,
		RunDate,
		PromptDate,
		FullSeries, -- Was Strike
		PutCall,
		Lots,
		Price,
		OpenClose,
		PostingAmount,
		Premium,
		Serial2
	FROM [RBC_Transaction]
	WHERE LoadState = 1
		AND [Filename] = @LocationPath
		AND (
				([IsMergedTrade] IS NULL OR [IsMergedTrade] = ''N'' OR RTRIM(IsMergedTrade) = '''')
				OR ([IsMergedTrade] = ''Y'' AND RIGHT(rundate, 6) <> LEFT(serial2, 6))
			)
		AND [PromptDate] <> ''99999999'' --KevinP 10 Mar 2010 - Make sure that if the prompt date happens to be 99999999, then skip the record completely

	--rd - make sure the As Of Date is not older than acceptable	
	DECLARE @CheckAsOfDate DATETIME
	SET @CheckAsOfDate = (SELECT MIN(CONVERT(DateTime, RunDate)) AS CheckRunDate FROM #temp1)
	IF (@CheckAsOfDate IS NOT NULL)
	BEGIN		
		DECLARE @IsAcceptable bit
		EXECUTE [dbo].[Load_IsFileTooOld] @DataSourceId,@LocationPath,@CheckAsOfDate,@IsAcceptable OUTPUT, @ReceiveLocationSysId, @RunId
		IF (@IsAcceptable = 0)
		BEGIN
			DROP TABLE #temp1
			UPDATE RBC_Transaction SET [LoadState] = 3 WHERE [Filename] = @LocationPath
			RAISERROR (''File is too old.'', 18, 0)
			RETURN
		END									
	END

	BEGIN TRAN T1

			-- BizTalk''s SQL Adapter uses more restrictive read serializable
			-- so this is necessary to relax it to something that is default
			-- and perfectly acceptable!
			SET TRANSACTION ISOLATION LEVEL READ COMMITTED

			DECLARE @RBC_TransactionID		int
			DECLARE	@Type						varchar(3)
			DECLARE	@Ledger						varchar(7)
			DECLARE	@Currency					varchar(3)
			DECLARE	@Market						varchar(5)
			DECLARE	@MarketCode					varchar(5)
			DECLARE	@RunDate					varchar(8)
			DECLARE	@PromptDate					varchar(8)
			DECLARE	@Strike						varchar(21)
			DECLARE	@PutCall					varchar(2)
			DECLARE	@Lots						varchar(21)
			DECLARE	@Price						varchar(21)
			DECLARE	@OpenClose					varchar(1)
			DECLARE @PostingAmount				VARCHAR(20)
			DECLARE @Premium					VARCHAR(20)
			DECLARE @Serial2					VARCHAR(10)
	
			DECLARE pos_cursor CURSOR FOR
			SELECT	RBC_TransactionID,
					[Type],
					Ledger,
					Currency,
					Market,
					MarketCode,
					RunDate,
					PromptDate,
					Strike,
					PutCall,
					Lots,
					Price,
					OpenClose,
					PostingAmount,
					Premium,
					Serial2
			FROM	#temp1

			OPEN pos_cursor

			FETCH NEXT FROM pos_cursor
			INTO 
					@RBC_TransactionID,
					@Type,
					@Ledger,
					@Currency,
					@Market,
					@MarketCode,
					@RunDate,
					@PromptDate,
					@Strike,
					@PutCall,
					@Lots,
					@Price,
					@OpenClose,
					@PostingAmount,
					@Premium,
					@Serial2

				-- Check @@FETCH_STATUS to see IF there are any more rows to fetch.
				WHILE @@FETCH_STATUS = 0
				BEGIN
					DECLARE		@AccountCd				varchar(100)
					DECLARE		@ExchangeCd				varchar(25)
					DECLARE		@AsOfDate				datetime
					DECLARE		@InstrumentCd			varchar(100)
					DECLARE		@Quantity				decimal(19,4)
					DECLARE		@MarketValue			decimal(19,4)
					DECLARE		@ExpYr					smallint
					DECLARE		@ExpMth					smallint
					DECLARE		@ExpDay					smallint
					DECLARE		@StrikePrice			decimal(19,4)
					DECLARE		@StrikePriceDivisor			decimal(19,4)
					DECLARE		@TrxTypeCd				varchar(25)
					DECLARE		@OptionTypeCd			varchar(25)
					DECLARE		@TrxDate				datetime
					DECLARE		@InstrumentTypeCd		varchar(100)
					DECLARE     @ErrorMessageForRecord	varchar(1024)
					DECLARE     @PriceDec				decimal(24,10)
					-- Temporary variables
                    DECLARE     @TempDate datetime
					DECLARE 	@Code varchar(100), @Code2 varchar(100)
					DECLARE		@TempNumLots				int
					DECLARE		@QuantityLong			int
					DECLARE		@QuantityShort			int
			
			SET @AccountCd = @Ledger
			SET @StrikePrice = NULL
			SET @PriceDec = NULL
            -- TODO Replace the ExchangeCode value constant with a real field value from the Temp Table
			SET	@ExchangeCd = @Market

			SET @TrxTypeCd = @Type

			-- ExpiryDate = PromptDate, PromptDate is in yyyymmdd ISO 112 format
			BEGIN TRY
				SET @TempDate = CONVERT(datetime, @PromptDate, 112)
				SET @ExpYr = DATEPART(yyyy, @TempDate)
				SET @ExpMth = DATEPART(mm, @TempDate)			
				SET @ExpDay = DATEPART(dd, @TempDate)
			END TRY
			BEGIN CATCH
				SET @ErrorMessageForRecord = ERROR_MESSAGE()
				EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @ErrorMessageForRecord, ''Success'', @RBC_TransactionID, @RunId
			END CATCH
				
			IF	@Type = ''001'' OR 
				@Type = ''002'' OR 
				@Type = ''014'' OR 
				@Type = ''018'' OR 
				@Type = ''019'' OR 
				@Type = ''091'' Or 
				@Type = ''005'' OR 
				@Type = ''003'' OR 
				@Type = ''004'' OR 
				@Type = ''020'' OR 
				@Type = ''093'' OR 
				@Type = ''006'' OR 
				@Type = ''007'' OR 
				@Type = ''012'' OR 
				@Type = ''013''
			BEGIN
				IF ISNUMERIC(@Strike) > 0 
				BEGIN
					SET @StrikePrice = CONVERT(decimal(19,4), @Strike)
				END
			END
						
			-- Set the OptionTypeCode - From @PutCall (NULL=Future, TP=Put TC=Call)
			IF @PutCall IS NULL AND (@Type = ''001'' OR @Type = ''002'' Or @Type = ''014'' OR @Type = ''018'' OR @Type = ''019'' OR @Type = ''091'' Or @Type = ''005'')
			   BEGIN
					
					SET @OptionTypeCd = ''Future''
					-- InstrumentTypeCd
					SET @InstrumentTypeCd = ''F''			
			   END
			ELSE IF @PutCall IS NOT NULL AND (@Type = ''003'' OR @Type = ''004'' OR @Type = ''020'' OR @Type = ''093'' OR @Type = ''006'' OR @Type = ''007'' OR @Type = ''012'' OR @Type = ''013'')
				BEGIN
                       
					-- The InstrumentTypeCd value is based on the @PutCall value
					-- We want to make sure that only in the case the @PutCall value is correct we also set the InstrumentTypeCd value
					IF @PutCall = ''TP''
						BEGIN		
							SET @OptionTypeCd = ''P''
							SET @InstrumentTypeCd = ''O''
						END
					ELSE IF @PutCall = ''TC''
						BEGIN	
							SET @OptionTypeCd = ''C''
							SET @InstrumentTypeCd = ''O''
						END
				END
			ELSE
				BEGIN
					-- Log that we''re skipping this record Type
					SET @ErrorMessageForRecord = ''Unable to Work out Put/Call value for RecordType: '' + @Type
					EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @ErrorMessageForRecord, ''Error'', @RBC_TransactionID, @RunId
				END
			
			-- We prefix the Instruments with the IntrumentTypeCode
			SET @InstrumentCd = @InstrumentTypeCd + ''_'' + @Market + ''_'' + @MarketCode

			-- Quantity = Lots
			SET @Quantity = 0
			IF ISNUMERIC(@Lots) > 0 
			BEGIN
				SET @Quantity = CONVERT(decimal(19,4), @Lots)
				
				-- Set QuantityLong and QuantityShort from @Lots
				SET @TempNumLots = CONVERT(int, @Lots)
					
				IF (@TempNumLots >= 0)
					BEGIN
						SET @QuantityLong = @TempNumLots
						SET @QuantityShort = 0
					END
				ELSE
					BEGIN
						SET @QuantityLong = 0
						SET @QuantityShort = ABS(@TempNumLots)
					END						

				IF @Type IN (''002'', ''004'', ''006'', ''013'', ''012'')
				BEGIN
					SET @QuantityLong = @QuantityLong * -1
					SET @QuantityShort = @QuantityShort * -1
				END
				
				IF @Type IN (''012'') --reverse long/shorts
				BEGIN
					DECLARE @TempQnt INT
					SET @TempQnt = @QuantityLong
					SET @QuantityLong = @QuantityShort
					SET @QuantityShort = @TempQnt
				END
			END

			set @Output = null
			declare @InstrumentTypeId int
			set @Code = @InstrumentTypeCd
			exec @ReturnValue = ib_Instrumenttype_AddAsNeeded @DataSourceId,@Code,@OutPut output
			set @InstrumentTypeId = @OutPut
			set @Output = null
			declare @FirmId int
			set @Code = @FirmCd
			exec @ReturnValue= [ib_Firm_AddAsNeeded] @DataSourceId,@Code,@OutPut output	
			set @FirmId = @OutPut
	
			set @Output = null
			set	@OutPut2 = null
			declare @AccountId int
			DECLARE @DetailAccountId INT
			declare @ClassId   int
			set @Code = @AccountCd
			DECLARE @IsImported bit
			SET @IsImported = NULL
			
			exec @ReturnValue= [ib_Account_AddAsNeeded] @Code,@FirmId,@OutPut output,@OutPut2 output, @IsImported = @IsImported OUTPUT
			set @AccountId = @OutPut
			set @ClassId = @OutPut2
			SET @DetailAccountId = @AccountId -- This is OK as @FirmId is correct Marex (R&N)
	
			IF (@IsImported = 1)
			BEGIN
			
				set @Output = null
				declare @CurrencyId int

				if @Currency is not Null
				begin
					exec @ReturnValue = [ib_Currency_AddAsNeeded] @DataSourceId, @Currency, @Output output
					set @CurrencyId = @Output
				end

				set @Output = null
				set @Output2 = null
				declare @InstrumentId int
				set @Code = @InstrumentCd
				exec @ReturnValue= [ib_Instrument_AddAsNeeded] @DataSourceId,@InstrumentTypeId,@Code,@CurrencyId,@Output output,@Output2 output	
				set @InstrumentId = @Output
				if @CurrencyId is null
				begin
					if @Output2 is null
						set @CurrencyId = @DefaultCurrencyId	
					else
						set @CurrencyId = @Output2
				end

				DECLARE	@MarketValueDivisor DECIMAL(19,4)
	
				SELECT @MarketValueDivisor = id.MarketValueDivisor 
				FROM ib_InstrumentDataSource id 
			    WHERE id.InstrumentId = @InstrumentId 
				   AND id.DataSourceId = @DataSourceId 
				   AND id.DataSourceId = @DataSourceId 
				   AND id.CurrencyId = @CurrencyId

				IF @MarketValueDivisor IS NULL OR @MarketValueDivisor = 0
				BEGIN
					SET @MarketValueDivisor = 1
				END

				/* New Code - Begin*/
				DECLARE @Base INT
				DECLARE @BaseId INT
				DECLARE @PriceDivisor DECIMAL(19, 4)
				
				SET @StrikePriceDivisor = NULL
				SET @PriceDivisor = NULL
				SET @Base = NULL
				SET @BaseId = NULL
				
				SELECT @StrikePriceDivisor = ids.StrikePriceDivisor
						, @PriceDivisor = ids.PriceDivisor
						, @Base = b.Base
						, @BaseId = b.BaseId
				FROM [dbo].[ib_InstrumentDataSource] ids
					LEFT OUTER JOIN ib_Base b ON b.BaseId = ids.BaseId
				WHERE ids.DataSourceId = @DataSourceId
					AND ids.DataSourceInstrumentCode = @InstrumentCd 
				
				IF ISNUMERIC(@Price) > 0
				BEGIN
					SET @PriceDec = CONVERT(DECIMAL(24, 10), @Price)
					--apply the 3-4 dp correction
					SET @PriceDec = dbo.PerformCorrections(@PriceDec, @BaseId)
				END
				
				IF @PriceDivisor IS NULL
				BEGIN
					SET @PriceDivisor = 1
				END
				
				--Reset correct price
				IF	@Type = ''001'' OR 
					@Type = ''002'' OR
					@Type = ''014'' OR
					@Type = ''018'' OR 
					@Type = ''019'' OR 
					@Type = ''091''
				BEGIN
					IF(@PriceDec IS NOT NULL)
					BEGIN
						SET @PriceDec = @PriceDec / @PriceDivisor
					END
				END
			
				SET @PriceDec = dbo.udf_ConvertToBase10(@PriceDec, @Base)
			
				IF	@Type = ''001'' OR 
					@Type = ''002'' OR
					@Type = ''018'' OR 
					@Type = ''019'' OR 
					@Type = ''091'' OR
					@Type = ''005'' OR			-- KevinP - Reset the Market Value for 005 Record Types as per conversation with Jeff..
					@Type = ''007''
				BEGIN
					SET @MarketValue = CONVERT(DECIMAL(19,4), @PostingAmount) / @MarketValueDivisor
				END
			
				IF	@Type = ''014'' -- This needs to be the inverse
				BEGIN
					SET @MarketValue = (CONVERT(DECIMAL(19,4), @PostingAmount) * -1) / @MarketValueDivisor
				END
			
				 -- The Market Value is to be derived from the Premium
				IF	@Type = ''006'' OR
					@Type = ''012'' OR 
					@Type = ''013'' OR
					@Type = ''003'' OR 
					@Type = ''004'' OR
					@Type = ''020'' OR 
					@Type = ''093''
				BEGIN
					SET @MarketValue = CONVERT(DECIMAL(19,4), @Premium) / @MarketValueDivisor
				END
			
				IF @Type IN (''004'', ''020'')
					SET @MarketValue = @MarketValue * -1

				IF @Type = ''004'' AND @PriceDec < 0
					SET @PriceDec = @PriceDec * -1
				-- fix price
				IF @Type IN (''006'', ''012'', ''013'')
					SET @PriceDec = 0
				/* New Code - End*/

				IF @StrikePrice IS NOT NULL
				BEGIN
					IF @StrikePriceDivisor IS NULL
					BEGIN
						SET @StrikePrice = @StrikePrice / @DefaultStrikePriceDivisor
					END
					ELSE
					BEGIN
						SET @StrikePrice = @StrikePrice / @StrikePriceDivisor
					END
				END
				
				-- TrxDate (first try serial2 but since not always a date, then go to rundate)
				IF LEN(@Serial2) = 10
					SET @TrxDate = ''20'' + LEFT(@Serial2, 6)
				ELSE
					SET @TrxDate = @RunDate
	
				-- AsOfDate
				SET @AsOfDate = @RunDate
				SET @SelectedAsOfDate = @AsOfDate

				EXEC [ib_Trx_WithIds_Load]
				@DataSourceId,			
				@ExchangeCd,				
				@FirmId,					
				@AccountId,
				@DetailAccountId,				
				@InstrumentId,			
				@ExpYr,					
				@ExpMth,					
				@ExpDay,					
				@StrikePrice,			
				@TrxTypeCd,				
				@OptionTypeCd,
				@Quantity,			
				@TrxDate,				
				@PriceDec,
				@RBC_TransactionID,
				@InstrumentTypeId,
				@AsOfDate,		
				@LocationPath,
				@MarketValue,
				@CurrencyId,
				@ClassId,
				@QuantityLong = @QuantityLong,
				@QuantityShort = @QuantityShort,
				@ReceiveLocationSysId = @ReceiveLocationSysId,
				@RunId = @RunId
				
			END -- IF @IsImported = 1
			
			--flip processed flag in source table.
			UPDATE [RBC_Transaction]
			SET [LoadState] = 2
			WHERE [RBC_TransactionID] = @RBC_TransactionID
				AND [LoadState] = 1

			FETCH NEXT FROM pos_cursor
			INTO 
					@RBC_TransactionID,
					@Type,
					@Ledger,
					@Currency,
					@Market,
					@MarketCode,
					@RunDate,
					@PromptDate,
					@Strike,
					@PutCall,
					@Lots,
					@Price,
					@OpenClose,
					@PostingAmount,
					@Premium,
					@Serial2

		END
			
			CLOSE pos_cursor
			DEALLOCATE pos_cursor
			
			--Update the other records where [IsMergedTrade] may = ''Y'', but haven''t updated their LoadState because they didn''t form part of the SELECT criteria
			--flip processed flag in source table.
			UPDATE [RBC_Transaction]
			SET [LoadState] = 2
			WHERE [FileName] = @LocationPath
				AND [LoadState] = 1

			UPDATE ib_ImportFile 
			SET AsOfDate = CAST(CONVERT(CHAR(10), @SelectedAsOfDate, 101) AS DATETIME)  
			WHERE ImportFileId = @ImportFileId

		COMMIT TRAN T1

	DROP TABLE #temp1
');

GO
EXECUTE ('PRINT N''Creating [stage].[MGETrade_LoadStateChange]''
');

GO
EXECUTE ('CREATE PROCEDURE [stage].[MGETrade_LoadStateChange] 
	-- Add the parameters for the stored procedure here
	(
		@OldLoadState	TINYINT,
		@NewLoadState	TINYINT
	)
AS
-- =============================================
-- Author:		KIR
-- Create date: 16 Jan 2019
-- Description:	Changes the LoadState of the MGETrade type table
-- =============================================
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

		UPDATE [stage].[MGETrade] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[aspnet_Membership_UpdateUserInfo]''
');

GO
SET QUOTED_IDENTIFIER OFF

GO
EXECUTE ('CREATE PROCEDURE [dbo].[aspnet_Membership_UpdateUserInfo]
    @ApplicationName                nvarchar(256),
    @UserName                       nvarchar(256),
    @IsPasswordCorrect              bit,
    @UpdateLastLoginActivityDate    bit,
    @MaxInvalidPasswordAttempts     int,
    @PasswordAttemptWindow          int,
    @CurrentTimeUtc                 datetime,
    @LastLoginDate                  datetime,
    @LastActivityDate               datetime
AS
SET NOCOUNT ON
BEGIN
    DECLARE @UserId                                 uniqueidentifier
    DECLARE @IsApproved                             bit
    DECLARE @IsLockedOut                            bit
    DECLARE @LastLockoutDate                        datetime
    DECLARE @FailedPasswordAttemptCount             int
    DECLARE @FailedPasswordAttemptWindowStart       datetime
    DECLARE @FailedPasswordAnswerAttemptCount       int
    DECLARE @FailedPasswordAnswerAttemptWindowStart datetime

    DECLARE @ErrorCode     int
    SET @ErrorCode = 0

    DECLARE @TranStarted   bit
    SET @TranStarted = 0

    IF( @@TRANCOUNT = 0 )
    BEGIN
	    BEGIN TRANSACTION
	    SET @TranStarted = 1
    END
    ELSE
    	SET @TranStarted = 0

    SELECT  @UserId = u.UserId,
            @IsApproved = m.IsApproved,
            @IsLockedOut = m.IsLockedOut,
            @LastLockoutDate = m.LastLockoutDate,
            @FailedPasswordAttemptCount = m.FailedPasswordAttemptCount,
            @FailedPasswordAttemptWindowStart = m.FailedPasswordAttemptWindowStart,
            @FailedPasswordAnswerAttemptCount = m.FailedPasswordAnswerAttemptCount,
            @FailedPasswordAnswerAttemptWindowStart = m.FailedPasswordAnswerAttemptWindowStart
    FROM    dbo.aspnet_Applications a, dbo.aspnet_Users u, dbo.aspnet_Membership m WITH ( UPDLOCK )
    WHERE   LOWER(@ApplicationName) = a.LoweredApplicationName AND
            u.ApplicationId = a.ApplicationId    AND
            u.UserId = m.UserId AND
            LOWER(@UserName) = u.LoweredUserName

    IF ( @@rowcount = 0 )
    BEGIN
        SET @ErrorCode = 1
        GOTO Cleanup
    END

    IF( @IsLockedOut = 1 )
    BEGIN
        GOTO Cleanup
    END

    IF( @IsPasswordCorrect = 0 )
    BEGIN
        IF( @CurrentTimeUtc > DATEADD( minute, @PasswordAttemptWindow, @FailedPasswordAttemptWindowStart ) )
        BEGIN
            SET @FailedPasswordAttemptWindowStart = @CurrentTimeUtc
            SET @FailedPasswordAttemptCount = 1
        END
        ELSE
        BEGIN
            SET @FailedPasswordAttemptWindowStart = @CurrentTimeUtc
            SET @FailedPasswordAttemptCount = @FailedPasswordAttemptCount + 1
        END

        BEGIN
            IF( @FailedPasswordAttemptCount >= @MaxInvalidPasswordAttempts )
            BEGIN
                SET @IsLockedOut = 1
                SET @LastLockoutDate = @CurrentTimeUtc
            END
        END
    END
    ELSE
    BEGIN
        IF( @FailedPasswordAttemptCount > 0 OR @FailedPasswordAnswerAttemptCount > 0 )
        BEGIN
            SET @FailedPasswordAttemptCount = 0
            SET @FailedPasswordAttemptWindowStart = CONVERT( datetime, ''17540101'', 112 )
            SET @FailedPasswordAnswerAttemptCount = 0
            SET @FailedPasswordAnswerAttemptWindowStart = CONVERT( datetime, ''17540101'', 112 )
            SET @LastLockoutDate = CONVERT( datetime, ''17540101'', 112 )
        END
    END

    IF( @UpdateLastLoginActivityDate = 1 )
    BEGIN
        UPDATE  dbo.aspnet_Users
        SET     LastActivityDate = @LastActivityDate
        WHERE   @UserId = UserId

        IF( @@ERROR <> 0 )
        BEGIN
            SET @ErrorCode = -1
            GOTO Cleanup
        END

        UPDATE  dbo.aspnet_Membership
        SET     LastLoginDate = @LastLoginDate
        WHERE   UserId = @UserId

        IF( @@ERROR <> 0 )
        BEGIN
            SET @ErrorCode = -1
            GOTO Cleanup
        END
    END


    UPDATE dbo.aspnet_Membership
    SET IsLockedOut = @IsLockedOut, LastLockoutDate = @LastLockoutDate,
        FailedPasswordAttemptCount = @FailedPasswordAttemptCount,
        FailedPasswordAttemptWindowStart = @FailedPasswordAttemptWindowStart,
        FailedPasswordAnswerAttemptCount = @FailedPasswordAnswerAttemptCount,
        FailedPasswordAnswerAttemptWindowStart = @FailedPasswordAnswerAttemptWindowStart
    WHERE @UserId = UserId

    IF( @@ERROR <> 0 )
    BEGIN
        SET @ErrorCode = -1
        GOTO Cleanup
    END

    IF( @TranStarted = 1 )
    BEGIN
	SET @TranStarted = 0
	COMMIT TRANSACTION
    END

    RETURN @ErrorCode

Cleanup:

    IF( @TranStarted = 1 )
    BEGIN
        SET @TranStarted = 0
    	ROLLBACK TRANSACTION
    END

    RETURN @ErrorCode

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Adjustment_GetByCurrencyId]''
');

GO
SET QUOTED_IDENTIFIER ON

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Select records from the ib_Adjustment table through an index
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[ib_Adjustment_GetByCurrencyId]
(

	@CurrencyId int   
)
AS


				SELECT
					[AdjustmentId],
					[TemplateId],
					[ExchangeId],
					[InstrumentId],
					[InternalExternalCode],
					[TradeDate],
					[AdjustmentDate],
					[Quantity],
					[CurrencyId],
					[ExpiryYear],
					[ExpiryMonth],
					[ExpiryDay],
					[StrikePrice],
					[TradePrice],
					[SettlementPrice],
					[OptionTypeCode],
					[Value],
					[PremiumValue],
					[OptionValue],
					[Description],
					[TemplateGroupId],
					[CreateDate],
					[CreateUsername],
					[UpdateDate],
					[UpdateUsername],
					[IsBuy],
					[MatchCodeId],
					[AdjustmentHeaderId],
					[DataSourceId],
					[FirmId],
					[QuantityLong],
					[QuantityShort],
					[DetailAccountId],
					[AccountId],
					[ClassId],
					[AdjustmentStatusId],
					[AdjustmentReasonId],
					[TrxTypeCode],
					[AdjustmentUserStatusId],
					[MatchingAdjustmentId],
					[ReplacesAdjustmentId]
				FROM
					[dbo].[ib_Adjustment]
				WHERE
					[CurrencyId] = @CurrencyId
				SELECT @@ROWCOUNT
					
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_RolfeNolan_GetDataSourceAndFirm]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_RolfeNolan_GetDataSourceAndFirm]
	(
		@FilePath VARCHAR(100)
		, @DataSourceCd VARCHAR(50) OUTPUT
		, @FirmCd VARCHAR(100) OUTPUT
	)
AS

	--	04 Jan 2011		amk		Creation (extracted from UDF IsFileForUS and deleted that UDF)
	--							also see MBAL-17212
	--	16 May 2012		ED		ADD new datasource - RNOT
	--  21 May 2012		ED		MBAL-20857 - Import additional R&N format files for OTC business(OR & ZZ)
	--  11 Jul 2012		ED		MBAL-21153 - Import additional R&N format files BB, IN
	--	13 Jul 2012		AAJM	MBAL-21153	Rename RNBB datasource to RNST
	--	09 Sept 2012	ED		MBAL 21133 - ADD new datasource - BZ
	--	07 Aug 2014		ED		EIB 25855  - add UG and UP
	--	20 Aug 2014		ED		EIB 25894  - add O1 and O2
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
	DECLARE @FilenameWithoutExtension VARCHAR(100) 
	SET @FilenameWithoutExtension = dbo.GetFilenameWithoutExtension(@FilePath)
	
	IF CHARINDEX(''US'', @FilenameWithoutExtension) <> 0
	BEGIN
		SET @FirmCd = ''Marex (NA)''
		SET @DataSourceCd = ''RNUS''
	END
	ELSE IF CHARINDEX(''U2'', @FilenameWithoutExtension) <> 0
		OR CHARINDEX(''UP'', @FilenameWithoutExtension) <> 0
		OR CHARINDEX(''UG'', @FilenameWithoutExtension) <> 0
	BEGIN
		SET @FirmCd = ''Marex (U2)''
		SET @DataSourceCd = ''RNU2''
	END
	ELSE IF CHARINDEX(''G2'', @FilenameWithoutExtension) <> 0
	BEGIN
		SET @FirmCd = ''Marex (G2)''
		SET @DataSourceCd = ''RNG2''
	END
	ELSE IF CHARINDEX(''OT'', @FilenameWithoutExtension) <> 0
			OR CHARINDEX(''OR'', @FilenameWithoutExtension) <> 0
			OR CHARINDEX(''HOSTOPNOP'', @FilenameWithoutExtension) <> 0
			OR CHARINDEX(''HOSTOPNOM'', @FilenameWithoutExtension) <> 0
			OR CHARINDEX(''HOSTOPNTM'', @FilenameWithoutExtension) <> 0
			OR CHARINDEX(''HOSTOPNTP'', @FilenameWithoutExtension) <> 0
	BEGIN
		SET @FirmCd = ''Marex (OT)''
		SET @DataSourceCd = ''RNOT''
	END
	ELSE IF CHARINDEX(''HOSTTRNST'', @FilenameWithoutExtension) <> 0
	BEGIN
		SET @FirmCd = ''Marex (ST)''
		SET @DataSourceCd = ''RNST''
	END
	ELSE IF CHARINDEX(''HOSTTRNIN'', @FilenameWithoutExtension) <> 0
	BEGIN
		SET @FirmCd = ''Marex (IN)''
		SET @DataSourceCd = ''RNIN''
	END
	ELSE IF CHARINDEX(''BZ'', @FilenameWithoutExtension) <> 0
	BEGIN
		SET @FirmCd = ''BZ''
		SET @DataSourceCd = ''BZ''
	END
	ELSE IF CHARINDEX(''O1'', @FilenameWithoutExtension) <> 0
	BEGIN
		SET @FirmCd = ''OTCM''
		SET @DataSourceCd = ''OTCM''
	END
	ELSE
	BEGIN
		SET @FirmCd = ''Marex''
		SET @DataSourceCd = ''RolfeNolan''
	END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_RolfeNolan_HOSTOPN_Load]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_RolfeNolan_HOSTOPN_Load] 
	(
		@LocationPath		VARCHAR(100)
		,@ReceiveLocationSysId INT
		,@RunId INT
	)
AS
SET NOCOUNT ON

-- Author:		Petru Konrad Bercea
-- Create date: 10.02.2009
-- Description:	This stored procedure pulls data from the RolfeNolan_HOSTOPN temp
-- table and inserts it into ib_Position
-- Whilst iterating through the records in RolfeNolan_HOSTOPN, all 
-- of these inserts are wrapped in a transaction so that any failure causes
-- the changes to not commit.
--
--
-- Revision History
--
-- 21 Feb 2009		Konrad		Removed ISDATE function calls as this function 
--								doesn''t recognise all the date format styles.
--
-- 17.04.09         Konrad      Added Try Catch block for PromptDate conversion from varchar to DateTime 
-- 22.04.09         Konrad		Fixed the bug of setting the StrikePrice for Future and not setting the optionTypeCode for Put and Call.
-- 30.04.09         Konrad      Changed the DataSource Code to unique value RolfeNolan for all RolfeNolan data types
-- 15.05.2009       Konrad      Added Filename field
-- 21.05.09			Konrad		Compute the Strike Price also by dividing it to the StrikePriceDivisor
-- 15.05.2009		Konrad		Added @ShortQuantity and @LongQuantity from @Quantity into the Position.
-- 18.06.2009		Konrad		Replaced MarketCode with @InstrumentTypeCd+@Market+@MarketCode for InstrumentCode
-- 23.06.2009		Konrad		Added MarketRate and Margin to the HOSTOPN table and to the Load
-- 09.07.2009       Konrad      Persists promptdate when ''99999999'' as year=9999, month=99, day=99
-- 22 Jul 2009		AAJM		MBAL-12377 use common source for default Strike Price Divisor
-- 04 Nov 2009		amk			Don''t process same file again
-- 03 Mar 2010		amk			MBAL-14836 adjust transaction isolation level
-- 30 Mar 2010		amk			MBAL-15105 Change how we construct instrument code
-- 31 Mar 2010		amk			MBAL-15029 loadstatechange no longer changes state 0 to 1 so do that here at start
-- 21 Apr 2010		AAJM		MBAL-14741 Save settlement prices from Market Rate
-- 26 Apr 2010		amk			MBAL-15240 Get base to pass in to routine for settlement price
-- 02 Jun 2010		ED			MBAL-15687 populate ib_ImportFile.AsOfDate
-- 23 Jun 2010		ED			MBAL-15913 Tidy up Trade/Settlement Price Corrections for Rounded Prices
-- 30 Jun 2010      ED			MBAL-15996 fix the asofdate, to get only date 
-- 16 Nov 2010		amk			MBAL-16988 vary firm for US files
-- 21 Dec 2010		amk			MBAL-17193 vary data source for US files
-- 04 Jan 2011		amk			MBAL-17212 two more data sources to support US
-- 03 Mar 2011		amk			MBAL-17728 fix how we compute as of date 
--								(use letter in filename not current date)
-- 03 Dec 2012		AAJM		MBAL-22047 Take strike price from new 7 char Strike field
-- 02 Jan 2014		RD			MBAL-24931 Added checking file age
-- 09 Jan 2014		ED			EIB 25004 - remove importLog table and use Log table
-- 14 Jan 2014		ED			EIB 25059 - refactor to check the AsOfDate outside of transaction
-- 25 Apr 2014		ED			EIB 25473 - raise error if file is too old and mark temp records as LoadState=3
-- 20 Aug 2014		ED			EIB 25894 - if DataSource=OTCM then it is external, so quantity = -1 * quantity and Market Value = -1 * Market Value
DECLARE @DefaultStrikePriceDivisor DECIMAL(19,4)
DECLARE @DataSourceCd VARCHAR(100)
DECLARE @ReturnValue INT, @Output INT, @Output2 int
DECLARE @DataSourceId INT
DECLARE @FirmCd VARCHAR(100)

DECLARE		@AsOfDate				datetime
DECLARE		@AsOfDayStr				varchar(2)
--- BEGIN AS OF DATE COMPUTATION
DECLARE @Today DATETIME
SET @Today = GETDATE()		-- used for YEAR portion ONLY

-- get last 2 characters of filename - this is a day number
SET @AsOfDate = NULL
SET @AsOfDayStr = SUBSTRING(@LocationPath, LEN(@LocationPath) - 1, 2)

-- get 3rd character from end of filename - this is a reuters month indicator (letter)
DECLARE @ReutersMonthChar CHAR(1)
SET @ReutersMonthChar = SUBSTRING(@LocationPath, LEN(@LocationPath) - 2, 1)
DECLARE @ReutersMonthNumber SMALLINT
SET @ReutersMonthNumber = dbo.GetReutersMonthNumber(@ReutersMonthChar)

DECLARE @Year SMALLINT
SET @Year = NULL
 
IF (ISNUMERIC(@AsOfDayStr) > 0) AND @ReutersMonthNumber > 0
BEGIN
	SET @Year = YEAR(@Today)
	SET @AsOfDate = CONVERT(DATETIME
		, CONVERT(VARCHAR(2), @ReutersMonthNumber) + ''/'' + @AsOfDayStr 
			+ ''/'' + CONVERT(VARCHAR(4), @Year), 101)

	-- back up 1 year if we''ve constructed a date into the future
	IF @AsOfDate > @Today
		SET @AsOfDate = DATEADD(yy, -1, @AsOfDate)
END
--- END AS OF DATE COMPUTATION
			
--rd - make sure the As Of Date is not older than acceptable
DECLARE @IsAcceptable bit
EXECUTE [dbo].[Load_IsFileTooOld] @DataSourceId,@LocationPath,@AsOfDate,@IsAcceptable OUTPUT, @ReceiveLocationSysId, @RunId
IF (@IsAcceptable = 0)
BEGIN
	UPDATE RolfeNolan_HOSTOPN SET [LoadState] = 3 WHERE [Filename] = @LocationPath
	RAISERROR (''File is too old.'', 18, 0)
	RETURN
END									

EXEC ib_RolfeNolan_GetDataSourceAndFirm @LocationPath, @DataSourceCd OUTPUT, @FirmCd OUTPUT

IF @LocationPath IS NULL SET @LocationPath = @DataSourceCd
					
EXEC @ReturnValue= [_ib_DataSource_GetByCodeForOutput] @DataSourceCd, @OutPut OUTPUT, @Output2 OUTPUT
SET @DataSourceId = @Output

--Gets the defaultStrikePriceDivisor
SET @DefaultStrikePriceDivisor = [dbo].[udf_GetDefaultStrikePriceDivisor](@DataSourceId, NULL)

-- Duplicate file check										
DECLARE @IsFileAlreadyLoaded INT
EXEC @IsFileALreadyLoaded = HasFileBeenLoaded @LocationPath, @DataSourceId

IF @IsFileAlreadyLoaded = 1
BEGIN
	UPDATE [RolfeNolan_HOSTOPN]
	SET [LoadState] = 3
	WHERE [LoadState] = 1
		AND [Filename] = @LocationPath
	
	RETURN
END
										
-- Store ImportFile record to be associated with Settlement Price load
DECLARE @ImportFileId INT
EXEC ib_ImportFile_Add @DataSourceId, @LocationPath, @ImportFileId OUTPUT
DECLARE @SelectedAsOfDate DATETIME
-- There really isn''t any need for orchestration to call a LoadStateChange anymore
-- since we only process rows for single file now
-- but to keep consistent with other loaders - we''ll update to LoadState 1 at 
-- start of this Load stored procedure
UPDATE [RolfeNolan_HOSTOPN]
SET LoadState = 1
WHERE LoadState = 0
	AND Filename = @LocationPath

CREATE TABLE #temp1
	(
		RolfeNolan_HOSTOPNID		int,
		Ledger						varchar(10),
		HostCurrency				varchar(21),
		Market						varchar(5),
		MarketCode					varchar(5),
		HostInstrument				varchar(21),
		PromptDate					varchar(8),
		TradeType					varchar(4),
		Series						varchar(6),
		Lots						varchar(21),
		PremiumRate					varchar(21),
		Price						varchar(21),
		MarketRate					varchar(21),
		[Filename]					varchar(512),
		Margin						varchar(21),
		Strike						varchar(7)
	)

	INSERT INTO #temp1
	(
		RolfeNolan_HOSTOPNID,
		Ledger,
		HostCurrency,
		Market,
		MarketCode,
		HostInstrument,
		PromptDate,
		TradeType,
		Series,
		Lots,
		PremiumRate,
		Price,
		MarketRate,
		[Filename],
		Margin,
		Strike
	)
	SELECT 	
		RolfeNolan_HOSTOPNID,
		Ledger,
		HostCurrency,
		Market,
		MarketCode,
		HostInstrument,
		PromptDate,
		TradeType,
		Series,
		Lots,
		PremiumRate,
		Price,
		MarketRate,
		[Filename],
		Margin,
		Strike
	FROM [dbo].[RolfeNolan_HOSTOPN]
	WHERE LoadState = 1
		AND [Filename] = @LocationPath

	BEGIN TRAN T1

			-- BizTalk''s SQL Adapter uses more restrictive read serializable
			-- so this is necessary to relax it to something that is default
			-- and perfectly acceptable!
			SET TRANSACTION ISOLATION LEVEL READ COMMITTED

			DECLARE @RolfeNolan_HOSTOPNID		int
			DECLARE @Ledger						varchar(10)
			DECLARE @HostCurrency				varchar(21)
			DECLARE @Market						varchar(5)
			DECLARE @MarketCode					varchar(5)
			DECLARE @HostInstrument				varchar(21)
			DECLARE @PromptDate					varchar(8)
			DECLARE @TradeType					varchar(4)
			DECLARE @Series						varchar(6)
			DECLARE @Lots						varchar(21)
			DECLARE @PremiumRate				varchar(21)
			DECLARE @Price						varchar(21)
			DECLARE @MarketRate					varchar(21)
			DECLARE @Margin						varchar(21)
			DECLARE @Filename					varchar(512)
			DECLARE @StrikeChr					varchar(7)

			DECLARE pos_cursor CURSOR FOR
			SELECT	RolfeNolan_HOSTOPNID,
					Ledger,
					HostCurrency,
					Market,
					MarketCode,
					HostInstrument,
					PromptDate,
					TradeType,
					Series,
					Lots,
					PremiumRate,
					Price,
					MarketRate,
					[Filename],
					Margin,
					Strike
			FROM	#temp1

			OPEN pos_cursor

			FETCH NEXT FROM pos_cursor
			INTO 
					@RolfeNolan_HOSTOPNID,
					@Ledger,
					@HostCurrency,
					@Market,
					@MarketCode,
					@HostInstrument,
					@PromptDate,
					@TradeType,
					@Series,
					@Lots,
					@PremiumRate,
					@Price,
					@MarketRate,
					@Filename,
					@Margin,
					@StrikeChr

				-- Check @@FETCH_STATUS to see IF there are any more rows to fetch.
				WHILE @@FETCH_STATUS = 0
				BEGIN
					DECLARE		@AccountCd				varchar(100)
					DECLARE		@ExchangeCd				varchar(25)
					DECLARE		@InstrumentCd			varchar(100)
					DECLARE		@Quantity				decimal(19,4)
					DECLARE		@ShortQuantity			decimal(19,4)
					DECLARE		@LongQuantity			decimal(19,4)
					DECLARE		@MarketValue			decimal(19,4)
					DECLARE		@ExpYr					smallint
					DECLARE		@ExpMth					smallint
					DECLARE		@ExpDay					smallint
					DECLARE		@PriceDivisor			DECIMAL(19,4)
					DECLARE		@StrikePrice			decimal(19,4)
					DECLARE		@StrikePriceDivisor		decimal(19,4)
					DECLARE		@TrxTypeCd				varchar(25)
					DECLARE		@OptionTypeCd			varchar(25)
					DECLARE		@TrxDate				datetime
					DECLARE		@InstrumentTypeCd		varchar(100)
					DECLARE     @ErrorMessageForRecord	varchar(1024)

					-- Temporary variables
                    DECLARE     @TempDate datetime
					DECLARE 	@Code varchar(100), @Code2 varchar(100)
					
			SET @AccountCd = @Ledger
			SET @StrikePrice = NULL
			SET	@ExchangeCd = @Market

			-- PromptDate can be 99999999

			IF @PromptDate = ''99999999''
                BEGIN
					SET @ExpYr = 9999
					SET @ExpMth = 99
					SET @ExpDay = 99
				END

			-- ExpiryDate = PromptDate, PromptDate is in yyyymmdd ISO 112 format
			ELSE IF @PromptDate <> ''99999999''
			BEGIN TRY
				SET @TempDate = CONVERT(datetime, @PromptDate, 112)
				SET @ExpYr = DATEPART(yyyy, @TempDate)
				SET @ExpMth = DATEPART(mm, @TempDate)			
				SET @ExpDay = DATEPART(dd, @TempDate)
			END TRY
			BEGIN CATCH
				SET @ErrorMessageForRecord = ERROR_MESSAGE()
				EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @ErrorMessageForRecord, ''Success'', @RolfeNolan_HOSTOPNID, @RunId
			END CATCH
				
			
			-- Set the OptionTypeCode - From Trade Type (FT=Future, TP=Put TC=Call)
			IF @TradeType = ''FT'' 
			   BEGIN
					SET @OptionTypeCd = ''Future''
					-- InstrumentTypeCd
					SET @InstrumentTypeCd = ''F''			
			   END
			ELSE IF @TradeType <> ''FT''
				BEGIN
					-- StrikePrice = Series, Series have a value only for TP and TC Trade types.
					IF ISNUMERIC(@StrikeChr) > 0 
						BEGIN
							SET @StrikePrice = CONVERT(decimal(19,4), @StrikeChr)
						END
                        
					-- The InstrumentTypeCd value is based on the TradeType value
					-- We want to make sure that only in the case the TradeType value is correct we also set the InstrumentTypeCd value
					IF @TradeType = ''TP''
						BEGIN		
							SET @OptionTypeCd = ''P''
							SET @InstrumentTypeCd = ''O''
						END
					ELSE IF @TradeType = ''TC''
						BEGIN	
							SET @OptionTypeCd = ''C''
							SET @InstrumentTypeCd = ''O''
						END
				END
			
			-- We prefix the Instruments with the IntrumentTypeCode
			SET @InstrumentCd = @InstrumentTypeCd + ''_'' + @Market + ''_'' + @HostInstrument

			DECLARE @Base INT
			DECLARE @BaseId INT
			SET @Base = NULL
			SET @BaseId = NULL
			
			SELECT @StrikePriceDivisor = ids.StrikePriceDivisor
				, @PriceDivisor = ids.PriceDivisor
				, @Base = b.Base
				, @BaseId = b.BaseId
			FROM [dbo].[ib_InstrumentDataSource] ids
				LEFT OUTER JOIN ib_Base b ON b.BaseId = ids.BaseId
			WHERE ids.DataSourceId = @DataSourceId
				AND ids.DataSourceInstrumentCode = @InstrumentCd 	
				
			IF @StrikePrice IS NOT NULL
			BEGIN
				
				IF @StrikePriceDivisor IS NULL
					BEGIN
						SET @StrikePrice		= @StrikePrice / @DefaultStrikePriceDivisor
					END
				ELSE
					BEGIN
						SET @StrikePrice		= @StrikePrice / @StrikePriceDivisor
					END		
			END

			-- Set Settlement Price				
			IF @PriceDivisor IS NULL 
				SET @PriceDivisor = 1
					
			DECLARE @SettlementPrice DECIMAL(24,10)
			SET @SettlementPrice = CONVERT(DECIMAL(24,10), @MarketRate) 
			--fix 3-4, 5-6 dps
			SET @SettlementPrice = dbo.PerformCorrections(@SettlementPrice, @BaseId)
			
			SET @SettlementPrice = @SettlementPrice / @PriceDivisor
				
			-- Quantity = Lots
			SET @Quantity = 0
			IF ISNUMERIC(@Lots) > 0 
				SET @Quantity = CONVERT(decimal(19,4), @Lots)
			IF @DataSourceCd = ''OTCM'' 
					SET @Quantity = -1 * @Quantity
			SET	@ShortQuantity = 0	
			SET	@LongQuantity = 0

			IF @Quantity > 0
				SET @LongQuantity = @Quantity

			IF @Quantity < 0
				SET @ShortQuantity = (-1) * @Quantity

			-- MarketValue = Lots * Price
			IF ISNUMERIC(@Margin) > 0
			BEGIN
					SET @MarketValue = CONVERT(decimal(19,4), @Margin)
					IF @DataSourceCd = ''OTCM'' 
						SET @MarketValue = -1 * @MarketValue
			END

			SET @TrxTypeCd = ''POSITION''

			-- TrxDate
			SET @TrxDate = GETDATE()

			
			
			SET @SelectedAsOfDate = @AsOfDate
			
			DECLARE @PositionId INT
			SET @PositionId = NULL
						
			EXEC [ib_Position_Load]
			@DataSourceCd,			
			@ExchangeCd,				
			@FirmCd,					
			@AccountCd,				
			@AsOfDate,				
			@InstrumentCd,			
			@Quantity,				
			@MarketValue,			
			@ExpYr,					
			@ExpMth,					
			@ExpDay,					
			@StrikePrice,			
			@TrxTypeCd,				
			@OptionTypeCd,			
			@TrxDate,				
			0,		-- This value is not used in the ib_Position_Load Stored Procedure, should be removed ?			
			@RolfeNolan_HOSTOPNID,
			@InstrumentTypeCd,		
			@LocationPath,
			@HostCurrency,
			@LongQuantity,
			@ShortQuantity,		
			@PositionId = @PositionId output, 
			@ReceiveLocationSysId = @ReceiveLocationSysId,
			@RunId = @RunId
										
			-- Add Settlement Price											
			EXEC ib_Price_AddFromPositionLoad
				@PositionId
				, @ImportFileId
				, @SettlementPrice
				, @Base
						
			--flip processed flag in source table.
			UPDATE [RolfeNolan_HOSTOPN]
			SET [LoadState] = 2
			WHERE [RolfeNolan_HOSTOPNID] = @RolfeNolan_HOSTOPNID
				AND [LoadState] = 1

			FETCH NEXT FROM pos_cursor
			INTO 
					@RolfeNolan_HOSTOPNID,
					@Ledger,
					@HostCurrency,
					@Market,
					@MarketCode,
					@HostInstrument,
					@PromptDate,
					@TradeType,
					@Series,
					@Lots,
					@PremiumRate,
					@Price,
					@MarketRate,
					@Filename,
					@Margin,
					@StrikeChr

		END
			
			CLOSE pos_cursor
			DEALLOCATE pos_cursor

			UPDATE ib_ImportFile 
			SET AsOfDate = CAST(CONVERT(CHAR(10), @SelectedAsOfDate, 101) AS DATETIME)  
			WHERE ImportFileId = @ImportFileId
			
		COMMIT TRAN T1

	DROP TABLE #temp1
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Adjustment_GetById]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Adjustment_GetById]
(
	@AdjustmentId INT
)
AS
/*
<details>
 <summary> Gets an adjustment by its id/summary>
 <created author="Laurentiu Macovei" Date="Thursday, 20 August 2006 23:12 GMT" /> 
 <updated author="Laurentiu Macovei" Date="Tuesday, 1 November 2006 12:38 GMT"> 
	Added templateId
 </updated>
 <updated author="Anil Kripalani" Date="28 November 2006"> 
	Added PremiumValue and OptionValue
 </updated>
  <updated author="Alister McLeod" Date="09 February 2010"> 
	Added IsBuy
 </updated>
</details>
-- 23 Jun 2010  ED  Get also QuantityShort and QuantityLong
-- 25 Jun 2010  ED  MBAL 15697 - Fix the join
-- 22 May 2014  ED  EIB 25492 - allow update of adjustment
*/
	SET NOCOUNT ON

	SELECT a.[AdjustmentId]
		  ,a.[TemplateId]
		  ,a.[ExchangeId]
		  ,a.[InstrumentId]
		  ,a.[InternalExternalCode]
		  ,a.[TradeDate]
		  ,a.[AdjustmentDate]
		  ,a.[Quantity]
		  ,a.[CurrencyId]
		  ,a.[ExpiryYear]
		  ,a.[ExpiryMonth]
		  ,a.[ExpiryDay]
		  ,a.[StrikePrice]
		  ,a.[TradePrice]
		  ,a.[SettlementPrice]
		  ,a.[OptionTypeCode]
		  ,a.[Value]
		  ,ISNULL(a.Description, '''') + '' '' + ISNULL(ah.Description,'''') Description
		  ,a.[TemplateGroupId]
		  ,a.[CreateDate]
		  ,a.[CreateUsername]
		  ,a.[UpdateDate]
		  ,a.[UpdateUsername]
		  ,a.[IsBuy]
		  ,a.[MatchCodeId]
		  ,a.[AdjustmentHeaderId]
		  ,a.[DataSourceId]
		  ,a.[FirmId]
		  ,ISNULL(a.QuantityLong,0)  QuantityLong
		  ,ISNULL(a.QuantityShort,0) QuantityShort
		  ,a.[DetailAccountId]
		  ,a.[AccountId]
		  ,a.[ClassId]
		  ,a.[AdjustmentStatusId]
		  ,a.[AdjustmentReasonId]
		  ,a.[TrxTypeCode]
		  ,a.[AdjustmentUserStatusId]
		  ,a.[MatchingAdjustmentId]
		  ,a.[ReplacesAdjustmentId]
		  ,c.[Code] AS CurrencyCode
		  ,e.[Name] AS ExchangeName
		  ,e.[Code] AS ExchangeCode
		  ,i.[Code] AS InstrumentCode
		  ,i.[Name] AS InstrumentName
		  ,m.[MatchCode] AS TemplateGroupDescription
		  ,t.[Description] AS TemplateDescription
		  ,a.[PremiumValue]
		  ,a.[OptionValue]
		  ,a.[IsBuy]
		  ,a.[AccountId]
		  ,ISNULL(QuantityShort,0) QuantityShort
		  ,ISNULL(QuantityLong,0)  QuantityLong
		  ,ac.[Code] AS AccountCode
		  ,ac.[Name] + '' [ '' + ac.[Code] + '' ~ '' +fac.[Code] + '' ]'' AS AccountName
		  ,dac.[Name] + '' [ '' + dac.[Code] + '' ~ '' +fdac.[Code] + '' ]''  AS DetailAccountName
		  ,ltrim(rtrim(i.Name)) + '' [ '' + ltrim(rtrim(i.Code)) + '' ]'' AS InstrumentNameFull
		  ,CASE WHEN a.AdjustmentStatusId IS NULL OR ast.Code=''U'' THEN 1 ELSE 0 END As IsOpen
	FROM [ib_Adjustment] a  
		INNER JOIN ib_Instrument i ON i.InstrumentId = a.InstrumentId 
		LEFT JOIN ib_AdjustmentHeader ah ON a.AdjustmentHeaderId = ah.AdjustmentHeaderId
		LEFT JOIN ib_MatchCode m ON m.MatchCodeId = a.MatchCodeId
		INNER JOIN ib_Template t ON t.TemplateId = a.TemplateId 
		INNER JOIN ib_Exchange e ON e.ExchangeId = a.ExchangeId 
		INNER JOIN ib_Currency c ON c.CurrencyId = a.CurrencyId 
		LEFT JOIN ib_Account ac ON ac.AccountId = a.AccountId
		LEFT JOIN ib_Account dac ON dac.AccountId = a.DetailAccountId
		LEFT JOIN ib_Firm fac on ac.FirmId = fac.FirmId
		LEFT JOIN ib_Firm fdac on dac.FirmId = fdac.FirmId
		LEFT JOIN ib_AdjustmentStatus ast ON ast.AdjustmentStatusId = a.AdjustmentStatusId
	WHERE AdjustmentId = @AdjustmentId
');

GO
EXECUTE ('PRINT N''Creating [stage].[MGETrade_Purge]''
');

GO
EXECUTE ('CREATE PROCEDURE [stage].[MGETrade_Purge] 
	(
		@LoadState		TINYINT = 0,
		@FileName       VARCHAR (512)= NULL
	)
AS

-- =============================================
-- Description:	Deletes from MGETrade table all the records where the LoadState is 0
-- =============================================
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
		DELETE FROM [stage].[MGETrade] WHERE LoadState = @LoadState AND [FileName] = COALESCE(@FileName, [FileName])

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[aspnet_Paths_CreatePath]''
');

GO
SET QUOTED_IDENTIFIER OFF

GO
EXECUTE ('CREATE PROCEDURE [dbo].[aspnet_Paths_CreatePath]
    @ApplicationId UNIQUEIDENTIFIER,
    @Path           NVARCHAR(256),
    @PathId         UNIQUEIDENTIFIER OUTPUT
AS
SET NOCOUNT ON
BEGIN
    BEGIN TRANSACTION
    IF (NOT EXISTS(SELECT * FROM dbo.aspnet_Paths WHERE LoweredPath = LOWER(@Path) AND ApplicationId = @ApplicationId))
    BEGIN
        INSERT dbo.aspnet_Paths (ApplicationId, Path, LoweredPath) VALUES (@ApplicationId, @Path, LOWER(@Path))
    END
    COMMIT TRANSACTION
    SELECT @PathId = PathId FROM dbo.aspnet_Paths WHERE LOWER(@Path) = LoweredPath AND ApplicationId = @ApplicationId
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Adjustment_GetByAccountId]''
');

GO
SET QUOTED_IDENTIFIER ON

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Select records from the ib_Adjustment table through an index
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[ib_Adjustment_GetByAccountId]
(

	@AccountId int   
)
AS


				SELECT
					[AdjustmentId],
					[TemplateId],
					[ExchangeId],
					[InstrumentId],
					[InternalExternalCode],
					[TradeDate],
					[AdjustmentDate],
					[Quantity],
					[CurrencyId],
					[ExpiryYear],
					[ExpiryMonth],
					[ExpiryDay],
					[StrikePrice],
					[TradePrice],
					[SettlementPrice],
					[OptionTypeCode],
					[Value],
					[PremiumValue],
					[OptionValue],
					[Description],
					[TemplateGroupId],
					[CreateDate],
					[CreateUsername],
					[UpdateDate],
					[UpdateUsername],
					[IsBuy],
					[MatchCodeId],
					[AdjustmentHeaderId],
					[DataSourceId],
					[FirmId],
					[QuantityLong],
					[QuantityShort],
					[DetailAccountId],
					[AccountId],
					[ClassId],
					[AdjustmentStatusId],
					[AdjustmentReasonId],
					[TrxTypeCode],
					[AdjustmentUserStatusId],
					[MatchingAdjustmentId],
					[ReplacesAdjustmentId]
				FROM
					[dbo].[ib_Adjustment]
				WHERE
					[AccountId] = @AccountId
				SELECT @@ROWCOUNT
					
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_RolfeNolan_HOSTTRN_Load]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_RolfeNolan_HOSTTRN_Load] 
	(
		@LocationPath		VARCHAR(100)
		,@ReceiveLocationSysId INT
		,@RunId INT
	)
AS
SET NOCOUNT ON

-- Author:		Petru Konrad Bercea
-- Create date: 28.04.2009
-- Description:	This stored procedure pulls data from the RolfeNolan_HOSTTRN temp
-- table and inserts it into ib_Position
-- Whilst iterating through the records in RolfeNolan_HOSTTRN, all 
-- of these inserts are wrapped in a transaction so that any failure causes
-- the changes to not commit.
--
--
-- Revision History
--
-- 06.05.09 Konrad Added fields Currency and Market from temp table into loading process
-- 08.05.09 Konrad Set the InstrumentCode = InstrumentTypeCode + MarketCode
-- 21.05.09 Konrad Compute the Strike Price also by dividing it to the StrikePriceDivisor
-- 18.06.2009		Konrad		Replaced MarketCode with @InstrumentTypeCd+@Market+@MarketCode for InstrumentCode
-- 09.07.2009       Konrad		Set Market Value to (-1 * (Price * ib_Instrument.LotSize * Lots) / ib_InstrumentDatasource.MarketValueDivisor 	)
-- 16.07.2009		AAJM		Added DetailAccountId field
-- 16.07.2009		Konrad		Fixed bug of ClassId not loaded
-- 21.07.2009		AAJM		Add comment to clarify DetailAccountId assignment
-- 21.07.2009		amk			Change marketvalue calculation to use tick size instead of lot size
-- 22 Jul 2009		AAJM		MBAL-12377 use common source for default Strike Price Divisor
-- 28 Jul 2009		AAJM		MBAL-12623 Store long and short volumes in ib_Trx
-- 04 Nov 2009		amk			Don''t process same file again
-- 03 Mar 2010		amk			MBAL-14836 adjust transaction isolation level
-- 05 Mar 2010		KevinP		Increased the variable size of the location path from 100 to 512. This could have created some problems!
-- 05 Mar 2010		KevinP		Limited the SELECT clause to only grab records where [IsMergedTrade] IS NULL(for older records) or ''N'' because the records we get may contain Merged trades, but we don''t want them in this load.
-- 17 Mar 2010		KevinP		Added Price Divisor. Commented out unneeded code too.
-- 30 Mar 2010		amk			MBAL-15105 Change how we construct instrument code
--								(separate parts with underscore)
-- 20 Apr 2010		amk			MBAL-15335: bug fix: include emptry string Type too
-- 21 Apr 2010		amk			MBAL-15372: tweak types that use posting / premium
-- 23 Apr 2010		amk			MBAL-15240: convert fractional price to base 10 if necessary
-- 28 Apr 2010		amk			MBAL-15434: use negative quantity for 002 and 004
-- 28 Apr 2010		AAJM		MBAL-15315: Ensure records are not imported for accounts with IsImported = 0
-- 29 Apr 2010		amk			MBAL-15434: use negative long/short quantity for 002 and 004
--					amk			MBAL-15450: include few other merged type trades per marc and jeff
-- 26 May 2010		amk			MBAL-15631: trade price still being rounded to 19,4 - change to 24,10
--								MBAL-15434: convert negative price to positive for type 004
-- 21 Jun 2010      ED			MBAL-15878: Get TrxType=''J'' too(Expiry Slip Type)(option type=006, set price = 0)
-- 22 Jun 2010      ED			MBAL-15879: Correct Option Exercise and Assignment Records(012, 013)
-- 23 Jun 2010		ED			MBAL-15913: Tidy up Trade/Settlement Price Corrections for Rounded Prices
-- 30 Jun 2010		amk			MBAL-16002: reverse sign of market value for option trade deletions
-- 05 Jul 2010      ED			MBAL-16041: fix the R&N  Exercise and Assignment transactions
-- 02 Aug 2010		amk			MBAL-16354: use serial2 for trx date when available
-- 14 Oct 2010		amk			MBAL-16823: for type 020 use premium in market value calc, not posting
-- 16 Nov 2010		amk			MBAL-16988: vary firm for US files
-- 21 Dec 2010		amk			MBAL-17193: vary data source for US files
-- 04 Jan 2011		amk			MBAL-17212: two more data sources to support US
-- 14 Jan 2011		amk			MBAL-17351: write to importfile too
-- 01 Apr 2011		AAJM		MBAL-17862: Fix 020-Bus Options Settlement market value sign
-- 03 Dec 2012		AAJM		MBAL-22047: Obtain Strike Price from 7 char field FullSeries (RecordType_Field11) not Strike
-- 02 Jan 2014		RD			MBAL-24931 Added checking file age
-- 09 Jan 2014		ED			EIB 25004 - remove importLog table and use Log table
-- 25 Apr 2014		ED			EIB 25473 - raise error if file is too old and mark temp records as LoadState=3
-- 24 Jun 2014		ED			EIB 25764 - add UTI
-- 30 Jun 2014		ED			EIB 25759 - don''t set DetailAccountId for LME
-- 20 Aug 2014		ED			EIB 25894 - if DataSource=OTCM then it is external, so quantity = -1 * quantity and Market Value = -1 * Market Value
DECLARE @DefaultStrikePriceDivisor DECIMAL(19,4)
DECLARE @DataSourceCd VARCHAR(100)
DECLARE @ReturnValue INT, @Output INT, @Output2 INT
DECLARE @DefaultCurrencyId INT
DECLARE @DataSourceId INT
DECLARE @FirmCd VARCHAR(100)

EXEC ib_RolfeNolan_GetDataSourceAndFirm @LocationPath, @DataSourceCd OUTPUT, @FirmCd OUTPUT

IF @LocationPath IS NULL SET @LocationPath = @DataSourceCd
					
EXEC @ReturnValue= [_ib_DataSource_GetByCodeForOutput] @DataSourceCd, @OutPut OUTPUT, @Output2 OUTPUT
SET @DataSourceId = @Output
SET @DefaultCurrencyId = @Output2	

--Gets the defaultStrikePriceDivisor
SET @DefaultStrikePriceDivisor = [dbo].[udf_GetDefaultStrikePriceDivisor](@DataSourceId, NULL)

-- Duplicate file check										
DECLARE @IsFileAlreadyLoaded INT
EXEC @IsFileALreadyLoaded = HasFileBeenLoaded @LocationPath, @DataSourceId

IF @IsFileAlreadyLoaded = 1
BEGIN
	UPDATE [RolfeNolan_HOSTTRN]
	SET [LoadState] = 3
	WHERE [LoadState] = 1
		AND [Filename] = @LocationPath
	
	RETURN
END

-- Store ImportFile record to be associated with Settlement Price load
DECLARE @ImportFileId INT
EXEC ib_ImportFile_Add @DataSourceId, @LocationPath, @ImportFileId OUTPUT
DECLARE @SelectedAsOfDate DATETIME

CREATE TABLE #temp1
	(
		RolfeNolan_HOSTTRNID		int,
		[Type]						varchar(3),
		Ledger						varchar(10),
		Currency					varchar(3),
		Market						varchar(5),
		MarketCode					varchar(5),
		RunDate						varchar(8),
		PromptDate					varchar(8),
		Strike						varchar(21),
		PutCall						varchar(2),
		Lots						varchar(21),
		Price						varchar(21),
		OpenClose					varchar(1),
		PostingAmount				VARCHAR(20),
		Premium						VARCHAR(20),
		Serial2						VARCHAR(10),
		UTI						VARCHAR(100)
	)

	INSERT INTO #temp1
	(
		RolfeNolan_HOSTTRNID,
		[Type],
		Ledger,
		Currency,
		Market,
		MarketCode,
		RunDate,
		PromptDate,
		Strike,
		PutCall,
		Lots,
		Price,
		OpenClose,
		PostingAmount,
		Premium,
		Serial2,
		UTI
	)
	SELECT 	
		RolfeNolan_HOSTTRNID,
		[Type],
		Ledger,
		Currency,
		Market,
		MarketCode,
		RunDate,
		PromptDate,
		FullSeries, -- Was Strike
		PutCall,
		Lots,
		Price,
		OpenClose,
		PostingAmount,
		Premium,
		Serial2,
		UTI
	FROM [RolfeNolan_HOSTTRN]
	WHERE LoadState = 1
		AND [Filename] = @LocationPath
		AND (
				([IsMergedTrade] IS NULL OR [IsMergedTrade] = ''N'' OR RTRIM(IsMergedTrade) = '''')
				OR ([IsMergedTrade] = ''Y'' AND RIGHT(rundate, 6) <> LEFT(serial2, 6))
			)
		AND [PromptDate] <> ''99999999'' --KevinP 10 Mar 2010 - Make sure that if the prompt date happens to be 99999999, then skip the record completely
		AND UTI <> ''CancelledByCompression''
		AND NOT UTI LIKE ''E01LMEC000-%''

	--rd - make sure the As Of Date is not older than acceptable	
	DECLARE @CheckAsOfDate DATETIME
	SET @CheckAsOfDate = (SELECT MIN(CONVERT(DateTime, RunDate)) AS CheckRunDate FROM #temp1)
	IF (@CheckAsOfDate IS NOT NULL)
	BEGIN		
		DECLARE @IsAcceptable bit
		EXECUTE [dbo].[Load_IsFileTooOld] @DataSourceId,@LocationPath,@CheckAsOfDate,@IsAcceptable OUTPUT, @ReceiveLocationSysId, @RunId
		IF (@IsAcceptable = 0)
		BEGIN
			DROP TABLE #temp1
			UPDATE [RolfeNolan_HOSTTRN] SET [LoadState] = 3 WHERE [Filename] = @LocationPath
			RAISERROR (''File is too old.'', 18, 0)
			RETURN
		END									
	END

	BEGIN TRAN T1

			-- BizTalk''s SQL Adapter uses more restrictive read serializable
			-- so this is necessary to relax it to something that is default
			-- and perfectly acceptable!
			SET TRANSACTION ISOLATION LEVEL READ COMMITTED

			DECLARE @RolfeNolan_HOSTTRNID		int
			DECLARE	@Type						varchar(3)
			DECLARE	@Ledger						varchar(10)
			DECLARE	@Currency					varchar(3)
			DECLARE	@Market						varchar(5)
			DECLARE	@MarketCode					varchar(5)
			DECLARE	@RunDate					varchar(8)
			DECLARE	@PromptDate					varchar(8)
			DECLARE	@Strike						varchar(21)
			DECLARE	@PutCall					varchar(2)
			DECLARE	@Lots						varchar(21)
			DECLARE	@Price						varchar(21)
			DECLARE	@OpenClose					varchar(1)
			DECLARE @PostingAmount				VARCHAR(20)
			DECLARE @Premium					VARCHAR(20)
			DECLARE @Serial2					VARCHAR(10)
			DECLARE @UTI						VARCHAR(100)
			DECLARE pos_cursor CURSOR FOR
			SELECT	RolfeNolan_HOSTTRNID,
					[Type],
					Ledger,
					Currency,
					Market,
					MarketCode,
					RunDate,
					PromptDate,
					Strike,
					PutCall,
					Lots,
					Price,
					OpenClose,
					PostingAmount,
					Premium,
					Serial2,
					UTI
			FROM	#temp1

			OPEN pos_cursor

			FETCH NEXT FROM pos_cursor
			INTO 
					@RolfeNolan_HOSTTRNID,
					@Type,
					@Ledger,
					@Currency,
					@Market,
					@MarketCode,
					@RunDate,
					@PromptDate,
					@Strike,
					@PutCall,
					@Lots,
					@Price,
					@OpenClose,
					@PostingAmount,
					@Premium,
					@Serial2,
					@UTI

				-- Check @@FETCH_STATUS to see IF there are any more rows to fetch.
				WHILE @@FETCH_STATUS = 0
				BEGIN
					DECLARE		@AccountCd				varchar(100)
					DECLARE		@ExchangeCd				varchar(25)
					DECLARE		@AsOfDate				datetime
					DECLARE		@InstrumentCd			varchar(100)
					DECLARE		@Quantity				decimal(19,4)
					DECLARE		@MarketValue			decimal(19,4)
					DECLARE		@ExpYr					smallint
					DECLARE		@ExpMth					smallint
					DECLARE		@ExpDay					smallint
					DECLARE		@StrikePrice			decimal(19,4)
					DECLARE		@StrikePriceDivisor			decimal(19,4)
					DECLARE		@TrxTypeCd				varchar(25)
					DECLARE		@OptionTypeCd			varchar(25)
					DECLARE		@TrxDate				datetime
					DECLARE		@InstrumentTypeCd		varchar(100)
					DECLARE     @ErrorMessageForRecord	varchar(1024)
					DECLARE     @PriceDec				decimal(24,10)
					-- Temporary variables
                    DECLARE     @TempDate datetime
					DECLARE 	@Code varchar(100), @Code2 varchar(100)
					DECLARE		@TempNumLots				int
					DECLARE		@QuantityLong			int
					DECLARE		@QuantityShort			int
			
			SET @AccountCd = @Ledger
			SET @StrikePrice = NULL
			SET @PriceDec = NULL
            -- TODO Replace the ExchangeCode value constant with a real field value from the Temp Table
			SET	@ExchangeCd = @Market

			SET @TrxTypeCd = @Type

			-- ExpiryDate = PromptDate, PromptDate is in yyyymmdd ISO 112 format
			BEGIN TRY
				SET @TempDate = CONVERT(datetime, @PromptDate, 112)
				SET @ExpYr = DATEPART(yyyy, @TempDate)
				SET @ExpMth = DATEPART(mm, @TempDate)			
				SET @ExpDay = DATEPART(dd, @TempDate)
			END TRY
			BEGIN CATCH
				SET @ErrorMessageForRecord = ERROR_MESSAGE()
				EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @ErrorMessageForRecord, ''Success'', @RolfeNolan_HOSTTRNID, @RunId
			END CATCH
				
			IF	@Type = ''001'' OR 
				@Type = ''002'' OR 
				@Type = ''014'' OR 
				@Type = ''018'' OR 
				@Type = ''019'' OR 
				@Type = ''091'' Or 
				@Type = ''005'' OR 
				@Type = ''003'' OR 
				@Type = ''004'' OR 
				@Type = ''020'' OR 
				@Type = ''093'' OR 
				@Type = ''006'' OR 
				@Type = ''007'' OR 
				@Type = ''012'' OR 
				@Type = ''013''
			BEGIN
				IF ISNUMERIC(@Strike) > 0 
				BEGIN
					SET @StrikePrice = CONVERT(decimal(19,4), @Strike)
				END
			END
						
			-- Set the OptionTypeCode - From @PutCall (NULL=Future, TP=Put TC=Call)
			IF @PutCall IS NULL AND (@Type = ''001'' OR @Type = ''002'' Or @Type = ''014'' OR @Type = ''018'' OR @Type = ''019'' OR @Type = ''091'' Or @Type = ''005'')
			   BEGIN
					
					SET @OptionTypeCd = ''Future''
					-- InstrumentTypeCd
					SET @InstrumentTypeCd = ''F''			
			   END
			ELSE IF @PutCall IS NOT NULL AND (@Type = ''003'' OR @Type = ''004'' OR @Type = ''020'' OR @Type = ''093'' OR @Type = ''006'' OR @Type = ''007'' OR @Type = ''012'' OR @Type = ''013'')
				BEGIN
                       
					-- The InstrumentTypeCd value is based on the @PutCall value
					-- We want to make sure that only in the case the @PutCall value is correct we also set the InstrumentTypeCd value
					IF @PutCall = ''TP''
						BEGIN		
							SET @OptionTypeCd = ''P''
							SET @InstrumentTypeCd = ''O''
						END
					ELSE IF @PutCall = ''TC''
						BEGIN	
							SET @OptionTypeCd = ''C''
							SET @InstrumentTypeCd = ''O''
						END
				END
			ELSE
				BEGIN
					-- Log that we''re skipping this record Type
					SET @ErrorMessageForRecord = ''Unable to Work out Put/Call value for RecordType: '' + @Type
					EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @ErrorMessageForRecord, ''Error'', @RolfeNolan_HOSTTRNID, @RunId
				END
			
			-- We prefix the Instruments with the IntrumentTypeCode
			SET @InstrumentCd = @InstrumentTypeCd + ''_'' + @Market + ''_'' + @MarketCode

			-- Quantity = Lots
			SET @Quantity = 0
			IF ISNUMERIC(@Lots) > 0 
			BEGIN
				SET @Quantity = CONVERT(decimal(19,4), @Lots)
				
				-- Set QuantityLong and QuantityShort from @Lots
				SET @TempNumLots = CONVERT(int, @Lots)
				IF @DataSourceCd = ''OTCM'' 
				BEGIN
					SET @Quantity = -1 * @Quantity	
					SET @TempNumLots = -1 * @TempNumLots	
				END

				IF (@TempNumLots >= 0)
					BEGIN
						SET @QuantityLong = @TempNumLots
						SET @QuantityShort = 0
					END
				ELSE
					BEGIN
						SET @QuantityLong = 0
						SET @QuantityShort = ABS(@TempNumLots)
					END						

				IF @Type IN (''002'', ''004'', ''006'', ''013'', ''012'')
				BEGIN
					SET @QuantityLong = @QuantityLong * -1
					SET @QuantityShort = @QuantityShort * -1
				END
				
				IF @Type IN (''012'') --reverse long/shorts
				BEGIN
					DECLARE @TempQnt INT
					SET @TempQnt = @QuantityLong
					SET @QuantityLong = @QuantityShort
					SET @QuantityShort = @TempQnt
				END
			END

			set @Output = null
			declare @InstrumentTypeId int
			set @Code = @InstrumentTypeCd
			exec @ReturnValue = ib_Instrumenttype_AddAsNeeded @DataSourceId,@Code,@OutPut output
			set @InstrumentTypeId = @OutPut
			set @Output = null
			declare @FirmId int
			set @Code = @FirmCd
			exec @ReturnValue= [ib_Firm_AddAsNeeded] @DataSourceId,@Code,@OutPut output	
			set @FirmId = @OutPut
	
			set @Output = null
			set	@OutPut2 = null
			declare @AccountId int
			DECLARE @DetailAccountId INT
			declare @ClassId   int
			set @Code = @AccountCd
			DECLARE @IsImported bit
			SET @IsImported = NULL
			
			exec @ReturnValue= [ib_Account_AddAsNeeded] @Code,@FirmId,@OutPut output,@OutPut2 output, @IsImported = @IsImported OUTPUT
			set @AccountId = @OutPut
			set @ClassId = @OutPut2
			IF @ExchangeCd = ''LME''
					SET @DetailAccountId = NULL
				ELSE
					SET @DetailAccountId = @AccountId -- This is OK as @FirmId is correct Marex (R&N)
	
			IF (@IsImported = 1)
			BEGIN
			
				set @Output = null
				declare @CurrencyId int

				if @Currency is not Null
				begin
					exec @ReturnValue = [ib_Currency_AddAsNeeded] @DataSourceId, @Currency, @Output output
					set @CurrencyId = @Output
				end

				set @Output = null
				set @Output2 = null
				declare @InstrumentId int
				set @Code = @InstrumentCd
				exec @ReturnValue= [ib_Instrument_AddAsNeeded] @DataSourceId,@InstrumentTypeId,@Code,@CurrencyId,@Output output,@Output2 output	
				set @InstrumentId = @Output
				if @CurrencyId is null
				begin
					if @Output2 is null
						set @CurrencyId = @DefaultCurrencyId	
					else
						set @CurrencyId = @Output2
				end

				DECLARE	@MarketValueDivisor DECIMAL(19,4)
	
				SELECT @MarketValueDivisor = id.MarketValueDivisor 
				FROM ib_InstrumentDataSource id 
			    WHERE id.InstrumentId = @InstrumentId 
				   AND id.DataSourceId = @DataSourceId 
				   AND id.DataSourceId = @DataSourceId 
				   AND id.CurrencyId = @CurrencyId

				IF @MarketValueDivisor IS NULL OR @MarketValueDivisor = 0
				BEGIN
					SET @MarketValueDivisor = 1
				END

				/* New Code - Begin*/
				DECLARE @Base INT
				DECLARE @BaseId INT
				DECLARE @PriceDivisor DECIMAL(19, 4)
				
				SET @StrikePriceDivisor = NULL
				SET @PriceDivisor = NULL
				SET @Base = NULL
				SET @BaseId = NULL
				
				SELECT @StrikePriceDivisor = ids.StrikePriceDivisor
						, @PriceDivisor = ids.PriceDivisor
						, @Base = b.Base
						, @BaseId = b.BaseId
				FROM [dbo].[ib_InstrumentDataSource] ids
					LEFT OUTER JOIN ib_Base b ON b.BaseId = ids.BaseId
				WHERE ids.DataSourceId = @DataSourceId
					AND ids.DataSourceInstrumentCode = @InstrumentCd 
				
				IF ISNUMERIC(@Price) > 0
				BEGIN
					SET @PriceDec = CONVERT(DECIMAL(24, 10), @Price)
					--apply the 3-4 dp correction
					SET @PriceDec = dbo.PerformCorrections(@PriceDec, @BaseId)
				END
				
				IF @PriceDivisor IS NULL
				BEGIN
					SET @PriceDivisor = 1
				END
				
				--Reset correct price
				IF	@Type = ''001'' OR 
					@Type = ''002'' OR
					@Type = ''014'' OR
					@Type = ''018'' OR 
					@Type = ''019'' OR 
					@Type = ''091''
				BEGIN
					IF(@PriceDec IS NOT NULL)
					BEGIN
						SET @PriceDec = @PriceDec / @PriceDivisor
					END
				END
			
				SET @PriceDec = dbo.udf_ConvertToBase10(@PriceDec, @Base)
			
				IF	@Type = ''001'' OR 
					@Type = ''002'' OR
					@Type = ''018'' OR 
					@Type = ''019'' OR 
					@Type = ''091'' OR
					@Type = ''005'' OR			-- KevinP - Reset the Market Value for 005 Record Types as per conversation with Jeff..
					@Type = ''007''
				BEGIN
					SET @MarketValue = CONVERT(DECIMAL(19,4), @PostingAmount) / @MarketValueDivisor
				END
			
				IF	@Type = ''014'' -- This needs to be the inverse
				BEGIN
					SET @MarketValue = (CONVERT(DECIMAL(19,4), @PostingAmount) * -1) / @MarketValueDivisor
				END
			
				 -- The Market Value is to be derived from the Premium
				IF	@Type = ''006'' OR
					@Type = ''012'' OR 
					@Type = ''013'' OR
					@Type = ''003'' OR 
					@Type = ''004'' OR
					@Type = ''020'' OR 
					@Type = ''093''
				BEGIN
					SET @MarketValue = CONVERT(DECIMAL(19,4), @Premium) / @MarketValueDivisor
				END
			
				IF @Type IN (''004'', ''020'')
					SET @MarketValue = @MarketValue * -1
				
				IF @DataSourceCd = ''OTCM'' 
					SET @MarketValue = -1 * @MarketValue
				
				IF @Type = ''004'' AND @PriceDec < 0
					SET @PriceDec = @PriceDec * -1
				-- fix price
				IF @Type IN (''006'', ''012'', ''013'')
					SET @PriceDec = 0
				/* New Code - End*/

				IF @StrikePrice IS NOT NULL
				BEGIN
					IF @StrikePriceDivisor IS NULL
					BEGIN
						SET @StrikePrice = @StrikePrice / @DefaultStrikePriceDivisor
					END
					ELSE
					BEGIN
						SET @StrikePrice = @StrikePrice / @StrikePriceDivisor
					END
				END
				
				-- TrxDate (first try serial2 but since not always a date, then go to rundate)
				IF LEN(@Serial2) = 10
					SET @TrxDate = ''20'' + LEFT(@Serial2, 6)
				ELSE
					SET @TrxDate = @RunDate
	
				-- AsOfDate
				SET @AsOfDate = @RunDate
				SET @SelectedAsOfDate = @AsOfDate

				EXEC [ib_Trx_WithIds_Load]
				@DataSourceId,			
				@ExchangeCd,				
				@FirmId,					
				@AccountId,
				@DetailAccountId,				
				@InstrumentId,			
				@ExpYr,					
				@ExpMth,					
				@ExpDay,					
				@StrikePrice,			
				@TrxTypeCd,				
				@OptionTypeCd,
				@Quantity,			
				@TrxDate,				
				@PriceDec,
				@RolfeNolan_HOSTTRNID,
				@InstrumentTypeId,
				@AsOfDate,		
				@LocationPath,
				@MarketValue,
				@CurrencyId,
				@ClassId,
				@QuantityLong = @QuantityLong,
				@QuantityShort = @QuantityShort,
				@ReceiveLocationSysId = @ReceiveLocationSysId,
				@RunId = @RunId,
				@UTI = @UTI
				
			END -- IF @IsImported = 1
			
			--flip processed flag in source table.
			UPDATE [RolfeNolan_HOSTTRN]
			SET [LoadState] = 2
			WHERE [RolfeNolan_HOSTTRNID] = @RolfeNolan_HOSTTRNID
				AND [LoadState] = 1

			FETCH NEXT FROM pos_cursor
			INTO 
					@RolfeNolan_HOSTTRNID,
					@Type,
					@Ledger,
					@Currency,
					@Market,
					@MarketCode,
					@RunDate,
					@PromptDate,
					@Strike,
					@PutCall,
					@Lots,
					@Price,
					@OpenClose,
					@PostingAmount,
					@Premium,
					@Serial2,
					@UTI

		END
			
			CLOSE pos_cursor
			DEALLOCATE pos_cursor
			
			--Update the other records where [IsMergedTrade] may = ''Y'', but haven''t updated their LoadState because they didn''t form part of the SELECT criteria
			--flip processed flag in source table.
			UPDATE [RolfeNolan_HOSTTRN]
			SET [LoadState] = 2
			WHERE [FileName] = @LocationPath
				AND [LoadState] = 1

			UPDATE ib_ImportFile 
			SET AsOfDate = CAST(CONVERT(CHAR(10), @SelectedAsOfDate, 101) AS DATETIME)  
			WHERE ImportFileId = @ImportFileId

		COMMIT TRAN T1

	DROP TABLE #temp1
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Adjustment_GetCountByExchange]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Adjustment_GetCountByExchange]
	@FromDate DATETIME = ''1 JAN 1980''
AS
	-- 21 Nov 2010		amk		Creation
	
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	SELECT e.Code as Exchange, a.AdjustmentDate, COUNT(*) AS Adjustments
	FROM ib_Adjustment a WITH (NOLOCK)
		JOIN ib_Exchange e ON e.ExchangeId = a.ExchangeId
	WHERE a.AdjustmentDate >= @FromDate
	GROUP BY e.Code, a.AdjustmentDate
');

GO
EXECUTE ('PRINT N''Creating [stage].[RosenthalCollinsPosition_LoadStateChange]''
');

GO
EXECUTE ('CREATE PROCEDURE [stage].[RosenthalCollinsPosition_LoadStateChange] 
	-- Add the parameters for the stored procedure here
	(
		@OldLoadState	TINYINT,
		@NewLoadState	TINYINT
	)
AS
-- =============================================
-- Author:		KIR
-- Create date: 16 Jan 2019
-- Description:	Changes the LoadState of the RosenthalCollinsPosition type table
-- =============================================
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

		UPDATE [stage].[RosenthalCollinsPosition] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[aspnet_Personalization_GetApplicationId]''
');

GO
SET QUOTED_IDENTIFIER OFF

GO
EXECUTE ('CREATE PROCEDURE [dbo].[aspnet_Personalization_GetApplicationId] (
    @ApplicationName NVARCHAR(256),
    @ApplicationId UNIQUEIDENTIFIER OUT)
AS
SET NOCOUNT ON
BEGIN
    SELECT @ApplicationId = ApplicationId FROM dbo.aspnet_Applications WHERE LOWER(@ApplicationName) = LoweredApplicationName
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Position_GetQueryResults]''
');

GO
SET QUOTED_IDENTIFIER ON

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Position_GetQueryResults]
(
		@UserId UNIQUEIDENTIFIER,
		@ExchangeId INT=NULL,
		@DataSourceId INT=NULL,
		@FirmId INT=NULL,
		@AsOfDateOperator VARCHAR(12)=''Equals'', -- Equals, Less Than, Greater Than, Between
        @AsOfDateFrom DATETIME=NULL,
        @AsOfDateTo DATETIME=NULL,
		@InstrumentId INT=NULL,
		@StrikePriceOperator VARCHAR(12)=''Equals'', -- Equals, Less Than, Greater Than, Between
        @StrikePriceFrom DECIMAL(24, 10)=NULL,
		@StrikePriceTo DECIMAL(24, 10)=NULL,
		@ExpiryDay INT=NULL,
		@ExpiryMonth INT=NULL,
		@ExpiryYear INT=NULL,
		@TradeType INT=2, -- 0 = Future, 1 = Option, 2 = All.
		@OptionType INT=2, -- 0 = Call, 1 = Put, 2 = All.
		@QuantityOperator VARCHAR(12)=''Equals'', -- Equals, Less Than, Greater Than, Between
        @QuantityFrom DECIMAL(24, 10)=NULL,
		@QuantityTo DECIMAL(24, 10)=NULL,
		@AccountOperator VARCHAR(11)=''Equals'', -- Equals, Starts With, Contains
        @Account VARCHAR(100)=NULL,
		@ClassId INT=NULL,
		@MarketValueOperator VARCHAR(12)=''Equals'', -- Equals, Less Than, Greater Than, Between
        @MarketValueFrom DECIMAL(24, 10)=NULL,
		@MarketValueTo DECIMAL(24, 10)=NULL,
		@IsForExport BIT=0,
		@FamilyCodeOperator VARCHAR(11)=''Equals'', -- Equals, Starts With, Contains
        @FamilyCode VARCHAR(100)=NULL
    )
AS
BEGIN
--Description: get the query result for positions
--Creation: 13 May 2010 ED
-- 06 Jul 2010 ED MBAL 16068 - improve the result of position query
-- 21 May 2012 ED MBAL 20868 - Date field of 999999 breaks Position Query
-- 15 Apr 2014 ED EIB 25542  - Add Long/Short columns
-- 22 Apr 2014 ED EIB 25502  - Add FamilyCode filtering
-- 25 Jun 2014 ED EIB 25775  - Display UTI
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    DECLARE @SQL NVARCHAR(4000)
	DECLARE @WHERE NVARCHAR(4000)
	DECLARE @SelectTopStatement VARCHAR(MAX)
	DECLARE @FROM NVARCHAR(4000)
	
	SET @FROM = '' FROM [dbo].[ib_Position] p (nolock)
	JOIN ib_DataSource ds ON ds.DataSourceId = p.DataSourceId
	JOIN ib_Exchange e ON e.ExchangeId = p.ExchangeId
	JOIN ib_Firm f ON f.FirmId = p.FirmId
	LEFT OUTER JOIN ib_Account a ON a.AccountId = p.AccountId
	JOIN ib_Instrument i ON i.InstrumentId = p.InstrumentId
	JOIN ib_InstrumentType it ON i.InstrumentTypeId=it.InstrumentTypeId
	LEFT OUTER JOIN ib_Class c ON c.ClassId = p.ClassId
	JOIN ib_Currency cur ON cur.CurrencyId = p.CurrencyId
	LEFT JOIN ib_Price price ON price.[AsOfDate] = p.AsOfDate 
							AND price.[DataSourceId] = p.DataSourceId 
							AND price.[ExchangeId] = p.ExchangeId
							AND price.[InstrumentId] = p.InstrumentId 
							AND price.[CurrencyId] = p.CurrencyId 
							AND price.[ExpiryYear] = p.ExpiryYear 
							AND price.[ExpiryMonth] = p.ExpiryMonth 
							AND (price.[ExpiryDay] = p.ExpiryDay OR (price.ExpiryDay IS NULL AND p.ExpiryDay IS NULL)) 
							AND (price.[StrikePrice] = p.StrikePrice  OR (price.StrikePrice IS NULL AND p.StrikePrice IS NULL)) 
							AND (price.[OptionTypeCode] = p.OptionTypeCode  OR (price.OptionTypeCode IS NULL AND p.OptionTypeCode IS NULL)) 
	
	''
		
	IF @IsForExport = 0
		SET @SelectTopStatement = ''SELECT TOP 1000 ''
	ELSE
		SET @SelectTopStatement = ''SELECT ''

	
	SET @WHERE = '' WHERE p.PositionId IS NOT NULL ''
--ids
	IF @ExchangeId IS NOT NULL
		SET @WHERE = @WHERE + '' AND p.ExchangeId=''+CAST(@ExchangeId AS VARCHAR(MAX))
	IF @DataSourceId IS NOT NULL
		SET @WHERE = @WHERE + '' AND p.DataSourceId='' +CAST(@DataSourceId AS VARCHAR(MAX))
	IF @FirmId IS NOT NULL
		SET @WHERE = @WHERE + '' AND p.FirmId='' +CAST(@FirmId AS VARCHAR(MAX))
	IF @InstrumentId IS NOT NULL
		SET @WHERE = @WHERE + '' AND p.InstrumentId=''+CAST(@InstrumentId AS VARCHAR(MAX))
	IF @ClassId IS NOT NULL
		SET @WHERE = @WHERE + '' AND p.ClassId='' +CAST(@ClassId AS VARCHAR(MAX))
--expiry
	IF @ExpiryDay IS NOT NULL
		SET @WHERE = @WHERE + '' AND p.ExpiryDay='' +CAST(@ExpiryDay AS VARCHAR(MAX))
	IF @ExpiryMonth IS NOT NULL
		SET @WHERE = @WHERE + '' AND p.ExpiryMonth='' +CAST(@ExpiryMonth AS VARCHAR(MAX))
	IF @ExpiryYear IS NOT NULL
		SET @WHERE = @WHERE + '' AND p.ExpiryYear='' +CAST(@ExpiryYear AS VARCHAR(MAX))
--
--datetime
	IF @AsOfDateFrom IS NOT NULL
		SET @WHERE = @WHERE + '' AND p.AsOfDate'' +dbo.OperatorTranslate(@AsOfDateOperator,CAST(@AsOfDateFrom AS VARCHAR(MAX)),CAST(@AsOfDateTo AS VARCHAR(MAX)),1,1)
--decimal
	IF @StrikePriceFrom IS NOT NULL
		SET @WHERE = @WHERE + '' AND p.StrikePrice'' + dbo.OperatorTranslate(@StrikePriceOperator, @StrikePriceFrom, @StrikePriceTo, 0,0)
	IF @QuantityFrom IS NOT NULL
		SET @WHERE = @WHERE + '' AND p.Quantity'' + dbo.OperatorTranslate(@QuantityOperator, @QuantityFrom, @QuantityTo, 0,0)
	IF @MarketValueFrom IS NOT NULL
		SET @WHERE = @WHERE + '' AND p.MarketValue'' + dbo.OperatorTranslate(@MarketValueOperator, @MarketValueFrom, @MarketValueTo, 0,0)
		
		
    IF @Account IS NOT NULL
        SET @WHERE = @WHERE + '' AND a.Code'' + dbo.OperatorTranslate(@AccountOperator, @Account, NULL, 1,0)
	
	IF @FamilyCode IS NOT NULL
		SET @WHERE = @WHERE + '' AND a.FamilyCode '' + dbo.OperatorTranslate(@FamilyCodeOperator, @FamilyCode, NULL, 1, 0)

	IF @TradeType = 0 --Future
		SET @WHERE = @WHERE + '' AND it.Code=''''F'''' ''
	
	IF @TradeType = 1 --Option
		SET @WHERE = @WHERE + '' AND (it.Code=''''O'''' OR it.Code=''''P'''') ''
		
	IF @OptionType = 0 --Call
		SET @WHERE = @WHERE + '' AND p.OptionTypeCode=''''C'''' ''
	
	IF @OptionType = 1 --Put
		SET @WHERE = @WHERE + '' AND p.OptionTypeCode=''''P'''' ''
    


SET @sql = @SelectTopStatement + ''e.Code AS Exchange 
					,ds.Code AS [DataSource]
					,i.Code AS [Instrument]
					,SUM(p.Quantity) Quantity
					,p.AsOfDate AS [AsOfDate]
					,p.ExpiryYear
					,SUBSTRING(DATENAME(MONTH, CONVERT( DATETIME, ''''2007-'''' + 
						CAST(CASE WHEN p.ExpiryMonth = 99 THEN 12 ELSE p.ExpiryMonth END AS VARCHAR(2)) + ''''-01'''', 120)),0,4) AS ExpiryMonth
					,CASE WHEN p.ExpiryDay = 99 THEN ''''31'''' ELSE p.ExpiryDay END as ExpiryDay
					,p.StrikePrice AS [StrikePrice], cur.Code AS [Currency]
					,p.OptionTypeCode AS [OptionType]
					,f.Code AS [Firm], a.Code AS [Account], c.Code AS [Class]
					,SUM(p.MarketValue) AS [MarketValue]
					,it.Code InstrumentType
					,price.SettlementPrice AS SettPrice
					,COUNT(*) AS NoRows
					,SUM(p.LongQuantity) AS Long
					,SUM(p.ShortQuantity) AS Short
					,a.FamilyCode
					,p.UTI 
      '' + @FROM + @WHERE + ''
      GROUP BY e.Code ,ds.Code,i.Code,p.AsOfDate,p.ExpiryYear,p.ExpiryMonth,p.ExpiryDay,p.StrikePrice, cur.Code
					,p.OptionTypeCode,f.Code, a.Code, c.Code,it.Code, price.SettlementPrice, a.FamilyCode, p.UTI 
        ORDER BY	i.code,
				p.ExpiryYear,
				p.ExpiryMonth,
				p.ExpiryDay,
				p.OptionTypeCode,
				p.StrikePrice,
				e.code,
				ds.code,
				f.code,
				c.code,
				a.code,
				cur.code''

-- Execute the query
EXEC sp_executesql @sql


END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Adjustment_GetByAdjustmentReasonId]''
');

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Select records from the ib_Adjustment table through an index
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[ib_Adjustment_GetByAdjustmentReasonId]
(

	@AdjustmentReasonId int   
)
AS


				SELECT
					[AdjustmentId],
					[TemplateId],
					[ExchangeId],
					[InstrumentId],
					[InternalExternalCode],
					[TradeDate],
					[AdjustmentDate],
					[Quantity],
					[CurrencyId],
					[ExpiryYear],
					[ExpiryMonth],
					[ExpiryDay],
					[StrikePrice],
					[TradePrice],
					[SettlementPrice],
					[OptionTypeCode],
					[Value],
					[PremiumValue],
					[OptionValue],
					[Description],
					[TemplateGroupId],
					[CreateDate],
					[CreateUsername],
					[UpdateDate],
					[UpdateUsername],
					[IsBuy],
					[MatchCodeId],
					[AdjustmentHeaderId],
					[DataSourceId],
					[FirmId],
					[QuantityLong],
					[QuantityShort],
					[DetailAccountId],
					[AccountId],
					[ClassId],
					[AdjustmentStatusId],
					[AdjustmentReasonId],
					[TrxTypeCode],
					[AdjustmentUserStatusId],
					[MatchingAdjustmentId],
					[ReplacesAdjustmentId]
				FROM
					[dbo].[ib_Adjustment]
				WHERE
					[AdjustmentReasonId] = @AdjustmentReasonId
				SELECT @@ROWCOUNT
					
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_HOSTOPN_Delete]''
');

GO
EXECUTE ('/*
<details>
 <summary>Deletes a data source by its id from the ib_DataSource table</summary>
 <created author="Laurentiu Macovei" Date="Friday, 8 September 2006 11:20PM GMT" /> 
</details>
*/
CREATE PROCEDURE [dbo].[ib_HOSTOPN_Delete]
(
	@DataSourceId int 
)
AS
SET NOCOUNT ON

DELETE FROM [dbo].[ib_position]
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_RolfeNolan_HOSTTRN_V2_Load]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_RolfeNolan_HOSTTRN_V2_Load]
	(
		  @LocationPath	varchar(512) = NULL
		, @ReceiveLocationSysId INT
		, @RunId INT
	)
AS
SET NOCOUNT ON
BEGIN


--KevinP - Defer Loading to the Master SP
-- 10 Jan 2014		ED			EIB 25004 - remove importLog table and use Log table

EXEC [dbo].[ib_RolfeNolan_HOSTTRN_Load]  @LocationPath, @ReceiveLocationSysId, @RunId
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Adjustment_GetDataForChart]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Adjustment_GetDataForChart]
AS
	--	25 Aug 2010		amk		Creation
	--	26 Aug 2010		amk		Finish work

	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	DECLARE @AsOfDate DATETIME
	SELECT @AsOfDate = MAX(AdjustmentDate)
	FROM ib_Adjustment

	SELECT a.AdjustmentDate AS AsOfDate, ds.Code AS DataSource, c.Code AS Currency
		, SUM(ABS(Quantity)) AS tot_qty, SUM(ABS(Value)) AS tot_value
		, COUNT(*) AS adj_count
	FROM ib_Adjustment a
		JOIN ib_DataSource ds ON ds.DataSourceId = a.DataSourceId
		JOIN ib_Currency c ON c.CurrencyId = a.CurrencyId
	WHERE a.AdjustmentDate = @AsOfDate
	GROUP BY a.AdjustmentDate, ds.Code, c.Code
');

GO
EXECUTE ('PRINT N''Creating [stage].[RosenthalCollinsPosition_Purge]''
');

GO
EXECUTE ('CREATE PROCEDURE [stage].[RosenthalCollinsPosition_Purge] 
	(
		@LoadState		TINYINT = 0,
		@FileName       VARCHAR (512)= NULL
	)
AS

-- =============================================
-- Author:		KIR
-- Create date: 16 Jan 2019
-- Description:	Deletes from RosenthalCollinsPosition table all the records where the LoadState is 0
-- =============================================
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
		DELETE FROM [stage].[RosenthalCollinsPosition] WHERE LoadState= @LoadState AND [FileName] = Coalesce(@FileName, [FileName])

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[aspnet_PersonalizationAdministration_DeleteAllState]''
');

GO
SET QUOTED_IDENTIFIER OFF

GO
EXECUTE ('CREATE PROCEDURE [dbo].[aspnet_PersonalizationAdministration_DeleteAllState] (
    @AllUsersScope bit,
    @ApplicationName NVARCHAR(256),
    @Count int OUT)
AS
SET NOCOUNT ON
BEGIN
    DECLARE @ApplicationId UNIQUEIDENTIFIER
    EXEC dbo.aspnet_Personalization_GetApplicationId @ApplicationName, @ApplicationId OUTPUT
    IF (@ApplicationId IS NULL)
        SELECT @Count = 0
    ELSE
    BEGIN
        IF (@AllUsersScope = 1)
            DELETE FROM aspnet_PersonalizationAllUsers
            WHERE PathId IN
               (SELECT Paths.PathId
                FROM dbo.aspnet_Paths Paths
                WHERE Paths.ApplicationId = @ApplicationId)
        ELSE
            DELETE FROM aspnet_PersonalizationPerUser
            WHERE PathId IN
               (SELECT Paths.PathId
                FROM dbo.aspnet_Paths Paths
                WHERE Paths.ApplicationId = @ApplicationId)

        SELECT @Count = @@ROWCOUNT
    END
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TrxType_Add]''
');

GO
SET QUOTED_IDENTIFIER ON

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_TrxType_Add]
    @DataSourceId INT
   ,@Code VARCHAR(100)
   ,@Description VARCHAR(100)
   ,@IsPosition BIT = 0
   ,@IsPremium BIT = 0
   ,@IsPandS BIT = 0
   ,@IsPandL BIT = 0
   ,@IsTrade BIT = 0
   ,@ExcludeFromTradeRec BIT = 0
   ,@IsCancellation BIT = 0
   ,@IsOptionMarketValue BIT = 0
   ,@IsAutoMatched BIT = 0
   ,@@TrxTypeId INT OUTPUT
AS 
SET NOCOUNT ON

BEGIN

    INSERT  INTO [dbo].[ib_TrxType]
            ( [DataSourceId]
            ,[Code]
            ,[Description]
            ,[IsPosition]
            ,[IsPremium]
            ,[IsPandS]
            ,[IsPandL]
            ,[CreateDate]
            ,[CreateUsername]
            ,[UpdateDate]
            ,[UpdateUsername]
            ,[IsTrade]
            ,[ExcludeFromTradeRec]
            ,[IsCancellation]
            ,[IsOptionMarketValue]
            ,[IsAutoMatched]
            )
    VALUES
            ( @DataSourceId
            ,@Code
            ,@Description
            ,@IsPosition
            ,@IsPremium
            ,@IsPandS
            ,@IsPandL
            ,GETDATE()
            ,SUSER_SNAME()
            ,NULL
            ,NULL
            ,@IsTrade
            ,@ExcludeFromTradeRec
            ,@IsCancellation
            ,@IsOptionMarketValue
            ,@IsAutoMatched
            )
           
    SELECT
        @@TrxTypeId = SCOPE_IDENTITY()           
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Position_GetSelected]''
');

GO
EXECUTE ('
  /*
<details>
 <summary>Returns selected positions</summary>
 <created author="anil.kripalani" date="17 Oct 2006"/>
 <updated author="anil.kripalani" date="19 Oct 2006" commens="new instr code parameter" />
</details>
 Version	Date			Author		Description
 1.1		31 Jan 2007		LM			Added extra parameters
			07 Feb 2007		amk			Bug Fix: Catch null optiontypecode in data

*/
CREATE PROCEDURE [dbo].[ib_Position_GetSelected]
	  @AsOfDate			DATETIME
	, @ExchangeCode		VARCHAR(25)		= ''%''
	, @DataSourceCode	VARCHAR(100)	= ''%''
	, @FirmCode			VARCHAR(100)	= ''%''
	, @InstrumentCode	VARCHAR(100)	= ''%''
	, @StrikePrice		MONEY			= NULL
	, @ExpiryDay		SMALLINT		= NULL
	, @ExpiryMonth		SMALLINT		= NULL
	, @ExpiryYear		SMALLINT		= NULL
	, @OptionTypeCode	VARCHAR(1)		= ''%''		 

AS

IF @StrikePrice		= -99 SET @StrikePrice = NULL
IF @ExpiryDay		= -99 SET @ExpiryDay = NULL
IF @ExpiryMonth		= -99 SET @ExpiryMonth = NULL
IF @ExpiryYear		= -99 SET @ExpiryYear = NULL


--	DECLARE @StrikePrice		MONEY		
--	DECLARE @ExpiryDay		SMALLINT		
--	DECLARE @ExpiryMonth		SMALLINT	
--	DECLARE @ExpiryYear		SMALLINT		
--	DECLARE @OptionTypeCode	VARCHAR(1)		


	SET NOCOUNT ON	

	SELECT TOP 1000 e.Code AS Exchange 
					,ds.Code AS [Data Source]
					,i.Code AS [Instrument]
					,p.Quantity
					,CONVERT(VARCHAR(10), p.AsOfDate, 111) AS [As Of]
					,CONVERT(VARCHAR(4), p.ExpiryYear) + ''/'' + CONVERT(VARCHAR(2), p.ExpiryMonth) + CASE WHEN p.ExpiryDay IS NULL THEN '''' ELSE ''/'' + CONVERT(VARCHAR(2), p.ExpiryDay) END AS Expiry
					,p.StrikePrice AS [Strike Price], cur.Code AS [Currency]
					,p.OptionTypeCode AS [Opt Type]
					,f.Code AS [Firm], a.Code AS [Account], c.Code AS [Class]
					,p.MarketValue AS [Market Value]
					,p.TrxTypeCode AS [Trx Type]

	FROM			[dbo].[ib_Position] p

	JOIN ib_DataSource ds ON ds.DataSourceId = p.DataSourceId
	JOIN ib_Exchange e ON e.ExchangeId = p.ExchangeId
	JOIN ib_Firm f ON f.FirmId = p.FirmId
	LEFT OUTER JOIN ib_Account a ON a.AccountId = p.AccountId
	JOIN ib_Instrument i ON i.InstrumentId = p.InstrumentId
	LEFT OUTER JOIN ib_Class c ON c.ClassId = p.ClassId
	JOIN ib_Currency cur ON cur.CurrencyId = p.CurrencyId

	WHERE	e.Code LIKE @ExchangeCode
	AND		ds.Code LIKE @DataSourceCode
	AND		f.Code LIKE @FirmCode
	AND		p.AsOfDate = @AsOfDate
	AND		i.Code LIKE @InstrumentCode
	AND		(p.StrikePrice = @StrikePrice OR @StrikePrice IS NULL)
	AND		(p.ExpiryDay = @ExpiryDay OR @ExpiryDay Is NULL) 
	AND		(p.ExpiryMonth = @ExpiryMonth  OR @ExpiryMonth IS NULL)
	AND		(p.ExpiryYear = @ExpiryYear OR @ExpiryYear IS NULL)
	AND		(p.OptionTypeCode LIKE @OptionTypeCode OR (@OptionTypeCode = ''%''))

	ORDER BY	i.code,
				p.ExpiryYear,
				p.ExpiryMonth,
				p.ExpiryDay,
				p.OptionTypeCode,
				p.StrikePrice,
				e.code,
				ds.code,
				f.code,
				c.code,
				a.code,
				cur.code
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Adjustment_GetByAdjustmentStatusId]''
');

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Select records from the ib_Adjustment table through an index
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[ib_Adjustment_GetByAdjustmentStatusId]
(

	@AdjustmentStatusId int   
)
AS


				SELECT
					[AdjustmentId],
					[TemplateId],
					[ExchangeId],
					[InstrumentId],
					[InternalExternalCode],
					[TradeDate],
					[AdjustmentDate],
					[Quantity],
					[CurrencyId],
					[ExpiryYear],
					[ExpiryMonth],
					[ExpiryDay],
					[StrikePrice],
					[TradePrice],
					[SettlementPrice],
					[OptionTypeCode],
					[Value],
					[PremiumValue],
					[OptionValue],
					[Description],
					[TemplateGroupId],
					[CreateDate],
					[CreateUsername],
					[UpdateDate],
					[UpdateUsername],
					[IsBuy],
					[MatchCodeId],
					[AdjustmentHeaderId],
					[DataSourceId],
					[FirmId],
					[QuantityLong],
					[QuantityShort],
					[DetailAccountId],
					[AccountId],
					[ClassId],
					[AdjustmentStatusId],
					[AdjustmentReasonId],
					[TrxTypeCode],
					[AdjustmentUserStatusId],
					[MatchingAdjustmentId],
					[ReplacesAdjustmentId]
				FROM
					[dbo].[ib_Adjustment]
				WHERE
					[AdjustmentStatusId] = @AdjustmentStatusId
				SELECT @@ROWCOUNT
					
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_ScheduledTask_Add]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_ScheduledTask_Add]
	@name nvarchar(50),
	@description nvarchar(200) = NULL,
	@taskTypeId int,
	@runAtTime DateTime = null,
	@runAtSpecificDay int = null,
	@frequency INT = NULL,
	@isActive BIT = NULL,
	@siteId INT = NULL,
	@templateId INT = NULL,
	@CreateUsername NVARCHAR(50) = NULL
	,@@ScheduledTaskId INT OUTPUT 
AS
SET NOCOUNT ON
	PRINT ''[ib_ScheduledTask_Add]''
	SELECT * FROM ib_ScheduledTask
	
	SELECT @isActive = COALESCE(@isActive, 1)
	
	--DECLARE @allTemplates BIT
	
	--required for all templates
	--@templateId == 0 - means that all templates, as templatewith id 0 is provided by ib_Rule_GetTemplateBySite
	--SET @allTemplates = (CASE  @templateId WHEN 0 THEN 1 ELSE NULL END)
	SET @templateId = (CASE @templateId WHEN 0 THEN NULL ELSE @templateId END)
	
	INSERT INTO ib_ScheduledTask 
		(Name, Description, TaskTypeId, RunAtSpecificDay,
		Frequency, NextRun, LastRun, IsActive, CreateUsername, UpdateUserName, SiteId, TemplateId,CreateDate, UpdateDate, RunAtTime
		--,AllTemplates
		)
	VALUES( @name, @description, @taskTypeId, @runAtSpecificDay,
		@frequency, null, null, @isActive, @CreateUsername, null, @siteId, @templateId, getdate(), null,@runAtTime 
		--,@allTemplates
		)
	
	SELECT 
		@@ScheduledTaskId = SCOPE_IDENTITY()
		
	EXEC [sch_Reschedule] @updateUsername = @CreateUsername
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Adjustment_GetLatestAsOfDate]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Adjustment_GetLatestAsOfDate] 
(
	@outputAsOfDate DATETIME = NULL OUTPUT
)
AS
SET NOCOUNT ON
-- 24 May 2010	ED	 created
-- 26 May 2010	AAJM output AsOfDate

BEGIN

	SELECT @outputAsOfDate = MAX(AdjustmentDate) FROM ib_Adjustment
	SELECT @outputAsOfDate

END
');

GO
EXECUTE ('PRINT N''Creating [stage].[RosenthalCollinsTrade_LoadStateChange]''
');

GO
EXECUTE ('CREATE PROCEDURE [stage].[RosenthalCollinsTrade_LoadStateChange] 
	-- Add the parameters for the stored procedure here
	(
		@OldLoadState	TINYINT,
		@NewLoadState	TINYINT
	)
AS
-- =============================================
-- Author:		KIR
-- Create date: 16 Jan 2019
-- Description:	Changes the LoadState of the RosenthalCollinsTrade type table
-- =============================================
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

		UPDATE [stage].[RosenthalCollinsTrade] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[aspnet_PersonalizationAdministration_FindState]''
');

GO
SET QUOTED_IDENTIFIER OFF

GO
EXECUTE ('CREATE PROCEDURE [dbo].[aspnet_PersonalizationAdministration_FindState] (
    @AllUsersScope bit,
    @ApplicationName NVARCHAR(256),
    @PageIndex              INT,
    @PageSize               INT,
    @Path NVARCHAR(256) = NULL,
    @UserName NVARCHAR(256) = NULL,
    @InactiveSinceDate DATETIME = NULL)
AS
SET NOCOUNT ON
BEGIN
    DECLARE @ApplicationId UNIQUEIDENTIFIER
    EXEC dbo.aspnet_Personalization_GetApplicationId @ApplicationName, @ApplicationId OUTPUT
    IF (@ApplicationId IS NULL)
        RETURN

    -- Set the page bounds
    DECLARE @PageLowerBound INT
    DECLARE @PageUpperBound INT
    DECLARE @TotalRecords   INT
    SET @PageLowerBound = @PageSize * @PageIndex
    SET @PageUpperBound = @PageSize - 1 + @PageLowerBound

    -- Create a temp table to store the selected results
    CREATE TABLE #PageIndex (
        IndexId int IDENTITY (0, 1) NOT NULL,
        ItemId UNIQUEIDENTIFIER
    )

    IF (@AllUsersScope = 1)
    BEGIN
        -- Insert into our temp table
        INSERT INTO #PageIndex (ItemId)
        SELECT Paths.PathId
        FROM dbo.aspnet_Paths Paths,
             ((SELECT Paths.PathId
               FROM dbo.aspnet_PersonalizationAllUsers AllUsers, dbo.aspnet_Paths Paths
               WHERE Paths.ApplicationId = @ApplicationId
                      AND AllUsers.PathId = Paths.PathId
                      AND (@Path IS NULL OR Paths.LoweredPath LIKE LOWER(@Path))
              ) AS SharedDataPerPath
              FULL OUTER JOIN
              (SELECT DISTINCT Paths.PathId
               FROM dbo.aspnet_PersonalizationPerUser PerUser, dbo.aspnet_Paths Paths
               WHERE Paths.ApplicationId = @ApplicationId
                      AND PerUser.PathId = Paths.PathId
                      AND (@Path IS NULL OR Paths.LoweredPath LIKE LOWER(@Path))
              ) AS UserDataPerPath
              ON SharedDataPerPath.PathId = UserDataPerPath.PathId
             )
        WHERE Paths.PathId = SharedDataPerPath.PathId OR Paths.PathId = UserDataPerPath.PathId
        ORDER BY Paths.Path ASC

        SELECT @TotalRecords = @@ROWCOUNT

        SELECT Paths.Path,
               SharedDataPerPath.LastUpdatedDate,
               SharedDataPerPath.SharedDataLength,
               UserDataPerPath.UserDataLength,
               UserDataPerPath.UserCount
        FROM dbo.aspnet_Paths Paths,
             ((SELECT PageIndex.ItemId AS PathId,
                      AllUsers.LastUpdatedDate AS LastUpdatedDate,
                      DATALENGTH(AllUsers.PageSettings) AS SharedDataLength
               FROM dbo.aspnet_PersonalizationAllUsers AllUsers, #PageIndex PageIndex
               WHERE AllUsers.PathId = PageIndex.ItemId
                     AND PageIndex.IndexId >= @PageLowerBound AND PageIndex.IndexId <= @PageUpperBound
              ) AS SharedDataPerPath
              FULL OUTER JOIN
              (SELECT PageIndex.ItemId AS PathId,
                      SUM(DATALENGTH(PerUser.PageSettings)) AS UserDataLength,
                      COUNT(*) AS UserCount
               FROM aspnet_PersonalizationPerUser PerUser, #PageIndex PageIndex
               WHERE PerUser.PathId = PageIndex.ItemId
                     AND PageIndex.IndexId >= @PageLowerBound AND PageIndex.IndexId <= @PageUpperBound
               GROUP BY PageIndex.ItemId
              ) AS UserDataPerPath
              ON SharedDataPerPath.PathId = UserDataPerPath.PathId
             )
        WHERE Paths.PathId = SharedDataPerPath.PathId OR Paths.PathId = UserDataPerPath.PathId
        ORDER BY Paths.Path ASC
    END
    ELSE
    BEGIN
        -- Insert into our temp table
        INSERT INTO #PageIndex (ItemId)
        SELECT PerUser.Id
        FROM dbo.aspnet_PersonalizationPerUser PerUser, dbo.aspnet_Users Users, dbo.aspnet_Paths Paths
        WHERE Paths.ApplicationId = @ApplicationId
              AND PerUser.UserId = Users.UserId
              AND PerUser.PathId = Paths.PathId
              AND (@Path IS NULL OR Paths.LoweredPath LIKE LOWER(@Path))
              AND (@UserName IS NULL OR Users.LoweredUserName LIKE LOWER(@UserName))
              AND (@InactiveSinceDate IS NULL OR Users.LastActivityDate <= @InactiveSinceDate)
        ORDER BY Paths.Path ASC, Users.UserName ASC

        SELECT @TotalRecords = @@ROWCOUNT

        SELECT Paths.Path, PerUser.LastUpdatedDate, DATALENGTH(PerUser.PageSettings), Users.UserName, Users.LastActivityDate
        FROM dbo.aspnet_PersonalizationPerUser PerUser, dbo.aspnet_Users Users, dbo.aspnet_Paths Paths, #PageIndex PageIndex
        WHERE PerUser.Id = PageIndex.ItemId
              AND PerUser.UserId = Users.UserId
              AND PerUser.PathId = Paths.PathId
              AND PageIndex.IndexId >= @PageLowerBound AND PageIndex.IndexId <= @PageUpperBound
        ORDER BY Paths.Path ASC, Users.UserName ASC
    END

    RETURN @TotalRecords
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TrxType_Delete]''
');

GO
SET QUOTED_IDENTIFIER ON

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_TrxType_Delete] ( @TrxTypeId INT )
AS 
SET NOCOUNT ON

DELETE FROM
    [dbo].[ib_TrxType]
WHERE
    TrxTypeId = @TrxTypeId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Adjustment_GetByAdjustmentUserStatusId]''
');

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Select records from the ib_Adjustment table through an index
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[ib_Adjustment_GetByAdjustmentUserStatusId]
(

	@AdjustmentUserStatusId int   
)
AS


				SELECT
					[AdjustmentId],
					[TemplateId],
					[ExchangeId],
					[InstrumentId],
					[InternalExternalCode],
					[TradeDate],
					[AdjustmentDate],
					[Quantity],
					[CurrencyId],
					[ExpiryYear],
					[ExpiryMonth],
					[ExpiryDay],
					[StrikePrice],
					[TradePrice],
					[SettlementPrice],
					[OptionTypeCode],
					[Value],
					[PremiumValue],
					[OptionValue],
					[Description],
					[TemplateGroupId],
					[CreateDate],
					[CreateUsername],
					[UpdateDate],
					[UpdateUsername],
					[IsBuy],
					[MatchCodeId],
					[AdjustmentHeaderId],
					[DataSourceId],
					[FirmId],
					[QuantityLong],
					[QuantityShort],
					[DetailAccountId],
					[AccountId],
					[ClassId],
					[AdjustmentStatusId],
					[AdjustmentReasonId],
					[TrxTypeCode],
					[AdjustmentUserStatusId],
					[MatchingAdjustmentId],
					[ReplacesAdjustmentId]
				FROM
					[dbo].[ib_Adjustment]
				WHERE
					[AdjustmentUserStatusId] = @AdjustmentUserStatusId
				SELECT @@ROWCOUNT
					
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_ScheduledTask_Update]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_ScheduledTask_Update]
	@name				NVARCHAR(50) = NULL,          
	@description		NVARCHAR(200) = NULL,
	@taskTypeId			INT = NULL,    
	@runAtTime			DateTime = NULL,     
	@runAtSpecificDay	INT = NULL,
	@frequency			INT = NULL,
	@isActive			BIT = NULL,
	@siteId				INT = NULL,
	@templateId			INT = NULL,
	@updateUsername		NVARCHAR(50) = NULL,
	@scheduledTaskId	INT
AS
SET NOCOUNT ON
	--DECLARE @allTemplates BIT
	
	--SET @allTemplates = (CASE  @templateId WHEN 0 THEN 1 ELSE NULL END)

	SELECT @updateUsername = COALESCE(@updateUsername, USER_NAME())
	SELECT
		@name = COALESCE(@name, Name),		
		@description = COALESCE(@description, Description),
		@taskTypeId = COALESCE(@taskTypeId, TaskTypeId),
		@runAtTime = COALESCE(@runAtTime, RunAtTime),
		@runAtSpecificDay = COALESCE(@runAtSpecificDay, RunAtSpecificDay),
		@frequency = COALESCE(@frequency, Frequency),
		@isActive = COALESCE(@isActive, IsActive),
		@siteId = COALESCE(@siteId, SiteId),
		@templateId = COALESCE(@templateId, TemplateId)
		--,@allTemplates = COALESCE(@allTemplates, AllTemplates)
	FROM
		ib_ScheduledTask
	WHERE
		ScheduledTaskId = @scheduledTaskId	
		
	UPDATE
		ib_ScheduledTask
	SET
		Name = @name,
		Description = @description,
		TaskTypeId = @taskTypeId,
		RunAtTime = @runAtTime,
		RunAtSpecificDay = @runAtSpecificDay,
		Frequency = @frequency,
		IsActive = @isActive,
		SiteId = @siteId,
		UpdateUsername = @updateUsername,
		UpdateDate = getdate(),
		TemplateId = @templateId
		--,AllTemplates = @allTemplates
	WHERE
		ScheduledTaskId = @scheduledTaskId	
		
	EXEC [sch_Reschedule] @updateUsername = @updateUsername
');

GO
EXECUTE ('PRINT N''Creating [stage].[RosenthalCollinsTrade_Purge]''
');

GO
EXECUTE ('CREATE PROCEDURE [stage].[RosenthalCollinsTrade_Purge] 
	(
		@LoadState		TINYINT = 0,
		@FileName       VARCHAR (512)= NULL
	)
AS

-- =============================================
-- Author:		KIR
-- Create date: 16 Jan 2019
-- Description:	Deletes from RosenthalCollinsTrade table all the records where the LoadState is 0
-- =============================================
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
		DELETE FROM [stage].[RosenthalCollinsTrade] WHERE LoadState= @LoadState AND [FileName] = Coalesce(@FileName, [FileName])

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[aspnet_PersonalizationAdministration_GetCountOfState]''
');

GO
SET QUOTED_IDENTIFIER OFF

GO
EXECUTE ('CREATE PROCEDURE [dbo].[aspnet_PersonalizationAdministration_GetCountOfState] (
    @Count int OUT,
    @AllUsersScope bit,
    @ApplicationName NVARCHAR(256),
    @Path NVARCHAR(256) = NULL,
    @UserName NVARCHAR(256) = NULL,
    @InactiveSinceDate DATETIME = NULL)
AS
SET NOCOUNT ON
BEGIN

    DECLARE @ApplicationId UNIQUEIDENTIFIER
    EXEC dbo.aspnet_Personalization_GetApplicationId @ApplicationName, @ApplicationId OUTPUT
    IF (@ApplicationId IS NULL)
        SELECT @Count = 0
    ELSE
        IF (@AllUsersScope = 1)
            SELECT @Count = COUNT(*)
            FROM dbo.aspnet_PersonalizationAllUsers AllUsers, dbo.aspnet_Paths Paths
            WHERE Paths.ApplicationId = @ApplicationId
                  AND AllUsers.PathId = Paths.PathId
                  AND (@Path IS NULL OR Paths.LoweredPath LIKE LOWER(@Path))
        ELSE
            SELECT @Count = COUNT(*)
            FROM dbo.aspnet_PersonalizationPerUser PerUser, dbo.aspnet_Users Users, dbo.aspnet_Paths Paths
            WHERE Paths.ApplicationId = @ApplicationId
                  AND PerUser.UserId = Users.UserId
                  AND PerUser.PathId = Paths.PathId
                  AND (@Path IS NULL OR Paths.LoweredPath LIKE LOWER(@Path))
                  AND (@UserName IS NULL OR Users.LoweredUserName LIKE LOWER(@UserName))
                  AND (@InactiveSinceDate IS NULL OR Users.LastActivityDate <= @InactiveSinceDate)
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TrxType_GetAll]''
');

GO
SET QUOTED_IDENTIFIER ON

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_TrxType_GetAll]
AS
SET NOCOUNT ON
--	Description: Get All Transaction Types
--  14 May 2010 ED Created

	SELECT tt.TrxTypeId, tt.Code, tt.Code+'' - ''+ tt.Description AS CodeName
	, d.Name + '' - ''+tt.Code+'' - ''+ tt.Description AS DataSourceCodeName
	FROM ib_TrxType tt
	INNER JOIN ib_Datasource d ON d.DataSourceId=tt.DataSourceId
	ORDER BY tt.Description
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Position_GetSelected_SureStepSample]''
');

GO
EXECUTE ('
CREATE PROCEDURE [dbo].[ib_Position_GetSelected_SureStepSample]
	  @AsOfDate DATETIME
	, @DataSourceCode VARCHAR(100) = ''%''
	, @StrikePrice MONEY = NULL

AS

	--	Description: Flexible Position query used from Position Search screen

	--	17 Oct 2006		amk		Creation
	--	19 Oct 2006		amk		New instr code parameter
	--	31 Jan 2007		lm		Added extra parameters
	--	07 Feb 2007		amk		Bug Fix: Catch null optiontypecode in data

	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON	

	DECLARE @myPrice MONEY
	DECLARE @yourPrice MONEY

	SET @myPrice = 15.99
	SET @yourPrice = @myPrice + 29.99

	-- 1. Only select TOP x rows so as not to flood the UI
	-- 2. ib_Account can be Null so use left outer join
	-- 3. Strike price may not be provided so "OR (@StrikePrice is NULL)"
	--	delivers on that

	SELECT TOP 1000 ds.Code AS [Data Source]
		, CONVERT(VARCHAR(4), p.ExpiryYear) + ''/'' + CONVERT(VARCHAR(2), p.ExpiryMonth) 
			+ CASE WHEN p.ExpiryDay IS NULL THEN '''' ELSE ''/'' + CONVERT(VARCHAR(2), p.ExpiryDay) END AS Expiry
		, p.StrikePrice AS [Strike Price], p.OptionTypeCode AS [Opt Type]
	FROM [dbo].[ib_Position] p
		JOIN ib_DataSource ds ON ds.DataSourceId = p.DataSourceId
		LEFT OUTER JOIN ib_Account a ON a.AccountId = p.AccountId
	WHERE ds.Code LIKE @DataSourceCode
		AND p.AsOfDate = @AsOfDate
		AND ((p.StrikePrice = @StrikePrice) OR (@StrikePrice IS NULL))
	ORDER BY p.ExpiryYear, p.ExpiryMonth, p.ExpiryDay
		, p.OptionTypeCode, p.StrikePrice, ds.code

	IF @myPrice > @yourPrice
	BEGIN
		SET @yourPrice = 199.95
		SET @myPrice = 1.99

		IF @yourPrice > @myPrice
		BEGIN
			SET @myPrice = 199.95
			SET @yourPrice = 1.99
		END
	END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Adjustment_GetByClassId]''
');

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Select records from the ib_Adjustment table through an index
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[ib_Adjustment_GetByClassId]
(

	@ClassId int   
)
AS


				SELECT
					[AdjustmentId],
					[TemplateId],
					[ExchangeId],
					[InstrumentId],
					[InternalExternalCode],
					[TradeDate],
					[AdjustmentDate],
					[Quantity],
					[CurrencyId],
					[ExpiryYear],
					[ExpiryMonth],
					[ExpiryDay],
					[StrikePrice],
					[TradePrice],
					[SettlementPrice],
					[OptionTypeCode],
					[Value],
					[PremiumValue],
					[OptionValue],
					[Description],
					[TemplateGroupId],
					[CreateDate],
					[CreateUsername],
					[UpdateDate],
					[UpdateUsername],
					[IsBuy],
					[MatchCodeId],
					[AdjustmentHeaderId],
					[DataSourceId],
					[FirmId],
					[QuantityLong],
					[QuantityShort],
					[DetailAccountId],
					[AccountId],
					[ClassId],
					[AdjustmentStatusId],
					[AdjustmentReasonId],
					[TrxTypeCode],
					[AdjustmentUserStatusId],
					[MatchingAdjustmentId],
					[ReplacesAdjustmentId]
				FROM
					[dbo].[ib_Adjustment]
				WHERE
					[ClassId] = @ClassId
				SELECT @@ROWCOUNT
					
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[aspnet_PersonalizationAdministration_ResetSharedState]''
');

GO
SET QUOTED_IDENTIFIER OFF

GO
EXECUTE ('CREATE PROCEDURE [dbo].[aspnet_PersonalizationAdministration_ResetSharedState] (
    @Count int OUT,
    @ApplicationName NVARCHAR(256),
    @Path NVARCHAR(256))
AS
SET NOCOUNT ON
BEGIN
    DECLARE @ApplicationId UNIQUEIDENTIFIER
    EXEC dbo.aspnet_Personalization_GetApplicationId @ApplicationName, @ApplicationId OUTPUT
    IF (@ApplicationId IS NULL)
        SELECT @Count = 0
    ELSE
    BEGIN
        DELETE FROM dbo.aspnet_PersonalizationAllUsers
        WHERE PathId IN
            (SELECT AllUsers.PathId
             FROM dbo.aspnet_PersonalizationAllUsers AllUsers, dbo.aspnet_Paths Paths
             WHERE Paths.ApplicationId = @ApplicationId
                   AND AllUsers.PathId = Paths.PathId
                   AND Paths.LoweredPath = LOWER(@Path))

        SELECT @Count = @@ROWCOUNT
    END
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TrxType_GetByDataSourceId]''
');

GO
SET QUOTED_IDENTIFIER ON

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_TrxType_GetByDataSourceId]
    @DataSourceId INT = NULL
AS 
SET NOCOUNT ON

SELECT
    tt.TrxTypeId
   ,tt.Code
   ,tt.Code + '' - '' + tt.Description AS CodeName
   ,d.Name + '' - '' + tt.Code + '' - '' + tt.Description AS DataSourceCodeName
   ,tt.CreateUsername
   ,tt.UpdateUsername
   ,tt.CreateDate
   ,tt.UpdateUsername
   ,tt.Description
FROM
    ib_TrxType tt
INNER JOIN ib_Datasource d
ON  d.DataSourceId = tt.DataSourceId
WHERE
    ( tt.DataSourceId = @DataSourceId OR
      @DataSourceId IS NULL
    )
ORDER BY
    d.Name
   ,tt.Code
   ,tt.Description
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Adjustment_GetByDataSourceId]''
');

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Select records from the ib_Adjustment table through an index
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[ib_Adjustment_GetByDataSourceId]
(

	@DataSourceId int   
)
AS


				SELECT
					[AdjustmentId],
					[TemplateId],
					[ExchangeId],
					[InstrumentId],
					[InternalExternalCode],
					[TradeDate],
					[AdjustmentDate],
					[Quantity],
					[CurrencyId],
					[ExpiryYear],
					[ExpiryMonth],
					[ExpiryDay],
					[StrikePrice],
					[TradePrice],
					[SettlementPrice],
					[OptionTypeCode],
					[Value],
					[PremiumValue],
					[OptionValue],
					[Description],
					[TemplateGroupId],
					[CreateDate],
					[CreateUsername],
					[UpdateDate],
					[UpdateUsername],
					[IsBuy],
					[MatchCodeId],
					[AdjustmentHeaderId],
					[DataSourceId],
					[FirmId],
					[QuantityLong],
					[QuantityShort],
					[DetailAccountId],
					[AccountId],
					[ClassId],
					[AdjustmentStatusId],
					[AdjustmentReasonId],
					[TrxTypeCode],
					[AdjustmentUserStatusId],
					[MatchingAdjustmentId],
					[ReplacesAdjustmentId]
				FROM
					[dbo].[ib_Adjustment]
				WHERE
					[DataSourceId] = @DataSourceId
				SELECT @@ROWCOUNT
					
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Adjustment_InsertSplitRecord]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Adjustment_InsertSplitRecord]
	@OriginalAdjustmentId INT
	, @AccountCode VARCHAR(100)
	, @Lots INT
	, @Value DECIMAL(19,4)
	, @Username VARCHAR(50)
AS
SET NOCOUNT ON

-- Description: Insert an Adjustment Split Record into the ib_Adjustment table.
-- When creating split records, all fields from the original record will be copied
-- with the exception of DetailAccountId which will be set the same as AccountId.
-- The Description will be copied from the original Adjustment record, with an added
-- note stating "Split from 15 lots" with Username, Date/Time.
-- If the State of the Adjustment was U (Unapproved Account) prior to the split,
-- the State of the Adjustment will be set to ''blank'' on the split record.

-- 27 May 2010	aajm	Creation
-- 01 Jun 2010	ED		Make the message to be same as on other adj activities
-- 21 Jun 2010	ED		MBAL-13980: Fix ClassId
-- 02 Aug 2010	amk		MBAL-16363: Bug fix: carry forward replacesadjustmentid too

BEGIN

-- Avoid conflict with TradeReconciliationDetail Foreign Key.
-- This AdjustmentId is not used in the drill down.
UPDATE ib_TradeReconciliationDetail
SET AdjustmentId = NULL
WHERE AdjustmentId = @OriginalAdjustmentId

DECLARE 
	@AdjustmentId INT
	, @ExchangeId INT
	, @TemplateId INT
	, @InstrumentId INT
	, @InternalExternalCode CHAR (1)
	, @TradeDate DATETIME
	, @AdjustmentDate DATETIME
	, @Quantity INT
	, @CurrencyId INT
	, @ExpiryYear SMALLINT
	, @ExpiryMonth SMALLINT
	, @ExpiryDay SMALLINT
	, @StrikePrice DECIMAL (19, 4)
	, @TradePrice DECIMAL (24, 10)
	, @SettlementPrice DECIMAL (24, 10)
	, @OptionTypeCode VARCHAR (25)
	, @Description VARCHAR (255)
	, @TemplateGroupId INT
	, @CreateUsername VARCHAR (50)
	, @PremiumValue DECIMAL (19, 6)
	, @OptionValue DECIMAL (19, 6)
	, @IsBuy BIT
	, @MatchCodeId INT
	, @AdjustmentHeaderId INT
	, @DataSourceId INT
	, @FirmId INT
	, @QuantityLong INT
	, @QuantityShort INT
	, @AccountId INT
	, @ClassId INT
	, @AdjustmentStatusId INT
	, @AdjustmentReasonId INT
	, @TrxTypeCode VARCHAR(25)
	, @AdjustmentUserStatusId INT
	, @UnapprovedAccountAdjustmentStatusId INT
	, @CreateDate DATETIME
	, @ReplacesAdjustmentId INT
	
SELECT 
	@ExchangeId = a.[ExchangeId]
	, @TemplateId = a.[TemplateId]
	, @InstrumentId = a.[InstrumentId]
	, @InternalExternalCode = a.[InternalExternalCode]
	, @TradeDate = [TradeDate]
	, @AdjustmentDate = [AdjustmentDate]
	, @Quantity = [Quantity]
	, @CurrencyId = [CurrencyId]
	, @ExpiryYear = [ExpiryYear]
	, @ExpiryMonth = [ExpiryMonth]
	, @ExpiryDay = [ExpiryDay]
	, @StrikePrice = [StrikePrice]
	, @TradePrice = [TradePrice]
	, @SettlementPrice = [SettlementPrice]
	, @OptionTypeCode = [OptionTypeCode]
	, @Description = [Description]
	, @TemplateGroupId = [TemplateGroupId]
	, @PremiumValue = [PremiumValue]
	, @OptionValue = [OptionValue]
	, @IsBuy = [IsBuy]
	, @MatchCodeId = [MatchCodeId]
	, @AdjustmentHeaderId = [AdjustmentHeaderId]
	, @DataSourceId = [DataSourceId]
	, @FirmId = [FirmId]
	, @QuantityLong = [QuantityLong]
	, @QuantityShort = [QuantityShort]
	, @ClassId = [ClassId]
	, @AdjustmentStatusId = [AdjustmentStatusId]
	, @AdjustmentReasonId = [AdjustmentReasonId]
	, @TrxTypeCode = [TrxTypeCode]
	, @AdjustmentUserStatusId = [AdjustmentUserStatusId]
	, @ReplacesAdjustmentId = ReplacesAdjustmentId
FROM [dbo].[ib_Adjustment] a 
WHERE a.AdjustmentId = @OriginalAdjustmentId

SELECT @AccountId = AccountId 
FROM ib_Account 
WHERE Code = @AccountCode

IF @AccountId IS NULL
	RAISERROR (N''There is no Account with Code: %s'', 11, 1, @AccountCode)

SET @ClassId = (SELECT ClassId 
				FROM ib_Account 
				WHERE AccountId = @AccountId)

SET @CreateDate = GETDATE()

IF @Description IS NOT NULL AND LEN(@Description) > 1 
	SET @Description = '' ; '' + @Description
ELSE
	SET @Description = ''''
	
SET @Description = ''Split from '' + CONVERT(NVARCHAR(20), CASE WHEN @QuantityLong != 0 THEN @Quantity ELSE -1*@Quantity END) + '' lots (''+@Username+'', ''+CONVERT(CHAR(10), CURRENT_TIMESTAMP, 103)+'' ''+CONVERT(CHAR(5), CURRENT_TIMESTAMP, 114)+'') '' + @Description

SELECT @UnapprovedAccountAdjustmentStatusId = AdjustmentStatusId 
FROM ib_AdjustmentStatus 
WHERE Code = ''U''

IF @QuantityLong <> 0 
	SET @QuantityLong = @Lots
ELSE IF @QuantityShort <> 0 
	SET @QuantityShort = @Lots
	
-- If the State of the Adjustment was U (Unapproved Account) prior to the split,
-- change to ''blank'' on split records.
IF (@AdjustmentStatusId = @UnapprovedAccountAdjustmentStatusId)
	SET @AdjustmentStatusId = NULL

INSERT INTO [dbo].[ib_Adjustment]
		   ( [ExchangeId]
		   , [TemplateId]
           , [InstrumentId]
           , [InternalExternalCode]
           , [TradeDate]
           , [AdjustmentDate]
           , [Quantity]
           , [CurrencyId]
           , [ExpiryYear]
           , [ExpiryMonth]
           , [ExpiryDay]
           , [StrikePrice]
           , [TradePrice]
           , [SettlementPrice]
           , [OptionTypeCode]
           , [Value]
           , [Description]
           , [TemplateGroupId]
           , [PremiumValue]
           , [OptionValue]
           , [IsBuy]
           , [MatchCodeId]
           , [AdjustmentHeaderId]
           , [DataSourceId]
           , [FirmId]
           , [QuantityLong]
           , [QuantityShort]
           , [DetailAccountId]
           , [AccountId]
           , [ClassId]
           , [AdjustmentStatusId]
           , [AdjustmentReasonId]
           , [TrxTypeCode]
           , [AdjustmentUserStatusId]
           , [CreateUsername]
           , [CreateDate]
           , ReplacesAdjustmentId
			)
	VALUES
			(
			@ExchangeId 
		   , @TemplateId
           , @InstrumentId 
           , @InternalExternalCode 
           , @TradeDate 
           , @AdjustmentDate 
           --, @Lots -- @Quantity, from Split Details
           , @QuantityLong - @QuantityShort -- Quantity
           , @CurrencyId 
           , @ExpiryYear 
           , @ExpiryMonth
           , @ExpiryDay 
           , @StrikePrice 
           , @TradePrice 
           , @SettlementPrice 
           , @OptionTypeCode 
           , @Value -- @Value from Split Details
           , @Description 
           , @TemplateGroupId
           , @PremiumValue 
           , @OptionValue
           , @IsBuy
           , @MatchCodeId
           , @AdjustmentHeaderId
           , @DataSourceId
           , @FirmId
           , @QuantityLong -- This may have be updated
           , @QuantityShort -- This may have been updated
           , @AccountId -- @DetailAccountId
           , @AccountId -- @AccountId - from Split Details
           , @ClassId
           , @AdjustmentStatusId
           , @AdjustmentReasonId
           , @TrxTypeCode
           , @AdjustmentUserStatusId
           , @Username
           , @CreateDate
           , @ReplacesAdjustmentId
			)
	
	SELECT @AdjustmentId = Scope_Identity()
	
	SELECT @AdjustmentId

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[_ib_Adjustment_Update]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[_ib_Adjustment_Update]
(
	@AdjustmentId INT,
	@TemplateId INT,
	@ExchangeId INT, 
	@InstrumentId INT, 
	@TradeDate DATETIME, 
	@AdjustmentDate DATETIME, 
	@Quantity DECIMAL(19,4), 
	@CurrencyId INT, 
	@ExpiryYear INT,
	@ExpiryMonth INT,
	@ExpiryDay INT = NULL,
	@StrikePrice DECIMAL(19,4), 
	@TradePrice DECIMAL(24,10), 
	@SettlementPrice DECIMAL(24,10), 
	@OptionTypeCode VARCHAR(25), 
	@Value DECIMAL(19,4), 
	@Description VARCHAR(255), 
	@UpdateUsername VARCHAR(50),
	@IsBuy BIT,
	@MatchCodeId INT,
	@DataSourceId INT,
	@FirmId INT,
	@AccountId INT,
	@DetailAccountId INT = NULL,
	@ClassId INT = NULL,
	@AdjustmentStatusId INT = NULL,
	@AdjustmentReasonId INT = NULL,
	@TrxTypeCode VARCHAR(25),
	@AdjustmentUserStatusId INT = NULL
)
AS
/*
<details>
 <summary> Updates an instrument from the ib_Intrument table</summary>
 <created author="Laurentiu Macovei" Date="Thursday, August 2006 15:12 GMT" /> 
 <updated author="Laurentiu Macovei" Date="Monday, 23 October 2006 12:43 GMT"> 
	Changed SettlementPrice and TradePrice to 19,6
 </updated>
 <updated author="Laurentiu Macovei" Date="Tuesday, 1 November 2006 12:32 GMT"> 
	Added templateId
 </updated>
 <updated author="Anil Kripalani" Date="28 November 2006"> 
	Added premium value and option value
 </updated>
  <updated author="Alister McLeod" Date="09 February 2010"> 
	Added IsBuy
 </updated>
     <updated author="Alister McLeod" Date="23 April 2010"> 
	MBAL-15416 Increase size of SettlementPrice and TradePrice field
 </updated>
</details>

-- 22 May 2014  ED  EIB 25492 - allow update of adjustment
-- 30 Sep 2014	ED	EIB 26042 - fix value formula for Premium instruments

*/
SET NOCOUNT ON
BEGIN TRY
BEGIN TRAN

	DECLARE @InternalExternalCode VARCHAR(1)

	SELECT @InternalExternalCode=InternalExternalCode 
		FROM ib_TemplateCompare 
		WHERE TemplateId = @TemplateId AND DataSourceId = @DataSourceId AND FirmId = @FirmId
	DECLARE @Notes VARCHAR(4000)	
	IF (@Description != '''')
		SET @Notes = @Description + '' (''+@UpdateUsername+'', ''+CONVERT(CHAR(10), CURRENT_TIMESTAMP, 103)+'' ''+CONVERT(CHAR(5), CURRENT_TIMESTAMP, 114)+'') ''
	UPDATE [dbo].[ib_Adjustment]
	   SET [TemplateId] = @TemplateId
		  ,[ExchangeId] = @ExchangeId
		  ,[InstrumentId] = @InstrumentId
		  ,[InternalExternalCode] = @InternalExternalCode
		  ,[TradeDate] = @TradeDate
		  ,[AdjustmentDate] = @AdjustmentDate
		  ,[Quantity] = CASE WHEN @IsBuy = 1 THEN @Quantity ELSE @Quantity * -1 END
		  ,[CurrencyId] = @CurrencyId
		  ,[ExpiryYear] = @ExpiryYear
		  ,[ExpiryMonth] = @ExpiryMonth
		  ,[ExpiryDay] = @ExpiryDay
		  ,[StrikePrice] = @StrikePrice
		  ,[TradePrice] = @TradePrice
		  ,[SettlementPrice] = @SettlementPrice
		  ,[OptionTypeCode] = @OptionTypeCode
		  ,[VALUE] = @Value
		  ,[Description] = @Notes+ISNULL(Description,'''')
		  ,[UpdateDate] = GETDATE()
		  ,[UpdateUsername] = @UpdateUsername
		  ,[IsBuy] = @IsBuy
		  ,[MatchCodeId] = @MatchCodeId
		  ,[DataSourceId] = @DataSourceId
		  ,[FirmId] = @FirmId
		  ,[QuantityLong] = CASE WHEN @IsBuy = 1 THEN @Quantity ELSE 0 END
		  ,[QuantityShort] = CASE WHEN @IsBuy = 1 THEN 0 ELSE @Quantity END
		  ,[DetailAccountId] = @DetailAccountId
		  ,[AccountId] = @AccountId
		  ,[ClassId] = @ClassId
		  ,[AdjustmentStatusId] = @AdjustmentStatusId
		  ,[AdjustmentReasonId] = @AdjustmentReasonId
		  ,[TrxTypeCode] = @TrxTypeCode
		  ,[AdjustmentUserStatusId] = @AdjustmentUserStatusId
	WHERE AdjustmentId = @AdjustmentId
	
	UPDATE ib_AdjustmentHeader
		SET   UpdateDate = GETDATE()
			, UpdateUsername = @UpdateUsername
			, AdjustmentReasonId = @AdjustmentReasonId
			, AdjustmentUserStatusId = @AdjustmentUserStatusId
		WHERE  [AdjustmentHeaderId] = (SELECT AdjustmentHeaderId FROM ib_Adjustment WHERE AdjustmentId = @AdjustmentId)
COMMIT TRAN
END TRY
BEGIN CATCH
ROLLBACK TRAN
EXEC [dbo].[sp_RethrowError]
END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[aspnet_PersonalizationAdministration_ResetUserState]''
');

GO
SET QUOTED_IDENTIFIER OFF

GO
EXECUTE ('CREATE PROCEDURE [dbo].[aspnet_PersonalizationAdministration_ResetUserState] (
    @Count                  int                 OUT,
    @ApplicationName        NVARCHAR(256),
    @InactiveSinceDate      DATETIME            = NULL,
    @UserName               NVARCHAR(256)       = NULL,
    @Path                   NVARCHAR(256)       = NULL)
AS
SET NOCOUNT ON
BEGIN
    DECLARE @ApplicationId UNIQUEIDENTIFIER
    EXEC dbo.aspnet_Personalization_GetApplicationId @ApplicationName, @ApplicationId OUTPUT
    IF (@ApplicationId IS NULL)
        SELECT @Count = 0
    ELSE
    BEGIN
        DELETE FROM dbo.aspnet_PersonalizationPerUser
        WHERE Id IN (SELECT PerUser.Id
                     FROM dbo.aspnet_PersonalizationPerUser PerUser, dbo.aspnet_Users Users, dbo.aspnet_Paths Paths
                     WHERE Paths.ApplicationId = @ApplicationId
                           AND PerUser.UserId = Users.UserId
                           AND PerUser.PathId = Paths.PathId
                           AND (@InactiveSinceDate IS NULL OR Users.LastActivityDate <= @InactiveSinceDate)
                           AND (@UserName IS NULL OR Users.LoweredUserName = LOWER(@UserName))
                           AND (@Path IS NULL OR Paths.LoweredPath = LOWER(@Path)))

        SELECT @Count = @@ROWCOUNT
    END
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Adjustment_GetByDetailAccountId]''
');

GO
SET QUOTED_IDENTIFIER ON

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Select records from the ib_Adjustment table through an index
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[ib_Adjustment_GetByDetailAccountId]
(

	@DetailAccountId int   
)
AS


				SELECT
					[AdjustmentId],
					[TemplateId],
					[ExchangeId],
					[InstrumentId],
					[InternalExternalCode],
					[TradeDate],
					[AdjustmentDate],
					[Quantity],
					[CurrencyId],
					[ExpiryYear],
					[ExpiryMonth],
					[ExpiryDay],
					[StrikePrice],
					[TradePrice],
					[SettlementPrice],
					[OptionTypeCode],
					[Value],
					[PremiumValue],
					[OptionValue],
					[Description],
					[TemplateGroupId],
					[CreateDate],
					[CreateUsername],
					[UpdateDate],
					[UpdateUsername],
					[IsBuy],
					[MatchCodeId],
					[AdjustmentHeaderId],
					[DataSourceId],
					[FirmId],
					[QuantityLong],
					[QuantityShort],
					[DetailAccountId],
					[AccountId],
					[ClassId],
					[AdjustmentStatusId],
					[AdjustmentReasonId],
					[TrxTypeCode],
					[AdjustmentUserStatusId],
					[MatchingAdjustmentId],
					[ReplacesAdjustmentId]
				FROM
					[dbo].[ib_Adjustment]
				WHERE
					[DetailAccountId] = @DetailAccountId
				SELECT @@ROWCOUNT
					
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ReturnIdsFromCommaSeparatedString]''
');

GO
EXECUTE ('CREATE FUNCTION [dbo].[ReturnIdsFromCommaSeparatedString]
(
	@IdsString NVARCHAR(MAX)
)
RETURNS @returnTable TABLE 
(
	Id INT
)
AS
-- Returns a table of Ids from a comma separated list
-- 29 JUL 2010	AAJM	Creation
BEGIN

	DECLARE @Id VARCHAR(10), @Pos INT

	SET @IdsString = LTRIM(RTRIM(@IdsString))+ '',''
	SET @Pos = CHARINDEX('','', @IdsString, 1)

	IF REPLACE(@IdsString, '','', '''') <> ''''
	BEGIN
		WHILE @Pos > 0
		BEGIN
			SET @Id = LTRIM(RTRIM(LEFT(@IdsString, @Pos - 1)))
			IF @Id <> ''''
			BEGIN
				INSERT INTO @returnTable (Id) VALUES (CAST(@Id AS int)) --Use Appropriate conversion
			END
			SET @IdsString = RIGHT(@IdsString, LEN(@IdsString) - @Pos)
			SET @Pos = CHARINDEX('','', @IdsString, 1)

		END
	END	

	RETURN 
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Adjustment_MatchAdjustmentsConfirmation]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Adjustment_MatchAdjustmentsConfirmation]
	@AdjustmentIdsCommaSeparated NVARCHAR(MAX)
AS
	-- Confirm Details related to the matching of multiple adjustments
	-- 28 Jul 2010	AAJM	MBAL-16331 Allow multiple entries for manual matching
	-- 18 Aug 2010	AAJM	MBAL-16467 and MBAL-16331 Update multiple matching amount
	--						checking criteria, and consequently the confirmation message.

SET NOCOUNT ON

CREATE TABLE #TempList -- Holds relevant AdjustmentIds
(
	AdjustmentId int
)

INSERT INTO #TempList (AdjustmentId)
SELECT Id
FROM [dbo].[ReturnIdsFromCommaSeparatedString](@AdjustmentIdsCommaSeparated)	

-- Create table to hold any temporary integer value in order to avoid selecting results
CREATE TABLE #TempSuppressQueryResults
(
	Id int
)

-- Get the number of datasources present
DECLARE @NumDataSources INT

INSERT INTO #TempSuppressQueryResults (Id)
SELECT DataSourceId
	FROM ib_Adjustment a 
	INNER JOIN #TempList t ON t.AdjustmentId = a.AdjustmentId	
	GROUP BY a.DataSourceId
	
SELECT @NumDataSources = @@RowCount	

-- PRINT @NumDataSources

-- Get the First DataSource''s Id
DECLARE @DataSourceId1 INT
	
SELECT TOP(1) @DataSourceId1 = DataSourceId
FROM
		(SELECT a.DataSourceId			
		FROM #TempList t 
		INNER JOIN ib_Adjustment a ON t.AdjustmentId = a.AdjustmentId
		GROUP BY a.DataSourceId
	
		) AS ds1
ORDER BY ds1.DataSourceId ASC 		

DECLARE @DataSourceName1 NVARCHAR(100)
SELECT @DataSourceName1 = ds1.Name FROM ib_DataSource ds1 WHERE ds1.DataSourceId = @dataSourceId1
		
IF @numDataSources = 1
	BEGIN
	
		DECLARE @TotalBoughtAmount DECIMAL(19,4)
		
		SET @TotalBoughtAmount =
			(SELECT SUM(a.value)
				FROM #TempList t 
				INNER JOIN ib_Adjustment a ON t.AdjustmentId = a.AdjustmentId
				WHERE a.DataSourceId = @DataSourceId1 AND a.QuantityLong <> 0
			 )
			 
		
		DECLARE @TotalSoldAmount DECIMAL(19,4)
		
		SET @TotalSoldAmount =
			(SELECT SUM(a.value)
				FROM #TempList t 
				INNER JOIN ib_Adjustment a ON t.AdjustmentId = a.AdjustmentId
				WHERE a.DataSourceId = @DataSourceId1 AND a.QuantityShort<> 0
			 )
			 				
		SELECT 
			@numDataSources AS [NumDataSources]
			, @DataSourceName1 AS [DataSourceName1]
			, @TotalBoughtAmount  AS [TotalBoughtAmount1]
			, @TotalSoldAmount AS [TotalSoldAmount1]
			, ISNULL(@TotalBoughtAmount, 0) + ISNULL(@TotalSoldAmount, 0)
		 AS [Difference1] -- Bought minus sold
			, 0.0 AS [DataSourceNett1]
			, '''' AS [DataSourceName2]
			, 0.0 AS [DataSourceNett2]
			, 0.0 AS [DataSourcesDifference] 
		
		RETURN 1
	END
ELSE IF @numDataSources = 2
	BEGIN	
		
		DECLARE @DataSourceId2 INT

		SELECT TOP(1) @DataSourceId2 = DataSourceId
		FROM
				(SELECT a.DataSourceId
				FROM #TempList t 
				INNER JOIN ib_Adjustment a ON t.AdjustmentId = a.AdjustmentId
				GROUP BY a.DataSourceId							
				) AS ds2
		ORDER BY ds2.DataSourceId DESC -- DESCENDING to get the other DataSource			
		
			
		DECLARE @DataSourceName2 NVARCHAR(100)
		SELECT @DataSourceName2 = ds2.Name FROM ib_DataSource ds2 WHERE ds2.DataSourceId = @dataSourceId2
		
		DECLARE @TotalNettAmountDataSource1 DECIMAL(19,4)
		DECLARE @TotalNettAmountDataSource2 DECIMAL(19,4)
		
		SELECT @TotalNettAmountDataSource1 = 
			(SELECT SUM(a.value)
				FROM #TempList t 
				INNER JOIN ib_Adjustment a ON t.AdjustmentId = a.AdjustmentId
				WHERE a.DataSourceId = @DataSourceId1
			 )
		
		--PRINT @TotalNettAmountDataSource1
		
		SELECT @TotalNettAmountDataSource2 = 
			(SELECT SUM(a.value)
				FROM #TempList t 
				INNER JOIN ib_Adjustment a ON t.AdjustmentId = a.AdjustmentId
				WHERE a.DataSourceId = @DataSourceId2
			 )
		
		--PRINT @TotalNettAmountDataSource2 
			
		SELECT 
			@numDataSources AS [NumDataSources]
			, @DataSourceName1 AS [DataSourceName1]
			, 0.0 AS [TotalBoughtAmount1]
			, 0.0 AS [TotalSoldAmount1]
			, 0.0 AS [Difference1] -- Bought minus sold
			, @TotalNettAmountDataSource1  AS [DataSourceNett1]
			, @DataSourceName2 AS [DataSourceName2]
			, @TotalNettAmountDataSource2 AS [DataSourceNett2]
			, ABS(@TotalNettAmountDataSource1 - @TotalNettAmountDataSource2) AS [DataSourcesDifference] -- First Nett - Second Nett
	
		RETURN 1
	END
	
DROP TABLE #TempList
DROP TABLE #TempSuppressQueryResults

RETURN 0
');

GO
EXECUTE ('PRINT N''Creating [dbo].[_ib_FirmDataSource_UpdateWithCheck]''
');

GO
EXECUTE (' /*
<details>
 <summary>Updates a firm data source from the ib_FirmDataSource table by its id</summary>
 <created author="Laurentiu Macovei" Date=" Sunday, 10 September 2006 9:26PM GMT" /> 
 <updated author="Laurentiu Macovei" Date=" Sunday, 24 September 2006 3:40PM GMT"> 
	Added check for duplicate feature
 </updated>
</details>
*/ 
CREATE PROCEDURE  [dbo].[_ib_FirmDataSource_UpdateWithCheck]
(
	@FirmDataSourceId int,
	@FirmId int,
    @DataSourceId int,
    @DataSourceFirmCode varchar(100),
    @UpdateUsername varchar(50)
)
AS
SET NOCOUNT ON

BEGIN TRY
--check for duplicates 
EXEC [dbo].[ib_FirmDataSource_CheckForDuplicate] @FirmId, @DataSourceId, @DataSourceFirmCode, @FirmDataSourceId

UPDATE [dbo].[ib_FirmDataSource]
   SET [FirmId] = @FirmId,
       [DataSourceId] = @DataSourceId,
       [DataSourceFirmCode] = @DataSourceFirmCode,
       [UpdateUsername] = @UpdateUsername
 WHERE FirmDataSourceId = @FirmDataSourceId
END TRY
BEGIN CATCH
	EXEC [dbo].[sp_RethrowError]
END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[aspnet_PersonalizationAllUsers_GetPageSettings]''
');

GO
SET QUOTED_IDENTIFIER OFF

GO
EXECUTE ('CREATE PROCEDURE [dbo].[aspnet_PersonalizationAllUsers_GetPageSettings] (
    @ApplicationName  NVARCHAR(256),
    @Path              NVARCHAR(256))
AS
SET NOCOUNT ON
BEGIN
    DECLARE @ApplicationId UNIQUEIDENTIFIER
    DECLARE @PathId UNIQUEIDENTIFIER

    SELECT @ApplicationId = NULL
    SELECT @PathId = NULL

    EXEC dbo.aspnet_Personalization_GetApplicationId @ApplicationName, @ApplicationId OUTPUT
    IF (@ApplicationId IS NULL)
    BEGIN
        RETURN
    END

    SELECT @PathId = u.PathId FROM dbo.aspnet_Paths u WHERE u.ApplicationId = @ApplicationId AND u.LoweredPath = LOWER(@Path)
    IF (@PathId IS NULL)
    BEGIN
        RETURN
    END

    SELECT p.PageSettings FROM dbo.aspnet_PersonalizationAllUsers p WHERE p.PathId = @PathId
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Adjustment_GetByFirmId]''
');

GO
SET QUOTED_IDENTIFIER ON

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Select records from the ib_Adjustment table through an index
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[ib_Adjustment_GetByFirmId]
(

	@FirmId int   
)
AS


				SELECT
					[AdjustmentId],
					[TemplateId],
					[ExchangeId],
					[InstrumentId],
					[InternalExternalCode],
					[TradeDate],
					[AdjustmentDate],
					[Quantity],
					[CurrencyId],
					[ExpiryYear],
					[ExpiryMonth],
					[ExpiryDay],
					[StrikePrice],
					[TradePrice],
					[SettlementPrice],
					[OptionTypeCode],
					[Value],
					[PremiumValue],
					[OptionValue],
					[Description],
					[TemplateGroupId],
					[CreateDate],
					[CreateUsername],
					[UpdateDate],
					[UpdateUsername],
					[IsBuy],
					[MatchCodeId],
					[AdjustmentHeaderId],
					[DataSourceId],
					[FirmId],
					[QuantityLong],
					[QuantityShort],
					[DetailAccountId],
					[AccountId],
					[ClassId],
					[AdjustmentStatusId],
					[AdjustmentReasonId],
					[TrxTypeCode],
					[AdjustmentUserStatusId],
					[MatchingAdjustmentId],
					[ReplacesAdjustmentId]
				FROM
					[dbo].[ib_Adjustment]
				WHERE
					[FirmId] = @FirmId
				SELECT @@ROWCOUNT
					
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_ImbalanceReport_GetDataForChart]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_ImbalanceReport_GetDataForChart]
AS
SET NOCOUNT ON

	--	17 Aug 2010		amk		Creation
	--	18 Aug 2010		amk		Tweaks

	DECLARE @IRid INT

	SET @IRid = (SELECT TOP 1 imbalancereportid 
	FROM ib_imbalancereport 
	ORDER BY today DESC, createdate DESC)

	SELECT r.today, r.yesterday, e.code AS exchange, s.currency
		, SUM(ABS(s.lots)) AS lots_out, SUM(ABS(s.variation)) AS value_out
	INTO #data
	FROM ib_imbalancereportsummary s
		JOIN ib_imbalancereport r ON r.imbalancereportid = s.imbalancereportid
		JOIN ib_exchange e ON e.exchangeid = s.exchangeid
	WHERE (lots <> 0 OR variation <> 0)
		AND s.imbalancereportid = @irid
	GROUP BY r.today, r.yesterday, s.currency, e.code
	HAVING SUM(ABS(s.variation)) <> 0

	SELECT DISTINCT exchange, today, yesterday
	INTO #exchanges
	FROM #data

	SELECT DISTINCT currency, today, yesterday
	INTO #currencies
	FROM #data

	SELECT e.exchange, c.currency, e.today, e.yesterday
	INTO #currencyExchange
	FROM #exchanges e
		CROSS JOIN #currencies c

	SELECT ISNULL(d.today, ce.today) AS today
		, ISNULL(d.yesterday, ce.yesterday) AS yesterday
		, ISNULL(d.exchange, ce.exchange) AS exchange
		, ISNULL(d.currency, ce.currency) AS currency
		, d.lots_out, d.value_out
	FROM #data d
		FULL OUTER JOIN #currencyExchange ce 
			ON ce.currency = d.currency AND ce.exchange = d.exchange
	ORDER BY ISNULL(d.exchange, ce.exchange)
		, ISNULL(d.currency, ce.currency)
');

GO
EXECUTE ('PRINT N''Creating [dbo].[DoesUTIContainsHVHForTradeReconciliationSummary]''
');

GO
EXECUTE ('CREATE FUNCTION [dbo].[DoesUTIContainsHVHForTradeReconciliationSummary]
(
	@TradeReconciliationSummaryId INT
)
RETURNS BIT
AS
--	Description: Does UTI Contains HVH for TradeReconciliationSummary
--	07 Jul 2014		ED		EIB 25802 - Created
BEGIN
	DECLARE @Result BIT = 0, @DoCheckUtiForHvh VARCHAR(10)
	SET @DoCheckUtiForHvh = (SELECT Value FROM Config WHERE [Key] = ''DoCheckUtiForHvh'')
	IF @DoCheckUtiForHvh IS NULL OR @DoCheckUtiForHvh = ''0''
		RETURN 1

	IF EXISTS(SELECT  TOP 1 *
				FROM [dbo].[ib_TradeReconciliationSummary] [trs]
				INNER JOIN [dbo].[ib_TradeReconciliationDetail] [trd] 
						ON [trs].[TradeReconciliationId] = [trd].[TradeReconciliationId]
							AND [trd].[ExchangeId] = [trs].[ExchangeId]
							AND [trd].[CurrencyId] = [trs].[CurrencyId]
							AND [trd].[InstrumentId] = [trs].[InstrumentId]
				INNER JOIN ib_Datasource d ON d.DataSourceId=trd.DataSourceId
				LEFT JOIN ib_Firm f ON f.FirmId=trd.FirmId
				LEFT JOIN ib_Account a ON a.AccountId=trd.AccountId
				LEFT JOIN ib_Account a2 ON a2.AccountId = trd.DetailAccountId
				LEFT OUTER JOIN ib_TrxType tt ON trd.TrxTypeCode = tt.Code AND tt.DataSourceId = trd.DataSourceId 
				LEFT JOIN ib_Trx trx ON trx.TrxId = trd.TrxId 
	
			WHERE [trs].[TradeReconciliationSummaryId] = @TradeReconciliationSummaryId
				AND [trd].[MatchCode] = [trs].[MatchCode]
				AND [trd].[ExpiryMonth] = [trs].[ExpiryMonth]
				AND [trd].[ExpiryYear] = [trs].[ExpiryYear]
				AND [trd].[ExpiryDay] = [trs].[ExpiryDay] 
				AND [trd].[OptionTypeCode] = [trs].[OptionTypeCode]
				AND [trd].[StrikePrice] = [trs].[StrikePrice]
				AND [trd].[TradePrice] = [trs].[TradePrice]
				AND SUBSTRING(trx.UTI, 19, 3) != ''HVH''
				AND trd.InternalExternalCode = ''I'')
	BEGIN
		RETURN 0
	END
	RETURN 1
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Adjustment_ValidateAdjustmentsForMatching]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Adjustment_ValidateAdjustmentsForMatching]
(
	@AdjustmentIds NVARCHAR(MAX)
	, @RequireSameMatchCodeForMatching BIT = 1
	, @ErrorMessage VARCHAR(4000) OUTPUT
)
AS
SET NOCOUNT ON
-- Validates that selected records meet the validation according to the user story.

-- Returns 0 if validation fails, 1 if it success in total (including the amount check)
-- and returns 2 if it succeeds except for the amount check.

-- 26 May 2010	ED		- created
-- 09 Jul 2010	ED		MBAL 16114 - Matching Code Inspection fixes
-- 13 Jul 2010	ED		MBAL 16125 - add bit for @RequireSameMatchCodeForMatching
-- 22 Jul 2010	AAJM	MBAL-16246 Adjust logic for "Equal" and "Equal and opposite" to accept positive vs negative quantity
-- 27 Jul 2010	AAJM	MBAL-16303 Manual matching not handling cancellations correctly
-- 27 Jul 2010	AAJM	MBAL-16303 Update according to rules change re. Same/Different/Equal/Opposite
-- 29 Jul 2010	AAJM	MBAL-16331 Update for multiple entries for manual matching
-- 13 Aug 2010	AAJM	MBAL-16445 Manual matching shouldn''t check price
-- 18 Aug 2010	AAJM	MBAL-16467 and MBAL-16331 Update multiple matching amount
--						checking criteria, and consequently the confirmation message.
-- 25 Jul 2014	ED  	EIB 25768 - match also DL and UM

BEGIN

	CREATE TABLE #TempList
	(
		AdjustmentId int
	)
	
	INSERT INTO #TempList (AdjustmentId)
	SELECT Id
	FROM [dbo].[ReturnIdsFromCommaSeparatedString](@AdjustmentIds)	

	-- Create table to hold any temporary integer value in order to avoid selecting results
	CREATE TABLE #TempSuppressQueryResults 
	(
		Id int
	)


	-- All adjustments must be of types TI, TC, or MI
	IF EXISTS (SELECT 1 FROM #TempList t
		INNER JOIN ib_Adjustment a  ON t.AdjustmentId = a.AdjustmentId
		INNER JOIN ib_AdjustmentHeader ah ON a.AdjustmentHeaderId=ah.AdjustmentHeaderId
		INNER JOIN ib_AdjustmentType [at] ON [at].AdjustmentTypeId=ah.AdjustmentTypeId
		WHERE [at].Code NOT IN (''TI'', ''TC'', ''MI'', ''DL'', ''UM''))
	BEGIN
		SET @ErrorMessage = ''All adjustments must be one of types TI, TC, MI, DL or UM.''
				SELECT -1
				RETURN -1
	END	
			
	-- Exchange, Currency, Instrument, Expiry Date (Month, Year, Day), P/C, and Strike are the same for all items


	DECLARE @onlyOneRowExpected INT
	
	INSERT INTO #TempSuppressQueryResults ( Id )
	SELECT ExchangeId -- Pick any Group by row
		FROM ib_Adjustment a 
		INNER JOIN #TempList t ON t.AdjustmentId = a.AdjustmentId	
		GROUP BY a.[ExchangeId], a.[CurrencyId], a.[InstrumentId], a.[ExpiryYear], a.[ExpiryMonth], a.[ExpiryDay], a.[OptionTypeCode], a.[StrikePrice]
	
	SELECT @onlyOneRowExpected = @@RowCount
			
	IF @onlyOneRowExpected > 1			
		BEGIN
			SET @ErrorMessage = ''One or more of the following fields do not match: Exchange, Currency, Instrument, Expiry, Option Type, Strike.''
			SELECT -1
			RETURN -1
		END

	-- Matchcode should be the same for all items
	IF @RequireSameMatchCodeForMatching = 1
		BEGIN

			INSERT INTO #TempSuppressQueryResults ( Id )
			SELECT a.MatchCodeId
			FROM ib_Adjustment a 
			INNER JOIN #TempList t ON t.AdjustmentId = a.AdjustmentId	
			GROUP BY a.MatchCodeId

			SELECT @onlyOneRowExpected = @@RowCount
			
			IF @onlyOneRowExpected > 1			
				BEGIN
					SET @ErrorMessage = ''Match Code should be same.''
					SELECT -1
					RETURN -1
				END		
		END

	-- Maximum of two different DataSources may be selected
	DECLARE @NumDataSources INT

	INSERT INTO #TempSuppressQueryResults ( Id )
		SELECT a.DataSourceId
		FROM ib_Adjustment a 
		INNER JOIN #TempList t ON t.AdjustmentId = a.AdjustmentId	
		GROUP BY a.DataSourceId
	
	SELECT @NumDataSources = @@RowCount	

	IF @NumDataSources > 2
	BEGIN
		SET @ErrorMessage = ''A maximum of two different Data Sources may be selected.''
				SELECT -1
				RETURN -1
	END

DECLARE @DataSourceId1 INT
DECLARE @Amount1 DECIMAL(24,10)
DECLARE @QuantityShort1 INT
DECLARE @QuantityLong1 INT

SELECT TOP(1) @DataSourceId1 = DataSourceId, @Amount1 = SumValue , @QuantityShort1 = SumQuantityShort, @QuantityLong1 = SumQuantityLong 
FROM
		(SELECT a.DataSourceId
			, SUM(a.Value) AS SumValue
			, SUM(a.QuantityShort) AS SumQuantityShort 
			, SUM(a.QuantityLong) AS SumQuantityLong
		FROM #TempList t 
		INNER JOIN ib_Adjustment a ON t.AdjustmentId = a.AdjustmentId
		GROUP BY a.DataSourceId
	
		) AS ds1
ORDER BY ds1.DataSourceId ASC 			

IF @NumDataSources = 1
	BEGIN
		
		IF (@QuantityLong1 - @QuantityShort1 <> 0)
		BEGIN
			SET @ErrorMessage = ''Lots must be equal and opposite.''
			SELECT -1
			RETURN -1
		END
	
	-- Now check amounts
	
	
	DECLARE @TotalBoughtAmount DECIMAL(19,4)
		
	SET @TotalBoughtAmount =
		(SELECT SUM(a.value)
			FROM #TempList t 
			INNER JOIN ib_Adjustment a ON t.AdjustmentId = a.AdjustmentId
			WHERE a.DataSourceId = @DataSourceId1 AND a.QuantityLong <> 0
		 )
			 
		
	DECLARE @TotalSoldAmount DECIMAL(19,4)
		
	SET @TotalSoldAmount =
		(SELECT SUM(a.value)
			FROM #TempList t 
			INNER JOIN ib_Adjustment a ON t.AdjustmentId = a.AdjustmentId
			WHERE a.DataSourceId = @DataSourceId1 AND a.QuantityShort<> 0
		 )
			 				
	IF ABS(ISNULL(@TotalBoughtAmount, 0) + ISNULL(@TotalSoldAmount, 0)) > 0
		BEGIN	
			SELECT 1
			RETURN 1 -- This indicates confirmation is required
		END		
			
	END -- One DataSource
ELSE IF @NumDataSources = 2
	BEGIN
	
		DECLARE @DataSourceId2 INT
		DECLARE @Amount2 DECIMAL(24,10)
		DECLARE @QuantityShort2 INT
		DECLARE @QuantityLong2 INT

		SELECT TOP(1) @DataSourceId2 = DataSourceId, @Amount2 = SumValue , @QuantityShort2 = SumQuantityShort, @QuantityLong2 = SumQuantityLong FROM
				(SELECT a.DataSourceId
					, SUM(a.Value) AS SumValue
					, SUM(a.QuantityShort) AS SumQuantityShort 
					, SUM(a.QuantityLong) AS SumQuantityLong
					FROM #TempList t 
					INNER JOIN ib_Adjustment a ON t.AdjustmentId = a.AdjustmentId
					GROUP BY a.DataSourceId							
					) AS ds2
		ORDER BY ds2.DataSourceId DESC -- DESCENDING to get the other DataSource			
	
		DECLARE @DataSourceSame BIT
		IF @DataSourceId1 != @DataSourceId2 
			SET @DataSourceSame = 0
		ELSE
			SET @DataSourceSame = 1

		IF @DataSourceSame = 0 AND 
			NOT EXISTS
				(	SELECT 1 FROM ib_TemplateCompare tc1
					INNER JOIN ib_templateCompare tc2 ON tc1.DataSourceId=@DataSourceId1 AND tc2.DataSourceId=@DataSourceId2
					WHERE tc1.InternalExternalCode!=tc2.InternalExternalCode
				)
					BEGIN
						SET @ErrorMessage = ''Data Sources are different, but not one internal and the other one external''
						SELECT -1
						RETURN -1
					END
			
		IF ((@QuantityLong1 - @QuantityShort1) <> (@QuantityLong2 - @QuantityShort2))
			BEGIN
				SET @ErrorMessage = ''Net lots for data sources must be equal.''
				SELECT -1
				RETURN -1
			END		

		-- Now do the check for Amount 
		-- Return 1 if amounts don''t tally

		DECLARE @TotalNettAmountDataSource1 DECIMAL(19,4)
		DECLARE @TotalNettAmountDataSource2 DECIMAL(19,4)
		
		SELECT @TotalNettAmountDataSource1 = 
			(SELECT SUM(a.value)
				FROM #TempList t 
				INNER JOIN ib_Adjustment a ON t.AdjustmentId = a.AdjustmentId
				WHERE a.DataSourceId = @DataSourceId1
			 )
		
		--PRINT @TotalNettAmountDataSource1
		
		SELECT @TotalNettAmountDataSource2 = 
			(SELECT SUM(a.value)
				FROM #TempList t 
				INNER JOIN ib_Adjustment a ON t.AdjustmentId = a.AdjustmentId
				WHERE a.DataSourceId = @DataSourceId2
			 )
		
		--PRINT @TotalNettAmountDataSource2 
				
		IF (@TotalNettAmountDataSource1 <> @TotalNettAmountDataSource2)
		BEGIN	
			SELECT 1
			RETURN 1 -- This indicates confirmation is required
		END		

		
END -- If Two DataSources

DROP TABLE #TempList
DROP TABLE #TempSuppressQueryResults

-- Otherwise everything validates and no confirmation is necessary
SELECT 0
RETURN 0
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[aspnet_Users_CreateUser]''
');

GO
SET QUOTED_IDENTIFIER OFF

GO
EXECUTE ('
CREATE PROCEDURE [dbo].[aspnet_Users_CreateUser]
    @ApplicationId    uniqueidentifier,
    @UserName         nvarchar(256),
    @IsUserAnonymous  bit,
    @LastActivityDate DATETIME,
    @UserId           uniqueidentifier OUTPUT
AS
SET NOCOUNT ON
BEGIN
    IF( @UserId IS NULL )
        SELECT @UserId = NEWID()
    ELSE
    BEGIN
        IF( EXISTS( SELECT UserId FROM dbo.aspnet_Users
                    WHERE @UserId = UserId ) )
            RETURN -1
    END

    INSERT dbo.aspnet_Users (ApplicationId, UserId, UserName, LoweredUserName, IsAnonymous, LastActivityDate)
    VALUES (@ApplicationId, @UserId, @UserName, LOWER(@UserName), @IsUserAnonymous, @LastActivityDate)

    RETURN 0
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[aspnet_Membership_CreateUser]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[aspnet_Membership_CreateUser]
    @ApplicationName                        nvarchar(256),
    @UserName                               nvarchar(256),
    @Password                               nvarchar(128),
    @PasswordSalt                           nvarchar(128),
    @Email                                  nvarchar(256),
    @PasswordQuestion                       nvarchar(256),
    @PasswordAnswer                         nvarchar(128),
    @IsApproved                             bit,
    @CurrentTimeUtc                         datetime,
    @CreateDate                             datetime = NULL,
    @UniqueEmail                            int      = 0,
    @PasswordFormat                         int      = 0,
    @UserId                                 uniqueidentifier OUTPUT
AS
SET NOCOUNT ON
BEGIN
    DECLARE @ApplicationId uniqueidentifier
    SELECT  @ApplicationId = NULL

    DECLARE @NewUserId uniqueidentifier
    SELECT @NewUserId = NULL

    DECLARE @IsLockedOut bit
    SET @IsLockedOut = 0

    DECLARE @LastLockoutDate  datetime
    SET @LastLockoutDate = CONVERT( datetime, ''17540101'', 112 )

    DECLARE @FailedPasswordAttemptCount int
    SET @FailedPasswordAttemptCount = 0

    DECLARE @FailedPasswordAttemptWindowStart  datetime
    SET @FailedPasswordAttemptWindowStart = CONVERT( datetime, ''17540101'', 112 )

    DECLARE @FailedPasswordAnswerAttemptCount int
    SET @FailedPasswordAnswerAttemptCount = 0

    DECLARE @FailedPasswordAnswerAttemptWindowStart  datetime
    SET @FailedPasswordAnswerAttemptWindowStart = CONVERT( datetime, ''17540101'', 112 )

    DECLARE @NewUserCreated bit
    DECLARE @ReturnValue   int
    SET @ReturnValue = 0

    DECLARE @ErrorCode     int
    SET @ErrorCode = 0

    DECLARE @TranStarted   bit
    SET @TranStarted = 0

    IF( @@TRANCOUNT = 0 )
    BEGIN
	    BEGIN TRANSACTION
	    SET @TranStarted = 1
    END
    ELSE
    	SET @TranStarted = 0

    EXEC dbo.aspnet_Applications_CreateApplication @ApplicationName, @ApplicationId OUTPUT

    IF( @@ERROR <> 0 )
    BEGIN
        SET @ErrorCode = -1
        GOTO Cleanup
    END

    SET @CreateDate = @CurrentTimeUtc

    SELECT  @NewUserId = UserId FROM dbo.aspnet_Users WHERE LOWER(@UserName) = LoweredUserName AND @ApplicationId = ApplicationId
    IF ( @NewUserId IS NULL )
    BEGIN
        SET @NewUserId = @UserId
        EXEC @ReturnValue = dbo.aspnet_Users_CreateUser @ApplicationId, @UserName, 0, @CreateDate, @NewUserId OUTPUT
        SET @NewUserCreated = 1
    END
    ELSE
    BEGIN
        SET @NewUserCreated = 0
        IF( @NewUserId <> @UserId AND @UserId IS NOT NULL )
        BEGIN
            SET @ErrorCode = 6
            GOTO Cleanup
        END
    END

    IF( @@ERROR <> 0 )
    BEGIN
        SET @ErrorCode = -1
        GOTO Cleanup
    END

    IF( @ReturnValue = -1 )
    BEGIN
        SET @ErrorCode = 10
        GOTO Cleanup
    END

    IF ( EXISTS ( SELECT UserId
                  FROM   dbo.aspnet_Membership
                  WHERE  @NewUserId = UserId ) )
    BEGIN
        SET @ErrorCode = 6
        GOTO Cleanup
    END

    SET @UserId = @NewUserId

    IF (@UniqueEmail = 1)
    BEGIN
        IF (EXISTS (SELECT *
                    FROM  dbo.aspnet_Membership m WITH ( UPDLOCK, HOLDLOCK )
                    WHERE ApplicationId = @ApplicationId AND LoweredEmail = LOWER(@Email)))
        BEGIN
            SET @ErrorCode = 7
            GOTO Cleanup
        END
    END

    IF (@NewUserCreated = 0)
    BEGIN
        UPDATE dbo.aspnet_Users
        SET    LastActivityDate = @CreateDate
        WHERE  @UserId = UserId
        IF( @@ERROR <> 0 )
        BEGIN
            SET @ErrorCode = -1
            GOTO Cleanup
        END
    END

    INSERT INTO dbo.aspnet_Membership
                ( ApplicationId,
                  UserId,
                  Password,
                  PasswordSalt,
                  Email,
                  LoweredEmail,
                  PasswordQuestion,
                  PasswordAnswer,
                  PasswordFormat,
                  IsApproved,
                  IsLockedOut,
                  CreateDate,
                  LastLoginDate,
                  LastPasswordChangedDate,
                  LastLockoutDate,
                  FailedPasswordAttemptCount,
                  FailedPasswordAttemptWindowStart,
                  FailedPasswordAnswerAttemptCount,
                  FailedPasswordAnswerAttemptWindowStart )
         VALUES ( @ApplicationId,
                  @UserId,
                  @Password,
                  @PasswordSalt,
                  @Email,
                  LOWER(@Email),
                  @PasswordQuestion,
                  @PasswordAnswer,
                  @PasswordFormat,
                  @IsApproved,
                  @IsLockedOut,
                  @CreateDate,
                  @CreateDate,
                  @CreateDate,
                  @LastLockoutDate,
                  @FailedPasswordAttemptCount,
                  @FailedPasswordAttemptWindowStart,
                  @FailedPasswordAnswerAttemptCount,
                  @FailedPasswordAnswerAttemptWindowStart )

    IF( @@ERROR <> 0 )
    BEGIN
        SET @ErrorCode = -1
        GOTO Cleanup
    END

    IF( @TranStarted = 1 )
    BEGIN
	    SET @TranStarted = 0
	    COMMIT TRANSACTION
    END

    RETURN 0

Cleanup:

    IF( @TranStarted = 1 )
    BEGIN
        SET @TranStarted = 0
    	ROLLBACK TRANSACTION
    END

    RETURN @ErrorCode

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[aspnet_PersonalizationAllUsers_ResetPageSettings]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[aspnet_PersonalizationAllUsers_ResetPageSettings] (
    @ApplicationName  NVARCHAR(256),
    @Path              NVARCHAR(256))
AS
SET NOCOUNT ON
BEGIN
    DECLARE @ApplicationId UNIQUEIDENTIFIER
    DECLARE @PathId UNIQUEIDENTIFIER

    SELECT @ApplicationId = NULL
    SELECT @PathId = NULL

    EXEC dbo.aspnet_Personalization_GetApplicationId @ApplicationName, @ApplicationId OUTPUT
    IF (@ApplicationId IS NULL)
    BEGIN
        RETURN
    END

    SELECT @PathId = u.PathId FROM dbo.aspnet_Paths u WHERE u.ApplicationId = @ApplicationId AND u.LoweredPath = LOWER(@Path)
    IF (@PathId IS NULL)
    BEGIN
        RETURN
    END

    DELETE FROM dbo.aspnet_PersonalizationAllUsers WHERE PathId = @PathId
    RETURN 0
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TrxType_GetTrxTypeById]''
');

GO
SET QUOTED_IDENTIFIER ON

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_TrxType_GetTrxTypeById] ( @TrxTypeId INT )
AS 
SET NOCOUNT ON

SELECT
    tt.[TrxTypeId]
   ,tt.[Code]
   ,tt.[Description]
   ,tt.[CreateDate]
   ,tt.[CreateUsername]
   ,tt.[UpdateDate]
   ,tt.[UpdateUsername]
   ,ds.Code + ''-'' + ds.Name [DataSourceCodeName]
   ,tt.DataSourceId
   ,IsPosition
   ,IsPremium
   ,IsTrade
   ,IsPandS
   ,IsPandL
   ,ExcludeFromTradeRec
   ,IsCancellation
   ,IsOptionMarketValue
   ,IsAutoMatched
FROM
    [dbo].[ib_TrxType] tt
LEFT OUTER JOIN [dbo].[ib_DataSource] ds
ON  ds.DataSourceId = tt.DataSourceId
WHERE
    [TrxTypeId] = @TrxTypeId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Adjustment_GetByInstrumentId]''
');

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Select records from the ib_Adjustment table through an index
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[ib_Adjustment_GetByInstrumentId]
(

	@InstrumentId int   
)
AS


				SELECT
					[AdjustmentId],
					[TemplateId],
					[ExchangeId],
					[InstrumentId],
					[InternalExternalCode],
					[TradeDate],
					[AdjustmentDate],
					[Quantity],
					[CurrencyId],
					[ExpiryYear],
					[ExpiryMonth],
					[ExpiryDay],
					[StrikePrice],
					[TradePrice],
					[SettlementPrice],
					[OptionTypeCode],
					[Value],
					[PremiumValue],
					[OptionValue],
					[Description],
					[TemplateGroupId],
					[CreateDate],
					[CreateUsername],
					[UpdateDate],
					[UpdateUsername],
					[IsBuy],
					[MatchCodeId],
					[AdjustmentHeaderId],
					[DataSourceId],
					[FirmId],
					[QuantityLong],
					[QuantityShort],
					[DetailAccountId],
					[AccountId],
					[ClassId],
					[AdjustmentStatusId],
					[AdjustmentReasonId],
					[TrxTypeCode],
					[AdjustmentUserStatusId],
					[MatchingAdjustmentId],
					[ReplacesAdjustmentId]
				FROM
					[dbo].[ib_Adjustment]
				WHERE
					[InstrumentId] = @InstrumentId
				SELECT @@ROWCOUNT
					
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_ImbalanceReport_GetDescriptionsAndCurrenciesForImbalanceReport]''
');

GO
EXECUTE ('/*
<details>
	<summary>Returns available descriptions and currencies for a given ImbalanceReportId</summary>
	<created author="laurentiu.macovei" date="Fri, 20 Oct 2006 19:07:14 GMT"/>
</details>
*/
CREATE PROCEDURE [dbo].[ib_ImbalanceReport_GetDescriptionsAndCurrenciesForImbalanceReport] 
@ImbalanceReportId int,
@ExchangeId int = NULL
AS
SET NOCOUNT ON;

WITH Variants(Description, CurrencyCode, CurrencyId)
AS
(
SELECT DISTINCT TOP 100000 irs.Description, c.Code as CurrencyCode, c.CurrencyId
	FROM ib_ImbalanceReportSummary irs
		INNER JOIN ib_Currency c ON irs.ImbalanceReportId = @ImbalanceReportId 
			AND (@ExchangeID IS NULL OR @ExchangeID = irs.ExchangeID)
			AND c.CurrencyId = irs.CurrencyId
	ORDER BY irs.Description, c.Code
) 
SELECT Description + '' / '' + CurrencyCode as DescriptionAndCode, Description, CurrencyId
	FROM Variants
');

GO
EXECUTE ('PRINT N''Creating [dbo].[GetAccountFromTemplateGroupByExchangeFirmMatchCode]''
');

GO
EXECUTE ('CREATE FUNCTION [dbo].[GetAccountFromTemplateGroupByExchangeFirmMatchCode]
(
	@ExchangeId INT,
	@FirmId INT,
	@MatchCodeId INT
)
RETURNS INT
AS
--	Description: GetAccountFromTemplateGroupByExchangeFirmMatchCode
--	25 Jun 2014		ED		EIB 25768 - Created
BEGIN
	DECLARE @AccountId INT, @TemplateId INT, @MatchCode VARCHAR(100)
	
	SELECT @TemplateId = TemplateId, @MatchCode = MatchCode FROM ib_MatchCode WHERE MatchCodeId = @MatchCodeId
	
	SET @AccountId = (SELECT TOP 1 AccountId 
						FROM ib_TemplateGroup 
						WHERE TemplateId = @TemplateId 
							AND Description = @MatchCode 
							AND ExchangeId = @ExchangeId 
							AND FirmId = @FirmId
					 )
	RETURN @AccountId
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_AdjustmentHeader_GetByAdjustmentId]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_AdjustmentHeader_GetByAdjustmentId]
(
	@AdjustmentId INT
)
AS
SET NOCOUNT ON
/*
	-- Description: get adj header by adj id
	-- Created ED 26 May 2010
*/
	SELECT ah.AdjustmentHeaderId, ISNULL(ah.AdjustmentReasonId,0) AdjustmentReasonId, ISNULL(ah.AdjustmentUserStatusId,0) AdjustmentUserStatusId, ah.Description Description
	FROM ib_AdjustmentHeader ah
	INNER JOIN ib_Adjustment a ON a.AdjustmentHeaderId=ah.AdjustmentHeaderId
	WHERE a.AdjustmentId=@AdjustmentId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[aspnet_PersonalizationPerUser_SetPageSettings]''
');

GO
SET QUOTED_IDENTIFIER OFF

GO
EXECUTE ('CREATE PROCEDURE [dbo].[aspnet_PersonalizationPerUser_SetPageSettings] (
    @ApplicationName  NVARCHAR(256),
    @UserName         NVARCHAR(256),
    @Path             NVARCHAR(256),
    @PageSettings     IMAGE,
    @CurrentTimeUtc   DATETIME)
AS
SET NOCOUNT ON
BEGIN
    DECLARE @ApplicationId UNIQUEIDENTIFIER
    DECLARE @PathId UNIQUEIDENTIFIER
    DECLARE @UserId UNIQUEIDENTIFIER

    SELECT @ApplicationId = NULL
    SELECT @PathId = NULL
    SELECT @UserId = NULL

    EXEC dbo.aspnet_Applications_CreateApplication @ApplicationName, @ApplicationId OUTPUT

    SELECT @PathId = u.PathId FROM dbo.aspnet_Paths u WHERE u.ApplicationId = @ApplicationId AND u.LoweredPath = LOWER(@Path)
    IF (@PathId IS NULL)
    BEGIN
        EXEC dbo.aspnet_Paths_CreatePath @ApplicationId, @Path, @PathId OUTPUT
    END

    SELECT @UserId = u.UserId FROM dbo.aspnet_Users u WHERE u.ApplicationId = @ApplicationId AND u.LoweredUserName = LOWER(@UserName)
    IF (@UserId IS NULL)
    BEGIN
        EXEC dbo.aspnet_Users_CreateUser @ApplicationId, @UserName, 0, @CurrentTimeUtc, @UserId OUTPUT
    END

    UPDATE   dbo.aspnet_Users WITH (ROWLOCK)
    SET      LastActivityDate = @CurrentTimeUtc
    WHERE    UserId = @UserId
    IF (@@ROWCOUNT = 0) -- Username not found
        RETURN

    IF (EXISTS(SELECT PathId FROM dbo.aspnet_PersonalizationPerUser WHERE UserId = @UserId AND PathId = @PathId))
        UPDATE dbo.aspnet_PersonalizationPerUser SET PageSettings = @PageSettings, LastUpdatedDate = @CurrentTimeUtc WHERE UserId = @UserId AND PathId = @PathId
    ELSE
        INSERT INTO dbo.aspnet_PersonalizationPerUser(UserId, PathId, PageSettings, LastUpdatedDate) VALUES (@UserId, @PathId, @PageSettings, @CurrentTimeUtc)
    RETURN 0
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[aspnet_PersonalizationAllUsers_SetPageSettings]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[aspnet_PersonalizationAllUsers_SetPageSettings] (
    @ApplicationName  NVARCHAR(256),
    @Path             NVARCHAR(256),
    @PageSettings     IMAGE,
    @CurrentTimeUtc   DATETIME)
AS
SET NOCOUNT ON
BEGIN
    DECLARE @ApplicationId UNIQUEIDENTIFIER
    DECLARE @PathId UNIQUEIDENTIFIER

    SELECT @ApplicationId = NULL
    SELECT @PathId = NULL

    EXEC dbo.aspnet_Applications_CreateApplication @ApplicationName, @ApplicationId OUTPUT

    SELECT @PathId = u.PathId FROM dbo.aspnet_Paths u WHERE u.ApplicationId = @ApplicationId AND u.LoweredPath = LOWER(@Path)
    IF (@PathId IS NULL)
    BEGIN
        EXEC dbo.aspnet_Paths_CreatePath @ApplicationId, @Path, @PathId OUTPUT
    END

    IF (EXISTS(SELECT PathId FROM dbo.aspnet_PersonalizationAllUsers WHERE PathId = @PathId))
        UPDATE dbo.aspnet_PersonalizationAllUsers SET PageSettings = @PageSettings, LastUpdatedDate = @CurrentTimeUtc WHERE PathId = @PathId
    ELSE
        INSERT INTO dbo.aspnet_PersonalizationAllUsers(PathId, PageSettings, LastUpdatedDate) VALUES (@PathId, @PageSettings, @CurrentTimeUtc)
    RETURN 0
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TrxType_Update]''
');

GO
SET QUOTED_IDENTIFIER ON

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_TrxType_Update]
	@DataSourceId INT,
	@Code VARCHAR(100),
	@Description VARCHAR(100),
	@IsPosition BIT = 0,
	@IsPremium BIT = 0,
	@IsPandS BIT = 0,
	@IsPandL BIT = 0,
	@IsTrade BIT = 0,
	@ExcludeFromTradeRec BIT = 0,
	@IsCancellation BIT = 0,
	@IsOptionMarketValue BIT = 0,
	@IsAutoMatched BIT = 0
AS
SET NOCOUNT ON
BEGIN
UPDATE [dbo].[ib_TrxType] SET    [Description] = @Description
								,[IsPosition] = @IsPosition
								,[IsPremium] = @IsPremium
								,[IsPandS] = @IsPandS
								,[IsPandL] = @IsPandL
								,[UpdateDate] = GETDATE()
								,[UpdateUsername] = SUSER_SNAME()
								,[IsTrade] = @IsTrade
								,[ExcludeFromTradeRec] = @ExcludeFromTradeRec
								,[IsCancellation] = @IsCancellation
								,[IsOptionMarketValue] = @IsOptionMarketValue
								,[IsAutoMatched] = @IsAutoMatched
WHERE [DataSourceId] = @DataSourceId
  AND [Code] = @Code
  AND ([Description] <> @Description OR
		[IsPosition] <> @IsPosition OR
		[IsPremium] <> @IsPremium OR
		[IsPandS] <> @IsPandS OR
		[IsPandL] <> @IsPandL OR
		[IsTrade] <> @IsTrade OR
		[ExcludeFromTradeRec] <> @ExcludeFromTradeRec OR
		[IsCancellation] <> @IsCancellation OR
		[IsOptionMarketValue] <> @IsOptionMarketValue OR
		[IsAutoMatched] <> @IsAutoMatched)
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Adjustment_GetByMatchingAdjustmentId]''
');

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Select records from the ib_Adjustment table through an index
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[ib_Adjustment_GetByMatchingAdjustmentId]
(

	@MatchingAdjustmentId int   
)
AS


				SELECT
					[AdjustmentId],
					[TemplateId],
					[ExchangeId],
					[InstrumentId],
					[InternalExternalCode],
					[TradeDate],
					[AdjustmentDate],
					[Quantity],
					[CurrencyId],
					[ExpiryYear],
					[ExpiryMonth],
					[ExpiryDay],
					[StrikePrice],
					[TradePrice],
					[SettlementPrice],
					[OptionTypeCode],
					[Value],
					[PremiumValue],
					[OptionValue],
					[Description],
					[TemplateGroupId],
					[CreateDate],
					[CreateUsername],
					[UpdateDate],
					[UpdateUsername],
					[IsBuy],
					[MatchCodeId],
					[AdjustmentHeaderId],
					[DataSourceId],
					[FirmId],
					[QuantityLong],
					[QuantityShort],
					[DetailAccountId],
					[AccountId],
					[ClassId],
					[AdjustmentStatusId],
					[AdjustmentReasonId],
					[TrxTypeCode],
					[AdjustmentUserStatusId],
					[MatchingAdjustmentId],
					[ReplacesAdjustmentId]
				FROM
					[dbo].[ib_Adjustment]
				WHERE
					[MatchingAdjustmentId] = @MatchingAdjustmentId
				SELECT @@ROWCOUNT
					
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_ImbalanceReport_GetExcahengesForImbalanceReport]''
');

GO
EXECUTE (' /*
<details>
	<summary>Returns available exchanges for a given ImbalanceReportId</summary>
	<created author="laurentiu.macovei" date="Fri, 20 Oct 2006 19:09:28 GMT"/>
</details>
*/
CREATE PROCEDURE [dbo].[ib_ImbalanceReport_GetExcahengesForImbalanceReport] 
@ImbalanceReportId int
AS
SET NOCOUNT ON

SELECT DISTINCT e.Code as ExchangeCode, e.ExchangeId
	FROM ib_ImbalanceReportSummary irs
		INNER JOIN ib_Exchange e ON irs.ImbalanceReportId = @ImbalanceReportId 
			AND e.ExchangeId = irs.ExchangeId
	ORDER BY e.Code
');

GO
EXECUTE ('PRINT N''Creating [dbo].[GetNextBusinessDay]''
');

GO
EXECUTE ('CREATE FUNCTION [dbo].[GetNextBusinessDay]
(
	@AsOfDate DATETIME
)
RETURNS DATETIME
AS
--    Description: get the next as of date
--    02 Jun 2010 ED Created
BEGIN
DECLARE @NextAsOfDate DATETIME
SET @NextAsOfDate = DATEADD(dd,1,@AsOfDate)

IF DATENAME(Weekday,@NextAsOfDate) = ''Saturday'' 
		BEGIN
			SET @NextAsOfDate = DATEADD(dd,2,@NextAsOfDate)
		END
	IF DATENAME(Weekday,@NextAsOfDate) = ''Sunday'' 
		BEGIN
			SET @NextAsOfDate = DATEADD(dd,1,@NextAsOfDate)
		END
RETURN @NextAsOfDate
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Adjustment_RollOverTradeAdjustments]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Adjustment_RollOverTradeAdjustments]
(
	@AsOfDate DATETIME
	, @ReportId INT = NULL
	, @TemplateId INT
)
AS
SET NOCOUNT ON
--	Description: create adjustment reconciliations

--	01 Jun 2010		ED		Created
--	18 Jun 2010		ED		MBAL-15867: rollover changes: SP log 
--	23 Jul 2010		AAJM	MBAL-16256: Rolled Adjustment Amounts Signed Incorrectly
--	26 Jul 2010		AAJM	MBAL-16256: Change Value formula for Trade Cancellations
--	29 Jul 2010		amk		MBAL-16334: attach roll overs to new adjustment headers
--	02 Aug 2010		amk		MBAL-16339: only go as far back as 5 days before As Of Date
--	03 Aug 2010		amk		MBAL-16334: bug fix - only grab the new headers just created
--	06 Jan 2011		amk		MBAL-17216: only rollover for one template
--	17 May 2012		ED		MBAL-17935: remove check for existing import file for datasource and asofdate
--	10 Jul 2012		ED		MBAL 21151 - Try to get settlement price ignoring datasource
--	16 Jul 2012		ED		MBAL 17935 - use imporfile.AsOfDate to filter rollover ignoring datasource
--  30 Dec 2013		rd		MBAL-24935: check for position file import on date greater than the asofdate (rather than equal to) so works on bank holiday dates when no files were imported.
--  25 Jun 2014		ED		EIB 25770: logic for Unmatched Adj/Trades
--  19 Dec 2014		ED		EIB 26110 - rollover DL adj
BEGIN TRY
	BEGIN TRAN

	--rollover part
	DECLARE @RolledOverStatusId INT

	SELECT @RolledOverStatusId = AdjustmentStatusId 
	FROM ib_AdjustmentStatus 
	WHERE Code=''R''

	DECLARE @AdjustmentsToRollover TABLE(AdjustmentId INT
		, AsOfDate DATETIME
		, SettlementPrice DECIMAL(24,10)
		, Value DECIMAL(19,4)
		, InstrumentTypeCode VARCHAR(25)
		, OldAdjustmentHeaderId INT
		)

	INSERT INTO @AdjustmentsToRollover (AdjustmentId, AsOfDate, InstrumentTypeCode, SettlementPrice, Value
		, OldAdjustmentHeaderId)
	SELECT a.AdjustmentId, dbo.GetNextBusinessDay(AdjustmentDate), it.Code, SettlementPrice, Value
		, a.AdjustmentHeaderId
	FROM ib_Adjustment a
		INNER JOIN ib_AdjustmentHeader ah ON ah.AdjustmentHeaderId = a.AdjustmentHeaderId
		INNER JOIN ib_AdjustmentType AT ON at.AdjustmentTypeId = ah.AdjustmentTypeId 
			AND at.Code IN (''TC'',''TI'',''MI'', ''UM'', ''DL'') -- only trade adjs
		INNER JOIN ib_Instrument i ON i.InstrumentId = a.InstrumentId
		INNER JOIN ib_InstrumentType it ON it.InstrumentTypeId = i.InstrumentTypeId
		LEFT JOIN ib_AdjustmentStatus adjStatus 
			ON adjStatus.AdjustmentStatusId = a.AdjustmentStatusId 
	WHERE (adjStatus.Code NOT IN (''A'',''M'',''R'') OR a.AdjustmentStatusId IS NULL)
		AND a.AdjustmentDate < @AsOfDate
		AND a.AdjustmentDate > DATEADD(d, -5, @AsOfDate)
		AND a.TemplateId = @TemplateId
		AND EXISTS(
			SELECT ImportFileId 
			FROM ib_ImportFile impf 
			WHERE impf.AsOfDate >= a.AdjustmentDate
			) -- position loaded after that AsOfDate

	UPDATE @AdjustmentsToRollover
	SET r.SettlementPrice = CASE WHEN InstrumentTypeCode = ''F'' OR InstrumentTypeCode = ''O'' THEN
			dbo.GetSettlementPriceByAlternateKey(AsOfDate, DataSourceId, ExchangeId, a.InstrumentId
				, CurrencyId, ExpiryYear, ExpiryMonth, ExpiryDay, StrikePrice, OptionTypeCode)
		ELSE
			r.SettlementPrice 
		END
	FROM @AdjustmentsToRollover r 
	INNER JOIN ib_Adjustment a ON a.AdjustmentId = r.AdjustmentId

	--if no sett price, try to get from the "other" datasource
	UPDATE @AdjustmentsToRollover
	SET r.SettlementPrice = dbo.GetSettlementPriceByAlternateKey(r.AsOfDate , 
		[dbo].[GetDataSourceIdForTradeAdjustments](a.TemplateId, a.InstrumentId, a.ExchangeId, mc.MatchCode, 
			CASE WHEN a.InternalExternalCode = ''I'' THEN ''E'' ELSE ''I'' END) -- "Other" DataSourceId
		, a.ExchangeId, a.InstrumentId, a.CurrencyId
		, a.ExpiryYear, a.ExpiryMonth, a.ExpiryDay, a.StrikePrice, a.OptionTypeCode)
	FROM @AdjustmentsToRollover r 
		INNER JOIN ib_Adjustment a ON a.AdjustmentId = r.AdjustmentId
		INNER JOIN ib_MatchCode mc ON a.MatchCodeId = mc.MatchCodeId
	WHERE r.SettlementPrice IS NULL
	--if no sett price, try to get from any datasource
	UPDATE @AdjustmentsToRollover
	SET r.SettlementPrice = (SELECT TOP 1 SettlementPrice FROM ib_Price 
			WHERE [AsOfDate] = r.AsOfDate AND [ExchangeId] = a.ExchangeId AND [InstrumentId] = a.InstrumentId AND [CurrencyId] = a.CurrencyId AND [ExpiryYear] = a.ExpiryYear AND [ExpiryMonth] = a.ExpiryMonth 
			AND ([ExpiryDay] = a.ExpiryDay OR (ExpiryDay IS NULL AND a.ExpiryDay IS NULL)) 
			AND ([StrikePrice] = a.StrikePrice OR (ISNULL(StrikePrice,0)=0 AND ISNULL(a.StrikePrice,0)=0)) 
			AND ([OptionTypeCode] = a.OptionTypeCode OR (ISNULL(OptionTypeCode,'''')='''' AND ISNULL(a.OptionTypeCode,'''')='''')))
	FROM @AdjustmentsToRollover r 
		INNER JOIN ib_Adjustment a ON a.AdjustmentId = r.AdjustmentId
		INNER JOIN ib_MatchCode mc ON a.MatchCodeId = mc.MatchCodeId
	WHERE r.SettlementPrice IS NULL

	--put the note if any settlement price can''t be found
	IF EXISTS (SELECT SettlementPrice 
				FROM @AdjustmentsToRollover 
				WHERE SettlementPrice IS NULL) AND @ReportId IS NOT NULL
		UPDATE ib_Report 
		SET Notes = ''Adjustment(s) rolled using previous day''''s settlement price'' 
		WHERE ReportId = @ReportId 

	--use previous day settlement price
	UPDATE @AdjustmentsToRollover
	SET r.SettlementPrice = a.SettlementPrice
	FROM @AdjustmentsToRollover r 
		INNER JOIN ib_Adjustment a ON a.AdjustmentId = r.AdjustmentId
	WHERE r.SettlementPrice IS NULL

	--calculate value
	UPDATE @AdjustmentsToRollover
	SET r.Value = CASE WHEN InstrumentTypeCode = ''F'' OR InstrumentTypeCode = ''O'' THEN
			(r.SettlementPrice - TradePrice) * dbo.GetInstrumentTickSizeByInstrumentId(a.InstrumentId)
			* (CASE WHEN a.QuantityLong != 0 THEN a.QuantityLong ELSE a.QuantityShort END) --lots
			* (CASE WHEN a.QuantityLong  != 0  THEN 1 ELSE -1 END) --when it is short multiply with -1		
		ELSE
			r.Value 
		END
	FROM @AdjustmentsToRollover r 
		INNER JOIN ib_Adjustment a ON  a.AdjustmentId = r.AdjustmentId
		INNER JOIN ib_AdjustmentHeader ah ON ah.AdjustmentHeaderId = a.AdjustmentHeaderId
		INNER JOIN ib_AdjustmentType AT ON at.AdjustmentTypeId = ah.AdjustmentTypeId 

	-- set the status for the rolled over adjustment
	UPDATE ib_Adjustment
	SET AdjustmentStatusId = @RolledOverStatusId
	FROM ib_Adjustment a 
		INNER JOIN @AdjustmentsToRollover r ON a.AdjustmentId = r.AdjustmentId

	-- BEGIN create new set of adjustment header records

	SELECT DISTINCT OldAdjustmentHeaderId
	INTO #DistinctAdjustmentHeaders
	FROM @AdjustmentsToRollover

	DECLARE @EarliestAdjustmentHeaderCreateDate DATETIME
	SET @EarliestAdjustmentHeaderCreateDate = GETDATE()

	INSERT INTO ib_AdjustmentHeader (AdjustmentTypeId, PriceId, SettlementPriceAdjustment
		, AdjustmentStatusId, AdjustmentReasonId, Description, AdjustmentUserStatusId
		, TradeReconciliationSummaryId, RolledForwardFromAdjustmentHeaderId)
	SELECT ah.AdjustmentTypeId, ah.PriceId, ah.SettlementPriceAdjustment
		, ah.AdjustmentStatusId, ah.AdjustmentReasonId, ah.Description, ah.AdjustmentUserStatusId
		, ah.TradeReconciliationSummaryId, ah.AdjustmentHeaderId
	FROM #DistinctAdjustmentHeaders a
		JOIN ib_AdjustmentHeader ah ON a.OldAdjustmentHeaderId = ah.AdjustmentHeaderId

	DROP TABLE #DistinctAdjustmentHeaders
		
	-- END create new set of adjustment header records

	--insert new adjustment	
	INSERT INTO [dbo].[ib_Adjustment] 
		( [TemplateId]
		, [ExchangeId]
		, [InstrumentId]
		, [InternalExternalCode]
		, [TradeDate]
		, [AdjustmentDate]
		, [Quantity]
		, [CurrencyId]
		, [ExpiryYear]
		, [ExpiryMonth]
		, [ExpiryDay]
		, [StrikePrice]
		, [TradePrice]
		, [SettlementPrice]
		, [OptionTypeCode]
		, [Value]
		, [PremiumValue]
		, [OptionValue]
		, [Description]
		, [TemplateGroupId]
		, [CreateDate]
		, [CreateUsername]
		, [IsBuy]
		, [MatchCodeId]
		, [AdjustmentHeaderId]
		, [DataSourceId]
		, [FirmId]
		, [QuantityLong]
		, [QuantityShort]
		, [DetailAccountId]
		, [AccountID]
		, [ClassId]
		, [AdjustmentStatusId]
		, [AdjustmentReasonId]
		, [TrxTypeCode]
		, [AdjustmentUserStatusId]
		, [MatchingAdjustmentId]
		, ReplacesAdjustmentId)
	SELECT a.TemplateId
			, a.ExchangeId
			, a.InstrumentId
			, a.InternalExternalCode
			, a.TradeDate
			, r.AsOfDate
			, a.Quantity
			, a.CurrencyId
			, a.ExpiryYear
			, a.ExpiryMonth
			, a.ExpiryDay
			, a.StrikePrice
			, a.TradePrice
			, r.SettlementPrice
			, a.OptionTypeCode
			, r.Value
			, a.PremiumValue
			, a.OptionValue
			, a.Description
			, a.TemplateGroupId
			, GETDATE()
			, a.CreateUsername
			, a.IsBuy
			, a.MatchCodeId
			, ah.AdjustmentHeaderId
			, a.DataSourceId
			, a.FirmId
			, a.QuantityLong
			, a.QuantityShort
			, a.DetailAccountId
			, a.AccountID
			, a.ClassId
			, NULL
			, a.AdjustmentReasonId
			, a.TrxTypeCode
			, a.AdjustmentUserStatusId
			, a.MatchingAdjustmentId
			, a.AdjustmentId
	FROM ib_Adjustment a
		INNER JOIN @AdjustmentsToRollover r ON a.AdjustmentId = r.AdjustmentId
		INNER JOIN ib_AdjustmentHeader ah ON r.OldAdjustmentHeaderId = ah.RolledForwardFromAdjustmentHeaderId
	WHERE ah.CreateDate >= @EarliestAdjustmentHeaderCreateDate
		
	COMMIT TRAN
END TRY
BEGIN CATCH
	ROLLBACK TRAN
	EXEC [dbo].[sp_RethrowError]
END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Adjustment_RollOverCQAdjustments]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Adjustment_RollOverCQAdjustments]
(
	@AsOfDate DATETIME
	, @TemplateId INT
)
AS
SET NOCOUNT ON
--	Description: create CQ adjustment reconciliations

--	18 Jun 2010		ED		created (MBAL 15867)
--	29 Jul 2010		amk		MBAL-16334: attach roll overs to new adjustment headers
--	02 Aug 2010		amk		MBAL-16339: only go as far back as 5 days before As Of Date
--	03 Aug 2010		amk		MBAL-16334: bug fix - only grab the new headers just created
--	06 Jan 2011		amk		MBAL-17216: only rollover for one template
--  30 Dec 2013		rd		MBAL-24935: check for position file import on date greater than the asofdate (rather than equal to) so works on bank holiday dates when no files were imported.
	
BEGIN TRY
	BEGIN TRAN

	--rollover part
	DECLARE @RolledOverStatusId INT

	SELECT @RolledOverStatusId = AdjustmentStatusId 
	FROM ib_AdjustmentStatus 
	WHERE Code = ''R''

	DECLARE @AdjustmentsToRollover TABLE(AdjustmentId INT, AsOfDate DATETIME, OldAdjustmentHeaderId INT)

	INSERT INTO @AdjustmentsToRollover(AdjustmentId, AsOfDate, OldAdjustmentHeaderId)
	SELECT a.AdjustmentId, dbo.GetNextBusinessDay(AdjustmentDate), a.AdjustmentHeaderId
	FROM ib_Adjustment a
		INNER JOIN ib_AdjustmentHeader ah ON ah.AdjustmentHeaderId = a.AdjustmentHeaderId
		INNER JOIN ib_AdjustmentType AT 
			ON at.AdjustmentTypeId = ah.AdjustmentTypeId AND at.Code = ''CQ'' -- only cq adjs
		LEFT JOIN ib_AdjustmentStatus adjStatus 
			ON adjStatus.AdjustmentStatusId = a.AdjustmentStatusId 
	WHERE (adjStatus.Code NOT IN (''A'',''M'',''R'') OR a.AdjustmentStatusId IS NULL)
		AND a.AdjustmentDate < @AsOfDate
		AND a.AdjustmentDate > DATEADD(d, -5, @AsOfDate)
		AND EXISTS(SELECT ImportFileId 
					FROM ib_ImportFile impf 
					WHERE impf.AsOfDate >= a.AdjustmentDate) -- position loaded after that AsOfDate
		AND a.TemplateId = @TemplateId

	UPDATE ib_Adjustment
	SET AdjustmentStatusId = @RolledOverStatusId
	FROM ib_Adjustment a 
		INNER JOIN @AdjustmentsToRollover r ON a.AdjustmentId = r.AdjustmentId

	-- BEGIN create new set of adjustment header records

	SELECT DISTINCT OldAdjustmentHeaderId
	INTO #DistinctAdjustmentHeaders
	FROM @AdjustmentsToRollover

	DECLARE @EarliestAdjustmentHeaderCreateDate DATETIME
	SET @EarliestAdjustmentHeaderCreateDate = GETDATE()

	INSERT INTO ib_AdjustmentHeader (AdjustmentTypeId, PriceId, SettlementPriceAdjustment
		, AdjustmentStatusId, AdjustmentReasonId, Description, AdjustmentUserStatusId
		, TradeReconciliationSummaryId, RolledForwardFromAdjustmentHeaderId)
	SELECT ah.AdjustmentTypeId, ah.PriceId, ah.SettlementPriceAdjustment
		, ah.AdjustmentStatusId, ah.AdjustmentReasonId, ah.Description, ah.AdjustmentUserStatusId
		, ah.TradeReconciliationSummaryId, ah.AdjustmentHeaderId
	FROM #DistinctAdjustmentHeaders a
		JOIN ib_AdjustmentHeader ah ON a.OldAdjustmentHeaderId = ah.AdjustmentHeaderId

	DROP TABLE #DistinctAdjustmentHeaders
		
	-- END create new set of adjustment header records

	INSERT INTO [dbo].[ib_Adjustment] ([TemplateId], [ExchangeId], [InstrumentId], [InternalExternalCode], [TradeDate], [AdjustmentDate], [Quantity], [CurrencyId]
		, [ExpiryYear], [ExpiryMonth], [ExpiryDay], [StrikePrice], [TradePrice]
		, [SettlementPrice]
		, [OptionTypeCode]
		, [Value]
		, [PremiumValue], [OptionValue], [Description], [TemplateGroupId], [CreateDate], [CreateUsername], [IsBuy], [MatchCodeId]
		, [AdjustmentHeaderId], [DataSourceId], [FirmId], [QuantityLong], [QuantityShort], [DetailAccountId], [AccountID], [ClassId], [AdjustmentStatusId]
		, [AdjustmentReasonId], [TrxTypeCode], [AdjustmentUserStatusId], [MatchingAdjustmentId],ReplacesAdjustmentId)
	SELECT a.TemplateId, a.ExchangeId, a.InstrumentId, a.InternalExternalCode, a.TradeDate, r.AsOfDate, a.Quantity, a.CurrencyId
		, a.ExpiryYear, a.ExpiryMonth, a.ExpiryDay, a.StrikePrice, a.TradePrice
		, a.SettlementPrice
		, a.OptionTypeCode
		, a.Value
		, a.PremiumValue, a.OptionValue, a.Description, a.TemplateGroupId, GETDATE(), a.CreateUsername, a.IsBuy, a.MatchCodeId
		, ah.AdjustmentHeaderId, a.DataSourceId, a.FirmId, a.QuantityLong, a.QuantityShort, a.DetailAccountId, a.AccountID, a.ClassId, NULL
		, a.AdjustmentReasonId, a.TrxTypeCode, a.AdjustmentUserStatusId, a.MatchingAdjustmentId, a.AdjustmentId
	FROM ib_Adjustment a
		INNER JOIN @AdjustmentsToRollover r ON a.AdjustmentId = r.AdjustmentId
		INNER JOIN ib_AdjustmentHeader ah ON r.OldAdjustmentHeaderId = ah.RolledForwardFromAdjustmentHeaderId
	WHERE ah.CreateDate >= @EarliestAdjustmentHeaderCreateDate
		
	COMMIT TRAN
END TRY
BEGIN CATCH
	ROLLBACK TRAN
	EXEC [dbo].[sp_RethrowError]
END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TradeReconciliation_BuildReport]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_TradeReconciliation_BuildReport]
	@CreateUsername varchar(50) = NULL,
	@UserId uniqueidentifier,	
	@TemplateId int,
	@TodayDate datetime,
	@AdjustmentReconciliationLevel INT,
	@Refresh bit = 1,
	@FilterExchangeId int = NULL,
	@FilterDescription varchar(100) = NULL,
	@FilterCurrencyId int = NULL,
	@FilterBreaks INT=1,
	@@OrderBy varchar(300) = NULL,
	@@StartRowIndex int = NULL,
	@@MaximumRows int = NULL,
	@@ReportId int OUTPUT, 
	@@TradeReconciliationId int OUTPUT

AS

--	Description: Generates the ib_TradeReconciliation by calling both Phase 1 and Phase 2, and stores the results in the Report table

--	30 Jul 2009		AAJM	Creation
--  07 Aug 2009		AAJM	Update to include additional Matching report phase
--  18 Aug 2009		AAJM	Fix to ensure web report does not refresh unexpectedly
--	29 Oct 2009		amk		Plug in step 2a (cancel out trade transfers)
--  18 May 2010     ED      Display also the ones that does not break
--  18 Jun 2010     ED      Call the sps to reconcile adjustments and to rollover adjustments
--  28 Jun 2010     ED      MBAL-15951: add parameter AdjustmentReconciliationLevel
--	06 Jan 2011		amk		MBAL-17216: pass in templateid into rollover and reconcile (match) stored procs
--	06 Jan 2011		amk		MBAL-17237: ensure calls to add new report record carry template so site can be saved correctly
--	21 Jul 2014		ED		EIB 25771 - add logic to reconcile UM adjs

SET NOCOUNT ON

--fix the problem when sending zero values to these paramaters
IF @@ReportId <= 0
	SET @@ReportId = null
IF @@TradeReconciliationId = 0
	SET @@TradeReconciliationId = null

--fix the username
IF (@CreateUsername IS NULL)
	SET @CreateUsername = SUSER_NAME()

--EXECUTE everything in a TRY/CATCH
BEGIN TRY

IF @Refresh = 0
BEGIN		

	SET @Refresh = 1
	
	IF @@ReportId IS NOT NULL
		BEGIN

			SELECT @@TradeReconciliationId = TR.TradeReconciliationId, @Refresh = 0
			FROM [dbo].[ib_TradeReconciliation] TR 
			INNER JOIN [dbo].[ib_Report] R ON TR.[TradeReconciliationId] = R.[TargetReportId]
				-- Check that the report is still the correct type etc			
				AND R.[ReportType] = ''TradeRec''
				AND TR.[TemplateId] = @TemplateId 
				AND TR.[Today] = @TodayDate
				AND R.ReportId = @@ReportId 

		END
	ELSE
		BEGIN
		
			SELECT TOP 1 @@TradeReconciliationId = TR.[TradeReconciliationId], @Refresh = 0 
				FROM [dbo].[ib_TradeReconciliation] TR 
			INNER JOIN [dbo].[ib_Report] R ON TR.[TradeReconciliationId] = R.[TargetReportId]
				AND R.[ReportType] = ''TradeRec''
				AND TR.[TemplateId] = @TemplateId 
				AND TR.[Today] = @TodayDate
				AND TR.[CreateDate] IN 
					(SELECT MAX([CreateDate]) 
						FROM [dbo].[ib_TradeReconciliation]
						WHERE [TemplateId] = @TemplateId 
							AND [Today] = @TodayDate)
			ORDER BY r.ReportId DESC
	
		END
	
END

IF @Refresh = 1
BEGIN
	--check if the specified reportId exists, otherwise set it to NULL to create a new one
	--for this operation we''ll use the @Refresh flag
	IF @@ReportId IS NOT NULL
		SELECT @Refresh = 0
			FROM ib_Report
			WHERE ReportId = @@ReportId
			
	IF @Refresh = 1 -- the reportId was not found
		SET @@ReportId = NULL -- so set it null
	ELSE SET @Refresh = 1 -- otherwise, restore the flag

	IF @@ReportId IS NULL
		EXEC [dbo].[ib_Report_CreateReport] ''TradeRec''
			, @CreateUserName, @UserID, @@ReportId OUTPUT, NULL, @TemplateId

	--validate the reportId
	SELECT @@ReportId = ReportId FROM [dbo].[ib_Report]
		WHERE @@ReportId = ReportId AND ReportType = ''TradeRec''
	IF @@RowCount = 0 
		RAISERROR (N''The specified reportId ''''%d'''' does not exist or is not an ''''TradeRec'''' report.'', 12, 1, @@ReportId)
	--validate the report status
	SELECT @@ReportId = ReportId FROM [dbo].[ib_Report]
		WHERE @@ReportId = ReportId AND ReportType = ''TradeRec'' AND Status = ''Added''
	IF @@RowCount = 0 
		RAISERROR (N''The specified reportId ''''%d'''' has is not in the ''''Added'''' status. Operation cannot continue.'', 12, 1, @@ReportId)

	DECLARE @SiteID int	
	SET @SiteID = -1


	--FIND the siteId for the provided userID that matches the first template
	SELECT TOP 1 @SiteId = su.SiteId 
		FROM [dbo].[ib_SiteUser] su
		INNER JOIN [dbo].[ib_SiteTemplate] st 
			ON  su.UserId = @UserID 
				AND st.SiteID = su.SiteId 
				AND st.TemplateId = @TemplateID

		IF @SiteId = -1
	BEGIN

		--Find the SiteId for the provided userId
		SELECT TOP 1 @SiteId = SiteId FROM ib_SiteUser
			WHERE UserId = @UserID AND IsPrimary = 1

		IF @SiteId = -1
		BEGIN
			--	Try to find a non-isPrimary SiteId for the speicified user
			SELECT TOP 1 @SiteId = SiteId FROM ib_SiteUser
				WHERE UserId = @UserID
			--if still not found, throw error
			IF @SiteId = -1
			BEGIN
				DECLARE @@UserId varchar(100)
				SET @@UserId = Cast(@UserId as varchar(100))
				RAISERROR (N''Provided userId ''''%s'''' does not have an associated site.'', 11, 1, @@UserId)
			END	
		END
	END
	--update the report status
	UPDATE [dbo].[ib_Report]
		SET [Status] = ''Building'',
			[Stage] = ''Calling Reconcile Adjustments'',
			[SiteId] = @SiteId
		WHERE ReportId = @@ReportId
	-- AdjustmentReconciliationLevel values
	--	0 = nothing
	--	1 = rollover only
	--	2 = reconciliation (auto-match) and rollover	
	IF @AdjustmentReconciliationLevel = 1 OR @AdjustmentReconciliationLevel = 2
	BEGIN
		--rollover trade adjustments
		EXEC ib_Adjustment_RollOverTradeAdjustments @TodayDate, @@ReportId, @TemplateId
		--rollover CQ adjustments
		EXEC ib_Adjustment_RollOverCQAdjustments @TodayDate, @TemplateId
	END
	IF @AdjustmentReconciliationLevel = 2
	BEGIN
		--reconcile trade adjustments(automatically matched)
		EXEC ib_TradeReconciliation_ReconcileAdjustments @TodayDate, @TemplateId
	END
	EXEC ib_Adjustment_GenerateForUnmatchedTrades @TodayDate, @TemplateId
	--update the report status
	UPDATE [dbo].[ib_Report]
		SET [Status] = ''Building'',
			[Stage] = ''Calling Step 1'',
			[SiteId] = @SiteId
		WHERE ReportId = @@ReportId

	EXEC [dbo].[ib_TradeReconciliation_BuildReportPhase1] 
		@CreateUsername,
		@TemplateId,
		@TodayDate,
		@UserId,
		@@ReportId,
		@@TradeReconciliationId OUTPUT

	--update the report status
	UPDATE [dbo].[ib_Report]
		SET [Status] = ''Building'',
			[Stage] = ''Calling Step 2'',
			[SiteId] = @SiteId
		WHERE ReportId = @@ReportId
		
	EXEC [dbo].[ib_TradeReconciliation_BuildReportPhase2] 
		@@ReportId,
		@@TradeReconciliationId
		
	--update the report status
	UPDATE [dbo].[ib_Report]
		SET [Status] = ''Building'',
			[Stage] = ''Calling Step 2a'',
			[SiteId] = @SiteId
		WHERE ReportId = @@ReportId
		
	EXEC [dbo].[ib_TradeReconciliation_BuildReportPhase2a] 
		@@ReportId,
		@@TradeReconciliationId
		
	--update the report status
	UPDATE [dbo].[ib_Report]
		SET [Status] = ''Building'',
			[Stage] = ''Calling Step 3'',
			[SiteId] = @SiteId
		WHERE ReportId = @@ReportId

	EXEC [dbo].[ib_TradeReconciliation_BuildReportPhase3]
		@@ReportId,
		@@TradeReconciliationId
	
	EXEC dbo.ib_TradeReconciliation_ReconcileUMAdjustments @TodayDate, @TemplateId, @@TradeReconciliationId

	-- Update the TargetReportId
	UPDATE ib_Report
	SET TargetReportId = @@TradeReconciliationId
	WHERE ReportId = @@ReportId

	--update the report status
	UPDATE [dbo].[ib_Report]
		SET [Stage] = ''SQL Job: Cleaning up''
		WHERE ReportId = @@ReportId
	
-- Clean-up reportDetail since we don''t need this data
--	DELETE FROM ib_TradeReconciliationDetail
--		WHERE TradeReconciliationId = @@TradeReconciliationId

-- Update the report status
	UPDATE [dbo].[ib_Report]
		SET [Stage] = ''SQL Job: Sending data to the output''
		WHERE ReportId = @@ReportId

END


-- Fix OrderBy
IF (ISNULL(@@OrderBy, '''')='''')
	SET @@OrderBy = ''Exchange, MatchCode, Currency ASC'' 
-- Fix the top
IF IsNull(@@MaximumRows, 0) <= 0
	SET @@MaximumRows = 0
IF IsNull(@@StartRowIndex, -1) <= -1 OR @@MaximumRows = 0 
	SET @@StartRowIndex = 0

DECLARE @SQL nvarchar(4000)
DECLARE @WHERE nvarchar(1000)

SET @WHERE = ''TradeReconciliationId = '' + Cast(@@TradeReconciliationId as varchar(100)) 
IF @FilterBreaks = 1	 
SET @WHERE = @WHERE + '' AND ([DifferenceLong] <> 0 OR [DifferenceShort] <> 0)''

IF @FilterExchangeID IS NOT NULL
	SET @WHERE = @WHERE + '' AND ExchangeID = '' + cast(@FilterExchangeId as varchar(100))

IF @FilterCurrencyID IS NOT NULL
	SET @WHERE = @WHERE + '' AND CurrencyID = '' + cast(@FilterCurrencyId as varchar(100))

IF @FilterDescription IS NOT NULL
	SET @WHERE = @WHERE + '' AND MatchCode = '''''' + replace(@FilterDescription, '''''''', '''''''''''') + ''''''''
	
IF @@MaximumRows >0
	SET @sql = ''
SELECT [ExchangeId], [InstrumentId], [ExpiryYear],
	[ExpiryMonth], [ExpiryDay], [OptionTypeCode],
	[CurrencyId], [StrikePrice], [TradePrice], [TotalInternalLong], [TotalInternalShort], [TotalExternalLong], [TotalExternalShort], [DifferenceLong], [DifferenceShort], [MatchCode], [Exchange], [Currency], [Instrument], [TradeReconciliationSummaryId]
FROM
	(SELECT TOP('' + CONVERT(nvarchar(10), @@StartRowIndex + @@MaximumRows) + '')''
ELSE SET @sql = ''SELECT''

--build the query
SET @sql = @sql + '' [ExchangeId], [InstrumentId], [ExpiryYear],
	[ExpiryMonth], [ExpiryDay], [OptionTypeCode],
	[CurrencyId], [StrikePrice], [TradePrice], [TotalInternalLong], [TotalInternalShort], [TotalExternalLong], [TotalExternalShort], [DifferenceLong], [DifferenceShort], [MatchCode], [Exchange], [Currency], [Instrument], [TradeReconciliationSummaryId]
''

IF @@MaximumRows >0
	SET @sql = @sql+'', ROW_NUMBER() OVER(ORDER BY '' + @@OrderBy + '') as RowNum''

SET @sql = @sql + ''
 FROM [dbo].[ib_TradeReconciliationSummary] trs
 WHERE '' + @WHERE

IF @@MaximumRows = 0
	SET @sql = @sql+''
 ORDER BY '' + @@OrderBy 

IF @@MaximumRows >0
	SET @sql = @sql +  '') x
WHERE RowNum > '' + CONVERT(nvarchar(10), @@StartRowIndex) + '' ORDER BY RowNum''

EXEC sp_executesql @sql


--build Notes

DECLARE @TemplateName VARCHAR(100)
SELECT @TemplateName = Description 
FROM ib_Template 
WHERE TemplateId = @TemplateId

DECLARE @Notes VARCHAR(255)
SET @Notes = @TemplateName
	+ '', '' + CONVERT(VARCHAR(10), @TodayDate, 103) 

--update the report status
IF @Refresh = 1 -- Ensure the stage is not updated when reloading report
	UPDATE [dbo].[ib_Report]
		SET [Stage] = ''SQL Job: Complete''
			, [Notes] = CASE WHEN Notes IS NULL THEN @Notes
						ELSE @Notes + ''. ''+ CONVERT(VARCHAR(4000), Notes) END
		WHERE ReportId = @@ReportId

END TRY
BEGIN CATCH
	DECLARE @ErrorMessage NVARCHAR(4000);
	SET @ErrorMessage = ERROR_MESSAGE()
	--update the error
	UPDATE [dbo].[ib_Report]
		SET Status = ''Error'',
			ErrorMessage = @ErrorMessage,
			ErrorDetails = ''The error was thrown in the '' + ERROR_PROCEDURE() + '' stored procedure at line '' + CAST(ERROR_LINE() as varchar(10)) + '' with severity '' + CAST(ERROR_SEVERITY() as varchar(10)) + '', state '' + CAST(ERROR_STATE() as varchar(10)) + '' and error number '' + Cast(ERROR_NUMBER() as varchar(10))
			, [Notes] = @Notes
	WHERE ReportId = @@ReportId
--	RAISERROR (@ErrorMessage, 16, 10) WITH LOG
END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_AdjustmentReason_GetCodeAndId]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_AdjustmentReason_GetCodeAndId]
AS
SET NOCOUNT ON
-- 26 May 2010 ED Created
SELECT Code, Description, AdjustmentReasonId 
	FROM ib_AdjustmentReason
');

GO
EXECUTE ('PRINT N''Creating [dbo].[aspnet_Users_DeleteUser]''
');

GO
SET QUOTED_IDENTIFIER OFF

GO
EXECUTE ('CREATE PROCEDURE [dbo].[aspnet_Users_DeleteUser]
    @ApplicationName  nvarchar(256),
    @UserName         nvarchar(256),
    @TablesToDeleteFrom int,
    @NumTablesDeletedFrom int OUTPUT
AS
SET NOCOUNT ON
BEGIN
-- Revision History
-- 15 May 2014  ED  EIB 24866 - don''t delete user, only set IsApproved to false

    SET @NumTablesDeletedFrom = 0
    DECLARE @UserId               uniqueidentifier
    SELECT  @UserId               = NULL
    
    DECLARE @ErrorCode   int
    DECLARE @RowCount    int

    SET @ErrorCode = 0
    SET @RowCount  = 0

    SET @UserId = (SELECT  u.UserId
					FROM    dbo.aspnet_Users u, dbo.aspnet_Applications a
					WHERE   u.LoweredUserName           = LOWER(@UserName)
							AND u.ApplicationId         = a.ApplicationId
							AND LOWER(@ApplicationName) = a.LoweredApplicationName)

    IF (@UserId IS NULL)
        RETURN @ErrorCode

	-- don''t delete, only mark as not approved

	UPDATE dbo.aspnet_Membership SET IsApproved = 0 WHERE @UserId = UserId
	SELECT @ErrorCode = @@ERROR,
               @RowCount = @@ROWCOUNT

    IF( @ErrorCode <> 0 )
             RETURN @ErrorCode

    RETURN 0
 
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[aspnet_Profile_DeleteProfiles]''
');

GO
EXECUTE ('
CREATE PROCEDURE [dbo].[aspnet_Profile_DeleteProfiles]
    @ApplicationName        nvarchar(256),
    @UserNames              nvarchar(4000)
AS
SET NOCOUNT ON
BEGIN
    DECLARE @UserName     nvarchar(256)
    DECLARE @CurrentPos   int
    DECLARE @NextPos      int
    DECLARE @NumDeleted   int
    DECLARE @DeletedUser  int
    DECLARE @TranStarted  bit
    DECLARE @ErrorCode    int

    SET @ErrorCode = 0
    SET @CurrentPos = 1
    SET @NumDeleted = 0
    SET @TranStarted = 0

    IF( @@TRANCOUNT = 0 )
    BEGIN
        BEGIN TRANSACTION
        SET @TranStarted = 1
    END
    ELSE
    	SET @TranStarted = 0

    WHILE (@CurrentPos <= LEN(@UserNames))
    BEGIN
        SELECT @NextPos = CHARINDEX(N'','', @UserNames,  @CurrentPos)
        IF (@NextPos = 0 OR @NextPos IS NULL)
            SELECT @NextPos = LEN(@UserNames) + 1

        SELECT @UserName = SUBSTRING(@UserNames, @CurrentPos, @NextPos - @CurrentPos)
        SELECT @CurrentPos = @NextPos+1

        IF (LEN(@UserName) > 0)
        BEGIN
            SELECT @DeletedUser = 0
            EXEC dbo.aspnet_Users_DeleteUser @ApplicationName, @UserName, 4, @DeletedUser OUTPUT
            IF( @@ERROR <> 0 )
            BEGIN
                SET @ErrorCode = -1
                GOTO Cleanup
            END
            IF (@DeletedUser <> 0)
                SELECT @NumDeleted = @NumDeleted + 1
        END
    END
    SELECT @NumDeleted
    IF (@TranStarted = 1)
    BEGIN
    	SET @TranStarted = 0
    	COMMIT TRANSACTION
    END
    SET @TranStarted = 0

    RETURN 0

Cleanup:
    IF (@TranStarted = 1 )
    BEGIN
        SET @TranStarted = 0
    	ROLLBACK TRANSACTION
    END
    RETURN @ErrorCode
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[aspnet_PersonalizationPerUser_GetPageSettings]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[aspnet_PersonalizationPerUser_GetPageSettings] (
    @ApplicationName  NVARCHAR(256),
    @UserName         NVARCHAR(256),
    @Path             NVARCHAR(256),
    @CurrentTimeUtc   DATETIME)
AS
SET NOCOUNT ON
BEGIN
    DECLARE @ApplicationId UNIQUEIDENTIFIER
    DECLARE @PathId UNIQUEIDENTIFIER
    DECLARE @UserId UNIQUEIDENTIFIER

    SELECT @ApplicationId = NULL
    SELECT @PathId = NULL
    SELECT @UserId = NULL

    EXEC dbo.aspnet_Personalization_GetApplicationId @ApplicationName, @ApplicationId OUTPUT
    IF (@ApplicationId IS NULL)
    BEGIN
        RETURN
    END

    SELECT @PathId = u.PathId FROM dbo.aspnet_Paths u WHERE u.ApplicationId = @ApplicationId AND u.LoweredPath = LOWER(@Path)
    IF (@PathId IS NULL)
    BEGIN
        RETURN
    END

    SELECT @UserId = u.UserId FROM dbo.aspnet_Users u WHERE u.ApplicationId = @ApplicationId AND u.LoweredUserName = LOWER(@UserName)
    IF (@UserId IS NULL)
    BEGIN
        RETURN
    END

    UPDATE   dbo.aspnet_Users WITH (ROWLOCK)
    SET      LastActivityDate = @CurrentTimeUtc
    WHERE    UserId = @UserId
    IF (@@ROWCOUNT = 0) -- Username not found
        RETURN

    SELECT p.PageSettings FROM dbo.aspnet_PersonalizationPerUser p WHERE p.PathId = @PathId AND p.UserId = @UserId
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TrxType_UpdateById]''
');

GO
SET QUOTED_IDENTIFIER ON

GO
EXECUTE ('CREATE  PROCEDURE [dbo].[ib_TrxType_UpdateById]
    @TrxTypeId INT
   ,@DataSourceId INT
   ,@Code VARCHAR(100) = NULL
   ,@Description VARCHAR(100)
   ,@IsPosition BIT = 0
   ,@IsPremium BIT = 0
   ,@IsPandS BIT = 0
   ,@IsPandL BIT = 0
   ,@IsTrade BIT = 0
   ,@ExcludeFromTradeRec BIT = 0
   ,@IsCancellation BIT = 0
   ,@IsOptionMarketValue BIT = 0
   ,@IsAutoMatched BIT = 0
   ,@UpdateUserName NVARCHAR(100) = NULL
AS 
SET NOCOUNT ON

BEGIN
    IF @UpdateUserName IS NULL 
        SET @UpdateUserName = SUSER_SNAME()
    UPDATE
        [dbo].[ib_TrxType]
    SET 
        [Description] = @Description
       ,[IsPosition] = @IsPosition
       ,[IsPremium] = @IsPremium
       ,[IsPandS] = @IsPandS
       ,[IsPandL] = @IsPandL
       ,[UpdateDate] = GETDATE()
       ,[UpdateUsername] = @UpdateUserName
       ,[IsTrade] = @IsTrade
       ,[ExcludeFromTradeRec] = @ExcludeFromTradeRec
       ,[IsCancellation] = @IsCancellation
       ,[IsOptionMarketValue] = @IsOptionMarketValue
       ,[IsAutoMatched] = @IsAutoMatched
    WHERE
        [TrxTypeId] = @TrxTypeId
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Adjustment_GetByTemplateId]''
');

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Select records from the ib_Adjustment table through an index
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[ib_Adjustment_GetByTemplateId]
(

	@TemplateId int   
)
AS


				SELECT
					[AdjustmentId],
					[TemplateId],
					[ExchangeId],
					[InstrumentId],
					[InternalExternalCode],
					[TradeDate],
					[AdjustmentDate],
					[Quantity],
					[CurrencyId],
					[ExpiryYear],
					[ExpiryMonth],
					[ExpiryDay],
					[StrikePrice],
					[TradePrice],
					[SettlementPrice],
					[OptionTypeCode],
					[Value],
					[PremiumValue],
					[OptionValue],
					[Description],
					[TemplateGroupId],
					[CreateDate],
					[CreateUsername],
					[UpdateDate],
					[UpdateUsername],
					[IsBuy],
					[MatchCodeId],
					[AdjustmentHeaderId],
					[DataSourceId],
					[FirmId],
					[QuantityLong],
					[QuantityShort],
					[DetailAccountId],
					[AccountId],
					[ClassId],
					[AdjustmentStatusId],
					[AdjustmentReasonId],
					[TrxTypeCode],
					[AdjustmentUserStatusId],
					[MatchingAdjustmentId],
					[ReplacesAdjustmentId]
				FROM
					[dbo].[ib_Adjustment]
				WHERE
					[TemplateId] = @TemplateId
				SELECT @@ROWCOUNT
					
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_AdjustmentStatus_GetCodeAndId]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_AdjustmentStatus_GetCodeAndId]
AS
SET NOCOUNT ON
-- 24 May 2010 ED Created
SELECT Code, Description, AdjustmentStatusId 
	FROM ib_AdjustmentStatus
');

GO
EXECUTE ('PRINT N''Creating [dbo].[aspnet_Profile_SetProperties]''
');

GO
SET QUOTED_IDENTIFIER OFF

GO
EXECUTE ('CREATE PROCEDURE [dbo].[aspnet_Profile_SetProperties]
    @ApplicationName        nvarchar(256),
    @PropertyNames          ntext,
    @PropertyValuesString   ntext,
    @PropertyValuesBinary   image,
    @UserName               nvarchar(256),
    @IsUserAnonymous        bit,
    @CurrentTimeUtc         datetime
AS
SET NOCOUNT ON
BEGIN
	--	06 Jan 2011		amk		MBAL-17257: save on writes by not updating lastactivitydate
	--	10 Jan 2011		amk		MBAL-17257: still trying to resolve timeout - now on update of profile
	--										so using rowlocks

    DECLARE @ApplicationId uniqueidentifier
    SELECT  @ApplicationId = NULL

    DECLARE @ErrorCode     int
    SET @ErrorCode = 0

    DECLARE @TranStarted   bit
    SET @TranStarted = 0

    IF( @@TRANCOUNT = 0 )
    BEGIN
       BEGIN TRANSACTION
       SET @TranStarted = 1
    END
    ELSE
    	SET @TranStarted = 0

    EXEC dbo.aspnet_Applications_CreateApplication @ApplicationName, @ApplicationId OUTPUT

    IF( @@ERROR <> 0 )
    BEGIN
        SET @ErrorCode = -1
        GOTO Cleanup
    END

    DECLARE @UserId uniqueidentifier
    DECLARE @LastActivityDate datetime
    SELECT  @UserId = NULL
    SELECT  @LastActivityDate = @CurrentTimeUtc

    SELECT @UserId = UserId
    FROM   dbo.aspnet_Users
    WHERE  ApplicationId = @ApplicationId AND LoweredUserName = LOWER(@UserName)
    IF (@UserId IS NULL)
        EXEC dbo.aspnet_Users_CreateUser @ApplicationId, @UserName, @IsUserAnonymous, @LastActivityDate, @UserId OUTPUT

    IF( @@ERROR <> 0 )
    BEGIN
        SET @ErrorCode = -1
        GOTO Cleanup
    END

	/*
	do not udpate lastactivitydate to save on writes

    UPDATE dbo.aspnet_Users
    SET    LastActivityDate=@CurrentTimeUtc
    WHERE  UserId = @UserId
    
    */

    IF( @@ERROR <> 0 )
    BEGIN
        SET @ErrorCode = -1
        GOTO Cleanup
    END

    IF (EXISTS( SELECT *
               FROM   dbo.aspnet_Profile WITH (NOLOCK)
               WHERE  UserId = @UserId))
        UPDATE dbo.aspnet_Profile WITH (ROWLOCK)
        SET    PropertyNames=@PropertyNames, PropertyValuesString = @PropertyValuesString,
               PropertyValuesBinary = @PropertyValuesBinary, LastUpdatedDate=@CurrentTimeUtc
        WHERE  UserId = @UserId
    ELSE
        INSERT INTO dbo.aspnet_Profile(UserId, PropertyNames, PropertyValuesString, PropertyValuesBinary, LastUpdatedDate)
             VALUES (@UserId, @PropertyNames, @PropertyValuesString, @PropertyValuesBinary, @CurrentTimeUtc)

    IF( @@ERROR <> 0 )
    BEGIN
        SET @ErrorCode = -1
        GOTO Cleanup
    END

    IF( @TranStarted = 1 )
    BEGIN
    	SET @TranStarted = 0
    	COMMIT TRANSACTION
    END

    RETURN 0

Cleanup:

    IF( @TranStarted = 1 )
    BEGIN
        SET @TranStarted = 0
    	ROLLBACK TRANSACTION
    END

    RETURN @ErrorCode

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[aspnet_PersonalizationPerUser_ResetPageSettings]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[aspnet_PersonalizationPerUser_ResetPageSettings] (
    @ApplicationName  NVARCHAR(256),
    @UserName         NVARCHAR(256),
    @Path             NVARCHAR(256),
    @CurrentTimeUtc   DATETIME)
AS
SET NOCOUNT ON
BEGIN
    DECLARE @ApplicationId UNIQUEIDENTIFIER
    DECLARE @PathId UNIQUEIDENTIFIER
    DECLARE @UserId UNIQUEIDENTIFIER

    SELECT @ApplicationId = NULL
    SELECT @PathId = NULL
    SELECT @UserId = NULL

    EXEC dbo.aspnet_Personalization_GetApplicationId @ApplicationName, @ApplicationId OUTPUT
    IF (@ApplicationId IS NULL)
    BEGIN
        RETURN
    END

    SELECT @PathId = u.PathId FROM dbo.aspnet_Paths u WHERE u.ApplicationId = @ApplicationId AND u.LoweredPath = LOWER(@Path)
    IF (@PathId IS NULL)
    BEGIN
        RETURN
    END

    SELECT @UserId = u.UserId FROM dbo.aspnet_Users u WHERE u.ApplicationId = @ApplicationId AND u.LoweredUserName = LOWER(@UserName)
    IF (@UserId IS NULL)
    BEGIN
        RETURN
    END

    UPDATE   dbo.aspnet_Users WITH (ROWLOCK)
    SET      LastActivityDate = @CurrentTimeUtc
    WHERE    UserId = @UserId
    IF (@@ROWCOUNT = 0) -- Username not found
        RETURN

    DELETE FROM dbo.aspnet_PersonalizationPerUser WHERE PathId = @PathId AND UserId = @UserId
    RETURN 0
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_UserMatchCodeAccess_GetUserMatchCodeRights]''
');

GO
SET QUOTED_IDENTIFIER ON

GO
EXECUTE ('
CREATE PROCEDURE [dbo].[ib_UserMatchCodeAccess_GetUserMatchCodeRights]
(
	@UserId		uniqueidentifier
)
AS

--	Description: Return MatchCodes and User''s Access Rights
--	02 Oct 2009		AAJM	Creation MBAL-11773

BEGIN

	SET NOCOUNT ON


	SELECT mc.MatchCodeId, mc.MatchCode, ISNULL(ar.Code, ''None'') AS AccessRight
	FROM ib_MatchCode mc
	LEFT JOIN ib_UserMatchCodeAccess umcs ON mc.MatchCodeId = umcs.MatchCodeId AND umcs.UserId = @UserId
LEFT JOIN ib_AccessRight ar ON umcs.AccessRightId = ar.AccessRightId
	

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Adjustment_GetByAdjustmentId]''
');

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Select records from the ib_Adjustment table through an index
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[ib_Adjustment_GetByAdjustmentId]
(

	@AdjustmentId int   
)
AS


				SELECT
					[AdjustmentId],
					[TemplateId],
					[ExchangeId],
					[InstrumentId],
					[InternalExternalCode],
					[TradeDate],
					[AdjustmentDate],
					[Quantity],
					[CurrencyId],
					[ExpiryYear],
					[ExpiryMonth],
					[ExpiryDay],
					[StrikePrice],
					[TradePrice],
					[SettlementPrice],
					[OptionTypeCode],
					[Value],
					[PremiumValue],
					[OptionValue],
					[Description],
					[TemplateGroupId],
					[CreateDate],
					[CreateUsername],
					[UpdateDate],
					[UpdateUsername],
					[IsBuy],
					[MatchCodeId],
					[AdjustmentHeaderId],
					[DataSourceId],
					[FirmId],
					[QuantityLong],
					[QuantityShort],
					[DetailAccountId],
					[AccountId],
					[ClassId],
					[AdjustmentStatusId],
					[AdjustmentReasonId],
					[TrxTypeCode],
					[AdjustmentUserStatusId],
					[MatchingAdjustmentId],
					[ReplacesAdjustmentId]
				FROM
					[dbo].[ib_Adjustment]
				WHERE
					[AdjustmentId] = @AdjustmentId
				SELECT @@ROWCOUNT
					
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_AdjustmentType_GetCodeAndId]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_AdjustmentType_GetCodeAndId]
AS
SET NOCOUNT ON
-- 24 May 2010 ED Created
-- 06 Aug 2014 ED EIB 25844 - sort the result
SELECT Code, Description, AdjustmentTypeId 
	FROM ib_AdjustmentType
	ORDER BY Code ASC
');

GO
EXECUTE ('PRINT N''Creating [dbo].[eib_Load_End]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[eib_Load_End]
(
	@LocationPath	varchar(100),
	@DataSourceCode varchar(100),
	@AsOfDate		datetime,
	@RecordCount	int,
	@ImportFileId	int,
	@StagingFileId	int,
	@LoadedStatus	int,
	@ReceiveLocationSysId int,
	@RunId int
)

AS
--  09 Jan 2014     ED      EIB 25004 - remove importLog table and use Log table
SET NOCOUNT ON

-- Construct loaded ended message
DECLARE @Message VARCHAR(1024)
SET @Message = @DataSourceCode + '' loader ended ('' + CONVERT(VARCHAR(10), @RecordCount) + '' added)'' 
EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @Message, ''Success'', '''', @RunId

-- Get data source ID and default currency ID
DECLARE @DataSourceId INT
DECLARE @DefaultCurrencyId INT
EXEC [_ib_DataSource_GetByCodeForOutput] @DataSourceCode, @DataSourceId OUTPUT, @DefaultCurrencyId OUTPUT	

-- Set import file as of date
UPDATE ib_ImportFile SET AsOfDate = @AsOfDate WHERE ImportFileId = @ImportFileId

-- Update staging file details
UPDATE
	eib_StagingFile
SET
	RecordCount		= @RecordCount,
	AsOfDate		= @AsOfDate,
	DataSourceId	= @DataSourceId,
	LoadDate		= GETDATE()
WHERE
	StagingFileId   = @StagingFileId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[aspnet_Profile_DeleteInactiveProfiles]''
');

GO
SET QUOTED_IDENTIFIER OFF

GO
EXECUTE ('
CREATE PROCEDURE [dbo].[aspnet_Profile_DeleteInactiveProfiles]
    @ApplicationName        nvarchar(256),
    @ProfileAuthOptions     int,
    @InactiveSinceDate      datetime
AS
SET NOCOUNT ON
BEGIN
    DECLARE @ApplicationId uniqueidentifier
    SELECT  @ApplicationId = NULL
    SELECT  @ApplicationId = ApplicationId FROM aspnet_Applications WHERE LOWER(@ApplicationName) = LoweredApplicationName
    IF (@ApplicationId IS NULL)
    BEGIN
        SELECT  0
        RETURN
    END

    DELETE
    FROM    dbo.aspnet_Profile
    WHERE   UserId IN
            (   SELECT  UserId
                FROM    dbo.aspnet_Users u
                WHERE   ApplicationId = @ApplicationId
                        AND (LastActivityDate <= @InactiveSinceDate)
                        AND (
                                (@ProfileAuthOptions = 2)
                             OR (@ProfileAuthOptions = 0 AND IsAnonymous = 1)
                             OR (@ProfileAuthOptions = 1 AND IsAnonymous = 0)
                            )
            )

    SELECT  @@ROWCOUNT
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_UserMatchCodeAccess_GetUserRightsByTemplate]''
');

GO
SET QUOTED_IDENTIFIER ON

GO
EXECUTE ('
CREATE PROCEDURE [dbo].[ib_UserMatchCodeAccess_GetUserRightsByTemplate]
(
	@UserId		uniqueidentifier
	, @TemplateId	int
)
AS

--	Description: Return MatchCodes and User''s Access Rights
--	02 Oct 2009		AAJM	Creation MBAL-11773

BEGIN

	SET NOCOUNT ON


	SELECT mc.MatchCodeId, mc.MatchCode, ISNULL(ar.Code, ''None'') AS AccessRight
	FROM ib_MatchCode mc
	LEFT JOIN ib_UserMatchCodeAccess umcs ON mc.MatchCodeId = umcs.MatchCodeId AND umcs.UserId = @UserId
LEFT JOIN ib_AccessRight ar ON umcs.AccessRightId = ar.AccessRightId
	WHERE mc.TemplateId = @TemplateId
	

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Price_GetSettlementPriceByAlternateKey]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Price_GetSettlementPriceByAlternateKey]
(
	@AsOfDate DATETIME,
    @DataSourceId INT,
    @ExchangeId INT,
    @InstrumentId INT,
    @CurrencyId INT,
    @ExpiryYear SMALLINT,
    @ExpiryMonth SMALLINT,
    @ExpiryDay SMALLINT,
    @StrikePrice DECIMAL(24,10),
    @OptionTypeCode VARCHAR(25),
    @SettlementPrice DECIMAL(25,10) OUTPUT
)
AS
SET NOCOUNT ON
/*
--	
--	Created 25 May 2010 ED
*/
SET @SettlementPrice = NULL
SELECT  @SettlementPrice = [dbo].[GetSettlementPriceByAlternateKey](@AsOfDate, @DataSourceId, @ExchangeId, @InstrumentId, @CurrencyId, 
		@ExpiryYear, @ExpiryMonth, @ExpiryDay, @StrikePrice, @OptionTypeCode)
');

GO
EXECUTE ('PRINT N''Creating [security].[Feature_Get_List]''
');

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Gets all records from the Feature table
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [security].[Feature_Get_List]

AS


				
				SELECT
					[FeatureId],
					[FeatureCode],
					[FeatureName]
				FROM
					[security].[Feature]
					
				SELECT @@ROWCOUNT
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_AdjustmentUserStatus_GetCodeAndId]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_AdjustmentUserStatus_GetCodeAndId]
AS
SET NOCOUNT ON
-- 24 May 2010 ED Created
SELECT Code, Description, AdjustmentUserStatusId 
	FROM ib_AdjustmentUserStatus
');

GO
EXECUTE ('PRINT N''Creating [dbo].[aspnet_Profile_GetNumberOfInactiveProfiles]''
');

GO
SET QUOTED_IDENTIFIER OFF

GO
EXECUTE ('
CREATE PROCEDURE [dbo].[aspnet_Profile_GetNumberOfInactiveProfiles]
    @ApplicationName        nvarchar(256),
    @ProfileAuthOptions     int,
    @InactiveSinceDate      datetime
AS
SET NOCOUNT ON
BEGIN
    DECLARE @ApplicationId uniqueidentifier
    SELECT  @ApplicationId = NULL
    SELECT  @ApplicationId = ApplicationId FROM aspnet_Applications WHERE LOWER(@ApplicationName) = LoweredApplicationName
    IF (@ApplicationId IS NULL)
    BEGIN
        SELECT 0
        RETURN
    END

    SELECT  COUNT(*)
    FROM    dbo.aspnet_Users u, dbo.aspnet_Profile p
    WHERE   ApplicationId = @ApplicationId
        AND u.UserId = p.UserId
        AND (LastActivityDate <= @InactiveSinceDate)
        AND (
                (@ProfileAuthOptions = 2)
                OR (@ProfileAuthOptions = 0 AND IsAnonymous = 1)
                OR (@ProfileAuthOptions = 1 AND IsAnonymous = 0)
            )
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ICE_AsgnRpt_Add]''
');

GO
SET QUOTED_IDENTIFIER ON

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ICE_AsgnRpt_Add]
	@BizDt						NVARCHAR(10)	= NULL
	, @SettlementPrice			DECIMAL(24,10)	= NULL
	, @SettlementCurrency		NVARCHAR(3)		= NULL
	, @InstrumentType			NVARCHAR(100) 	= NULL
	, @PutCall					BIT 			= NULL
	, @InstrExchange			NVARCHAR(25) 	= NULL
	, @CommodityId				VARCHAR(3) 		= NULL
	, @MaturityMonthYear		NVARCHAR(8) 	= NULL
	, @StrikePrice				DECIMAL(19,4)	= NULL	
	, @FactorLotSize			INT				= NULL
	, @PosQtyType				NVARCHAR(3)		= NULL
	, @QtyLong					INT				= NULL
	, @QtyShort					INT				= NULL
	, @QtyDate					NVARCHAR(10)	= NULL	
	, @ClearingHouse			NVARCHAR(4)		= NULL
	, @Exchange					NVARCHAR(4)		= NULL	
	, @TradingMember			NVARCHAR(3) 	= NULL	
	, @Trader					NVARCHAR(3) 	= NULL	
	, @ClearingMember			NVARCHAR(3) 	= NULL
	, @UserAccountInfo			NVARCHAR(14)	= NULL
	, @PositionAccount			NVARCHAR(1)		= NULL
	, @MarginingAccount			INT				= NULL
	, @FileName					NVARCHAR(512)	= NULL		
	
AS
--	13 Jul 2010		AAJM		Creation
--	01 Mar 2012		AAJM		MBAL-20193 Update StrikePrice to Decimal

	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	INSERT INTO ICE_AsgnRpt (
	BizDt					
	, SettlementPrice		
	, SettlementCurrency
	, InstrumentType	
	, PutCall			
	, InstrExchange		
	, CommodityId		
	, MaturityMonthYear	
	, StrikePrice		
	, FactorLotSize
	, PosQtyType	
	, QtyLong		
	, QtyShort	
	, QtyDate
	, ClearingHouse	
	, Exchange			
	, TradingMember			
	, Trader	
	, ClearingMember
	, UserAccountInfo
	, PositionAccount	
	, MarginingAccount			
	, [FileName]	
    )
	VALUES (
	@BizDt				
	, @SettlementPrice		
	, @SettlementCurrency	
	, @InstrumentType		
	, @PutCall			
	, @InstrExchange	
	, @CommodityId		
	, @MaturityMonthYear	
	, @StrikePrice		
	, @FactorLotSize
	, @PosQtyType		
	, @QtyLong		
	, @QtyShort	
	, @QtyDate	
	, @ClearingHouse	
	, @Exchange			
	, @TradingMember		
	, @Trader
	, @ClearingMember	
	, @UserAccountInfo	
	, @PositionAccount	
	, @MarginingAccount	
	, @FileName		
	)
RETURN 0
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_PriceReport_CreateReportRecord]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_PriceReport_CreateReportRecord]
	@TodaysDate DATETIME,
	@TemplateId INT = 0,
	@Username VARCHAR(100)
AS
SET NOCOUNT ON
BEGIN

INSERT INTO [dbo].[ib_PriceReport] (TodaysDate, [TemplateId],[CreateUsername])
VALUES (@TodaysDate, @TemplateId, @Username)

SELECT SCOPE_IDENTITY()

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Assembly_CreateAssembly]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Assembly_CreateAssembly]
	@bin VARBINARY(MAX),
	@shortName NVARCHAR(50),
	@fullName  NVARCHAR(200)
AS
SET NOCOUNT ON

	INSERT INTO ib_Assembly VALUES (@fullName, ''sa'', ''sa'', @bin, @shortName, getdate(), getdate())
');

GO
EXECUTE ('PRINT N''Creating [dbo].[aspnet_Profile_GetProfiles]''
');

GO
SET QUOTED_IDENTIFIER OFF

GO
EXECUTE ('
CREATE PROCEDURE [dbo].[aspnet_Profile_GetProfiles]
    @ApplicationName        nvarchar(256),
    @ProfileAuthOptions     int,
    @PageIndex              int,
    @PageSize               int,
    @UserNameToMatch        nvarchar(256) = NULL,
    @InactiveSinceDate      datetime      = NULL
AS
SET NOCOUNT ON
BEGIN
    DECLARE @ApplicationId uniqueidentifier
    SELECT  @ApplicationId = NULL
    SELECT  @ApplicationId = ApplicationId FROM aspnet_Applications WHERE LOWER(@ApplicationName) = LoweredApplicationName
    IF (@ApplicationId IS NULL)
        RETURN

    -- Set the page bounds
    DECLARE @PageLowerBound int
    DECLARE @PageUpperBound int
    DECLARE @TotalRecords   int
    SET @PageLowerBound = @PageSize * @PageIndex
    SET @PageUpperBound = @PageSize - 1 + @PageLowerBound

    -- Create a temp table TO store the select results
    CREATE TABLE #PageIndexForUsers
    (
        IndexId int IDENTITY (0, 1) NOT NULL,
        UserId uniqueidentifier
    )

    -- Insert into our temp table
    INSERT INTO #PageIndexForUsers (UserId)
        SELECT  u.UserId
        FROM    dbo.aspnet_Users u, dbo.aspnet_Profile p
        WHERE   ApplicationId = @ApplicationId
            AND u.UserId = p.UserId
            AND (@InactiveSinceDate IS NULL OR LastActivityDate <= @InactiveSinceDate)
            AND (     (@ProfileAuthOptions = 2)
                   OR (@ProfileAuthOptions = 0 AND IsAnonymous = 1)
                   OR (@ProfileAuthOptions = 1 AND IsAnonymous = 0)
                 )
            AND (@UserNameToMatch IS NULL OR LoweredUserName LIKE LOWER(@UserNameToMatch))
        ORDER BY UserName

    SELECT  u.UserName, u.IsAnonymous, u.LastActivityDate, p.LastUpdatedDate,
            DATALENGTH(p.PropertyNames) + DATALENGTH(p.PropertyValuesString) + DATALENGTH(p.PropertyValuesBinary)
    FROM    dbo.aspnet_Users u, dbo.aspnet_Profile p, #PageIndexForUsers i
    WHERE   u.UserId = p.UserId AND p.UserId = i.UserId AND i.IndexId >= @PageLowerBound AND i.IndexId <= @PageUpperBound

    SELECT COUNT(*)
    FROM   #PageIndexForUsers

    DROP TABLE #PageIndexForUsers
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ICE_PosRpt_Add]''
');

GO
SET QUOTED_IDENTIFIER ON

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ICE_PosRpt_Add]
	@BizDt						NVARCHAR(10)	= NULL
	, @SettlementPrice			DECIMAL(24,10)	= NULL
	, @SettPriceType			NVARCHAR(1)		= NULL
	, @ContingentPrice			DECIMAL(24,10)	= NULL
	, @SettlementCurrency		NVARCHAR(3)		= NULL
	, @InstrumentType			NVARCHAR(100) 	= NULL
	, @PutCall					BIT 			= NULL
	, @InstrExchange			NVARCHAR(25) 	= NULL
	, @CommodityId				VARCHAR(3) 		= NULL
	, @MaturityMonthYear		NVARCHAR(8) 	= NULL
	, @StrikePrice				DECIMAL(19,4)	= NULL
	, @FactorLotSize			INT				= NULL
	, @PosQtyType				NVARCHAR(3)		= NULL
	, @QtyLong					INT				= NULL
	, @QtyShort					INT				= NULL
	, @VolLongNonMargin			INT				= NULL
	, @VolShortNonMargin		INT				= NULL
	, @TradedLongLots			INT				= NULL
	, @TradedShortLots			INT				= NULL			
	, @QtySettlementLong		INT				= NULL	
	, @QtySettlementShort		INT				= NULL
	, @QtyTransferInLong		INT				= NULL	
	, @QtyTransferInShort		INT				= NULL
	, @QtyTransferOutLong		INT				= NULL	
	, @QtyTransferOutShort		INT				= NULL
	, @QtyDeliveryIssuedLong	INT				= NULL	
	, @QtyDeliveryIssuedShort	INT				= NULL
	, @QtyStoppedLong			INT				= NULL	
	, @QtyStoppedShort			INT				= NULL
	, @QtyOptionExercLong		INT				= NULL
	, @QtyOptionExercShort		INT				= NULL
	, @QtyOptionsAssignLong		INT				= NULL
	, @QtyOptionsAssignShort	INT				= NULL
	, @QtyExpOptionLong			INT				= NULL
	, @QtyExpOptionShort		INT				= NULL
	, @PayCollectAmt			DECIMAL(19,10)	= NULL
	, @PayCollectCcy			NVARCHAR(3)		= NULL
	, @PremPayCollectAmt		DECIMAL(19,10)	= NULL
	, @PremPayCollectCcy		NVARCHAR(3)		= NULL
	, @FCBAAmt					DECIMAL(19,10)	= NULL
	, @FCBACcy					NVARCHAR(3)		= NULL
	, @ContingentMarginAmt		DECIMAL(19,10)	= NULL
	, @ContingentMarginCcy		NVARCHAR(3)		= NULL
	, @TradingMember			NVARCHAR(3) 	= NULL
	, @ClearingFirm				NVARCHAR(3) 	= NULL
	, @ClearingMember			NVARCHAR(3) 	= NULL
	, @ClearingHouse			NVARCHAR(4)		= NULL
	, @Exchange					NVARCHAR(4)		= NULL
	, @PositionAccount			NVARCHAR(1)		= NULL
	, @MarginingAccount			INT				= NULL
	, @FileName					NVARCHAR(512)	= NULL		
	
AS
--	13 Jul 2010		AAJM		Creation
--	01 Mar 2012		AAJM		MBAL-20193 Update StrikePrice to Decimal

	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	INSERT INTO ICE_PosRpt (
	BizDt					
	, SettlementPrice		
	, SettPriceType		
	, ContingentPrice	
	, SettlementCurrency
	, InstrumentType	
	, PutCall			
	, InstrExchange		
	, CommodityId		
	, MaturityMonthYear	
	, StrikePrice	
	, FactorLotSize		
	, PosQtyType	
	, QtyLong		
	, QtyShort		
	, VolLongNonMargin		
	, VolShortNonMargin	
	, TradedLongLots		
	, TradedShortLots		
	, QtySettlementLong	
	, QtySettlementShort	
	, QtyTransferInLong		
	, QtyTransferInShort		
	, QtyTransferOutLong		
	, QtyTransferOutShort		
	, QtyDeliveryIssuedLong	
	, QtyDeliveryIssuedShort
	, QtyStoppedLong		
	, QtyStoppedShort			
	, QtyOptionsAssignLong	
	, QtyOptionsAssignShort
	, QtyExpOptionLong			
	, QtyExpOptionShort		
	, PayCollectAmt		
	, PayCollectCcy		
	, PremPayCollectAmt	
	, PremPayCollectCcy		
	, FCBAAmt			
	, FCBACcy				
	, ContingentMarginAmt	
	, ContingentMarginCcy	
	, TradingMember		
	, ClearingFirm		
	, ClearingMember
	, ClearingHouse		
	, Exchange		
	, PositionAccount	
	, MarginingAccount			
	, [FileName]	
    )
	VALUES (
	@BizDt				
	, @SettlementPrice		
	, @SettPriceType		
	, @ContingentPrice		
	, @SettlementCurrency	
	, @InstrumentType		
	, @PutCall			
	, @InstrExchange	
	, @CommodityId		
	, @MaturityMonthYear	
	, @StrikePrice		
	, @FactorLotSize		
	, @PosQtyType		
	, @QtyLong		
	, @QtyShort		
	, @VolLongNonMargin	
	, @VolShortNonMargin	
	, @TradedLongLots		
	, @TradedShortLots		
	, @QtySettlementLong	
	, @QtySettlementShort	
	, @QtyTransferInLong	
	, @QtyTransferInShort	
	, @QtyTransferOutLong	
	, @QtyTransferOutShort	
	, @QtyDeliveryIssuedLong	
	, @QtyDeliveryIssuedShort	
	, @QtyStoppedLong	
	, @QtyStoppedShort	
	, @QtyOptionsAssignLong	
	, @QtyOptionsAssignShort	
	, @QtyExpOptionLong		
	, @QtyExpOptionShort	
	, @PayCollectAmt	
	, @PayCollectCcy
	, @PremPayCollectAmt	
	, @PremPayCollectCcy
	, @FCBAAmt		
	, @FCBACcy		
	, @ContingentMarginAmt	
	, @ContingentMarginCcy	
	, @TradingMember	
	, @ClearingFirm		
	, @ClearingMember	
	, @ClearingHouse	
	, @Exchange		
	, @PositionAccount	
	, @MarginingAccount	
	, @FileName		
	)
RETURN 0
');

GO
EXECUTE ('PRINT N''Creating [security].[Feature_Insert]''
');

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Inserts a record into the Feature table
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [security].[Feature_Insert]
(

	@FeatureId int    OUTPUT,

	@FeatureCode varchar (20)  ,

	@FeatureName nvarchar (50)  
)
AS


				
				INSERT INTO [security].[Feature]
					(
					[FeatureCode]
					,[FeatureName]
					)
				VALUES
					(
					@FeatureCode
					,@FeatureName
					)
				
				-- Get the identity value
				SET @FeatureId = SCOPE_IDENTITY()
									
							
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_ImbalanceReportSummary_GetDetailsAdjustment]''
');

GO
EXECUTE ('
CREATE PROCEDURE [dbo].[ib_ImbalanceReportSummary_GetDetailsAdjustment]
(
		@ImbalanceReportSummaryId INT
)
AS
SET NOCOUNT ON
/*

	-- Description: Get the Adjustment values for a Summary Record
	-- created 26 May 2010 ED
	-- 30 Jun 2010 ED MBAL 15949 - don''t get manually/automated matched records
*/
SELECT a.AdjustmentDate AsOfDate, a.TradeDate, d.[Name] Datasource, f.[Name] Firm, ISNULL(ac.[Code],'''') Account
	,ISNULL(dac.[Code],'''') DetailAccount
	, a.QuantityLong, a.QuantityShort, a.Value, a.TradePrice
		, at.Code + '' - ''+at.Description TrxType
		, a.InternalExternalCode
FROM [dbo].[ib_ImbalanceReportSummary] irs
	INNER JOIN ib_ImbalanceReport ir ON ir.ImbalanceReportId=irs.ImbalanceReportId
	INNER JOIN ib_Adjustment a ON (a.AdjustmentDate=ir.Today OR a.AdjustmentDate=ir.Yesterday AND a.TemplateId=ir.TemplateId)
		AND a.[ExchangeId]=irs.[ExchangeId]
		AND a.[InstrumentId]=irs.[InstrumentId]
		AND a.[CurrencyId]=irs.[CurrencyId]
		AND a.[ExpiryMonth]=irs.[ExpiryMonth]
		AND a.[ExpiryYear]=irs.[ExpiryYear]
		AND (a.[ExpiryDay]=irs.[ExpiryDay] OR (a.[ExpiryDay] IS NULL AND irs.[ExpiryDay] IS NULL))
		AND ISNULL(a.[OptionTypeCode],'''')=ISNULL(irs.[OptionTypeCode],'''')
		AND ISNULL(a.[StrikePrice],0)=ISNULL(irs.[StrikePrice],0)
	INNER JOIN ib_AdjustmentHeader ah ON a.AdjustmentHeaderId=ah.AdjustmentHeaderId
	INNER JOIN ib_AdjustmentType AT ON at.AdjustmentTypeId=ah.AdjustmentTypeId
	INNER JOIN ib_MatchCode mc ON mc.MatchCodeId=a.MatchCodeId AND irs.Description=mc.MatchCode
	LEFT JOIN ib_Datasource d ON d.DatasourceId=a.DataSourceId
	LEFT JOIN ib_Firm f ON f.FirmId=a.FirmId
	LEFT JOIN ib_Account ac ON ac.AccountId=a.AccountId
	LEFT JOIN ib_Account dac ON dac.AccountId=a.DetailAccountId
	LEFT JOIN ib_AdjustmentStatus [as] ON [as].AdjustmentStatusId=a.AdjustmentStatusId
WHERE ImbalanceReportSummaryId=@ImbalanceReportSummaryId AND ([as].Code NOT IN (''A'',''M'') OR a.AdjustmentStatusId IS NULL)
ORDER BY AsOfDate, Datasource, Firm, Account, QuantityShort, QuantityLong, VALUE, d.DataSourceId, f.FirmId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[PositionsRealisedCash_Load]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[PositionsRealisedCash_Load]
( 
	@AsOfDate			DATE,
	@AccountCd			VARCHAR(100),
	@Product			VARCHAR(5),
	@CurrencyCd			VARCHAR(100), 
	@Contract			VARCHAR(5),
	@PromptDate			DATE,
	@Strike				MONEY,
	@IsCall				BIT,
	@TransactionValue	MONEY,
	@DataSourceCd		VARCHAR(100),
	@ExchangeCd			VARCHAR(25),
	@FirmCd				VARCHAR(100),
	@InstrumentTypeCd	CHAR(1),
	@InstrumentCd		VARCHAR(100),
	@TempTableRecordId	INT,
	@LocationPath		VARCHAR(255),
	@ReceiveLocationSysId   INT,
	@RunId                  INT,
	@PositionsRealisedCashId	INT = NULL	OUTPUT
)
AS
SET NOCOUNT ON

/*
-- Description: load records into PositionsRealisedCash table
-- 01 Jul 2014	ED	EIB 25781 - Creation
-- 12 Sep 2014	ED	EIB 25981 - map to P instead of O for InstrumentType

*/

	DECLARE @ReturnValue INT,@OutPut INT,@OutPut2 INT 
	DECLARE @DataSourceId INT
	DECLARE @DefaultCurrencyId INT
	DECLARE @Code VARCHAR(100)
	SET @Code = @DataSourceCd
	EXEC @ReturnValue= [_ib_DataSource_GetByCodeForOutput] @Code,@OutPut OUTPUT,@OutPut2 OUTPUT	
	SET @DataSourceId = @OutPut
	SET @DefaultCurrencyId = @Output2		

	SET @OutPut = NULL
	DECLARE @ExchangeId INT
	SET @Code = @ExchangeCd
	EXEC @ReturnValue = ib_DataSourceExchange_GetByCode @DataSourceId,@Code,@Output OUTPUT
	SET @ExchangeId = @OutPut

	--if no exchange found then quit here.
	IF @ExchangeId IS NULL 
		BEGIN
		DECLARE @now DATETIME
		DECLARE @user VARCHAR(100)
		DECLARE @logmsg VARCHAR(100)
		SET @user = SUSER_SNAME()
		SET @now = GETDATE()
		SET @logmsg = ''Exchange Code Not Found for PositionsRealisedCash_Load run for code: '' + ISNULL(@ExchangeCd,'''')
		EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @logmsg, ''Warning'', @TempTableRecordId, @RunId
		END
	ELSE
		BEGIN
		SET @Output = NULL
		DECLARE @InstrumentTypeId INT
		SET @Code = @InstrumentTypeCd
		EXEC @ReturnValue = ib_Instrumenttype_AddAsNeeded @DataSourceId,@Code,@OutPut OUTPUT
		SET @InstrumentTypeId = @OutPut
		SET @Output = NULL
		DECLARE @FirmId INT
		SET @Code = @FirmCd
		EXEC @ReturnValue= [ib_Firm_AddAsNeeded] @DataSourceId,@Code,@OutPut OUTPUT	
		SET @FirmId = @OutPut
	
		SET @Output = NULL
		SET	@OutPut2 = NULL
		DECLARE @AccountId INT
		SET @Code = @AccountCd
		DECLARE @IsImported BIT
		SET @IsImported = NULL
		
		EXEC @ReturnValue= [ib_Account_AddAsNeeded] @Code,@FirmId,@OutPut OUTPUT,@OutPut2 OUTPUT, @IsImported = @IsImported OUTPUT	
		SET @AccountId = @OutPut
        			
		IF (@IsImported = 1)
		BEGIN
		
			SET @Output = NULL
			DECLARE @CurrencyId INT

			IF @CurrencyCd IS NOT NULL
			BEGIN
				EXEC @ReturnValue = [ib_Currency_AddAsNeeded] @DataSourceId, @CurrencyCd, @Output OUTPUT
				SET @CurrencyId = @Output
			END
			DECLARE @InstrumentId INT = NULL
			SET @Output = NULL
			SET @Output2 = NULL
			SET @Code = @InstrumentCd
			EXEC @ReturnValue= [ib_Instrument_AddAsNeeded] @DataSourceId,@InstrumentTypeId,@Code,@CurrencyId,@Output OUTPUT,@Output2 OUTPUT	
			SET @InstrumentId = @Output
			IF @CurrencyId IS NULL
			BEGIN
				IF @Output2 IS NULL
					SET @CurrencyId = @DefaultCurrencyId	
				ELSE
					SET @CurrencyId = @Output2
			END

			INSERT INTO PositionsRealisedCash
				(AsOfDate, AccountId, Product, CurrencyId, CONTRACT, PromptDate, Strike, IsCall, TransactionValue, DataSourceId, ExchangeId, FirmId, InstrumentTypeCode, InstrumentCode, InstrumentId, TempTableRecordId)
			VALUES(@AsOfDate, @AccountId, @Product, @CurrencyId, @Contract, @PromptDate, @Strike, @IsCall, @TransactionValue, @DataSourceId, @ExchangeId, @FirmId, @InstrumentTypeCd, @InstrumentCd, @InstrumentId, @TempTableRecordId)
			
			SELECT @PositionsRealisedCashId = SCOPE_IDENTITY()

		END -- End if IsImported
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Assembly_DeleteAssembly]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Assembly_DeleteAssembly]
	@assemblyId int
AS
SET NOCOUNT ON
	DELETE FROM ib_Assembly WHERE AssemblyId = @assemblyId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Account_Delete]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Account_Delete]
@AccountId INT
AS
SET NOCOUNT ON
/*
<details>
	<summary>Deletes an Account</summary>
	<created author="konrad" Date="Fri, 12 june 2009, 1:31AM GMT" />		
</details>
*/
-- 17 May 2010	ED	add try/catch on delete
-- 28 Jul 2014	ED	EIB 25483 - delete also swift statement 

BEGIN TRY
	DELETE FROM ib_SwiftStatementSeed  WHERE AccountId = @AccountId
	DELETE 
	FROM ib_Account 
	WHERE (AccountId = @AccountId) 
END TRY
BEGIN CATCH
	EXEC [dbo].[sp_RethrowError] ''Account is currently in use!''	
END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[aspnet_Profile_GetProperties]''
');

GO
SET QUOTED_IDENTIFIER OFF

GO
EXECUTE ('CREATE PROCEDURE [dbo].[aspnet_Profile_GetProperties]
    @ApplicationName      nvarchar(256),
    @UserName             nvarchar(256),
    @CurrentTimeUtc       datetime
AS
SET NOCOUNT ON
BEGIN
	--	06 Jan 2011		amk		MBAL-17257: save on writes by not updating lastactivitydate

    DECLARE @ApplicationId uniqueidentifier
    SELECT  @ApplicationId = NULL
    SELECT  @ApplicationId = ApplicationId FROM dbo.aspnet_Applications WHERE LOWER(@ApplicationName) = LoweredApplicationName
    IF (@ApplicationId IS NULL)
        RETURN

    DECLARE @UserId uniqueidentifier
    SELECT  @UserId = NULL

    SELECT @UserId = UserId
    FROM   dbo.aspnet_Users
    WHERE  ApplicationId = @ApplicationId AND LoweredUserName = LOWER(@UserName)

    IF (@UserId IS NULL)
        RETURN
    SELECT TOP 1 PropertyNames, PropertyValuesString, PropertyValuesBinary
    FROM         dbo.aspnet_Profile WITH (NOLOCK)
    WHERE        UserId = @UserId

	/*
	do not update lastactivitydate to save on writes
	
    IF (@@ROWCOUNT > 0)
    BEGIN
    
        UPDATE dbo.aspnet_Users
        SET    LastActivityDate=@CurrentTimeUtc
        WHERE  UserId = @UserId
    END
    */
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ICE_TrdCaptRpt_Add]''
');

GO
SET QUOTED_IDENTIFIER ON

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ICE_TrdCaptRpt_Add]
	@AsOfInd					NVARCHAR(1)		= NULL
	, @AvgPx					NVARCHAR (9)	= NULL
	, @AvgPxInd					NVARCHAR(1) 	= NULL
	, @BizDt					NVARCHAR(10)	= NULL
	, @Currency					NVARCHAR(3)     = NULL
	, @CopyMsgInd				NVARCHAR(1)		= NULL
	, @LastPx					DECIMAL(24,10)	= NULL
	, @LastQty					INT				= NULL
	, @MtchStat					NVARCHAR(1) 	= NULL
	, @ExecType					NVARCHAR(1) 	= NULL
	, @TradeDate				NVARCHAR(11) 	= NULL
	, @TradeId					BIGINT 			= NULL
	, @TradeReportType			INT				= NULL
	, @VenueType				NVARCHAR(1)		= NULL
	, @TradeSubType				TINYINT 		= NULL
	, @TradeType				TINYINT 		= NULL
	, @TrdTyp2					TINYINT 		= NULL
	, @TrxTime					NVARCHAR(24) 	= NULL
	, @ExecId					NVARCHAR(16)	= NULL
	, @TransferReason			NVARCHAR(4)		= NULL
	, @OrigTradeId				INT 			= NULL
	, @InstrExchange			NVARCHAR(25) 	= NULL
	, @InstrumentType			NVARCHAR(100) 	= NULL
	, @CommodityId				VARCHAR(3) 		= NULL
	, @MaturityMonthYear		NVARCHAR(8) 	= NULL
	, @PutCall					BIT 			= NULL
	, @StrikePrice				DECIMAL(19,4)	= NULL
	, @SideBuySellFlag			TINYINT			= NULL
	, @ClearingHouse			NVARCHAR(4)		= NULL
	, @Exchange					NVARCHAR(4)		= NULL
	, @TradingMember			NVARCHAR(3) 	= NULL
	, @Trader					NVARCHAR(3)		= NULL
	, @ClearingMember			NVARCHAR(3)		= NULL
	, @OppTradingMember			NVARCHAR(3)		= NULL
	, @OppTrader				NVARCHAR(3) 	= NULL
	, @CustomerAccount			NVARCHAR(14) 	= NULL
	, @PositionAccount			NVARCHAR(1) 	= NULL
	, @SettlementAccount		INT				= NULL
	, @AllocationQty			INT				= NULL
	, @AllocationExchange		NVARCHAR(4)		= NULL
	, @AllocationClearingHouse	NVARCHAR(4)		= NULL
	, @AllocTradingMember		NVARCHAR(3)		= NULL
	, @AllocationTrader			NVARCHAR(3)		= NULL 
	, @FileName					NVARCHAR(512)	= NULL


AS
--	08 Jul 2010		AAJM		Creation
--  22 Jul 2010		AAJM		MBAL-16261 Adjust data type of TradeId
--  01 Mar 2012		AAJM		MBAL-20193 Adjust data type of StrikePrice
--	29 Oct 2014		ED			EIB 26160 - Use Currency
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	INSERT INTO ICE_TrdCaptRpt (
	[AsOfInd]
	, [AvgPx]
	, [AvgPxInd]
	, [BizDt]
	, [Currency]
	, [CopyMsgInd]
	, [LastPx]
	, [LastQty]
	, [MtchStat]
	, [ExecType]
	, [TradeDate]
	, [TradeId]
	, [TradeReportType]
	, [VenueType]
	, [TradeSubType]
	, [TradeType]
	, [TrdTyp2]
	, [TrxTime]
	, [ExecId]
	, [TransferReason]
	, [OrigTradeId]
	, [InstrExchange]
	, [InstrumentType]
	, [CommodityId]
	, [MaturityMonthYear]
	, [PutCall]
	, [StrikePrice]
	, [SideBuySellFlag]
	, [ClearingHouse]
	, [Exchange]
	, [TradingMember]
	, [Trader]
	, [ClearingMember]
	, [OppTradingMember]
	, [OppTrader]
	, [CustomerAccount]
	, [PositionAccount]
	, [SettlementAccount]
	, [AllocationQty]
	, [AllocationExchange]
	, [AllocationClearingHouse]
	, [AllocTradingMember]
	, [AllocationTrader]
	, [FileName]
	)
	VALUES (
	@AsOfInd
	, @AvgPx
	, @AvgPxInd
	, @BizDt 
	, @Currency
	, @CopyMsgInd
	, @LastPx
	, @LastQty
	, @MtchStat
	, @ExecType
	, @TradeDate
	, @TradeId
	, @TradeReportType
	, @VenueType
	, @TradeSubType
	, @TradeType
	, @TrdTyp2
	, @TrxTime
	, @ExecId
	, @TransferReason
	, @OrigTradeId
	, @InstrExchange
	, @InstrumentType
	, @CommodityId
	, @MaturityMonthYear
	, @PutCall
	, @StrikePrice
	, @SideBuySellFlag
	, @ClearingHouse
	, @Exchange
	, @TradingMember
	, @Trader
	, @ClearingMember
	, @OppTradingMember
	, @OppTrader
	, @CustomerAccount
	, @PositionAccount
	, @SettlementAccount
	, @AllocationQty
	, @AllocationExchange
	, @AllocationClearingHouse
	, @AllocTradingMember
	, @AllocationTrader
	, @FileName
	)
RETURN 0
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_PriceReportSummary_GetPriceReportData]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_PriceReportSummary_GetPriceReportData]
@PriceReportId INT,
@FilterBreaks SMALLINT,
@FilterExchangeId INT = NULL
AS
SET NOCOUNT ON
BEGIN

--@FilterBreaks, Possible Values : 0=All, 1=Breaks Only, 2 = Missing  values
-- 07 Jul 2010 ED MBAL 16005 - add new filter: Missing Values
IF @FilterBreaks = 0
BEGIN
	SELECT * 
	FROM ib_PriceReportSummary ps
	WHERE PriceReportId = @PriceReportId
	  AND ExchangeId = COALESCE(@FilterExchangeId, ExchangeId)
	ORDER BY ps.ExchangeCode, ps.CurrencyCode, ps.InstrumentCode, ps.ExpiryYear, ps.ExpiryMonth, ps.ExpiryDay, ps.PutCall, ps.StrikePrice
END

IF @FilterBreaks = 1
BEGIN
	SELECT * 
	FROM ib_PriceReportSummary ps
	WHERE PriceReportId = @PriceReportId
	  AND ExchangeId = COALESCE(@FilterExchangeId, ExchangeId)
	  AND Variation <> 0 AND Internal_PriceId IS NOT NULL AND External_PriceId IS NOT NULL
	ORDER BY ps.ExchangeCode, ps.CurrencyCode, ps.InstrumentCode, ps.ExpiryYear, ps.ExpiryMonth, ps.ExpiryDay, ps.PutCall, ps.StrikePrice
END

IF @FilterBreaks = 2
BEGIN
	SELECT * 
	FROM ib_PriceReportSummary ps
	WHERE PriceReportId = @PriceReportId
	  AND ExchangeId = COALESCE(@FilterExchangeId, ExchangeId)
	  AND (Internal_PriceId IS NULL OR External_PriceId IS NULL)
	ORDER BY ps.ExchangeCode, ps.CurrencyCode, ps.InstrumentCode, ps.ExpiryYear, ps.ExpiryMonth, ps.ExpiryDay, ps.PutCall, ps.StrikePrice
END

END
');

GO
EXECUTE ('PRINT N''Creating [security].[Feature_Update]''
');

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Updates a record in the Feature table
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [security].[Feature_Update]
(

	@FeatureId int   ,

	@FeatureCode varchar (20)  ,

	@FeatureName nvarchar (50)  
)
AS


				
				
				-- Modify the updatable columns
				UPDATE
					[security].[Feature]
				SET
					[FeatureCode] = @FeatureCode
					,[FeatureName] = @FeatureName
				WHERE
[FeatureId] = @FeatureId 
				
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_ImbalanceReportSummary_GetDetailsHeader]''
');

GO
EXECUTE ('CREATE Procedure [dbo].[ib_ImbalanceReportSummary_GetDetailsHeader]
(
	@ImbalanceReportSummaryId INT
)
AS
SET NOCOUNT ON

-- ED		28 Apr 2009		Creation
-- KevinP	26 Feb 2010		Added ability to return the Long/Short totals for External/Internal
-- KevinP	04 Mar 2010		Modified SELECT statement to default for NULL Strike Price and OptionTypeCode to avoid duplicates in the header.
-- KevinP	11 Mar 2010		Modified Select to make sure it counts the Internal and External Longs and Shorts, i.s.o their Nett values. MBAL-14924
-- KevinP	18 Mar 2010		Re-applied SP to Test Env, and modified the query performance
-- AAJM		06 Apr 2010		MBAL-15150 Return InstrumentId
-- amk		21 Sep 2010		MBAL-16672: Allow for no positions or trxs (so left join not inner)

SELECT TemplateDescription
	, [ExpiryYear],[ExpiryMonth], [ExpiryDay], [OptionTypeCode]
	, [CurrencyId], [StrikePrice],[Description], [Exchange], [Currency], [Instrument], Today, Yesterday
	, SUM(InternalLongQuantity) AS InternalLongQuantity
	, SUM(InternalShortQuantity) AS InternalShortQuantity
	, SUM(ExternalLongQuantity) AS ExternalLongQuantity
	, SUM(ExternalShortQuantity)AS ExternalShortQuantity
	, [InstrumentId]
FROM
(
	SELECT t.Description TemplateDescription
		, ird.[ExpiryYear],ird.[ExpiryMonth], ird.[ExpiryDay], ISNULL(ird.[OptionTypeCode],'''') AS [OptionTypeCode]
		, ird.[CurrencyId], ISNULL(ird.[StrikePrice],0) AS [StrikePrice], irs.[Description], [Exchange], [Currency], [Instrument], Today, Yesterday
		, CASE WHEN p.AsOfDate = ir.Today AND InternalExternalCode = ''I'' THEN LongQuantity ELSE 0 END AS InternalLongQuantity
		, CASE WHEN p.AsOfDate = ir.Today AND InternalExternalCode = ''I'' THEN ShortQuantity ELSE 0 END AS InternalShortQuantity
		, CASE WHEN p.AsOfDate = ir.Today AND InternalExternalCode = ''E'' THEN LongQuantity ELSE 0 END AS ExternalLongQuantity
		, CASE WHEN p.AsOfDate = ir.Today AND InternalExternalCode = ''E'' THEN ShortQuantity ELSE 0 END AS ExternalShortQuantity
		, [ird].[InstrumentId]
	FROM [dbo].[ib_ImbalanceReportSummary] irs
		INNER JOIN ib_ImbalanceReport ir ON ir.ImbalanceReportId = irs.ImbalanceReportId
		INNER JOIN ib_ImbalanceReportDetail ird ON ird.ImbalanceReportId = ir.ImbalanceReportId
			AND ird.[ExchangeId] = irs.[ExchangeId]
			AND ird.[InstrumentId] = irs.[InstrumentId]
			AND ird.[CurrencyId] = irs.[CurrencyId]
			AND ird.[ExpiryMonth] = irs.[ExpiryMonth]
			AND ird.[ExpiryYear] = irs.[ExpiryYear]
			AND (ird.[ExpiryDay] = irs.[ExpiryDay] OR (ird.[ExpiryDay] IS NULL AND irs.[ExpiryDay] IS NULL))
			AND ISNULL(ird.[OptionTypeCode],'''') = ISNULL(irs.[OptionTypeCode],'''')
			AND ISNULL(ird.[StrikePrice],0) = ISNULL(irs.[StrikePrice],0)
		INNER JOIN ib_ImbalanceReportPhase2Trace IRP2T ON irs.Description = irp2t.Description 
			AND ird.ImbalanceReportDetailId = irp2t.ImbalanceReportDetailId
		LEFT OUTER JOIN ib_Position p ON p.ExchangeId = ird.ExchangeId
			AND p.FirmId = ird.FirmId
			AND (p.AccountId = ird.AccountId OR (p.AccountId IS NULL AND ird.AccountId IS NULL))
			AND p.InstrumentId = ird.InstrumentId
			AND (p.ClassId = ird.ClassId OR (p.ClassId IS NULL AND ird.ClassId IS NULL))
			AND p.ExpiryYear = ird.ExpiryYear
			AND p.ExpiryMonth = ird.ExpiryMonth	
			AND (p.ExpiryDay = ird.ExpiryDay OR (p.ExpiryDay IS NULL AND ird.ExpiryDay IS NULL))
			AND ISNULL(p.OptionTypeCode, '''') = ISNULL(ird.OptionTypeCode, '''')
			AND p.CurrencyId = ird.CurrencyId
			AND ISNULL(p.StrikePrice,0) = ISNULL(ird.StrikePrice,0)
			AND (p.AsOfDate = ir.Today OR p.AsOfDate = ir.Yesterday)
		INNER JOIN ib_Template t ON t.TemplateId = ir.TemplateId
		INNER JOIN ib_TemplateCompare tc ON tc.TemplateId = t.TemplateId 
			AND tc.DataSourceId = ird.DataSourceId AND tc.FirmId = ird.FirmId
		INNER JOIN ib_Datasource d ON d.DatasourceId = ird.DataSourceId
		INNER JOIN ib_Firm f ON f.FirmId = ird.FirmId
		LEFT JOIN ib_Account a ON a.AccountId = ird.AccountId
		LEFT JOIN ib_Class c ON c.ClassId = ird.ClassId
	WHERE ImbalanceReportSummaryId = @ImbalanceReportSummaryId
) d
GROUP BY TemplateDescription
	, [ExpiryYear],[ExpiryMonth], [ExpiryDay], [OptionTypeCode]
	, [CurrencyId], [StrikePrice],[Description], [Exchange], [Currency], [Instrument], [InstrumentId]
	, Today, Yesterday
');

GO
EXECUTE ('PRINT N''Creating [dbo].[GetLastDayOfTheMonth]''
');

GO
EXECUTE ('CREATE FUNCTION [dbo].[GetLastDayOfTheMonth]
(
	@Date DATETIME
)
RETURNS DATETIME
AS
BEGIN
-- Description: return last business day of the month
-- 19 Feb 2016  ED  EIB 38467 - created
	DECLARE @NewDate DATETIME
	-- first day of next month
	SET  @NewDate = DATEADD(mm, DATEDIFF(m, 0, @Date) + 1, 0)
	SET @NewDate = DATEADD(dd, -1, @NewDate)
	RETURN @NewDate
END
');

GO
EXECUTE ('PRINT N''Creating [stage].[BmfPosition_Load]''
');

GO
EXECUTE ('CREATE PROCEDURE [stage].[BmfPosition_Load]
(
	@LocationPath VARCHAR(100)
	,@ReceiveLocationSysId INT
	,@RunId INT
)
AS
SET NOCOUNT ON

-- Description:	This stored procedure pulls data from the stage.BmfPosition temp
-- table and inserts it into ib_Pos
-- Whilst iterating through the records in stage.BmfPosition, all 
-- of these inserts are wrapped in a transaction so that any failure causes
-- the changes to not commit.
--
-- 25 Mar 2016	ED	EIB 38652 - Creation

BEGIN

	DECLARE @Message			VARCHAR(1024)
	DECLARE @AddCount			INT
	SET @AddCount = 0
					
	DECLARE @DataSourceCode VARCHAR(100), @ExchangeCode VARCHAR(100), @FirmCode VARCHAR(100)
	DECLARE @DataSourceId INT
	DECLARE @Code VARCHAR(100)
	DECLARE @Code2 VARCHAR(100)
	DECLARE @ReturnValue INT
	DECLARE @Output INT
	DECLARE @Output2 INT
	DECLARE @DefaultCurrencyId INT
			
	-- Get Datasource
	SET @DataSourceCode = ''BMF''
	SET @ExchangeCode = ''BMF''
	SET @FirmCode = ''BMF''
	
	SET @Code = @DataSourceCode
	EXEC @ReturnValue= [_ib_DataSource_GetByCodeForOutput] @Code,@OutPut output,@Output2 output	
	SET @DataSourceId = @Output
	SET @DefaultCurrencyId = @Output2	

	-- Duplicate file check										
	DECLARE @IsFileAlreadyLoaded INT
	EXEC @IsFileALreadyLoaded = HasFileBeenLoaded @LocationPath, @DataSourceId

	IF @IsFileAlreadyLoaded = 1
	BEGIN
		UPDATE stage.BmfPosition
		SET LoadState = 3
		WHERE LoadState = 1
			AND FileName = @LocationPath		
		RETURN
	END
	
	-- Set AsOfDate from Filename
	DECLARE @AsOfDate DATETIME
	
	DECLARE @DateChr VARCHAR(8)
	SET @DateChr = RIGHT(@LocationPath, CHARINDEX(''\'',REVERSE(@LocationPath))-17)
		
	SET @AsOfDate = CONVERT(DATETIME, @DateChr, 112)		
	
	DECLARE @IsAcceptable bit
	EXECUTE [dbo].[Load_IsFileTooOld] @DataSourceId, @LocationPath, @AsOfDate, @IsAcceptable OUTPUT, @ReceiveLocationSysId, @RunId
	IF (@IsAcceptable = 0)
	BEGIN
			
		UPDATE stage.BmfPosition SET LoadState = 3 WHERE LoadState = 1 AND FileName = @LocationPath	
		RAISERROR (''File is too old.'', 18, 0)
		RETURN
	END									

	-- Store ImportFile record for use
	DECLARE @ImportFileId INT
	EXEC ib_ImportFile_Add @DataSourceId, @LocationPath, @ImportFileId output
	
	--Gets the defaultStrikePriceDivisor
	DECLARE	@DefaultStrikePriceDivisor	DECIMAL(19,6)
	SET @DefaultStrikePriceDivisor = [dbo].[udf_GetDefaultStrikePriceDivisor](@DataSourceId, NULL)


	SET XACT_ABORT ON 

	BEGIN TRAN T1

		-- BizTalk''s SQL Adapter uses more restrictive read serializable
		-- so this is necessary to relax it to something that is default
		-- and perfectly acceptable!
		SET TRANSACTION ISOLATION LEVEL READ COMMITTED

		BEGIN TRY
			DECLARE @BmfPositionId INT
			DECLARE @CustomerCode VARCHAR(100)
			DECLARE @CurrentPosition INT
			DECLARE @BuySell VARCHAR(1)
			DECLARE @Contract VARCHAR(100)
			DECLARE @Market VARCHAR(100)
			DECLARE @ContractMonth VARCHAR(100)
			DECLARE @SettlementPrice DECIMAL (24, 10)
			DECLARE @MaturityDate DATE
			DECLARE @MarketValue DECIMAL (24, 10)
			DECLARE @StrikePriceDec DECIMAL (24, 10)

			DECLARE pos_cursor CURSOR FOR
			SELECT [BmfPositionId]
				    ,CustomerCode
					,OpenPosition
					,BuySell
					,Contract
					,Market
					,ContractMonth
					,CurrentSettlementPrice
					,MaturityDate
					,Settlement
					,StrikePrice
			FROM stage.BmfPosition 
			WHERE LoadState = 1 AND Filename = @LocationPath
				AND BuySell != '''' AND OpenPosition != 0


			OPEN pos_cursor

			FETCH NEXT FROM pos_cursor
			INTO 
				 @BmfPositionId
				,@CustomerCode
				,@CurrentPosition
				,@BuySell
				,@Contract
				,@Market
				,@ContractMonth
				,@SettlementPrice
				,@MaturityDate
				,@MarketValue
				,@StrikePriceDec
				-- Check @@FETCH_STATUS to see IF there are any more rows to fetch.
				WHILE @@FETCH_STATUS = 0
				BEGIN
					DECLARE		@InstrumentCd			VARCHAR(100)
					DECLARE		@InstrumentTypeCd		VARCHAR(100)
					DECLARE		@ExpYr					SMALLINT
					DECLARE		@ExpMth					SMALLINT
					DECLARE		@ExpDay					SMALLINT
					DECLARE		@MarketValueDec			DECIMAL(19,4)
					DECLARE		@MarketValueDivisor		DECIMAL(19,4)
					DECLARE		@StrikePriceDivisor		DECIMAL(19,4)
					DECLARE		@StrikePrice		    DECIMAL(19,4)
					DECLARE     @PutCall VARCHAR(1) 
					DECLARE		@Currency VARCHAR(3) 
					DECLARE     @NetLots INT
					DECLARE     @BoughtLots INT
					DECLARE     @SoldLots INT
			
					SET @Currency = ''USD''

					IF @BuySell = ''C'' -- C - buy, V - sell
					BEGIN
						SET @BoughtLots = @CurrentPosition
						SET @SoldLots = 0
					END
					ELSE
					BEGIN
						SET @BoughtLots = 0
						SET @SoldLots = @CurrentPosition
					END
					SET @NetLots = @BoughtLots - @SoldLots
					
					SET @MarketValueDec = NULL		
					SET @InstrumentTypeCd = NULL	
			
					-- Set InstrumentTypeCd
					IF @Market IN (''FUT'')
					BEGIN
						SET @InstrumentTypeCd = ''F''
						SET @PutCall = NULL
					END						
					ELSE
					BEGIN
						SET @InstrumentTypeCd = ''O''
						IF LEFT(RIGHT(@ContractMonth, 2),1) IN (''M'', ''N'', ''P'', ''Q'')
							SET @PutCall = ''P''
							ELSE
							SET @PutCall = ''C''
					END

					-- We prefix the Instruments with the IntrumentTypeCode
					SET @InstrumentCd = @InstrumentTypeCd + ''_'' + @ExchangeCode + ''_'' + @Contract			
					
					SET @ExpDay = NULL
					SET @ExpMth = NULL
					SET @ExpYr = NULL
					IF (@InstrumentTypeCd = ''O'')
						SET @MaturityDate = DATEADD(MONTH, 1, @MaturityDate)
					SET @MaturityDate = dbo.GetLastDayOfTheMonth(@MaturityDate)	
					-- Set ExpiryDate
					SET @ExpYr = YEAR(@MaturityDate)
					SET @ExpMth = MONTH(@MaturityDate)
					SET @ExpDay = DAY(@MaturityDate)

					DECLARE @PositionId INT		
					SET @PositionId = NULL
					SET @MarketValueDivisor = NULL
					SET @StrikePriceDivisor = NULL

					SELECT @MarketValueDivisor = MarketValueDivisor, @StrikePriceDivisor = StrikePriceDivisor
						FROM [dbo].[ib_InstrumentDataSource] WHERE DataSourceId = @DataSourceId AND DataSourceInstrumentCode = @InstrumentCd 
					
					SET @MarketValueDec = NULL
					--IF (@InstrumentTypeCd = ''F'')
					--	SET @MarketValueDec = @MarketValue / ISNULL(@MarketValueDivisor, 1)
			
					SET @StrikePrice = NULL
					IF (@InstrumentTypeCd = ''O'')
						SET @StrikePrice = @StrikePriceDec / ISNULL(@StrikePriceDivisor, ISNULL(@DefaultStrikePriceDivisor, 1))
			
					

			
					EXEC [ib_Position_Load]
					@DataSourceCode			
					, @ExchangeCode
					, @FirmCode -- Firm will be added if not present					
					, @CustomerCode -- account code
					, @AsOfDate				
					, @InstrumentCd			
					, @NetLots			
					, @MarketValueDec			
					, @ExpYr					
					, @ExpMth					
					, @ExpDay	
					, @StrikePrice			
					, ''POSITION'' -- trxTypeCode				
					, @PutCall -- @OptionTypeCode
					, NULL -- @TrxDate 			
					, NULL --@SettlementPrice -- This value is NOT actually used in the ib_Position_Load Stored Procedure, should be removed ?			
					, @BmfPositionId
					, @InstrumentTypeCd		
					, @LocationPath
					, @Currency
					, @LongQuantity = @BoughtLots
					, @ShortQuantity = @SoldLots
					, @TradedLongQuantity = NULL
					, @TradedShortQuantity = NULL
					, @ClassId = NULL
					, @UseNetForCloseOut = 0
					, @PositionId = @PositionId output
					, @ReceiveLocationSysId = @ReceiveLocationSysId
					, @RunId = @RunId
			
					--flip processed flag in source table.
					UPDATE stage.BmfPosition WITH (ROWLOCK) SET [LoadState] = 2 WHERE BmfPositionId = @BmfPositionId AND [LoadState] = 1
					IF (@PositionId IS NOT NULL AND @PositionId > 0)
						BEGIN
							SET @AddCount = @AddCount + 1
							EXEC ib_Price_AddFromPositionLoad @PositionId, @ImportFileId, @SettlementPrice 	
						END
			
					FETCH NEXT FROM pos_cursor
					INTO 
						 @BmfPositionId
						,@CustomerCode
						,@CurrentPosition
						,@BuySell
						,@Contract
						,@Market
						,@ContractMonth
						,@SettlementPrice
						,@MaturityDate
						,@MarketValue
						,@StrikePriceDec
				END
			
		CLOSE pos_cursor
		DEALLOCATE pos_cursor

			-- Now update state of any left-over temporary transaction records
			-- so there are no ''left-overs''
			UPDATE stage.BmfPosition WITH (ROWLOCK) SET [LoadState] = 2 WHERE [LoadState] = 1 AND [FileName] = @LocationPath

			SET @Message = @DataSourceCode + '' position loader ended ('' + CONVERT(VARCHAR(10), @AddCount) + '' added).'' 
		
			EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @Message, ''Success'', '''', @RunId

			UPDATE ib_ImportFile SET AsOfDate = @AsOfDate WHERE ImportFileId = @ImportFileId
			
		COMMIT TRAN T1
	
	END TRY
	BEGIN CATCH 

		IF XACT_STATE() = -1 
			ROLLBACK TRANSACTION
	
		SET @Message = @DataSourceCode + '' position loader failed.'' 		
		EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @Message, ''Error'', '''', @RunId
	
		EXEC [dbo].[sp_RethrowError]
		
	END CATCH 

	SET XACT_ABORT OFF

END

RETURN 0
');

GO
EXECUTE ('PRINT N''Creating [dbo].[aspnet_RegisterSchemaVersion]''
');

GO
SET QUOTED_IDENTIFIER OFF

GO
EXECUTE ('
CREATE PROCEDURE [dbo].[aspnet_RegisterSchemaVersion]
    @Feature                   nvarchar(128),
    @CompatibleSchemaVersion   nvarchar(128),
    @IsCurrentVersion          bit,
    @RemoveIncompatibleSchema  bit
AS
SET NOCOUNT ON
BEGIN
    IF( @RemoveIncompatibleSchema = 1 )
    BEGIN
        DELETE FROM dbo.aspnet_SchemaVersions WHERE Feature = LOWER( @Feature )
    END
    ELSE
    BEGIN
        IF( @IsCurrentVersion = 1 )
        BEGIN
            UPDATE dbo.aspnet_SchemaVersions
            SET IsCurrentVersion = 0
            WHERE Feature = LOWER( @Feature )
        END
    END

    INSERT  dbo.aspnet_SchemaVersions( Feature, CompatibleSchemaVersion, IsCurrentVersion )
    VALUES( LOWER( @Feature ), @CompatibleSchemaVersion, @IsCurrentVersion )
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[IDEM_DS13_Add]''
');

GO
SET QUOTED_IDENTIFIER ON

GO
EXECUTE ('




-- =============================================
-- Author:		Lee Manifold
-- Create date: 15 Sep 2006
-- Description:	Insert into IDEM_DS13 table
-- =============================================
CREATE PROCEDURE [dbo].[IDEM_DS13_Add]
	(
	@MemberClearCode			varchar(4),
	@DataFileCode				varchar(4),
	@RecordNumber				varchar(6),
	@Date						varchar(8),
	@ABIMemberCode				varchar(5),
	@MarketCode					varchar(2),
	@Account					varchar(1),
	@PositionType				varchar(1),
	@Symbol						varchar(6),
	@InstrumentType				varchar(1),
	@Expiry						varchar(8),
	@OptionType					varchar(1),
	@RepoType					varchar(1),
	@StrikePrice				varchar(13),
	@IsinCode					varchar(12),
	@Description				varchar(20),
	@LongPosition				varchar(10),
	@ShortPosition				varchar(10),
	@LongPositionCounterValue	varchar(17),
	@ShortPositionCounterValue	varchar(17),
	@LongAccruedCoupen			varchar(17),
	@ShortAccruedCoupen			varchar(17),
	@CurrencyCode				varchar(2),
	@UnderlyingPrice			varchar(13),
	@GCMABICode					varchar(5),
	@DeliveryAccount			varchar(5),
	@PositionAlreadyDelivered	varchar(50),
	@ValoreSottostante			varchar(13),
	@FailExecution				varchar(1),
	@BondShareCash				varchar(1),
	@BonisMalis					varchar(1),
	@Multiplier					varchar(6),
	@SubAccount					varchar(4),
	@SettlementPrice			varchar(13),
	@DeliveryABICode			varchar(5)
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	INSERT INTO [dbo].[IDEM_DS13]
           (
			[MemberClearCode]
           ,[DataFileCode]
           ,[RecordNumber]
           ,[Date]
           ,[ABIMemberCode]
           ,[MarketCode]
           ,[Account]
           ,[PositionType]
           ,[Symbol]
           ,[InstrumentType]
           ,[Expiry]
           ,[OptionType]
           ,[RepoType]
           ,[StrikePrice]
           ,[IsinCode]
           ,[Description]
           ,[LongPosition]
           ,[ShortPosition]
           ,[LongPositionCounterValue]
           ,[ShortPositionCounterValue]
           ,[LongAccruedCoupen]
           ,[ShortAccruedCoupen]
           ,[CurrencyCode]
           ,[UnderlyingPrice]
           ,[GCMABICode]
           ,[DeliveryAccount]
           ,[PositionAlreadyDelivered]
           ,[ValoreSottostante]
           ,[FailExecution]
           ,[BondShareCash]
           ,[BonisMalis]
           ,[Multiplier]
           ,[SubAccount]
           ,[SettlementPrice]
		   ,[DeliveryABICode]
			)
     VALUES
           (
			@MemberClearCode,
			@DataFileCode,
			@RecordNumber,
			@Date,
			@ABIMemberCode,
			@MarketCode,
			@Account,
			@PositionType,
			@Symbol,
			@InstrumentType,
			@Expiry,
			@OptionType,
			@RepoType,
			@StrikePrice,
			@IsinCode,
			@Description,
			@LongPosition,
			@ShortPosition,
			@LongPositionCounterValue,
			@ShortPositionCounterValue,
			@LongAccruedCoupen,
			@ShortAccruedCoupen,
			@CurrencyCode,
			@UnderlyingPrice,
			@GCMABICode,
			@DeliveryAccount,
			@PositionAlreadyDelivered,
			@ValoreSottostante,
			@FailExecution,
			@BondShareCash,
			@BonisMalis,
			@Multiplier,
			@SubAccount,
			@SettlementPrice,
		    @DeliveryABICode	
			)
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_PriceReportSummary_ValidatePriceAdjustments]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_PriceReportSummary_ValidatePriceAdjustments]
(
	@PriceReportSummaryId INT
	,@IsExternal BIT
)
AS
SET NOCOUNT ON
/*
<details>
	<summary> Validates that selected record may be adjusted</summary>
	<created author="ED" Date="06 May 2010" />
</details>
*/
BEGIN
--first, internal/external price id not nulls
IF NOT EXISTS(SELECT PriceReportId FROM ib_PriceReportSummary
			WHERE PriceReportSummaryId=@PriceReportSummaryId 
			AND Internal_PriceId IS NOT NULL AND External_PriceId IS NOT NULL
		)
		BEGIN
			SELECT 1
			RETURN 
		END
--second, check if exists a imbalance report
DECLARE @ImbalanceReportId INT
DECLARE @TemplateId INT
DECLARE @AsOfDate DATETIME

SELECT  @TemplateId=TemplateId, @AsOfDate = TodaysDate FROM ib_priceReport pr
	INNER JOIN ib_PriceReportSummary prs ON prs.PriceReportId=pr.PriceReportId
	WHERE prs.PriceReportSummaryId=@PriceReportSummaryId 
CREATE TABLE #iid(id INT)
INSERT INTO #iid(id)
	EXEC @ImbalanceReportId=[dbo].[ib_ImbalanceReport_GetLatestImbalanceReportIdByTemplateIdAndDate] @TemplateId, @AsOfDate

SELECT  @ImbalanceReportId=id FROM #iid
DROP TABLE #iid
IF @ImbalanceReportId IS NULL 
BEGIN 
	SELECT 2
	RETURN 
END

IF EXISTS(SELECT Lots FROM ib_ImbalanceReportSummary irs	
			INNER JOIN ib_PriceReportSummary prs
			ON 
				[prs].[ExchangeId] = [irs].[ExchangeId]
				AND [prs].[InstrumentId] = [irs].[InstrumentId]
				AND [prs].[ExpiryYear] = [irs].[ExpiryYear]
				AND [prs].[ExpiryMonth] = [irs].[ExpiryMonth]
				AND [prs].[ExpiryDay] = [irs].[ExpiryDay]
				AND (([prs].[PutCall] = [irs].[OptionTypeCode]) OR ([prs].[PutCall] IS NULL AND [irs].[OptionTypeCode] IS NULL))
				AND [prs].[CurrencyId] = [irs].[CurrencyId]
				AND (([prs].[StrikePrice] = [irs].[StrikePrice]) OR ([prs].[StrikePrice] IS NULL AND [irs].[StrikePrice] IS NULL))
		WHERE ImbalanceReportId=@ImbalanceReportId	AND
		prs.PriceReportSummaryId=@PriceReportSummaryId AND Lots != 0 -- filtering condition
		)
BEGIN
	SELECT 3
	RETURN 
END	
	
SELECT 0

END
');

GO
EXECUTE ('PRINT N''Creating [security].[Feature_Delete]''
');

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Deletes a record in the Feature table
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [security].[Feature_Delete]
(

	@FeatureId int   
)
AS


				DELETE FROM [security].[Feature] WITH (ROWLOCK) 
				WHERE
					[FeatureId] = @FeatureId
					
			

');

GO
EXECUTE ('PRINT N''Creating [stage].[BmfPositionsRealisedCash_Load]''
');

GO
EXECUTE ('CREATE PROCEDURE [stage].[BmfPositionsRealisedCash_Load]
(
	@LocationPath VARCHAR(100)
	,@ReceiveLocationSysId INT
	,@RunId INT
)
AS
SET NOCOUNT ON

-- Description:	This stored procedure pulls data from the stage.BmfPositionsRealisedCash temp
-- table and inserts it into PositionsRealisedCash
-- Whilst iterating through the records in stage.BmfPositionsRealisedCash, all 
-- of these inserts are wrapped in a transaction so that any failure causes
-- the changes to not commit.
--
-- 01 Jul 2014	ED	EIB 25781 - Creation
-- 09 Sep 2014	ED	EIB 25981 - add logic for F records
-- 12 Sep 2014	ED	EIB 25981 - map to P instead of O for InstrumentType

BEGIN

	DECLARE @Message			VARCHAR(1024)
	DECLARE @AddCount			INT
	SET @AddCount = 0
					
	DECLARE @DataSourceCode VARCHAR(100), @ExchangeCode VARCHAR(100), @FirmCode VARCHAR(100)
	DECLARE @DataSourceId INT
	DECLARE @Code VARCHAR(100)
	DECLARE @Code2 VARCHAR(100)
	DECLARE @ReturnValue INT
	DECLARE @Output INT
	DECLARE @Output2 INT
	DECLARE @DefaultCurrencyId INT
	
	DECLARE @FutureProducts TABLE(Product VARCHAR(5))
	INSERT INTO @FutureProducts(Product) VALUES(''SR''), (''SC'')
			
	-- Get Datasource
	SET @DataSourceCode = ''BMF''
	SET @ExchangeCode = ''BMF''
	SET @FirmCode = ''BMF''
	
	SET @Code = @DataSourceCode
	EXEC @ReturnValue= [_ib_DataSource_GetByCodeForOutput] @Code,@OutPut OUTPUT,@Output2 OUTPUT	
	SET @DataSourceId = @Output
	SET @DefaultCurrencyId = @Output2	


	-- Duplicate file check										
	DECLARE @IsFileAlreadyLoaded INT
	EXEC @IsFileALreadyLoaded = HasFileBeenLoaded @LocationPath, @DataSourceId

	IF @IsFileAlreadyLoaded = 1
	BEGIN
		UPDATE stage.BmfPositionsRealisedCash
		SET LoadState = 3
		WHERE LoadState = 1
			AND FileName = @LocationPath		
		RETURN
	END
	
	DECLARE @CheckAsOfDate DATETIME
	SET @CheckAsOfDate = 
		(SELECT MIN(AData) AS CheckRunDate FROM stage.BmfPositionsRealisedCash 
			WHERE LoadState = 1 AND Filename = @LocationPath AND JType IN (''Ajuste''))
	IF (@CheckAsOfDate IS NOT NULL)
	BEGIN		
		DECLARE @IsAcceptable BIT
		EXECUTE [dbo].[Load_IsFileTooOld] @DataSourceId,@LocationPath,@CheckAsOfDate,@IsAcceptable OUTPUT, @ReceiveLocationSysId, @RunId
		IF (@IsAcceptable = 0)
		BEGIN
			
			UPDATE stage.BmfPositionsRealisedCash SET LoadState = 3 WHERE LoadState = 1 AND FileName = @LocationPath	
			RAISERROR (''File is too old.'', 18, 0)
			RETURN
		END									
	END

	-- Store ImportFile record for use
	DECLARE @ImportFileId INT
	EXEC ib_ImportFile_Add @DataSourceId, @LocationPath, @ImportFileId OUTPUT
	
	--Gets the defaultStrikePriceDivisor
	DECLARE	@DefaultStrikePriceDivisor	DECIMAL(19,6)
	SET @DefaultStrikePriceDivisor = [dbo].[udf_GetDefaultStrikePriceDivisor](@DataSourceId, NULL)


	SET XACT_ABORT ON 

	BEGIN TRAN T1

		-- BizTalk''s SQL Adapter uses more restrictive read serializable
		-- so this is necessary to relax it to something that is default
		-- and perfectly acceptable!
		SET TRANSACTION ISOLATION LEVEL READ COMMITTED

		BEGIN TRY
			DECLARE @BmfPositionsRealisedCashId INT
			DECLARE @ReportDate DATE  
			DECLARE @AccountCode VARCHAR(100)  
			DECLARE @Product VARCHAR(5)  
			DECLARE @Currency CHAR(3)  
			DECLARE @TransactionType VARCHAR(100)
			DECLARE @MaturityMonth VARCHAR(3)
			DECLARE @Strike VARCHAR(100) 
			DECLARE @CallOrPut VARCHAR(1) 
			DECLARE @TransactionValue MONEY 
			DECLARE @Type VARCHAR(4)
			DECLARE @StrikePriceDec DECIMAL (24, 10)

			DECLARE pos_cursor CURSOR FOR
			SELECT  BmfPositionsRealisedCashId,
					AData,
					DClientCode,  
					FContract,
					''USD'',
					JType,
					HMaturityMonth,
					StrikePrice,
					IsCall,
					MAmount, 
					G
			FROM stage.BmfPositionsRealisedCash 
			WHERE LoadState = 1 AND Filename = @LocationPath AND MAmount != 0

			OPEN pos_cursor

			FETCH NEXT FROM pos_cursor
			INTO 
				    @BmfPositionsRealisedCashId,
					@ReportDate,
					@AccountCode,  
					@Product,
					@Currency,
					@TransactionType,
					@MaturityMonth,
					@StrikePriceDec,
					@CallOrPut,
					@TransactionValue,
					@Type
				-- Check @@FETCH_STATUS to see IF there are any more rows to fetch.
				WHILE @@FETCH_STATUS = 0
				BEGIN
					DECLARE @IsCall		BIT
					DECLARE @InstrumentTypeCode CHAR(1)
					DECLARE @InstrumentCode VARCHAR(100)
					DECLARE @RecordDate DATETIME
					DECLARE @StrikePriceDivisor  DECIMAL(19,4)
					DECLARE @StrikePrice         DECIMAL(19,4)

			SET @RecordDate = @ReportDate
				
			DECLARE @PromptDate DATE
			SET @PromptDate = CONVERT(DATETIME, CONVERT(VARCHAR(2), 
					dbo.GetReutersMonthNumber(LEFT(@MaturityMonth,1))) + ''/1/20'' + RIGHT(@MaturityMonth, 2), 101)
			SET @PromptDate = dbo.GetLastDayOfTheMonth(@PromptDate)
			
			IF(@Type = ''FUT'')
					SET @InstrumentTypeCode = ''F''
				ELSE
					SET @InstrumentTypeCode = ''O''
					
			SET @InstrumentCode = @InstrumentTypeCode + ''_'' + @ExchangeCode + ''_'' + @Product	
			
			SET @StrikePriceDivisor = NULL
			SET @StrikePrice = NULL
			IF (@InstrumentTypeCode = ''O'')
				BEGIN
					SELECT @StrikePriceDivisor = StrikePriceDivisor
						FROM [dbo].[ib_InstrumentDataSource] WHERE DataSourceId = @DataSourceId AND DataSourceInstrumentCode = @InstrumentCode 
					SET @StrikePrice = @StrikePriceDec / ISNULL(@StrikePriceDivisor, ISNULL(@DefaultStrikePriceDivisor, 1))
				END
			SET @IsCall = CASE WHEN @CallOrPut IS NULL OR @CallOrPut = ''0'' THEN 0 ELSE 1 END 
			DECLARE @PositionsRealisedCashId INT = NULL
			
			EXEC dbo.PositionsRealisedCash_Load @RecordDate, @AccountCode, @Product, @Currency, @Product, @PromptDate, @StrikePrice, @IsCall,
					@TransactionValue, @DataSourceCode, @ExchangeCode, @FirmCode, @InstrumentTypeCode, @InstrumentCode, @BmfPositionsRealisedCashId,
					@LocationPath, @ReceiveLocationSysId, @RunId, @PositionsRealisedCashId OUTPUT
			
			IF (@PositionsRealisedCashId IS NOT NULL AND @PositionsRealisedCashId > 0)
					SET @AddCount = @AddCount + 1		

			--flip processed flag in source table.
			UPDATE stage.BmfPositionsRealisedCash WITH (ROWLOCK) SET [LoadState] = 2 WHERE BmfPositionsRealisedCashId = @BmfPositionsRealisedCashId AND [LoadState] = 1
			
			
			FETCH NEXT FROM pos_cursor
			INTO 
					@BmfPositionsRealisedCashId,
					@ReportDate,
					@AccountCode,  
					@Product,
					@Currency,
					@TransactionType,
					@MaturityMonth,
					@StrikePriceDec,
					@CallOrPut,
					@TransactionValue,
					@Type
		END
			
		CLOSE pos_cursor
		DEALLOCATE pos_cursor

			-- Now update state of any left-over temporary transaction records
			-- so there are no ''left-overs''
			UPDATE stage.BmfPositionsRealisedCash WITH (ROWLOCK) SET [LoadState] = 2 WHERE [LoadState] = 1 AND [FileName] = @LocationPath

			SET @Message = @DataSourceCode + '' PositionsRealisedCash loader ended ('' + CONVERT(VARCHAR(10), @AddCount) + '' added).'' 
		
			EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @Message, ''Success'', '''', @RunId

			UPDATE ib_ImportFile SET AsOfDate = @CheckAsOfDate WHERE ImportFileId = @ImportFileId
			
		COMMIT TRAN T1
	
	END TRY
	BEGIN CATCH 

		IF XACT_STATE() = -1 
			ROLLBACK TRANSACTION
	
		SET @Message = @DataSourceCode + '' PositionsRealisedCash loader failed.'' 		
		EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @Message, ''Error'', '''', @RunId
	
		EXEC [dbo].[sp_RethrowError]
		
	END CATCH 

	SET XACT_ABORT OFF

END

RETURN 0
');

GO
EXECUTE ('PRINT N''Creating [dbo].[CleanAndTrim]''
');

GO
EXECUTE ('CREATE FUNCTION [dbo].[CleanAndTrim] (
       @Str nvarchar(max)
)
RETURNS nvarchar(max) AS
BEGIN
       DECLARE @Result nvarchar(max)

       SET @Result = LTRIM(RTRIM(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
              LTRIM(RTRIM(@Str)), CHAR(9), '' ''), CHAR(10), '' ''), CHAR(11), '' ''), CHAR(12), '' ''), CHAR(13), '' '')))

       RETURN @Result
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[AccountCsv]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[AccountCsv]
(
[AccountCsvId] [int] NOT NULL IDENTITY(1, 1),
[Firm] [varchar] (100) NULL,
[Office] [varchar] (100) NULL,
[Acct] [varchar] (100) NULL,
[Status] [varchar] (100) NULL,
[ShortName] [varchar] (100) NULL,
[LegalEntityNamePlusAccountType] [varchar] (100) NULL,
[LegalEntityNameContPlusAddress] [varchar] (100) NULL,
[Address] [varchar] (100) NULL,
[Address2] [varchar] (100) NULL,
[Address3] [varchar] (100) NULL,
[Address4] [varchar] (100) NULL,
[Country] [varchar] (100) NULL,
[State] [varchar] (100) NULL,
[Class] [varchar] (100) NULL,
[SubClass] [varchar] (100) NULL,
[RelFirm] [varchar] (100) NULL,
[RelOff] [varchar] (100) NULL,
[RelAcct] [varchar] (100) NULL,
[FileName] [varchar] (512) NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [AccountCsvLoadStateDefaultConstraint] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [AccountCsvCreateDateDefaultConstraint] DEFAULT (getdate())
)
');

GO
EXECUTE ('PRINT N''Creating primary key [AccountCsvPrimaryKeyConstraint] on [dbo].[AccountCsv]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[AccountCsv] ADD CONSTRAINT [AccountCsvPrimaryKeyConstraint] PRIMARY KEY CLUSTERED  ([AccountCsvId])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_AccountCsv_Load]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_AccountCsv_Load] 
	(
		 @LocationPath VARCHAR(100)
		,@ReceiveLocationSysId INT = NULL
		,@RunId INT = NULL
	)
AS
SET NOCOUNT ON
	--	01 Feb 2019	KR	Create
	--  02 Feb 2019 KR	Set all accounts to active and fix loadstate 

	DECLARE @DataSourceCd  AS VARCHAR(100)
	SET @DataSourceCd = ''RNU2''
	DECLARE @DataSourceId INT	
	DECLARE @DefaultCurrencyId INT
	EXEC [_ib_DataSource_GetByCodeForOutput] @DataSourceCd, @DataSourceId output, @DefaultCurrencyId output
	
	-- There really isn''t any need for orchestration to call a LoadStateChange anymore
	-- since we only process rows for single file now
	-- but to keep consistent with other loaders - we''ll update to LoadState 1 at 
	-- start of this Load stored procedure
	UPDATE AccountCsv
	SET LoadState = 1
	WHERE LoadState = 0
		AND Filename = @LocationPath

	BEGIN TRANSACTION T1

	-- BizTalk''s SQL Adapter uses more restrictive read serializable
	-- so this is necessary to relax it to something that is default
	-- and perfectly acceptable!
	SET TRANSACTION ISOLATION LEVEL READ COMMITTED

	-- Now proceed with load

	DECLARE @Message VARCHAR(1024)

	-- first find the firm
	DECLARE @FirmCode VARCHAR(100)
	DECLARE @FirmId INT
	SET @FirmCode = ''Marex (U2)''
	EXEC ib_Firm_GetByCode @FirmCode, @FirmId OUTPUT
	IF @FirmId IS NULL
	BEGIN
		SET @Message = ''Firm with code '' + @FirmCode 
			+ '' not found in i-Balancer; account not synced''
		RAISERROR(@Message, 15, 1)
	END

	DECLARE @AddCount INT
	DECLARE @UpdateCount INT
	DECLARE @SkipCount INT
	SET @AddCount = 0
	SET @UpdateCount = 0
	SET @SkipCount = 0

	DECLARE @AccountID INT
	DECLARE @BusinessType VARCHAR(100)
	DECLARE @Class VARCHAR(100)
	DECLARE @LedgerCode VARCHAR(100)
	DECLARE @LedgerName VARCHAR(100)
	DECLARE @SalesCode VARCHAR(100)
	DECLARE @FamilyCode VARCHAR(100)
	DECLARE @IsOmnibus BIT

	CREATE TABLE #temp1
	(
		AccountID INT
		, BusinessType VARCHAR(100) COLLATE Latin1_General_CI_AS
		, Class VARCHAR(100) COLLATE Latin1_General_CI_AS
		, LedgerCode VARCHAR(100) COLLATE Latin1_General_CI_AS
		, LedgerName VARCHAR(100) COLLATE Latin1_General_CI_AS
		, SalesCode VARCHAR(100) COLLATE Latin1_General_CI_AS
		, FamilyCode VARCHAR(100) COLLATE Latin1_General_CI_AS
		, IsOmnibus BIT
	)

	INSERT INTO #temp1 (AccountId, BusinessType, Class, LedgerCode, LedgerName, SalesCode, FamilyCode, IsOmnibus)
	SELECT AccountCsvId
	, ''BusinessType''
	, CASE WHEN LEFT(Acct, 1) = ''0'' OR ([Firm] = ''Z'' AND (LEFT(Acct, 1) = ''6'' OR RTRIM(LTRIM(Office)) + RTRIM(LTRIM(Acct)) = ''111M3501'')) THEN
		CASE 
				WHEN [Firm] = ''D'' THEN ''US7'' 
				WHEN [Firm] = ''P'' THEN ''US8''
				WHEN [Firm] = ''R'' THEN ''US9''
				WHEN [Firm] = ''S'' THEN ''US10''
				WHEN [Firm] = ''Z'' THEN ''US2''
			END
		ELSE
			CASE
				WHEN [Firm] = ''D'' THEN ''US5'' 
				WHEN [Firm] = ''P'' THEN ''US4''
				WHEN [Firm] = ''R'' THEN ''US1''
				WHEN [Firm] = ''S'' THEN ''US6''
				WHEN [Firm] = ''Z'' THEN ''US3''
			END
		END			
		-- Office in the RCG can be left padded with spaces if less than 3 characters long, Marex requires the spaces to be replaced with zeros
	, RIGHT(''000''+RTRIM(LTRIM(Office)),3) + RTRIM(LTRIM(Acct))	
	, ShortName
	, ''SalesCode''
	-- magic to handle the funky family code characters in the RCG file
	, CASE WHEN [Firm] = ''P'' THEN NULLIF(dbo.cleanandtrim([RelAcct]), '''') ELSE NULL END
	, CASE WHEN [SubClass] = ''O'' THEN 1 ELSE 0 END 
	FROM AccountCsv a
	WHERE a.LoadState = 1
		AND a.Filename = @LocationPath
	
	-- set all accounts which don''t have the code appearing in the staging table
	UPDATE ib_Account
	SET IsApproved = 0
	WHERE NOT EXISTS (SELECT 1 FROM #temp1 WHERE Code = LedgerCode) AND FirmId = @FirmId

	DECLARE pos_cursor CURSOR FOR
	SELECT AccountId, BusinessType, Class, LedgerCode, LedgerName, SalesCode, FamilyCode, IsOmnibus
	FROM #temp1

	OPEN pos_cursor

	FETCH NEXT FROM pos_cursor
	INTO @AccountId, @BusinessType, @Class, @LedgerCode, @LedgerName, @SalesCode, @FamilyCode, @IsOmnibus

	DECLARE @CurrentAccountName VARCHAR(100)
	DECLARE @CurrentAccountClassId INT
	DECLARE @DestinationAccountId INT
	DECLARE @CurrentIsApproved BIT
	DECLARE @CurrentFamilyCode VARCHAR(100)
	DECLARE @CurrentIsOmnibus BIT

	DECLARE @ClassId INT

	-- Check @@FETCH_STATUS to see IF there are any more rows to fetch.
	WHILE @@FETCH_STATUS = 0
	BEGIN
		-- check for account record
		SET @CurrentAccountName = NULL
		SET @CurrentAccountClassId = NULL
		SET @DestinationAccountId = NULL
		SET @CurrentIsApproved = NULL
		SET @CurrentFamilyCode = NULL
		SET @CurrentIsOmnibus = NULL

		SELECT @CurrentAccountName = a.Name
			, @CurrentAccountClassId = a.ClassId
			, @DestinationAccountId = a.AccountId
			, @CurrentIsApproved = a.IsApproved
			, @CurrentFamilyCode = a.FamilyCode
			, @CurrentIsOmnibus = a.IsOmnibus
		FROM ib_Account a
		WHERE a.Code = @LedgerCode
			AND a.FirmId = @FirmId

		-- check if class exists
		SET @ClassId = NULL
		EXEC ib_Class_GetByCode @Class, @ClassId OUTPUT
		IF @ClassId IS NULL
		BEGIN
			-- log message but proceed as we may want to deactivate the account
			SET @Message = ''Class '' + @Class + '' for account '' + @LedgerCode + '' not found in i-Balancer; account not synced''
			EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @Message, ''Success'', '''', @RunId
		END
		
		DECLARE @UpdateUsername VARCHAR(50)
		SET @UpdateUsername = SUSER_SNAME()

		IF @DestinationAccountId IS NULL
		BEGIN
			-- do add
			EXEC ib_Account_Add @FirmId, @LedgerCode, @LedgerName, 1, @ClassId, @IsImported=1, @FamilyCode = @FamilyCode, @IsOmnibus = @IsOmnibus
			SET @AddCount = @AddCount + 1
		END
		ELSE
		BEGIN
			IF @ClassId <> @CurrentAccountClassId
				OR (@ClassId IS NULL and @CurrentAccountClassId IS NOT NULL)
				OR (@ClassId IS NOT NULL and @CurrentAccountClassId IS NULL)
				OR @LedgerName <> @CurrentAccountName
				OR @CurrentIsApproved = 0
				OR ISNULL(@FamilyCode,'''') <> ISNULL(@CurrentFamilyCode,'''')
				OR @IsOmnibus != @CurrentIsOmnibus
			BEGIN
				-- do update
				EXEC ib_Account_Update @DestinationAccountId, @FirmId, @ClassId, @LedgerCode, @LedgerName, 1, @UpdateUsername, NULL, NULL, @FamilyCode, @IsOmnibus = @IsOmnibus
				SET @UpdateCount = @UpdateCount + 1
			END
			ELSE
				SET @SkipCount = @SkipCount + 1
		END

 		--flip processed flag in source table.
		UPDATE AccountCsv
		WITH (ROWLOCK)
		SET LoadState = 2
		WHERE AccountCsvID = @AccountID
			AND LoadState = 1

		FETCH NEXT FROM pos_cursor
		INTO @AccountId, @BusinessType, @Class, @LedgerCode, @LedgerName, @SalesCode, @FamilyCode, @IsOmnibus
	END
			
	CLOSE pos_cursor
	DEALLOCATE pos_cursor
	
	SET @Message = ''Accounts loader ended ('' 
		+ CONVERT(VARCHAR(10), @AddCount) + '' added; '' 
		+ CONVERT(VARCHAR(10), @UpdateCount) + '' updated; '' 
		+ CONVERT(VARCHAR(10), @SkipCount) + '' skipped)''
	EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @Message, ''Success'', '''', @RunId

	DROP TABLE #temp1
	
	COMMIT TRANSACTION T1
');

GO
EXECUTE ('PRINT N''Creating [dbo].[aspnet_Roles_CreateRole]''
');

GO
SET QUOTED_IDENTIFIER OFF

GO
EXECUTE ('CREATE PROCEDURE [dbo].[aspnet_Roles_CreateRole]
    @ApplicationName  nvarchar(256),
    @RoleName         nvarchar(256)
AS
SET NOCOUNT ON
BEGIN
    DECLARE @ApplicationId uniqueidentifier
    SELECT  @ApplicationId = NULL

    DECLARE @ErrorCode     int
    SET @ErrorCode = 0

    DECLARE @TranStarted   bit
    SET @TranStarted = 0

    IF( @@TRANCOUNT = 0 )
    BEGIN
        BEGIN TRANSACTION
        SET @TranStarted = 1
    END
    ELSE
        SET @TranStarted = 0

    EXEC dbo.aspnet_Applications_CreateApplication @ApplicationName, @ApplicationId OUTPUT

    IF( @@ERROR <> 0 )
    BEGIN
        SET @ErrorCode = -1
        GOTO Cleanup
    END

    IF (EXISTS(SELECT RoleId FROM dbo.aspnet_Roles WHERE LoweredRoleName = LOWER(@RoleName) AND ApplicationId = @ApplicationId))
    BEGIN
        SET @ErrorCode = 1
        GOTO Cleanup
    END

    INSERT INTO dbo.aspnet_Roles
                (ApplicationId, RoleName, LoweredRoleName)
         VALUES (@ApplicationId, @RoleName, LOWER(@RoleName))

    IF( @@ERROR <> 0 )
    BEGIN
        SET @ErrorCode = -1
        GOTO Cleanup
    END

    IF( @TranStarted = 1 )
    BEGIN
        SET @TranStarted = 0
        COMMIT TRANSACTION
    END

    RETURN(0)

Cleanup:

    IF( @TranStarted = 1 )
    BEGIN
        SET @TranStarted = 0
        ROLLBACK TRANSACTION
    END

    RETURN @ErrorCode

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[IDEM_DS13_LoadStateChange]''
');

GO
SET QUOTED_IDENTIFIER ON

GO
EXECUTE ('-- =============================================
-- Author:		Lee Manifold
-- Create date: 15 Sep 2006
-- Description:	Changes the LoadState of the IDEM_DS13 type table
-- =============================================
CREATE PROCEDURE [dbo].[IDEM_DS13_LoadStateChange] 
	-- Add the parameters for the stored procedure here
	(
	@OldLoadState	TINYINT,
	@NewLoadState	TINYINT,
	@RecordDate		DATETIME = NULL
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	-- Need to add code to handle RecordDate
	IF @RecordDate IS NOT NULL 
	BEGIN

		UPDATE [dbo].[IDEM_DS13] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState

	END

	IF @RecordDate IS NULL 
	BEGIN

		UPDATE [dbo].[IDEM_DS13] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState

	END


END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_QueueItem_GetQueueStatuses]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_QueueItem_GetQueueStatuses]
AS
SET NOCOUNT ON
	SELECT * FROM ib_QueueStatus
');

GO
EXECUTE ('PRINT N''Creating [security].[Feature_GetByFeatureCode]''
');

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Select records from the Feature table through an index
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [security].[Feature_GetByFeatureCode]
(

	@FeatureCode varchar (20)  
)
AS


				SELECT
					[FeatureId],
					[FeatureCode],
					[FeatureName]
				FROM
					[security].[Feature]
				WHERE
					[FeatureCode] = @FeatureCode
				SELECT @@ROWCOUNT
					
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_ImbalanceReportSummary_GetDetailsTransaction]''
');

GO
EXECUTE ('CREATE Procedure [dbo].[ib_ImbalanceReportSummary_GetDetailsTransaction]
(
		@ImbalanceReportSummaryId int
)
AS
SET NOCOUNT ON
/*
<details>
	<summary> Get the Transaction values for a Summary Record</summary>
	<created author="ED" Date="28 Apr 2009" />
	<changed ED - MBAL-11570 - OptionTypeCode AND StrikePrice may be null in trx table />
	<changed amk - 5 Oct 09 - return trx type too />
	<changed amk - 6 Oct 09 - fix trx type join />
	<changed amk - 26 Feb 10 - MBAL-14843 - show trxtype desc too />
	<changed amk - 26 Feb 10 - MBAL-14811 - missing some trxs - dont join to trace table />
	<changed KevinP - 10 Mar 2010 - MBAL-14919 - Checnged to return Account Code rather than Name/>
	<changed AAJM - 16 Mar 2010 - MBAL-14912 and MBAL-14811 - Re-add join to Trace Table/>
	<changed amk - 21 Apr 2010 - MBAL-15332 - Show new IsOptionMarketValue col/>
</details>
*/
SELECT AsOfDate, d.[Name] Datasource, f.[Name] Firm, a.[Code] Account, Quantity, MarketValue 
		,InternalExternalCode, Price, TrxDate
		, TrxTypeCode + ''-'' + ISNULL(tt.Description, '''') AS TrxTypeCode
		, CASE WHEN tt.IsPandS = 1 THEN ''Y'' ELSE ''N'' END AS IsPandS
		, CASE WHEN tt.IsPremium = 1 THEN ''Y'' ELSE ''N'' END AS IsPremium
		, CASE WHEN tt.IsOptionMarketValue = 1 THEN ''Y'' ELSE ''N'' END AS IsOptionMarketValue
FROM [dbo].[ib_ImbalanceReportSummary] irs
	INNER JOIN ib_ImbalanceReport ir ON ir.ImbalanceReportId=irs.ImbalanceReportId
	INNER JOIN ib_ImbalanceReportDetail ird ON ird.ImbalanceReportId=ir.ImbalanceReportId
		AND ird.[ExchangeId]=irs.[ExchangeId]
		AND ird.[InstrumentId]=irs.[InstrumentId]
		AND ird.[CurrencyId]=irs.[CurrencyId]
		AND ird.[ExpiryMonth]=irs.[ExpiryMonth]
		AND ird.[ExpiryYear]=irs.[ExpiryYear]
		AND (ird.[ExpiryDay]=irs.[ExpiryDay] OR (ird.[ExpiryDay] IS NULL AND irs.[ExpiryDay] IS NULL))
		AND ISNULL(ird.[OptionTypeCode],'''')=ISNULL(irs.[OptionTypeCode],'''')
		AND ISNULL(ird.[StrikePrice],0)=ISNULL(irs.[StrikePrice],0)
	INNER JOIN ib_ImbalanceReportPhase2Trace IRP2T ON irs.Description=irp2t.Description 
		AND ird.ImbalanceReportDetailId=irp2t.ImbalanceReportDetailId
	INNER JOIN ib_Trx tx ON tx.ExchangeId=ird.ExchangeId
		AND tx.FirmId = ird.FirmId
		AND (tx.AccountId=ird.AccountId OR (tx.AccountId IS NULL AND ird.AccountId IS NULL))
		AND tx.InstrumentId=ird.InstrumentId
		AND (tx.ClassId=ird.ClassId OR (tx.ClassId IS NULL AND ird.ClassId IS NULL))
		AND tx.ExpiryYear=ird.ExpiryYear
		AND tx.ExpiryMonth=ird.ExpiryMonth	
		AND (tx.ExpiryDay=ird.ExpiryDay OR (tx.ExpiryDay IS NULL AND ird.ExpiryDay IS NULL))
		AND ISNULL(tx.OptionTypeCode,'''')=ISNULL(ird.OptionTypeCode,'''')
		AND tx.CurrencyId=ird.CurrencyId
		AND ISNULL(tx.StrikePrice,0)=ISNULL(ird.StrikePrice,0)
		AND (tx.AsOfDate=ir.Today OR tx.AsOfDate=ir.Yesterday)
	INNER JOIN ib_Template t ON t.TemplateId=ir.TemplateId
	INNER JOIN ib_TemplateCompare tc ON tc.TemplateId=t.TemplateId AND tc.DataSourceId=tx.DataSourceId AND tc.FirmId=tx.FirmId
	INNER JOIN ib_Datasource d ON d.DatasourceId=tx.DataSourceId
	INNER JOIN ib_Firm f ON f.FirmId=tx.FirmId
	INNER JOIN ib_Account a ON a.AccountId=tx.AccountId
	LEFT OUTER JOIN ib_TrxType tt ON tt.Code = tx.TrxTypeCode
		AND tt.DataSourceId = tx.DataSourceId
WHERE ImbalanceReportSummaryId=@ImbalanceReportSummaryId
ORDER BY AsOfDate, Datasource, Firm, Account, Quantity, MarketValue
');

GO
EXECUTE ('PRINT N''Creating [stage].[BmfTrade_Load]''
');

GO
EXECUTE ('CREATE PROCEDURE [stage].[BmfTrade_Load]
(
	@LocationPath VARCHAR(100)
	,@ReceiveLocationSysId INT
	,@RunId INT
)
AS
SET NOCOUNT ON

-- Description:	This stored procedure pulls data from the stage.BmfTrade temp
-- table and inserts it into ib_Trx
-- Whilst iterating through the records in stage.BmfTrade, all 
-- of these inserts are wrapped in a transaction so that any failure causes
-- the changes to not commit.
--
-- 25 Mar 2016	ED	EIB 38652 - Creation

--TO DO

BEGIN

	DECLARE @Message			VARCHAR(1024)
	DECLARE @AddCount			INT
	SET @AddCount = 0
					
	DECLARE @DataSourceCode VARCHAR(100), @ExchangeCode VARCHAR(100), @FirmCode VARCHAR(100)
	DECLARE @DataSourceId INT
	DECLARE @Code VARCHAR(100)
	DECLARE @Code2 VARCHAR(100)
	DECLARE @ReturnValue INT
	DECLARE @Output INT
	DECLARE @Output2 INT
	DECLARE @DefaultCurrencyId INT
			
	-- Get Datasource
	SET @DataSourceCode = ''BMF''
	SET @ExchangeCode = ''BMF''
	SET @FirmCode = ''BMF''
	
	SET @Code = @DataSourceCode
	EXEC @ReturnValue= [_ib_DataSource_GetByCodeForOutput] @Code,@OutPut output,@Output2 output	
	SET @DataSourceId = @Output
	SET @DefaultCurrencyId = @Output2	

	-- Duplicate file check										
	DECLARE @IsFileAlreadyLoaded INT
	EXEC @IsFileALreadyLoaded = HasFileBeenLoaded @LocationPath, @DataSourceId

	IF @IsFileAlreadyLoaded = 1
	BEGIN
		UPDATE stage.BmfTrade
		SET LoadState = 3
		WHERE LoadState = 1
			AND FileName = @LocationPath		
		RETURN
	END
	
	-- Set AsOfDate from Filename
	DECLARE @AsOfDate DATETIME
	
	DECLARE @DateChr VARCHAR(8)
	SET @DateChr = RIGHT(@LocationPath, CHARINDEX(''\'',REVERSE(@LocationPath))-5)
		
	SET @AsOfDate = CONVERT(DATETIME, @DateChr, 112)	
	
	DECLARE @IsAcceptable bit
	EXECUTE [dbo].[Load_IsFileTooOld] @DataSourceId, @LocationPath, @AsOfDate, @IsAcceptable OUTPUT, @ReceiveLocationSysId, @RunId
	IF (@IsAcceptable = 0)
		BEGIN
			
			UPDATE stage.BmfTrade SET LoadState = 3 WHERE LoadState = 1 AND FileName = @LocationPath	
			RAISERROR (''File is too old.'', 18, 0)
			RETURN
	END									
	

	-- Store ImportFile record for use
	DECLARE @ImportFileId INT
	EXEC ib_ImportFile_Add @DataSourceId, @LocationPath, @ImportFileId output

	--Gets the defaultStrikePriceDivisor
	DECLARE	@DefaultStrikePriceDivisor	DECIMAL(19,6)
	SET @DefaultStrikePriceDivisor = [dbo].[udf_GetDefaultStrikePriceDivisor](@DataSourceId, NULL)

	SET XACT_ABORT ON 

	BEGIN TRAN T1

		-- BizTalk''s SQL Adapter uses more restrictive read serializable
		-- so this is necessary to relax it to something that is default
		-- and perfectly acceptable!
		SET TRANSACTION ISOLATION LEVEL READ COMMITTED

		BEGIN TRY
			DECLARE @BmfTradeId INT
			DECLARE @TradeDate DATE
			DECLARE @CustomerCode VARCHAR(100)
			DECLARE @BuySell VARCHAR(1)
			DECLARE @Contract VARCHAR(100)
			DECLARE @Market VARCHAR(100)
			DECLARE @ContractMonth VARCHAR(100)
			DECLARE @TradePrice DECIMAL (24, 10)
			DECLARE @Amount INT
			DECLARE @MaturityDate DATE
			DECLARE @StrikePrice DECIMAL (24, 10)
			
			DECLARE trx_cursor CURSOR FOR
			SELECT BmfTradeId
					,TradeDate
					,CustomerCode
					,BuySell
					,Contract
					,Market
					,ContractMonth
					,TradePrice
					,Amount
					,MaturityDate
					,StrikePrice
					
			FROM stage.BmfTrade WHERE LoadState = 1 AND Filename = @LocationPath
			
			OPEN trx_cursor

			FETCH NEXT FROM trx_cursor
			INTO 
				    @BmfTradeId
					,@TradeDate
					,@CustomerCode
					,@BuySell
					,@Contract
					,@Market
					,@ContractMonth
					,@TradePrice
					,@Amount
					,@MaturityDate
					,@StrikePrice

				-- Check @@FETCH_STATUS to see IF there are any more rows to fetch.
				WHILE @@FETCH_STATUS = 0
				BEGIN
					DECLARE		@InstrumentCd			VARCHAR(100)
					DECLARE		@InstrumentTypeCd		VARCHAR(100)
					DECLARE		@QuantityLong			DECIMAL(19,4)
					DECLARE		@QuantityShort			DECIMAL(19,4)
					DECLARE		@SignedQuantity			DECIMAL(19,4)
					DECLARE		@ExpYr					SMALLINT
					DECLARE		@ExpMth					SMALLINT
					DECLARE		@ExpDay					SMALLINT
					DECLARE		@StrikePriceValue		DECIMAL(19,4)
					DECLARE		@TradePriceValue		DECIMAL(24,10)
					DECLARE		@TradePriceDivisor		DECIMAL(19,4)
					DECLARE		@StrikePriceDivisor		DECIMAL(19,4)
					DECLARE		@MarketValueDec			DECIMAL(19,4)
					DECLARE		@MarketValueDivisor		DECIMAL(19,4)
					DECLARE		@TrxTypeCode			VARCHAR(25)
					DECLARE		@TrxTypeDesc			VARCHAR(25)

					DECLARE     @PutCall VARCHAR(1) 
					DECLARE		@Currency VARCHAR(3) 

					SET @Currency = ''USD''

					IF @BuySell = ''C'' -- C - buy, V - sell
					BEGIN
						SET @QuantityLong = @Amount
						SET @QuantityShort = 0
					END
					ELSE
					BEGIN
						SET @QuantityLong = 0
						SET @QuantityShort = @Amount
					END
					SET @SignedQuantity = @QuantityLong - @QuantityShort
					
					SET @MarketValueDec = NULL		
					SET @InstrumentTypeCd = NULL	
			
					-- Set InstrumentTypeCd
					IF @Market IN (''FUT'')
					BEGIN
						SET @InstrumentTypeCd = ''F''
						SET @PutCall = NULL
					END						
					ELSE
					BEGIN
						SET @InstrumentTypeCd = ''O''
						IF LEFT(RIGHT(@ContractMonth, 2),1) IN (''M'',''N'',''P'', ''Q'')
							SET @PutCall = ''P''
							ELSE
							SET @PutCall = ''C''
					END

					-- We prefix the Instruments with the IntrumentTypeCode
					SET @InstrumentCd = @InstrumentTypeCd + ''_'' + @ExchangeCode + ''_'' + @Contract			
					
					SET @TrxTypeCode = NULL
					SET @TrxTypeDesc = NULL
					--TODO??
					SET @TrxTypeCode = ''BMF''
					SET @TrxTypeDesc = ''BMF''
					
					-- Set ExpiryDate		
					SET @ExpDay = NULL
					SET @ExpMth = NULL
					SET @ExpYr = NULL	

					SET @ExpDay = NULL
					SET @ExpMth = NULL
					SET @ExpYr = NULL	
					IF (@InstrumentTypeCd = ''O'')
						SET @MaturityDate = DATEADD(MONTH, 1, @MaturityDate)
					SET @MaturityDate = dbo.GetLastDayOfTheMonth(@MaturityDate)	
					-- Set ExpiryDate
					SET @ExpYr = YEAR(@MaturityDate)
					SET @ExpMth = MONTH(@MaturityDate)
					SET @ExpDay = DAY(@MaturityDate)

						-- Get Divisors						
					SET @StrikePriceDivisor = NULL
					SET @TradePriceDivisor = NULL
					DECLARE @InstrumentId INT			
					SELECT  @MarketValueDivisor = ids.MarketValueDivisor,
							@StrikePriceDivisor = ids.StrikePriceDivisor
							, @TradePriceDivisor = ids.PriceDivisor
							, @InstrumentId = ids.InstrumentId
					FROM [dbo].[ib_InstrumentDataSource] ids
					WHERE ids.DataSourceId = @DataSourceId
						AND ids.DataSourceInstrumentCode = @InstrumentCd

					-- Set Price	
					SET @TradePriceValue = NULL
					SET @TradePriceValue = CONVERT(DECIMAL(24,10), @TradePrice) / ISNULL(@TradePriceDivisor, 1)
					
					-- Set StrikePrice
					SET @StrikePriceValue = NULL	
					IF (@InstrumentTypeCd = ''O'')
						SET @StrikePriceValue = @StrikePrice / ISNULL(@StrikePriceDivisor, ISNULL(@DefaultStrikePriceDivisor, 1))
					
					SET @MarketValueDec = NULL
					SET @MarketValueDec = @TradePrice * ISNULL(dbo.GetInstrumentTickSizeByInstrumentId(@InstrumentId), 1) * @SignedQuantity * -1 / ISNULL(@MarketValueDivisor, 1)
					
					IF NOT EXISTS(SELECT 1 FROM ib_TrxType WHERE DataSourceId = @DataSourceId AND Code = @TrxTypeCode)
						INSERT INTO ib_TrxType (DataSourceId, Code, [Description], IsAutoMatched)
							VALUES(@DataSourceId, @TrxTypeCode, @TrxTypeDesc, 1)
						
					DECLARE @TrxId INT
					SET @TrxId = NULL
					EXEC [ib_Trx_Load]
						@DataSourceCode			
						, @ExchangeCode -- exchange				
						, @FirmCode
						, @CustomerCode -- @AccountCode	
						, NULL -- DetailAccountCd		
						, @InstrumentCd			
						, @ExpYr					
						, @ExpMth 					
						, @ExpDay 					
						, @StrikePriceValue			
						, @TrxTypeCode -- trxtypecode
						, @PutCall -- optionTypeCode
						, @SignedQuantity			
						, @TradeDate				
						, @TradePriceValue
						, @BmfTradeId
						, @InstrumentTypeCd
						, @AsOfDate		
						, @LocationPath
						, @MarketValueDec -- marketValue
						, @Currency
						, @TrxId = @TrxId OUTPUT
						, @QuantityLong = @QuantityLong 
						, @QuantityShort = @QuantityShort
						, @ReceiveLocationSysId = @ReceiveLocationSysId
						, @RunId = @RunId

					--flip processed flag in source table.
					UPDATE stage.BmfTrade WITH (ROWLOCK) SET [LoadState] = 2 WHERE BmfTradeId = @BmfTradeId AND [LoadState] = 1
					IF (@TrxId IS NOT NULL AND @TrxId > 0)
						SET @AddCount = @AddCount + 1
			
					FETCH NEXT FROM trx_cursor
					INTO 
							@BmfTradeId
							,@TradeDate
							,@CustomerCode
							,@BuySell
							,@Contract
							,@Market
							,@ContractMonth
							,@TradePrice
							,@Amount
							,@MaturityDate
							,@StrikePrice
				END
			
		CLOSE trx_cursor
		DEALLOCATE trx_cursor

			-- Now update state of any left-over temporary transaction records
			-- so there are no ''left-overs''
			UPDATE stage.BmfTrade
			WITH (ROWLOCK)
			SET [LoadState] = 2
			WHERE [LoadState] = 1 AND [FileName] = @LocationPath

			SET @Message = @DataSourceCode + '' transaction loader ended ('' + CONVERT(VARCHAR(10), @AddCount) + '' added).'' 
		
			EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @Message, ''Success'', '''', @RunId

			UPDATE ib_ImportFile SET AsOfDate = @AsOfDate WHERE ImportFileId = @ImportFileId
			
		COMMIT TRAN T1
	
	END TRY
	BEGIN CATCH 

		IF XACT_STATE() = -1 
			ROLLBACK TRANSACTION
	
		SET @Message = @DataSourceCode + '' transaction loader failed.'' 		
		EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @Message, ''Error'', '''', @RunId
	
		EXEC [dbo].[sp_RethrowError]
		
	END CATCH 

	SET XACT_ABORT OFF

END

RETURN 0
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Assembly_UpdateAssembly]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Assembly_UpdateAssembly]
	@assemblyId int, 
	@bin VARBINARY(MAX),
	@shortName NVARCHAR(50),
	@fullName  NVARCHAR(200)
AS
SET NOCOUNT ON

	UPDATE 
		ib_Assembly
	SET
		FullName = @fullName,
		ShortName = @shortName,
		UpdateDate = getdate(),
		Bin = @bin
	WHERE
		AssemblyId = @assemblyId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Adjustment_AddAdjustmentWithHeader]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Adjustment_AddAdjustmentWithHeader]
(
	@TemplateId INT,
	@AdjustmentDate DATETIME,
	@TradeDate DATETIME,
	@DataSourceId INT,
	@FirmId INT,
	@MatchCodeId INT,
	@ExchangeId INT,
	@AccountId INT,
	@DetailAccountId INT=NULL,
	@CurrencyId INT,
	@InstrumentId INT,
	@ExpiryDay INT=NULL,
	@ExpiryMonth INT,
	@ExpiryYear INT,
	@OptionTypeCode VARCHAR(25), 
	@StrikePrice DECIMAL(24,10), 
	@TradePrice DECIMAL(24,10), 
	@SettlementPrice DECIMAL(24,10), 
	@IsBuy BIT,
	@Quantity INT,
	@Value DECIMAL(24,10), 
	@Description VARCHAR(255),
	@CreateUsername VARCHAR(50),
	@AdjustmentID INT OUTPUT
)
AS
SET NOCOUNT ON
/*
	-- Description: Insert new check amount adjustments
	
	-- 25 May 2010		ED		Created
	-- 27 May 2010		ED		MBAL-15678: poke imbalance report
	-- 04 Aug 2010		amk		MBAL-16382: incorrect sign on quantity field
	-- 06 Aug 2010		amk		Externalize calculate imbalance logic so it can be re-used
	-- 16 Jun 2014		ED		EIB 25492 - add timestamp to description
*/
BEGIN TRY
	BEGIN TRAN
	DECLARE @AdjustmentTypeId INT
	DECLARE @AdjustmentHeaderId INT
	DECLARE @InternalExternalCode VARCHAR(1)

	SELECT @InternalExternalCode=InternalExternalCode 
	FROM ib_TemplateCompare
	WHERE TemplateId = @TemplateId 
		AND DataSourceId = @DataSourceId 
		AND FirmId = @FirmId
	
	SELECT @AdjustmentTypeId = AdjustmentTypeId 
	FROM ib_AdjustmentType 
	WHERE Code = ''MI'' --manual insert
	DECLARE @Notes VARCHAR(4000)	
	IF (@Description != '''')
		SET @Notes = @Description + '' (''+@CreateUsername+'', ''+CONVERT(CHAR(10), CURRENT_TIMESTAMP, 103)+'' ''+CONVERT(CHAR(5), CURRENT_TIMESTAMP, 114)+'') ''
	INSERT INTO [dbo].[ib_AdjustmentHeader] ([AdjustmentTypeId]
		, [CreateDate], [CreateUsername], [Description])
	SELECT @AdjustmentTypeId, GETDATE(), @CreateUsername, @Notes
	
	SET @AdjustmentHeaderId = SCOPE_IDENTITY()

	INSERT INTO [dbo].[ib_Adjustment] 
		([TemplateId], [ExchangeId], [InstrumentId], [InternalExternalCode]
		, [TradeDate], [AdjustmentDate]
		, [Quantity]
		, [CurrencyId]
		, [ExpiryYear], [ExpiryMonth], [ExpiryDay], [StrikePrice]
		, [TradePrice], [SettlementPrice], [OptionTypeCode], [VALUE]
		, [CreateDate], [CreateUsername], [IsBuy], [MatchCodeId]
		, [AdjustmentHeaderId], [DataSourceId], [FirmId]
		, [QuantityLong]
		, [QuantityShort]
		, [DetailAccountId], [AccountId])
	SELECT 
		@TemplateId, @ExchangeId, @InstrumentId, @InternalExternalCode
		, @TradeDate, @AdjustmentDate
		, CASE WHEN @IsBuy = 1 THEN @Quantity ELSE @Quantity * -1 END
		, @CurrencyId
		, @ExpiryYear, @ExpiryMonth, @ExpiryDay, @StrikePrice
		, @TradePrice, @SettlementPrice, @OptionTypeCode, @Value
		, GETDATE(), @CreateUsername, @IsBuy, @MatchCodeId
		, @AdjustmentHeaderId, @DataSourceId, @FirmId
		, CASE WHEN @IsBuy = 1 THEN @Quantity ELSE 0 END
		, CASE WHEN @IsBuy = 1 THEN 0 ELSE @Quantity END
		, @DetailAccountId, @AccountId
		
	SELECT @AdjustmentId = SCOPE_IDENTITY()

	DECLARE @ImbalanceReportId INT
	DECLARE @ImbalanceReportSummaryId INT

	DECLARE @temp_ImbalanceReportId TABLE (ImbalanceReportId INT)
	INSERT INTO @temp_ImbalanceReportId(ImbalanceReportId)
		EXEC [dbo].[ib_ImbalanceReport_GetLatestImbalanceReportIdByTemplateIdAndDate] @TemplateId, @AdjustmentDate

	SELECT  @ImbalanceReportId=ImbalanceReportId 
	FROM @temp_ImbalanceReportId

	DECLARE @Ids TABLE(Id INT)
	
	INSERT INTO @Ids(Id)
	SELECT DISTINCT ImbalanceReportSummaryId 
	FROM ib_ImbalanceReportSummary irs
		INNER JOIN ib_MatchCode mc ON mc.MatchCode = irs.Description
	WHERE irs.ExchangeId = @ExchangeId
		AND irs.InstrumentId = @InstrumentId
		AND irs.CurrencyId = @CurrencyId
		AND irs.ExpiryYear = @ExpiryYear
		AND irs.ExpiryMonth = @ExpiryMonth
		AND irs.ExpiryDay = @ExpiryDay
		AND (ISNULL(irs.OptionTypeCode, '''') = ISNULL(@OptionTypeCode, ''''))
		AND (ISNULL(irs.StrikePrice, 0) = ISNULL(@StrikePrice, 0))
		AND mc.MatchCodeId = @MatchCodeId
		AND irs.ImbalanceReportId = @ImbalanceReportId
		
	IF @@ROWCOUNT = 1
		SELECT @ImbalanceReportSummaryId = Id 
		FROM @Ids
		
	--if only one found, update:
	IF @ImbalanceReportSummaryId IS NOT NULL
	BEGIN
		EXEC [dbo].[ib_ImbalanceReport_GatherAdjustments]
			@ImbalanceReportId, @ImbalanceReportSummaryId, @AdjustmentHeaderId

		--calculate Lots and variation
		EXEC ib_ImbalanceReport_CalculateImbalance 
			@ImbalanceReportId, @ImbalanceReportSummaryId
	END

	COMMIT TRAN
END TRY
BEGIN CATCH
	ROLLBACK TRAN
	EXEC [dbo].[sp_RethrowError]
END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[aspnet_Roles_DeleteRole]''
');

GO
SET QUOTED_IDENTIFIER OFF

GO
EXECUTE ('
CREATE PROCEDURE [dbo].[aspnet_Roles_DeleteRole]
    @ApplicationName            nvarchar(256),
    @RoleName                   nvarchar(256),
    @DeleteOnlyIfRoleIsEmpty    bit
AS
SET NOCOUNT ON
BEGIN
    DECLARE @ApplicationId uniqueidentifier
    SELECT  @ApplicationId = NULL
    SELECT  @ApplicationId = ApplicationId FROM aspnet_Applications WHERE LOWER(@ApplicationName) = LoweredApplicationName
    IF (@ApplicationId IS NULL)
        RETURN(1)

    DECLARE @ErrorCode     int
    SET @ErrorCode = 0

    DECLARE @TranStarted   bit
    SET @TranStarted = 0

    IF( @@TRANCOUNT = 0 )
    BEGIN
        BEGIN TRANSACTION
        SET @TranStarted = 1
    END
    ELSE
        SET @TranStarted = 0

    DECLARE @RoleId   uniqueidentifier
    SELECT  @RoleId = NULL
    SELECT  @RoleId = RoleId FROM dbo.aspnet_Roles WHERE LoweredRoleName = LOWER(@RoleName) AND ApplicationId = @ApplicationId

    IF (@RoleId IS NULL)
    BEGIN
        SELECT @ErrorCode = 1
        GOTO Cleanup
    END
    IF (@DeleteOnlyIfRoleIsEmpty <> 0)
    BEGIN
        IF (EXISTS (SELECT RoleId FROM dbo.aspnet_UsersInRoles  WHERE @RoleId = RoleId))
        BEGIN
            SELECT @ErrorCode = 2
            GOTO Cleanup
        END
    END


    DELETE FROM dbo.aspnet_UsersInRoles  WHERE @RoleId = RoleId

    IF( @@ERROR <> 0 )
    BEGIN
        SET @ErrorCode = -1
        GOTO Cleanup
    END

    DELETE FROM dbo.aspnet_Roles WHERE @RoleId = RoleId  AND ApplicationId = @ApplicationId

    IF( @@ERROR <> 0 )
    BEGIN
        SET @ErrorCode = -1
        GOTO Cleanup
    END

    IF( @TranStarted = 1 )
    BEGIN
        SET @TranStarted = 0
        COMMIT TRANSACTION
    END

    RETURN(0)

Cleanup:

    IF( @TranStarted = 1 )
    BEGIN
        SET @TranStarted = 0
        ROLLBACK TRANSACTION
    END

    RETURN @ErrorCode
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[IDEM_DS13_Purge]''
');

GO
SET QUOTED_IDENTIFIER ON

GO
EXECUTE ('
-- =============================================
-- Author:		Lee Manifold
-- Create date: 15 Aug 2006
-- Description:	Deletes records from the [IDEM_DS13]tables
-- =============================================
CREATE PROCEDURE [dbo].[IDEM_DS13_Purge]
	(
	@LoadState		TINYINT = 0,
	@RecordDate		DATETIME = NULL
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	
	--raiserror (''Lee doing specific raiserror in stored proc for testing'', 19, 1) with log
	
	IF @RecordDate IS NOT NULL 
	BEGIN
		--****Need to Add code here to factor in @RecordDate into table fields 
		DELETE 	FROM [dbo].[IDEM_DS13] WHERE LoadState= @LoadState
	END
	
	IF @RecordDate IS NULL 
	BEGIN

		DELETE 	FROM [dbo].[IDEM_DS13] WHERE LoadState= @LoadState

	END
END
');

GO
EXECUTE ('PRINT N''Creating [security].[Feature_GetByFeatureName]''
');

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Select records from the Feature table through an index
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [security].[Feature_GetByFeatureName]
(

	@FeatureName nvarchar (50)  
)
AS


				SELECT
					[FeatureId],
					[FeatureCode],
					[FeatureName]
				FROM
					[security].[Feature]
				WHERE
					[FeatureName] = @FeatureName
				SELECT @@ROWCOUNT
					
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_ImbalanceReportSummary_GetNotes]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_ImbalanceReportSummary_GetNotes]
(
	@ImbalanceReportSummaryId INT
)
AS
-- Revision History
-- 21 May 2014  ED  EIB 25497 - created

SET NOCOUNT ON
SELECT Notes FROM ib_ImbalanceReportSummary WHERE ImbalanceReportSummaryId = @ImbalanceReportSummaryId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Base_CheckForDuplicate]''
');

GO
EXECUTE (' /*
<details>
 <summary>
	Checks for the duplicate bases with same code. 
</summary>
 <created author="Laurentiu Macovei" Date="Thursday, 14 September 2006 15:59PM GMT" /> 
</details>
*/
create PROCEDURE [dbo].[ib_Base_CheckForDuplicate]
@Code varchar(100),
@BaseId int
AS
SET NOCOUNT ON

DECLARE @Count int

SELECT TOP 1 @Count = 1
	FROM [dbo].[ib_Base] c
	WHERE Code = @Code
		AND BaseID <> @BaseId

IF @Count > 0
	RAISERROR (N''There is already another currency with same code (%s). Please specify other code!'', 11, 1, @Code)
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Adjustment_AddFromSSIS]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Adjustment_AddFromSSIS]
(
	@AdjustmentId INT,
	@DataSourceCode VARCHAR(100), 
	@FirmCode VARCHAR(100), 
	@MatchCode VARCHAR(100), 
	@ExchangeCode VARCHAR(100), 
	@AccountCode VARCHAR(100),
	@DetailAccountCode VARCHAR(100) = NULL, 
	@CurrencyCode VARCHAR(100), 
	@InstrumentCode VARCHAR(100),
	@TemplateId INT,
	@AdjustmentDate DATETIME, 
	@TradeDate DATETIME,
	@ExpiryDay INT,
	@ExpiryMonth INT,
	@ExpiryYear INT,
	@OptionTypeCode VARCHAR(25), 
	@StrikePrice DECIMAL(24,10), 
	@TradePrice DECIMAL(24,10), 
	@SettlementPrice DECIMAL(24,10), 
	@IsBuy BIT,
	@Quantity INT,
	@Value DECIMAL(24,10), 
	@Description VARCHAR(255),
	@ReceiveLocationSysId INT,
	@RunId INT,
	@Filename VARCHAR(255),
	@AdjustmentStatusCode VARCHAR(255)
)	
AS
/*
	-- Description: Insert adjustments from SSIS
	
	-- 25 Apr 2014		ED		Created EIB 25494
	-- 07 May 2014		ED		EIB 25605 - don''t fail if adj exist 
*/

BEGIN
	
	SET NOCOUNT ON 
	SELECT 1
	DECLARE @DataSourceId INT, @FirmId INT, @MatchCodeId INT, @ExchangeId INT, @AccountId INT,
		@DetailAccountId INT, @CurrencyId INT, @InstrumentId INT, @CreateUserName VARCHAR(50), @Message VARCHAR(255), @IsError BIT = 0
	
	IF EXISTS (SELECT AdjustmentId FROM ib_Adjustment WHERE AdjustmentId = @AdjustmentId)
	BEGIN
		SET @Message = ''Adjustment already exists '' + CONVERT(VARCHAR(100), @AdjustmentId)
		EXEC Log_Insert @ReceiveLocationSysId, @Filename, ''Orchestrated'', @Message , ''Warning'', '''', @RunId
		RETURN
	END

	SET @DataSourceId = (SELECT DataSourceId FROM ib_DataSource WHERE Code = @DataSourceCode)
	IF @DataSourceId IS NULL
	BEGIN
		SET @Message = ''DataSource not found '' + @DataSourceCode
		EXEC Log_Insert @ReceiveLocationSysId, @Filename, ''Orchestrated'', @Message , ''Error'', '''', @RunId
		SET @IsError = 1
	END
	IF @FirmCode IS NOT NULL AND LTRIM(RTRIM(@FirmCode)) != ''''
	BEGIN
		SET @FirmId = (SELECT FirmId FROM ib_Firm WHERE Code = @FirmCode)
		IF @FirmId IS NULL
		BEGIN
			SET @Message = ''Firm not found '' + @FirmCode
			EXEC Log_Insert @ReceiveLocationSysId, @Filename, ''Orchestrated'', @Message , ''Error'', '''', @RunId
			SET @IsError = 1
		END
	END
	SET @MatchCodeId = (SELECT MatchCodeId FROM ib_MatchCode WHERE MatchCode = @MatchCode AND TemplateId = @TemplateId)
	IF @MatchCodeId IS NULL
	BEGIN
		SET @Message = ''MatchCode not found '' + @MatchCode
		EXEC Log_Insert @ReceiveLocationSysId, @Filename, ''Orchestrated'', @Message , ''Error'', '''', @RunId
		SET @IsError = 1
	END
	SET @ExchangeId = (SELECT ExchangeId FROM ib_Exchange WHERE Code = @ExchangeCode)
	IF @ExchangeId IS NULL
	BEGIN
		SET @Message = ''Exchange not found '' + @ExchangeCode
		EXEC Log_Insert @ReceiveLocationSysId, @Filename, ''Orchestrated'', @Message , ''Error'', '''', @RunId
		SET @IsError = 1
	END
	IF @AccountCode IS NOT NULL AND LTRIM(RTRIM(@AccountCode)) != ''''
	BEGIN
		IF @FirmId IS NOT NULL
			SET @AccountId = (SELECT AccountId FROM ib_Account WHERE Code = @AccountCode AND FirmId = @FirmId)
		IF @AccountId IS NULL
			SET @AccountId = (SELECT AccountId FROM ib_Account WHERE Code = @AccountCode)
		IF @AccountId IS NULL
		BEGIN
			SET @Message = ''Account not found '' + @AccountCode
			EXEC Log_Insert @ReceiveLocationSysId, @Filename, ''Orchestrated'', @Message , ''Error'', '''', @RunId
			SET @IsError = 1
		END
	END
	IF @DetailAccountCode IS NOT NULL AND @FirmId IS NOT NULL AND LTRIM(RTRIM(@DetailAccountCode)) != ''''
	BEGIN
		SET @DetailAccountId = (SELECT AccountId FROM ib_Account WHERE Code = @DetailAccountCode AND FirmId = @FirmId)
		IF @DetailAccountId IS NULL
		BEGIN
			SET @Message = ''DetailAccountCode not found '' + @DetailAccountCode
			EXEC Log_Insert @ReceiveLocationSysId, @Filename, ''Orchestrated'', @Message , ''Error'', '''', @RunId
			SET @IsError = 1
		END
	END
	SET @CurrencyId = (SELECT CurrencyId FROM ib_Currency WHERE Code = @CurrencyCode)
	IF @CurrencyId IS NULL
	BEGIN
		SET @Message = ''Currency not found '' + @CurrencyCode
		EXEC Log_Insert @ReceiveLocationSysId, @Filename, ''Orchestrated'', @Message , ''Error'', '''', @RunId
		SET @IsError = 1
	END
	SET @InstrumentId = (SELECT InstrumentId FROM ib_Instrument WHERE Code = @InstrumentCode)
	IF @InstrumentId IS NULL
	BEGIN
		SET @Message = ''Instrument not found '' + @InstrumentCode
		EXEC Log_Insert @ReceiveLocationSysId, @Filename, ''Orchestrated'', @Message , ''Error'', '''', @RunId
		SET @IsError = 1
	END
	IF @AdjustmentStatusCode IS NOT NULL AND LTRIM(RTRIM(@AdjustmentStatusCode)) != ''U'' AND LTRIM(RTRIM(@AdjustmentStatusCode)) != ''''
	BEGIN
		SET @Message = ''State not open '' + @AdjustmentStatusCode
		EXEC Log_Insert @ReceiveLocationSysId, @Filename, ''Orchestrated'', @Message , ''Warning'', '''', @RunId
		SET @IsError = 1
	END

	IF @IsError = 1
		RETURN
	SET @CreateUserName = SUSER_SNAME()
	EXEC ib_Adjustment_AddAdjustmentWithHeader @TemplateId, @AdjustmentDate, @TradeDate, @DataSourceId, @FirmId, @MatchCodeId, @ExchangeId, @AccountId, 
			@DetailAccountId, @CurrencyId, @InstrumentId, @ExpiryDay, @ExpiryMonth, @ExpiryYear, @OptionTypeCode, @StrikePrice, @TradePrice, @SettlementPrice, @IsBuy,
			@Quantity, @Value, @Description, @CreateUserName, @AdjustmentId

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[aspnet_Roles_GetAllRoles]''
');

GO
SET QUOTED_IDENTIFIER OFF

GO
EXECUTE ('
CREATE PROCEDURE [dbo].[aspnet_Roles_GetAllRoles] (
    @ApplicationName           nvarchar(256))
AS
SET NOCOUNT ON
BEGIN
    DECLARE @ApplicationId uniqueidentifier
    SELECT  @ApplicationId = NULL
    SELECT  @ApplicationId = ApplicationId FROM aspnet_Applications WHERE LOWER(@ApplicationName) = LoweredApplicationName
    IF (@ApplicationId IS NULL)
        RETURN
    SELECT RoleName
    FROM   dbo.aspnet_Roles WHERE ApplicationId = @ApplicationId
    ORDER BY RoleName
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[IDEM_DS14_Add]''
');

GO
SET QUOTED_IDENTIFIER ON

GO
EXECUTE ('-- =============================================
-- Author:		Lee Manifold
-- Create date: 18 Sep 2006
-- Description:	Insert into IDEM_DS14 table
-- =============================================
CREATE PROCEDURE [dbo].[IDEM_DS14_Add]
	(
	@MemberClearCode	varchar(4),
	@DataFileCode		varchar(4),
	@RecordNumber		varchar(6),
	@Date				varchar(8),
	@ABIMemberCode		varchar(5),
	@Account			varchar(1),
	@SubAccount			varchar(4),
	@Symbol				varchar(6),
    @Expiry				varchar(8),
    @Strike				varchar(13),
    @ProductType		varchar(1),
    @InfoType			varchar(2),
    @ISINCode			varchar(12),
    @Description		varchar(20),
    @LongPositions		varchar(20),
    @LongPositionsSign	varchar(1),
    @ShortPositions		varchar(50),
    @ShortPositionsSign	varchar(1),
    @OpenClose			varchar(1),
    @BuySell			varchar(1),
    @MarginValue		varchar(13),
    @DebitCredit		varchar(1),
    @ReferenceNumber	varchar(8),
    @Price				varchar(13),
    @SettlementPrice	varchar(13),
    @ReferenceDate		varchar(8),
    @GCMABIcode			varchar(5)
	)
AS
	BEGIN
		-- SET NOCOUNT ON added to prevent extra result sets from
		-- interfering with SELECT statements.
		SET NOCOUNT ON;

		INSERT INTO [dbo].[IDEM_DS14]
			   (
				[MemberClearingCode],
				[DataFileCode],
				[RecordNumber],
				[Date]
			   ,[ABIMemberCode]
			   ,[Account]
			   ,[SubAccount]
			   ,[Symbol]
			   ,[Expiry]
			   ,[Strike]
			   ,[ProductType]
			   ,[InfoType]
			   ,[ISINCode]
			   ,[Description]
			   ,[LongPositions]
			   ,[LongPositionsSign]
			   ,[ShortPositions]
			   ,[ShortPositionsSign]
			   ,[OpenClose]
			   ,[BuySell]
			   ,[MarginValue]
			   ,[DebitCredit]
			   ,[ReferenceNumber]
			   ,[Price]
			   ,[SettlementPrice]
			   ,[ReferenceDate]
			   ,[GCMABIcode]
				)
		 VALUES
			   (
				@MemberClearCode,
				@DataFileCode,
				@RecordNumber,
				@Date,
				@ABIMemberCode,
				@Account,
				@SubAccount,
				@Symbol,
				@Expiry,
				@Strike,
				@ProductType,
				@InfoType,
				@ISINCode,
				@Description,
				@LongPositions,
				@LongPositionsSign,
				@ShortPositions,
				@ShortPositionsSign,
				@OpenClose,
				@BuySell,
				@MarginValue,
				@DebitCredit,
				@ReferenceNumber,
				@Price,
				@SettlementPrice,
				@ReferenceDate,
				@GCMABIcode
				)
	
	END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Report_GetLatestCompleted]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Report_GetLatestCompleted]
	@UserName NVARCHAR(256)
AS
	--	21 Nov 2010		amk		Creation

	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	-- only selecting most recent of each report type
	-- note this is a hack since there could be different templates
	-- and different as of dates - just for demo purposes

	SELECT ISNULL(ir.Today
					, ISNULL(cr.TodaysDate
						, ISNULL(cl.Date
							, ISNULL(pr.TodaysDate, tr.Today)))) AS AsOfDate
		, r.ReportType, r.Status, r.URL, r.CreateDate, r.WebReportURL, r.ReportId
	FROM aspnet_users u
		JOIN ib_SiteUser su ON su.userid = u.userid
		JOIN ib_Report r ON r.siteid = su.siteid
		LEFT OUTER JOIN ib_ImbalanceReport ir ON r.ReportType = ''Imbalance'' 
			AND r.TargetReportId = ir.ImbalanceReportId
		LEFT OUTER JOIN ib_CashReport cr ON r.ReportType = ''Cash Report'' 
			AND r.TargetReportId = cr.CashReportId
		LEFT OUTER JOIN ib_CloseoutReport cl ON r.ReportType = ''Closeout'' 
			AND r.TargetReportId = cl.CloseoutReportId
		LEFT OUTER JOIN ib_PriceReport pr ON r.ReportType = ''Price Rec'' 
			AND r.TargetReportId = pr.PriceReportId
		LEFT OUTER JOIN ib_TradeReconciliation tr ON r.ReportType = ''TradeRec'' 
			AND r.TargetReportId = tr.TradeReconciliationId
	WHERE u.username = @UserName
		AND r.Status = ''Complete''
		AND r.ReportId IN (SELECT TOP 1 r2.ReportId FROM ib_Report r2 WHERE r2.ReportType = r.ReportType ORDER BY r2.CreateDate DESC)
	ORDER BY r.CreateDate DESC
');

GO
EXECUTE ('PRINT N''Creating [security].[Feature_GetByFeatureId]''
');

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Select records from the Feature table through an index
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [security].[Feature_GetByFeatureId]
(

	@FeatureId int   
)
AS


				SELECT
					[FeatureId],
					[FeatureCode],
					[FeatureName]
				FROM
					[security].[Feature]
				WHERE
					[FeatureId] = @FeatureId
				SELECT @@ROWCOUNT
					
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_ImbalanceReportSummary_GetSummaryByAccountIdAndTransactionDetails]''
');

GO
EXECUTE ('
CREATE Procedure [dbo].[ib_ImbalanceReportSummary_GetSummaryByAccountIdAndTransactionDetails]
(
		@ImbalanceReportSummaryId int
)
AS
SET NOCOUNT ON

/*
<details>
	<summary> Get the Transaction values for a Summary Record</summary>
	<created author="AAJM" Date="16 Jul 2009" />
	<changed ED - MBAL-11570 - OptionTypeCode AND StrikePrice may be null in trx table />
	<changed AM - MBAL-12456 - Trade Level Rec: Drill down to trade level />
	<changed 23 Apr 2010	AAJM	MBAL-15416 Increase size of SettlementPrice field />
</details>
*/

CREATE TABLE #Temp
(
DetailAccountId INT NOT NULL
, AsOfDate DATETIME NOT NULL
, Datasource VARCHAR(100) NOT NULL
, Firm VARCHAR(100) NOT NULL
, Account VARCHAR(100) NOT NULL
, DetailAccount VARCHAR(100) NULL
, IntQuantity DECIMAL(19,4) NOT NULL
, ExtQuantity DECIMAL(19,4) NOT NULL
, MarketValue DECIMAL(19,4) NULL
, Price DECIMAL(24,10) NULL
, TrxDate DATETIME NOT NULL
, [Type] VARCHAR(100) NULL
)

INSERT INTO #Temp
SELECT DetailAccountId = 
CASE WHEN tx.DetailAccountId IS NULL THEN -1
ELSE tx.DetailAccountId
END
, tx.AsOfDate AS AsOfDate
, d.[Name] Datasource
, f.[Name] Firm
, a.[Name] Account
, a2.Name AS DetailAccount
,CASE tc.InternalExternalCode
	WHEN ''I'' THEN Quantity
	ELSE 0
	END AS IntQuantity
,CASE tc.InternalExternalCode
	WHEN ''E'' THEN Quantity
	ELSE 0
	END AS ExtQuantity 
, tx.MarketValue 
, tx.Price
, tx.TrxDate
, tt.Description AS [Type]
FROM [dbo].[ib_ImbalanceReportSummary] irs
	INNER JOIN ib_ImbalanceReport ir ON ir.ImbalanceReportId=irs.ImbalanceReportId
	INNER JOIN ib_ImbalanceReportDetail ird ON ird.ImbalanceReportId=ir.ImbalanceReportId
		AND ird.[ExchangeId]=irs.[ExchangeId]
		AND ird.[InstrumentId]=irs.[InstrumentId]
		AND ird.[CurrencyId]=irs.[CurrencyId]
		AND ird.[ExpiryMonth]=irs.[ExpiryMonth]
		AND ird.[ExpiryYear]=irs.[ExpiryYear]
		AND (ird.[ExpiryDay]=irs.[ExpiryDay] OR (ird.[ExpiryDay] IS NULL AND irs.[ExpiryDay] IS NULL))
		AND ISNULL(ird.[OptionTypeCode],'''')=ISNULL(irs.[OptionTypeCode],'''')
		AND ISNULL(ird.[StrikePrice],0)=ISNULL(irs.[StrikePrice],0)
	INNER JOIN ib_ImbalanceReportPhase2Trace IRP2T ON irs.Description=irp2t.Description 
		AND ird.ImbalanceReportDetailId=irp2t.ImbalanceReportDetailId
	INNER JOIN ib_Trx tx ON tx.ExchangeId=ird.ExchangeId
		AND tx.FirmId = ird.FirmId
		AND (tx.AccountId=ird.AccountId OR (tx.AccountId IS NULL AND ird.AccountId IS NULL))
		AND tx.InstrumentId=ird.InstrumentId
		AND (tx.ClassId=ird.ClassId OR (tx.ClassId IS NULL AND ird.ClassId IS NULL))
		AND tx.ExpiryYear=ird.ExpiryYear
		AND tx.ExpiryMonth=ird.ExpiryMonth	
		AND (tx.ExpiryDay=ird.ExpiryDay OR (tx.ExpiryDay IS NULL AND ird.ExpiryDay IS NULL))
		AND ISNULL(tx.OptionTypeCode,'''')=ISNULL(ird.OptionTypeCode,'''')
		AND tx.CurrencyId=ird.CurrencyId
		AND ISNULL(tx.StrikePrice,0)=ISNULL(ird.StrikePrice,0)
		AND (tx.AsOfDate=ir.Today OR tx.AsOfDate=ir.Yesterday)
	INNER JOIN ib_Template t ON t.TemplateId=ir.TemplateId
	INNER JOIN ib_TemplateCompare tc ON tc.TemplateId=t.TemplateId AND tc.DataSourceId=tx.DataSourceId AND tc.FirmId=tx.FirmId
	INNER JOIN ib_Datasource d ON d.DatasourceId=tx.DataSourceId
	INNER JOIN ib_Firm f ON f.FirmId=tx.FirmId
	INNER JOIN ib_Account a ON a.AccountId=tx.AccountId
	LEFT JOIN ib_Account a2 ON a2.AccountId = tx.DetailAccountId
	INNER JOIN ib_TrxType tt ON tx.TrxTypeCode = tt.Code
WHERE ImbalanceReportSummaryId=@ImbalanceReportSummaryId
ORDER BY AsOfDate, Datasource, Firm, Account, Quantity, MarketValue

SELECT DetailAccountId, DetailAccount, SUM(IntQuantity) AS IntQuantityTotal, SUM(ExtQuantity) AS ExtQuantityTotal, (SUM(IntQuantity) - SUM(ExtQuantity)) AS Diff
FROM #Temp
GROUP BY DetailAccountId, DetailAccount

SELECT * FROM #Temp
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Base_GetBaseById]''
');

GO
EXECUTE (' /*
<details>
 <summary> Selects a base from the ib_Base table by its id</summary>
 <created author="Laurentiu Macovei" Date=" Thursday 14 September 2006 9:26PM GMT" /> 
</details>
*/
CREATE PROCEDURE [dbo].[ib_Base_GetBaseById]
	@BaseId int
AS
SET NOCOUNT ON
SELECT * FROM [dbo].[ib_Base]
	WHERE BaseID = @BaseID
');

GO
EXECUTE ('PRINT N''Creating [dbo].[aspnet_Roles_RoleExists]''
');

GO
SET QUOTED_IDENTIFIER OFF

GO
EXECUTE ('
CREATE PROCEDURE [dbo].[aspnet_Roles_RoleExists]
    @ApplicationName  nvarchar(256),
    @RoleName         nvarchar(256)
AS
SET NOCOUNT ON
BEGIN
    DECLARE @ApplicationId uniqueidentifier
    SELECT  @ApplicationId = NULL
    SELECT  @ApplicationId = ApplicationId FROM aspnet_Applications WHERE LOWER(@ApplicationName) = LoweredApplicationName
    IF (@ApplicationId IS NULL)
        RETURN(0)
    IF (EXISTS (SELECT RoleName FROM dbo.aspnet_Roles WHERE LOWER(@RoleName) = LoweredRoleName AND ApplicationId = @ApplicationId ))
        RETURN(1)
    ELSE
        RETURN(0)
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[IDEM_DS14_LoadStateChange]''
');

GO
SET QUOTED_IDENTIFIER ON

GO
EXECUTE ('
-- =============================================
-- Author:		Lee Manifold
-- Create date: 18 Sep 2006
-- Description:	Changes the LoadState of the IDEM_DS14 type table
-- =============================================
CREATE PROCEDURE [dbo].[IDEM_DS14_LoadStateChange] 
	-- Add the parameters for the stored procedure here
	(
	@OldLoadState	TINYINT,
	@NewLoadState	TINYINT,
	@RecordDate		DATETIME = NULL
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	-- Need to add code to handle RecordDate
	IF @RecordDate IS NOT NULL 
	BEGIN

		UPDATE [dbo].[IDEM_DS14] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState

	END

	IF @RecordDate IS NULL 
	BEGIN

		UPDATE [dbo].[IDEM_DS14] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState

	END


END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[vw_aspnet_MembershipUsers]''
');

GO
SET QUOTED_IDENTIFIER OFF

GO
EXECUTE ('
  CREATE VIEW [dbo].[vw_aspnet_MembershipUsers]
  AS SELECT [dbo].[aspnet_Membership].[UserId],
            [dbo].[aspnet_Membership].[PasswordFormat],
            [dbo].[aspnet_Membership].[MobilePIN],
            [dbo].[aspnet_Membership].[Email],
            [dbo].[aspnet_Membership].[LoweredEmail],
            [dbo].[aspnet_Membership].[PasswordQuestion],
            [dbo].[aspnet_Membership].[PasswordAnswer],
            [dbo].[aspnet_Membership].[IsApproved],
            [dbo].[aspnet_Membership].[IsLockedOut],
            [dbo].[aspnet_Membership].[CreateDate],
            [dbo].[aspnet_Membership].[LastLoginDate],
            [dbo].[aspnet_Membership].[LastPasswordChangedDate],
            [dbo].[aspnet_Membership].[LastLockoutDate],
            [dbo].[aspnet_Membership].[FailedPasswordAttemptCount],
            [dbo].[aspnet_Membership].[FailedPasswordAttemptWindowStart],
            [dbo].[aspnet_Membership].[FailedPasswordAnswerAttemptCount],
            [dbo].[aspnet_Membership].[FailedPasswordAnswerAttemptWindowStart],
            [dbo].[aspnet_Membership].[Comment],
            [dbo].[aspnet_Users].[ApplicationId],
            [dbo].[aspnet_Users].[UserName],
            [dbo].[aspnet_Users].[MobileAlias],
            [dbo].[aspnet_Users].[IsAnonymous],
            [dbo].[aspnet_Users].[LastActivityDate]
  FROM [dbo].[aspnet_Membership] INNER JOIN [dbo].[aspnet_Users]
      ON [dbo].[aspnet_Membership].[UserId] = [dbo].[aspnet_Users].[UserId]
  
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Report_GetReportByIdAndUserId]''
');

GO
SET QUOTED_IDENTIFIER ON

GO
EXECUTE ('/*
<details>
	<summary> Returns the url for a specific report id and user id. </summary>
	<created author="Laurentiu Macovei" Date="Saturday, 07 Aug 2006 04:26PM GMT" />
</details>
*/
CREATE PROCEDURE [dbo].[ib_Report_GetReportByIdAndUserId]
	@ReportId int,
	@UserId uniqueidentifier
AS
SET NOCOUNT ON
SELECT [r].[Url]
	FROM [dbo].[ib_Report] r
		INNER JOIN [dbo].[ib_Site] s ON [s].SiteId = [r].[SiteId] AND [r].[ReportId] = @ReportId
		INNER JOIN [dbo].[ib_SiteUser] su ON [su].[SiteId] = [s].[SiteID] AND [su].[UserId] = @UserId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[vw_ib_CashReport_BrokerData_Get_List]''
');

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Gets all records from the vw_ib_CashReport_BrokerData view
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[vw_ib_CashReport_BrokerData_Get_List]

AS


                    
                    SELECT
                        [DataSourceId],
                        [BrokerName],
                        [CurrencyId],
                        [CurrencyCode],
                        [CurrencyName],
                        [TemplateTypeClassId],
                        [TemplateTypeClassCode],
                        [MatchCode],
                        [TemplateTypeClassName],
                        [InstrumentTypeCode],
                        [InstrumentTypeName],
                        [Internal_TOTE],
                        [Internal_PandS],
                        [Internal_AdjOTE],
                        [Internal_AdjSegNon],
                        [External_TOTE],
                        [External_PandS],
                        [External_AdjOTE],
                        [External_AdjSegNon],
                        [Difference],
                        [CashReportId],
                        [InstrumentTypeId],
                        [MatchCodeId],
                        [TodaysDate],
                        [cheque_adj]
                    FROM
                        [dbo].[vw_ib_CashReport_BrokerData]
                        
                    SELECT @@ROWCOUNT			
                

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_ImbalanceReportSummary_UpdateNotes]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_ImbalanceReportSummary_UpdateNotes]
(
	@ImbalanceReportSummaryId INT,
	@Notes VARCHAR(4000)
)
AS
-- Revision History
-- 21 May 2014  ED  EIB 25497 - created

SET NOCOUNT ON
UPDATE ib_ImbalanceReportSummary SET Notes = @Notes WHERE ImbalanceReportSummaryId = @ImbalanceReportSummaryId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Base_GetCodeAndBaseIdForAllBases]''
');

GO
EXECUTE (' /*
<details>
 <summary>
	Selects all the code and baseId from ib_Base table
</summary>
 <created author="Laurentiu Macovei" Date="Thursday, 14 September 2006 16:28PM GMT" /> 
</details>
-- 23 Jun 2010 ED MBAL 15913 - Tidy up Trade/Settlement Price Corrections for Rounded Prices
*/
create PROCEDURE [dbo].[ib_Base_GetCodeAndBaseIdForAllBases]
AS
SET NOCOUNT ON

SELECT b.[Code] as Code, b.[BaseId], b.Name
	FROM [dbo].[ib_Base] b
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ReturnLastValueInSeparatedList]''
');

GO
EXECUTE ('CREATE FUNCTION [dbo].[ReturnLastValueInSeparatedList]
(
	@separatedString NVARCHAR(50)
	, @separator CHAR(1)
)
RETURNS NVARCHAR(50)
AS
-- Description: Returns the last value from a separated list
-- 26 May 2010	AAJM	Creation

BEGIN

	DECLARE @position INT
	SET @position = LEN(@separatedString )
	
	DECLARE @thisChar CHAR(1)
	SET @thisChar = NULL
	
	DECLARE @foundSeparator BIT
	SET @foundSeparator = 0
	
	WHILE (@foundSeparator = 0 AND @position > 0)
		BEGIN
			SET @thisChar = SUBSTRING(@separatedString , @position, 1)
			
			IF @thisChar = @separator
				BREAK
					
			SET @position = @position - 1
	
		END

	DECLARE @result NVARCHAR(50)
	SET @result = RIGHT(@separatedString , LEN(@separatedString ) - @position)

	RETURN @result

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Adjustment_GetAdjustmentsFormattedForRolfeNolanExport]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Adjustment_GetAdjustmentsFormattedForRolfeNolanExport]
	@AsOfDate DATETIME = NULL
AS
SET NOCOUNT ON

-- Description: Returns adjustments for AsOfDate in format ready for inclusion
-- in a file for import into Rolfe and Nolan.
-- See User Story MBAL-14031d Adjustment List v2.doc "Export to R&N" section.
-- 26 May 2010	AAJM	Creation
-- 30 Jun 2010	AAJM	Modifications incl. Don''t include null or unapproved accounts and StrikePriceDivisor etc
-- 05 Jul 2010  AAJM	Fix up erroneous code

BEGIN

	IF @AsOfDate IS NULL 
		EXEC ib_Adjustment_GetLatestAsOfDate @AsOfDate OUTPUT
	
	DECLARE @RolfeNolanDataSourceId INT
	SELECT @RolfeNolanDataSourceId = DataSourceId FROM ib_DataSource WHERE Code = ''RolfeNolan''
	
	DECLARE @separator CHAR(1)
	SET @separator = ''_''
	
	DECLARE @currentDate NVARCHAR(8)
	SELECT @currentDate = CONVERT(VARCHAR(8), GETDATE(), 112) 
	
	-- Header Record
	SELECT  
	''000000'' AS Sequence_Number
	, ''H'' AS Operation
	, SPACE(6) AS Reference_Sequence
	, @currentDate AS Serial_Date
	
	
	DECLARE @tblDetails TABLE
	(
		[Sequence_Number] INT IDENTITY(1,1)
		, [Serial_Date] DATETIME
		, [Instrument] NVARCHAR(4)
		, [Delivery_Date] NVARCHAR(8)
		, [Trade_Type] NVARCHAR(1)
		, [Exercise_Price] DECIMAL(19,4)
		, [Buy_Sell] NVARCHAR(1)
		, [Volume] DECIMAL(19,4)
		, [Price] DECIMAL (24,10)
		, [Account] VARCHAR(100)
	)
	
	 
	-- Get Data for Detail Records
	INSERT INTO @tblDetails 
	(
		[Serial_Date]
		, [Instrument]
		, [Delivery_Date]
		, [Trade_Type]
		, [Exercise_Price]
		, [Buy_Sell]
		, [Volume]
		, [Price]
		, [Account]
	)
SELECT 
		 a.TradeDate AS [Serial_Date]
		, [dbo].[ReturnLastValueInSeparatedList](ids.DataSourceInstrumentCode, @separator) AS [Instrument]
		, CONVERT(VARCHAR(4), a.ExpiryYear) + RIGHT(''00'' + CONVERT(VARCHAR,a.ExpiryMonth), 2) + ''01'' AS [Delivery_Date]
		, CASE (LEFT(ids.DataSourceInstrumentCode, 1))
			WHEN ''F'' THEN ''F''
			WHEN ''O'' THEN CONVERT(NVARCHAR(1), a.OptionTypeCode)
		END AS [Trade_Type]
		, a.StrikePrice * ISNULL(ids.StrikePriceDivisor, 1) AS [Exercise_Price] 
		, CASE
			WHEN a.QuantityShort <> 0 THEN ''S''
			ELSE ''B''		   
		END AS [Buy_Sell]
		, [a].[Quantity] AS [Volume]
		-- Conversion for TradePrice if necessary (TBA)
		--, dbo.ConvertFromBase10((a.[TradePrice] * ISNULL(ids.PriceDivisor, 1)), b.Base) AS [Price]
		, a.[TradePrice] * ISNULL(ids.PriceDivisor, 1) AS [Price]
		, ac.Code AS [Account]		
	FROM ib_Adjustment a
	INNER JOIN ib_AdjustmentHeader ah ON ah.AdjustmentHeaderId=a.AdjustmentHeaderId
	INNER JOIN ib_AdjustmentType at ON at.AdjustmentTypeId=ah.AdjustmentTypeId
	INNER JOIN ib_InstrumentDataSource ids ON a.InstrumentId = ids.InstrumentId AND ids.DataSourceId = @RolfeNolanDataSourceId
	INNER JOIN ib_Account ac ON a.AccountId = ac.AccountId
	LEFT OUTER JOIN ib_Base b ON b.BaseId = ids.BaseId
	WHERE a.AdjustmentDate = @AsOfDate
	AND a.InternalExternalCode = ''I'' AND at.Code = ''TI''
	AND (a.AccountId IS NOT NULL AND ac.IsApproved = 1) -- Must be approved	
	
	-- Formatting
	SELECT
		RIGHT(''000000'' + CONVERT(VARCHAR, det.[Sequence_Number]), 6) AS [Sequence_Number]
		, ''I'' AS [Operation]
		, SPACE(6) AS [Reference_Sequence] 
		, CONVERT(VARCHAR(8), det.[Serial_Date] , 112)  AS [Serial_Date]
		, LEFT (det.[Instrument] + ''    '', 4)
		, det.[Delivery_Date]
		, det.[Trade_Type]
		, LEFT (CONVERT(VARCHAR, det.[Exercise_Price]) + ''00000000000000000000'' , 20) AS [Exercise_Price]
		, SPACE(8) AS [Option_Date] 
		, det.[Buy_Sell]
		, RIGHT(''00000'' + CONVERT(VARCHAR,CONVERT(INT, [det].[Volume])), 5) AS [Volume] 
		-- Price:
		-- Format so that it is returned as 12 characters.
		-- Should not have a decimal point if the number has no fractional part.
		, CASE 
		   	  WHEN ( det.[Price] = FLOOR(det.[Price]))
			 	  THEN (RIGHT (''000000000000'' + CONVERT(VARCHAR,CONVERT(INT, det.[Price])) , 12))
			  ELSE
				  (LEFT (CONVERT(VARCHAR,det.[Price]) + ''000000000000'', 12))		
		  END AS [Price]
		, ''A'' AS [Action]
		, LEFT(det.[Account] + ''      '', 6) AS [Account]			
		, SPACE(6) AS [Counterparty_Code] 
		, SPACE(25) AS [Interface_Account] 
		, SPACE(8) AS [Slip_Number] 
		, SPACE(32) AS [BO_Overrides] 
		, SPACE(13) AS [Execution_Details] 
		, SPACE(763) AS [Other_Details]
		, RIGHT(''000000'' + CONVERT(VARCHAR, [Sequence_Number] - 1), 6) AS [Sequence_Number] -- Last detail record
		, ''T'' AS [Operation]
		, SPACE(6) AS [Reference_Sequence]
		, @currentDate AS [Serial_Date]
	FROM @tblDetails det
	
	-- Trailer Record
	SELECT  
	(RIGHT(''000000'' + CONVERT(VARCHAR,(SELECT MAX(Sequence_Number) FROM @tblDetails)), 6)) AS [Sequence_Number] -- Last detail record
	, ''T'' AS Operation
	, SPACE(6) AS Reference_Sequence
	, @currentDate AS Serial_Date
	
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[IDEM_DS14_Purge]''
');

GO
EXECUTE ('

-- =============================================
-- Author:		Lee Manifold
-- Create date: 18 Aug 2006
-- Description:	Deletes records from the [IDEM_DS14]tables
-- =============================================
CREATE PROCEDURE [dbo].[IDEM_DS14_Purge]
	(
	@LoadState		TINYINT = 0,
	@RecordDate		DATETIME = NULL
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	
	--raiserror (''Lee doing specific raiserror in stored proc for testing'', 19, 1) with log
	
	IF @RecordDate IS NOT NULL 
	BEGIN
		--****Need to Add code here to factor in @RecordDate into table fields 
		DELETE 	FROM [dbo].[IDEM_DS14] WHERE LoadState= @LoadState
	END
	
	IF @RecordDate IS NULL 
	BEGIN

		DELETE 	FROM [dbo].[IDEM_DS14] WHERE LoadState= @LoadState

	END
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_ImbalanceReportSummary_ValidateAdjustments]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_ImbalanceReportSummary_ValidateAdjustments]
(
	@ImbalanceReportSummaryId1 int
	,@ImbalanceReportSummaryId2 int
)
AS
SET NOCOUNT ON
/*
<details>
	<summary> Validates that selected records have same required values</summary>
	<created author="ED" Date="05 May 2010" />
</details>
*/
BEGIN
IF EXISTS(SELECT ImbalanceReportId FROM
			ib_ImbalanceReportSummary irs1 WHERE
				irs1.ImbalanceReportSummaryId = @ImbalanceReportSummaryId1
				AND EXISTS(SELECT ImbalanceReportId FROM
					ib_ImbalanceReportSummary irs2 WHERE
					irs2.ImbalanceReportSummaryId = @ImbalanceReportSummaryId2
					AND irs1.[ExchangeId] = irs2.[ExchangeId]
					AND irs1.[InstrumentId] = irs2.[InstrumentId]
					AND irs1.[ExpiryYear] = irs2.[ExpiryYear]
					AND irs1.[ExpiryMonth] = irs2.[ExpiryMonth]
					AND irs1.[ExpiryDay] = irs2.[ExpiryDay]
					AND irs1.[OptionTypeCode] = irs2.[OptionTypeCode]
					AND irs1.[CurrencyId] = irs2.[CurrencyId]
					AND irs1.[StrikePrice] = irs2.[StrikePrice]
					)
				)
	SELECT 1
ELSE
SELECT 0
END
');

GO
EXECUTE ('PRINT N''Creating [stage].[Europower_Load]''
');

GO
EXECUTE ('CREATE procedure [stage].[Europower_Load]
	(
		@LocationPath VARCHAR(100)
		,@ReceiveLocationSysId INT
		,@RunId INT
	)
AS
SET NOCOUNT ON

/*
Description:  This stored procedure pulls data from the stage.Europower
table and inserts it into the ib_Position ./ ib_trx table.  Also, any
new values encountered for firm, account, instrument, and currency create
new values in the lookups, as well as new values in the data tables for
these values.

Whilst iterating through the records in stage.Europower, all 
of these inserts are wrapped in a transaction so that any failure causes
the changes to not commit.

29 Jun 2016		ED		EIB 39182 - Created
*/

	/*
	Logic:  Get all the Positional data. Update the Production tables
			Get all the Transactional data. Updat the Production tables
	*/
	DECLARE @DataSourceCd VARCHAR(100)
	DECLARE @TrxTypePos VARCHAR(4)
	DECLARE @TrxTypeTrade VARCHAR(3)
	DECLARE @TrxTypeTradeAmended VARCHAR(4)

	SET @DataSourceCd = ''EEX''
	SET @TrxTypePos = ''END''
	SET @TrxTypeTrade = ''000''
	SET @TrxTypeTradeAmended = ''000a''

	DECLARE @ReturnValue				INT
	DECLARE	@Output						INT  
	DECLARE	@Output2					INT
	DECLARE @DataSourceId				INT
	DECLARE @Code						VARCHAR(100)
	DECLARE @DefaultCurrencyId	INT

	--Gets the DataSource and DefaultCurrencyId values
	SET @Code = @DataSourceCd
	EXEC @ReturnValue = [dbo].[_ib_DataSource_GetByCodeForOutput] @Code, @OutPut OUTPUT, @Output2 OUTPUT
	SET @DataSourceId = @Output
	SET @DefaultCurrencyId = @Output2

	-- Duplicate file check										
	DECLARE @IsFileAlreadyLoaded INT
	EXEC @IsFileALreadyLoaded = HasFileBeenLoaded @LocationPath, @DataSourceId

	IF @IsFileAlreadyLoaded = 1
	BEGIN
		UPDATE [stage].[Europower]
		SET [LoadState] = 3
		WHERE [LoadState] = 1
			AND [FileName] = @LocationPath -- Is there a Filename column?
		
		RETURN
	END
	
	-- Store ImportFile record to be associated with Settlement Price load
	DECLARE @ImportFileId INT
	EXEC ib_ImportFile_Add @DataSourceId, @LocationPath, @ImportFileId OUTPUT
	DECLARE @SelectedAsOfDate DATETIME
	--Gets the defaultStrikePriceDivisor
	DECLARE	@DefaultStrikePriceDivisor	DECIMAL(19,6)
	SET @DefaultStrikePriceDivisor = [dbo].[udf_GetDefaultStrikePriceDivisor](@DataSourceId, NULL)

	DECLARE @SwapQuantity INT

	CREATE TABLE #TempPos
	(
		[ID]					INT,
		[ExchangeCode]			VARCHAR(4), 
		[FirmCode]				VARCHAR(5),
		[AccountID]				VARCHAR(32),
		[InstrumentCode]		VARCHAR(10), 
		[InstrumentTypeCode]	VARCHAR(1),
		[SumtrnLngQty]			INT, --Quantity Lng-sht 
		[SumtrnShtQty]			INT, 
		[CurrencyCode]			VARCHAR(3), 
		[MarketValue]			VARCHAR(20),			
		[ExpiryYear]			INT, 
		[ExpiryMonth]			INT, 
		[StrikePrice]			INT, 
		[OptionTypeCode]		VARCHAR(1),
		[rptPrntEffDat]			DATETIME,
		[CntrVersNo]			INT,
		[CurrSetlmtPrc]			VARCHAR(20)
	)
			
	INSERT INTO #TempPos
	(
		[ID],
		[ExchangeCode],
		[FirmCode],			
		[AccountID],
		[InstrumentCode],
		[InstrumentTypeCode],
		[SumtrnLngQty],			
		[SumtrnShtQty],			
		[CurrencyCode],			
		[MarketValue],						
		[ExpiryYear],			
		[ExpiryMonth],			
		[StrikePrice],			
		[OptionTypeCode],
		[rptPrntEffDat],
		[CntrVersNo],
		[CurrSetlmtPrc]
	)
	SELECT [EuropowerID],
				''XEUR'',
				[membexchIDCod], 
				[accTypGrp],
				[ProdID], 
				LEFT([ProdTypId],1),
				[sumtrnLngQty],
				[sumtrnShtQty],
				[currTypCod],
				[sumCntrPrmVmarAmnt],		
				[CntrExpYrDat],
				[CntrExpMthDat],
				[cntrExerPrc],
				[cntrClasCod],
				[rptPrntEffDat],
				[CntrVersNo],
				[currSetlmtPrc]
	FROM [stage].[Europower] e
		JOIN [dbo].[ib_TrxType]
			ON [ib_TrxType].[Code] = e.[TrnTyp] 
				AND ib_TrxType.DataSourceId = @DataSourceId
	WHERE [LoadState] = 1
		AND [ib_TrxType].[IsPosition] = 1
		AND [ib_TrxType].[code] = @TrxTypePos
		AND [FileName] = @LocationPath

	--rd - make sure the As Of Date is not older than acceptable	
	DECLARE @CheckAsOfDate DATETIME
	SET @CheckAsOfDate = (SELECT MIN(rptPrntEffDat) AS CheckRunDate FROM #TempPos WHERE rptPrntEffDat IS NOT NULL)
	IF (@CheckAsOfDate IS NOT NULL)
	BEGIN		
		DECLARE @IsAcceptable bit
		EXECUTE [dbo].[Load_IsFileTooOld] @DataSourceId,@LocationPath,@CheckAsOfDate,@IsAcceptable OUTPUT, @ReceiveLocationSysId, @RunId
		IF (@IsAcceptable = 0)
		BEGIN
			DROP TABLE #TempPos
			UPDATE [stage].[Europower] SET [LoadState] = 3 WHERE [Filename] = @LocationPath
			RAISERROR (''File is too old.'', 18, 0)
			RETURN
		END
	END	

	CREATE TABLE #TempQuantitiesSource
	(
		[ID]					INT,
		[InstrumentCode]		VARCHAR(10), 
		[InstrumentTypeCode]	VARCHAR(1),
		[CurrencyCode]			VARCHAR(3), 
		[trnLngQty]				INT, --Quantity Lng-sht 
		[trnShtQty]				INT, 
		[ExpiryYear]			INT, 
		[ExpiryMonth]			INT, 
		[StrikePrice]			DECIMAL(19,6), 
		[OptionTypeCode]		VARCHAR(1),
		[FirmCd]				VARCHAR(5),	
		[AccountCd]				VARCHAR(32)
	)

	INSERT INTO #TempQuantitiesSource
	(
		[ID],
		[InstrumentCode], 
		[InstrumentTypeCode],
		[CurrencyCode],
		[trnLngQty],
		[trnShtQty], 
		[ExpiryYear], 
		[ExpiryMonth], 
		[StrikePrice], 
		[OptionTypeCode],
		[FirmCd],	
		[AccountCd]
	)
	SELECT [EuropowerID],
				[ProdID], 
				LEFT([ProdTypId],1),
				[currTypCod],
				[trnLngQty],
				[trnShtQty], 
				[CntrExpYrDat],
				[CntrExpMthDat],
				[cntrExerPrc],
				[cntrClasCod],
				[MembExchIdCod],	
				[accTypGrp]
	FROM [stage].[Europower] e
		JOIN ib_TrxType
			ON ib_TrxType.Code = e.TrnTyp
				AND ib_TrxType.DataSourceId = @DataSourceId
	WHERE LoadState = 1
		AND (ib_TrxType.IsTrade = 1 OR ib_TrxType.Code IN (''020'', ''021'', ''030'', ''031'', ''035'', ''040'', ''043'', ''044'', ''045'', ''046''))
		AND FileName = @LocationPath
	
	CREATE TABLE #TempQuantitiesDestination
	(
		[DestID]					INT IDENTITY(1,1) NOT NULL,
		[InstrumentCode]		VARCHAR(10), 
		[InstrumentTypeCode]	VARCHAR(1),
		[CurrencyCode]			VARCHAR(3), 
		[ExpiryYear]			INT, 
		[ExpiryMonth]			INT, 
		[StrikePrice]			DECIMAL(19,6) null, 
		[OptionTypeCode]		VARCHAR(1) null,
		[FirmCd]				VARCHAR(5),	
		[AccountCd]				VARCHAR(32)
		CONSTRAINT [PK_#TempQuantitiesDestination] PRIMARY KEY CLUSTERED 
	(	[DestID] ASC
	)	WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
	) ON [PRIMARY]
	
	CREATE TABLE #TempQuantityValues
	(
		[ID]					INT NOT NULL,
		[trnLngQty]				DECIMAL(19,4),  
		[trnShtQty]				DECIMAL(19,4) 
	)

	INSERT INTO #TempQuantitiesDestination
	(
		[InstrumentCode], 
		[InstrumentTypeCode],
		[CurrencyCode],
		[ExpiryYear], 
		[ExpiryMonth], 
		[StrikePrice], 
		[OptionTypeCode],
		[FirmCd],	
		[AccountCd]
	)
	SELECT DISTINCT [InstrumentCode], 
					  [InstrumentTypeCode],
					  [CurrencyCode],
					  [ExpiryYear], 
					  [ExpiryMonth], 
					  [StrikePrice], 
					  [OptionTypeCode],
					  [FirmCd],	
					  [AccountCd]
	FROM #TempQuantitiesSource

	INSERT INTO #TempQuantityValues
	(
		[ID], 
		[trnLngQty],
		[trnShtQty]
	)
	SELECT [DestID], 0, 0
	FROM #TempQuantitiesDestination

	BEGIN TRAN TradedQuantTran

	-- BizTalk''s SQL Adapter uses more restrictive read serializable
	-- so this is necessary to relax it to something that is default
	-- and perfectly acceptable!
	SET TRANSACTION ISOLATION LEVEL READ COMMITTED

	DECLARE @DestId						INT
	DECLARE @trdQuantLongSum			INT
	DECLARE @trdQuantShortSum			INT
	DECLARE	@InstrumentCodeDest			VARCHAR(10)
	DECLARE	@InstrumentTypeCodeDest		VARCHAR(1)
	DECLARE	@CurrencyCodeDest			VARCHAR(3) 
	DECLARE	@trnLngQtyDest				DECIMAL(19,4)
	DECLARE	@trnShtQtyDest				DECIMAL(19,4) 
	DECLARE	@ExpiryYearDest				INT 
	DECLARE	@ExpiryMonthDest			INT 
	DECLARE	@StrikePriceDest			DECIMAL(19,6) 
	DECLARE	@OptionTypeCodeDest			VARCHAR(1)
	DECLARE @FirmCod						VARCHAR(5)
	DECLARE	@AccountCod					VARCHAR(32)

	DECLARE pos_cursor_dest CURSOR FOR
		SELECT 	[DestID],
				[InstrumentCode], 
				[InstrumentTypeCode],
				[CurrencyCode],
				[ExpiryYear], 
				[ExpiryMonth], 
				[StrikePrice], 
				[OptionTypeCode],
				[FirmCd],	
				[AccountCd]
		FROM #TempQuantitiesDestination
		
		OPEN pos_cursor_dest

		FETCH NEXT FROM pos_cursor_dest
		INTO	
				 @DestId,					
				 @InstrumentCodeDest,
				 @InstrumentTypeCodeDest,
				 @CurrencyCodeDest, 
				 @ExpiryYearDest, 
				 @ExpiryMonthDest,
				 @StrikePriceDest, 
				 @OptionTypeCodeDest,
				 @FirmCod,
				 @AccountCod

		WHILE @@FETCH_STATUS = 0
		BEGIN

				 SELECT @trdQuantLongSum = SUM([trnLngQty]), @trdQuantShortSum = SUM([trnShtQty])
				 FROM #TempQuantitiesSource
				 WHERE [InstrumentCode] = @InstrumentCodeDest AND 
						[InstrumentTypeCode] = @InstrumentTypeCodeDest AND
						[CurrencyCode] = @CurrencyCodeDest AND
						[ExpiryYear] = @ExpiryYearDest AND
						[ExpiryMonth] = @ExpiryMonthDest AND
						[FirmCd] = @FirmCod AND	
						[AccountCd] = @AccountCod AND
						((@StrikePriceDest is not null AND [StrikePrice] = @StrikePriceDest) OR [StrikePrice] is null) AND
						((@OptionTypeCodeDest is not null AND [OptionTypeCode] = @OptionTypeCodeDest) OR [OptionTypeCode] is null)

				 SET @trnLngQtyDest = CAST(@trdQuantLongSum as DECIMAL(19,4))
				 SET @trnShtQtyDest = CAST(@trdQuantShortSum as DECIMAL(19,4))

				 UPDATE #TempQuantityValues
				 SET [trnLngQty] = @trnLngQtyDest,
					 [trnShtQty] = @trnShtQtyDest
				 WHERE [ID] = @DestId 

				 SET @StrikePriceDest = null
				 SET @OptionTypeCodeDest = null	

		FETCH NEXT FROM pos_cursor_dest
		INTO	
				 @DestId,					
				 @InstrumentCodeDest,
				 @InstrumentTypeCodeDest,
				 @CurrencyCodeDest, 
				 @ExpiryYearDest, 
				 @ExpiryMonthDest,
				 @StrikePriceDest, 
				 @OptionTypeCodeDest,
				 @FirmCod,
				 @AccountCod

	END

	CLOSE pos_cursor_dest
	DEALLOCATE pos_cursor_dest

	COMMIT TRAN TradedQuantTran

	DROP TABLE #TempQuantitiesSource
	
	BEGIN TRAN T1

		-- BizTalk''s SQL Adapter uses more restrictive read serializable
		-- so this is necessary to relax it to something that is default
		-- and perfectly acceptable!
		SET TRANSACTION ISOLATION LEVEL READ COMMITTED

		DECLARE @tmpID					INT
		DECLARE @tmpExchangeCode		VARCHAR(4) 
		DECLARE @tmpFirmCode			VARCHAR(5)
		DECLARE @tmpAccountID			VARCHAR(32)
		DECLARE @tmpInstrumentCode		VARCHAR(10) 
		DECLARE @tmpInstrumentTypeCode	VARCHAR(1)
		DECLARE @tmpSumtrnLngQty		INT --Quantity Lng-sht 
		DECLARE @tmpSumtrnShtQty		INT 
		DECLARE @tmpCurrencyCode		VARCHAR(3) 
		DECLARE @tmpMarketValue			VARCHAR(20)			
		DECLARE @tmpExpiryYear			INT 
		DECLARE @tmpExpiryMonth			INT 
		DECLARE @tmpStrikePrice			DECIMAL(19,6)
		DECLARE @tmpOptionTypeCode		VARCHAR(1)
		DECLARE	@tmprptPrntEffDat		Datetime
		DECLARE	@tmpCntrVersNo			INT
		DECLARE @started				bit
		DECLARE @tmpCurrSetlmtPrc		VARCHAR(20)
		
		SET @started = 0

		DECLARE pos_cursor CURSOR FOR
		SELECT 	[ID],
				[ExchangeCode],
				[FirmCode],			
				[AccountID],
				[InstrumentCode],
				[InstrumentTypeCode],
				[SumtrnLngQty],			
				[SumtrnShtQty],			
				[CurrencyCode],			
				[MarketValue],						
				[ExpiryYear],			
				[ExpiryMonth],			
				[StrikePrice],			
				[OptionTypeCode],
				[rptPrntEffDat],
				[CntrVersNo],
				[CurrSetlmtPrc]
		FROM	#TempPos
		OPEN pos_cursor

		FETCH NEXT FROM pos_cursor
		INTO	
				 @tmpID,					
				 @tmpExchangeCode,		 
				 @tmpFirmCode,			
				 @tmpAccountID,
				 @tmpInstrumentCode,		
				 @tmpInstrumentTypeCode,
				 @tmpSumtrnLngQty,		--Quantity Lng-sht 
				 @tmpSumtrnShtQty,		
				 @tmpCurrencyCode,		 
				 @tmpMarketValue,					
				 @tmpExpiryYear,			
				 @tmpExpiryMonth,			
				 @tmpStrikePrice,			
				 @tmpOptionTypeCode,
				 @tmprptPrntEffDat,
				 @tmpCntrVersNo, 	
				 @tmpCurrSetlmtPrc
		-- Check @@FETCH_STATUS to see if there are any more rows to fetch.
		WHILE @@FETCH_STATUS = 0
		BEGIN

			DECLARE @ExchangeCd			VARCHAR(25)
			DECLARE @FirmCd				VARCHAR(100)
			DECLARE @AccountCd			VARCHAR(100)
			DECLARE @AsOfDate			datetime
			DECLARE @InstrumentCd		VARCHAR(100)
			DECLARE @QuantityPS			DECIMAL(18,10)
			DECLARE @MarketValue		DECIMAL(19,4)
			DECLARE @ExpiryDate			datetime
			DECLARE @StrikePrice		DECIMAL(19,6)
			DECLARE @TrxTypeCd			VARCHAR(25)
			DECLARE @OptionTypeCd		VARCHAR(25)
			DECLARE @QuantityTR			DECIMAL(18,10)
			DECLARE @TrxDate			datetime
			DECLARE @Price				DECIMAL(19,4)
			DECLARE @ExpYr				smallint
			DECLARE @ExpMth				smallint
			DECLARE @ExpDay				smallint
			DECLARE	@InstrumentTypeCd	VARCHAR(100)
			DECLARE	@QuantityLong		INT
			DECLARE	@QuantityShort		INT

			--specify datasource in proc.
			
			--here I have to do this so that I can grab the ticksize
			--so that I can do the quantity calculation.
			DECLARE @Code2						VARCHAR(100)
			DECLARE @InstrumentTypeId			INT
			DECLARE @CurrencyId					INT
			DECLARE @InstrumentId				INT
			DECLARE @ExchangeId					INT
			DECLARE	@LongQuantity				DECIMAL(19,4) 
			DECLARE	@ShortQuantity				DECIMAL(19,4)
			DECLARE	@TradedLongQuantity			DECIMAL(19,4)
			DECLARE	@TradedShortQuantity		DECIMAL(19,4)
			DECLARE @StrikePriceDivisor			DECIMAL(19,4)
			DECLARE	@PriceDivisor				DECIMAL(19,4)

			IF @started = 0
			BEGIN
				SET @Output = null
				SET @Output2 = null

				SET @started = 1
			END

			IF @tmpCntrVersNo IS NOT NULL AND @tmpCntrVersNo <> 0
				BEGIN		
					SET @tmpInstrumentCode = RTRIM(@tmpInstrumentCode) + ''_'' + RTRIM(LTRIM(CAST(@tmpCntrVersNo AS VARCHAR(10))))
					PRINT ''Pos''
					PRINT @tmpInstrumentCode
				END
			--Gets the InstrumentTypeId
			SET	@Code = @tmpInstrumentTypeCode 
			--PRINT ''START - ib_Instrumenttype_AddAsNeeded''
			EXEC @ReturnValue = [dbo].[ib_Instrumenttype_AddAsNeeded] @DataSourceId,@Code,@OutPut output
			SET	@InstrumentTypeId = @Output
			SET @Output2 = null
			SET @Output = null
			
			--PRINT  ''END - ib_Instrumenttype_AddAsNeeded''
			--PRINT  ''START [ib_Instrument_AddAsNeeded]''
			--Sets the InstrumentId and the CurrencyId
			SET @Code = @tmpInstrumentCode
			EXEC @ReturnValue= [ib_Instrument_AddAsNeeded] @DataSourceId,@InstrumentTypeId,@Code,@CurrencyId,@OutPut output,@OutPut2 output	
			SET @InstrumentId = @Output
			SET @CurrencyId = @Output2
			--PRINT ''END [ib_Instrument_AddAsNeeded]''
			IF @CurrencyId is null
			BEGIN
				SET @CurrencyId = @DefaultCurrencyId
			END

			SET @ExchangeCd			= @tmpExchangeCode
			SET @FirmCd				= @tmpFirmCode
			SET @AccountCd			= @tmpAccountID
			SET @AsOfDate			= @tmprptPrntEffDat
			SET @InstrumentCd		= @tmpInstrumentCode
			SET @QuantityPS			= CAST((@tmpSumtrnLngQty -  @tmpSumtrnshtQty) AS DECIMAL(18,10))
			SET @MarketValue		= @tmpMarketValue
			
			SET @StrikePriceDivisor	= null
			SELECT	@StrikePriceDivisor	= StrikePriceDivisor
					, @PriceDivisor = PriceDivisor
			FROM [dbo].[ib_InstrumentDataSource]
			WHERE DataSourceId = @DataSourceId
				AND DataSourceInstrumentCode = @InstrumentCd 

			IF @StrikePriceDivisor IS NULL
				BEGIN
					SET @StrikePrice = CAST(@tmpStrikePrice as DECIMAL(19,4)) / @DefaultStrikePriceDivisor
				END
			ELSE
				BEGIN
					SET @StrikePrice = CAST(@tmpStrikePrice as DECIMAL(19,4)) / @StrikePriceDivisor
				END

			-- Set Settlement Price				
			IF @PriceDivisor IS NULL 
				SET @PriceDivisor = 1
					
			DECLARE @SettlementPrice DECIMAL(24,10)
			SET @SettlementPrice = CONVERT(DECIMAL(24,10), @tmpCurrSetlmtPrc) / @PriceDivisor
			
			SET @TrxTypeCd			= ''POS'' 
			SET @OptionTypeCd		= @tmpOptionTypeCode
			SET @TrxDate			= GETDATE()
			--SET @QuantityTR			= CAST(@tmpQuantity as DECIMAL(18,10))
			SET @ExpYr				= @tmpExpiryYear
			SET @ExpMth				= @tmpExpiryMonth
			SET @ExpDay				= 0
			SET @InstrumentTypeCd	= @tmpInstrumentTypeCode --@InstrumentTypeId
			SET @LongQuantity		= @tmpSumtrnLngQty
			SET @ShortQuantity		= @tmpSumtrnShtQty	

			SET @TradedLongQuantity	 = NULL	 
			SET @TradedShortQuantity = NULL 	 

			SELECT @TradedLongQuantity = trnLngQty, @TradedShortQuantity = trnShtQty
			FROM #TempQuantitiesDestination
				RIGHT JOIN #TempQuantityValues ON ID = DestID
			WHERE [InstrumentCode] = @tmpInstrumentCode AND 
				  [InstrumentTypeCode] = @tmpInstrumentTypeCode AND
				  [CurrencyCode] = @tmpCurrencyCode AND
				  [ExpiryYear] = @tmpExpiryYear AND 
				  [ExpiryMonth] = @tmpExpiryMonth AND 
				  [FirmCd] = @FirmCd AND	
				  [AccountCd] = @AccountCd AND	
				  (([StrikePrice] is not null AND [StrikePrice] = @tmpStrikePrice) OR [StrikePrice] is null) AND
				  (([OptionTypeCode] is not null AND [OptionTypeCode] = @tmpOptionTypeCode) OR [OptionTypeCode] is null)

			SET @ExpDay = dbo.udf_OnLoad_ExpiryDate_Get_Day(@ExpYr,@ExpMth,@ExpDay)
			
			
			
			
			DECLARE @PositionId INT
			SET @PositionId = NULL
			
			EXEC	[dbo].[ib_Position_Load]
					@DataSourceCd,
					@ExchangeCd,
					@FirmCd,
					@AccountCd,	
					@AsOfDate,
					@InstrumentCd,
					@QuantityPS,
					@MarketValue,
					@ExpYr,
					@ExpMth,
					@ExpDay,
					@StrikePrice,
					@TrxTypeCd,
					@OptionTypeCd,
					@TrxDate,
					@Price,
					@tmpID,
					@InstrumentTypeCd,
					@LocationPath,
					@tmpCurrencyCode,
					@LongQuantity,		
					@ShortQuantity,			 
					@TradedLongQuantity,	
					@TradedShortQuantity,	
					@PositionId = @PositionId OUTPUT, 
					@ReceiveLocationSysId = @ReceiveLocationSysId,
					@RunId = @RunId
					
			-- Add Settlement Price											
			EXEC ib_Price_AddFromPositionLoad
				@PositionId
				, @ImportFileId
				, @SettlementPrice 	
				
			--flip processed flag in source table.
			
			UPDATE [stage].[Europower]
			SET [LoadState] = 2
			WHERE EuropowerID = @tmpID
				AND [LoadState] = 1

			SET @tmpStrikePrice = null
			SET @tmpOptionTypeCode = null

			FETCH NEXT FROM pos_cursor
			INTO 
				 @tmpID,					
				 @tmpExchangeCode,		 
				 @tmpFirmCode,			
				 @tmpAccountID,			
				 @tmpInstrumentCode,		
				 @tmpInstrumentTypeCode,
				 @tmpSumtrnLngQty,		--Quantity Lng-sht 
				 @tmpSumtrnShtQty,		
				 @tmpCurrencyCode,		 
				 @tmpMarketValue,					
				 @tmpExpiryYear,			
				 @tmpExpiryMonth,			
				 @tmpStrikePrice,			
				 @tmpOptionTypeCode,
				 @tmprptPrntEffDat,
				 @tmpCntrVersNo,
				 @tmpCurrSetlmtPrc
		END

		CLOSE pos_cursor
		DEALLOCATE pos_cursor

	COMMIT TRAN T1

	DROP TABLE #TempPos
	DROP TABLE #TempQuantityValues
	DROP TABLE #TempQuantitiesDestination
	/****Now do the Transaction Type ****/

	DECLARE @DetailAccountCd	VARCHAR(36) -- AAJM Added for MBAL-12454
	
	SET @DefaultCurrencyId		= NULL
	SET @ExchangeCd				= NULL
	SET @FirmCd					= NULL
	SET @AccountCd				= NULL
	SET @DetailAccountCd		= NULL -- AAJM Added for MBAL-12454
	SET @AsOfDate				= NULL
	SET @InstrumentCd			= NULL
	SET @QuantityPS				= NULL
	SET @MarketValue			= NULL
	SET @ExpiryDate				= NULL
	SET @StrikePrice			= NULL
	SET @TrxTypeCd				= NULL
	SET @OptionTypeCd			= NULL
	SET @QuantityTR				= NULL
	SET @TrxDate				= NULL
	SET @Price					= NULL
	SET @ExpYr					= NULL
	SET @ExpMth					= NULL
	SET @ExpDay					= NULL
	SET	@InstrumentTypeCd		= NULL

	DECLARE @MarexFirmId INT
	SET @MarexFirmId = [dbo].[udf_GetMarexFirmId]() -- AAJM Added for MBAL-12454

	CREATE TABLE #TempTrx
	(
		[ID]					INT,
		[ExchangeCode]			VARCHAR(4), 
		[FirmCode]				VARCHAR(5),
		[AccountID]				VARCHAR(32),
		[DetailAccountCd]		VARCHAR(36), -- AAJM Added for MBAL-12454
		[TrxDate]				datetime,
		[InstrumentCode]		VARCHAR(10), 
		[InstrumentTypeCode]	VARCHAR(1),
		[SumtrnLngQty]			INT, --Quantity Lng-sht 
		[SumtrnShtQty]			INT, 
		[CurrencyCode]			VARCHAR(3), 
		[MarketValue]			VARCHAR(20),
		[Price]					VARCHAR(20),
		[ExpiryYear]			INT, 
		[ExpiryMonth]			INT, 
		[StrikePrice]			INT, 
		[OptionTypeCode]		VARCHAR(1),
		[TrxTypeCode]			VARCHAR(3),
		[trnLngQty]				INT,	
		[trnshtQty]				INT,
		[rptPrntEffDat]			datetime,
		[CntrVersNo]			INT,
		[BuyCod]                VARCHAR(1)
	)
			
	INSERT INTO #TempTrx
	(
		[ID],
		[ExchangeCode],
		[FirmCode],			
		[AccountID],
		[DetailAccountCd], -- AAJM Added for MBAL-12454
		[TrxDate],				
		[InstrumentCode],
		[InstrumentTypeCode],
		[SumtrnLngQty],			
		[SumtrnShtQty],			
		[CurrencyCode],			
		[MarketValue],
		[Price],						
		[ExpiryYear],			
		[ExpiryMonth],			
		[StrikePrice],			
		[OptionTypeCode],
		[TrxTypeCode],
		[trnLngQty],	
		[trnshtQty],
		[rptPrntEffDat],
		[CntrVersNo],
		[BuyCod]			
	)
	SELECT [EuropowerID],
				[origExchId],
				[membexchIDCod], 
				[accTypGrp],
				[custText], -- AAJM Added for MBAL-12454
				[OrigTrnDat],
				[ProdID], 
				RIGHT([ProdTypId],1),
				[sumtrnLngQty],
				[sumtrnShtQty],
				[currTypCod],
				[prmVmarAmnt],
				[trdMtchPrc],
				[CntrExpYrDat],
				[CntrExpMthDat],
				[cntrExerPrc],
				[cntrClasCod],
				[trnTyp],
				[trnLngQty],	
				[trnshtQty],
				[rptPrntEffDat],
				[CntrVersNo],
				[buyCod]			
	FROM [stage].[Europower] e
		LEFT OUTER JOIN [dbo].[ib_TrxType]
			ON [ib_TrxType].[Code] = e.[TrnTyp] 		
				AND ib_TrxType.DataSourceId = @DataSourceId
	WHERE [LoadState] = 1
		AND ([ib_TrxType].[IsPosition] = 0
			OR [ib_TrxType].[IsPosition] IS NULL)
		AND [FileName] = @LocationPath

	BEGIN TRAN T2

		-- BizTalk''s SQL Adapter uses more restrictive read serializable
		-- so this is necessary to relax it to something that is default
		-- and perfectly acceptable!
		SET TRANSACTION ISOLATION LEVEL READ COMMITTED

		DECLARE @tmpTrxID					INT
		DECLARE @tmpTrxExchangeCode			VARCHAR(4) 
		DECLARE @tmpTrxFirmCode				VARCHAR(5)
		DECLARE @tmpTrxAccountID			VARCHAR(32)
		DECLARE @tmpTrxDetailAccountCd		VARCHAR(36) -- AAJM Added for MBAL-12454
		DECLARE @tmpTrxTrxDate				datetime
		DECLARE @tmpTrxInstrumentCode		VARCHAR(10)
		DECLARE @tmpTrxInstrumentTypeCode	VARCHAR(1)
		DECLARE @tmpTrxSumtrnLngQty			INT --Quantity Lng-sht 
		DECLARE @tmpTrxSumtrnShtQty			INT 
		DECLARE @tmpTrxCurrencyCode			VARCHAR(3) 
		DECLARE @tmpTrxMarketValue			VARCHAR(20)
		DECLARE @tmpTrxPrice				VARCHAR(20)
		DECLARE @tmpTrxExpiryYear			INT 
		DECLARE @tmpTrxExpiryMonth			INT
		DECLARE @tmpTrxStrikePrice			DECIMAL(19,6) 
		DECLARE @tmpTrxOptionTypeCode		VARCHAR(1)
		DECLARE @tmpTrxTrxTypeCode			VARCHAR(3) 
		DECLARE @tmpTrxtrnLngQty			INT	
		DECLARE	@tmpTrxtrnShtQty			INT
		DECLARE	@tmpTrxrptPrntEffDat		datetime
		DECLARE @tmpTrxCntrVersNo			INT
		DECLARE @ClassID					INT
		DECLARE @tmpBuyCod                  char(1)
		SET @started = 0

		DECLARE trx_cursor CURSOR FOR
		SELECT 	[ID],
				[ExchangeCode],
				[FirmCode],			
				[AccountID],
				[DetailAccountCd], -- AAJM Added for MBAL-12454
				[TrxDate],				
				[InstrumentCode],
				[InstrumentTypeCode],
				[SumtrnLngQty],			
				[SumtrnShtQty],			
				[CurrencyCode],			
				[MarketValue],
				[Price],						
				[ExpiryYear],			
				[ExpiryMonth],			
				[StrikePrice],			
				[OptionTypeCode],
				[TrxTypeCode],
				[trnLngQty],	
				[trnshtQty],
				[rptPrntEffDat],
				[CntrVersNo],
				[BuyCod]			

		FROM	#TempTrx
		OPEN trx_cursor

		FETCH NEXT FROM trx_cursor
		INTO	
			 @tmpTrxID,					
			 @tmpTrxExchangeCode,		
			 @tmpTrxFirmCode,			
			 @tmpTrxAccountID,
			 @tmpTrxDetailAccountCd,	-- AAJM Added for MBAL-12454		
			 @tmpTrxTrxDate,			
			 @tmpTrxInstrumentCode,		
			 @tmpTrxInstrumentTypeCode,	
			 @tmpTrxSumtrnLngQty,		
			 @tmpTrxSumtrnShtQty,		 
			 @tmpTrxCurrencyCode,		
			 @tmpTrxMarketValue,		
			 @tmpTrxPrice,			
			 @tmpTrxExpiryYear,			
			 @tmpTrxExpiryMonth,		
			 @tmpTrxStrikePrice,		
			 @tmpTrxOptionTypeCode,		
			 @tmpTrxTrxTypeCode,
			 @tmpTrxtrnLngQty,	
			 @tmpTrxtrnShtQty,
			 @tmpTrxrptPrntEffDat,
			 @tmpTrxCntrVersNo,
			 @tmpBuyCod	

		-- Check @@FETCH_STATUS to see if there are any more rows to fetch.
		WHILE @@FETCH_STATUS = 0
		BEGIN
			--specify datasource in proc.
			--here I have to do this so that I can grab the ticksize
			--so that I can do the quantity calculation.
			
			IF @started = 0
			BEGIN
				SET @Output = null
				SET @Output2 = null
				SET @ClassID = null

				SET @started = 1
			END

			IF @tmpTrxCntrVersNo IS NOT NULL AND @tmpTrxCntrVersNo <> 0
				BEGIN	
					SET  @tmpTrxInstrumentCode = RTRIM(@tmpTrxInstrumentCode) + ''_'' + RTRIM(LTRIM(CAST(@tmpTrxCntrVersNo AS VARCHAR(10))))
					PRINT ''Trx''
					PRINT @tmpTrxCntrVersNo
				END
			--Gets the InstrumentTypeId
			SET	@Code = @tmpTrxInstrumentTypeCode 
			
			EXEC @ReturnValue = [dbo].[ib_Instrumenttype_AddAsNeeded] @DataSourceId,@Code,@OutPut output
			SET	@InstrumentTypeId = @Output
			SET @Output2 = null
			SET @Output = null
			
			--Sets the InstrumentId and the CurrencyId
			SET @Code = @tmpTrxInstrumentCode
			EXEC @ReturnValue= [ib_Instrument_AddAsNeeded] @DataSourceId,@InstrumentTypeId,@Code,@CurrencyId,@OutPut output,@OutPut2 output	
			SET @InstrumentId = @Output
			SET @CurrencyId = @Output2
			
			IF @CurrencyId is null
			BEGIN
				SET @CurrencyId = @DefaultCurrencyId
			END
				
			SET @ExchangeCd			= @tmpTrxExchangeCode
			SET @FirmCd				= @tmpTrxFirmCode
			SET @AccountCd			= @tmpTrxAccountID
			SET @DetailAccountCd	= @tmpTrxDetailAccountCd  -- AAJM Added for MBAL-12454
			SET @AsOfDate			= @tmpTrxrptPrntEffDat
			SET @SelectedAsOfDate   = @AsOfDate
			SET @InstrumentCd		= @tmpTrxInstrumentCode
			
			SET @QuantityLong = ISNULL(@tmpTrxTrnLngQty,0)
			SET @QuantityShort = ISNULL(@tmpTrxTrnShtQty,0)

			SET @QuantityTR = CAST((@QuantityLong - @QuantityShort) AS DECIMAL(18,10))
											
			SET @MarketValue = @tmpTrxMarketValue

			SET @StrikePriceDivisor	= null
			
			SELECT @StrikePriceDivisor	= StrikePriceDivisor
			FROM [dbo].[ib_InstrumentDataSource]
			WHERE DataSourceId = @DataSourceId
				AND DataSourceInstrumentCode = @InstrumentCd 

			IF @StrikePriceDivisor IS NULL
				BEGIN
					SET @StrikePrice = CAST(@tmpTrxStrikePrice as DECIMAL(19,4)) / @DefaultStrikePriceDivisor
				END
			ELSE
				BEGIN
					SET @StrikePrice = CAST(@tmpTrxStrikePrice as DECIMAL(19,4)) / @StrikePriceDivisor
				END	
				
			SET @TrxTypeCd			= @tmpTrxTrxTypeCode 
			SET @OptionTypeCd		= @tmpTrxOptionTypeCode
			SET @TrxDate			= @tmpTrxTrxDate
			SET @Price				= @tmpTrxPrice
			SET @ExpYr				= @tmpTrxExpiryYear
			SET @ExpMth				= @tmpTrxExpiryMonth
			SET @ExpDay				= 0
			SET @InstrumentTypeCd	= @tmpTrxInstrumentTypeCode --@InstrumentTypeId

			SET @ExpDay = dbo.udf_OnLoad_ExpiryDate_Get_Day(@ExpYr,@ExpMth,@ExpDay)
			
			IF (@tmpBuyCod = ''B'')
				BEGIN
					SET @QuantityLong = @QuantityLong - @QuantityShort
					SET @QuantityShort = 0
				END
			ELSE
				BEGIN
					SET @QuantityShort = @QuantityShort - @QuantityLong
					SET @QuantityLong = 0
				END

			IF @QuantityLong < 0 AND @TrxTypeCd = @TrxTypeTrade 
			BEGIN
				-- swap the long and short quantitites and reverse the	sign
				-- of course short in this case should be zero, but we''ll swap anyway
				SET @SwapQuantity = @QuantityShort
				SET @QuantityShort = @QuantityLong * -1
				SET @QuantityLong = @SwapQuantity
				SET @TrxTypeCd = @TrxTypeTradeAmended
			END
			ELSE 
			BEGIN
				IF @QuantityShort < 0 AND @TrxTypeCd = @TrxTypeTrade
				BEGIN 
					-- swap the long and short quantitites and reverse the sign
					-- of course long in this case should be zero, but we''ll swap anyway
					SET @SwapQuantity = @QuantityLong
					SET @QuantityLong = @QuantityShort * -1
					SET @QuantityShort = @SwapQuantity
					SET @TrxTypeCd = @TrxTypeTradeAmended
				END
			END
			

			EXEC [dbo].[ib_Trx_Load]
					@DataSourceCd,
					@ExchangeCd,
					@FirmCd,
					@AccountCd,	
					@DetailAccountCd,
					@InstrumentCd,
					@ExpYr,
					@ExpMth,
					@ExpDay,
					@StrikePrice,
					@TrxTypeCd,
					@OptionTypeCd,
					@QuantityTR,
					@TrxDate,
					@Price,
					@tmpTrxID,
					@InstrumentTypeCd,
					@AsOfDate,
					@LocationPath,
					@MarketValue,
					@tmpTrxCurrencyCode,
					@ClassID,
					@MarexFirmId, -- AAJM Added for MBAL-12454
					@QuantityLong = @QuantityLong,
					@QuantityShort = @QuantityShort,
					@ReceiveLocationSysId = @ReceiveLocationSysId,
					@RunId = @RunId

			--flip processed flag in source table.
			--PRINT ''END3''
			UPDATE [stage].[Europower]
			SET [LoadState] = 2
			WHERE EuropowerID = @tmpTrxID
				AND [LoadState] = 1

			FETCH NEXT FROM trx_cursor
			INTO 
			 @tmpTrxID,					
			 @tmpTrxExchangeCode,		
			 @tmpTrxFirmCode,			
			 @tmpTrxAccountID,	
			 @tmpTrxDetailAccountCd, -- AAJM Added for MBAL-12454		
			 @tmpTrxTrxDate,			
			 @tmpTrxInstrumentCode,		
			 @tmpTrxInstrumentTypeCode,	
			 @tmpTrxSumtrnLngQty,		
			 @tmpTrxSumtrnShtQty,		 
			 @tmpTrxCurrencyCode,		
			 @tmpTrxMarketValue,		
			 @tmpTrxPrice,			
			 @tmpTrxExpiryYear,			
			 @tmpTrxExpiryMonth,		
			 @tmpTrxStrikePrice,		
			 @tmpTrxOptionTypeCode,		
			 @tmpTrxTrxTypeCode,
			 @tmpTrxtrnLngQty,	
			 @tmpTrxtrnShtQty,
			 @tmpTrxrptPrntEffDat,
			 @tmpTrxCntrVersNo,
			 @tmpBuyCod	
		END

		CLOSE trx_cursor
		DEALLOCATE trx_cursor

		UPDATE ib_ImportFile 
		SET AsOfDate = @SelectedAsOfDate 
		WHERE ImportFileId = @ImportFileId
	COMMIT TRAN T2

	DROP TABLE #TempTrx
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_BaseDataSource_GetByCode]''
');

GO
EXECUTE ('

-- =============================================
-- Author:		Lee Manifold
-- Create date: 30 Jan 2007
-- Description:	Retrieves BaseId from ib_DataSourceBase
-- ==============================================

CREATE PROC [dbo].[ib_BaseDataSource_GetByCode]
	(
	@DataSourceId	int,
	@Code			varchar(25),
	@BaseId			int output
	)
AS
SET NOCOUNT ON

	SELECT	@BaseId = [BaseId]
 
	FROM	[dbo].[ib_BaseDataSource]

	WHERE	[DataSourceBaseCode]	= @Code
	AND		[DataSourceId]			= @DataSourceId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[is_G_LoadStateChange]''
');

GO
EXECUTE ('
-- =============================================
-- Author:		Lee Manifold
-- Create date: 12 Jul 2006
-- Description:	Changes the LoadState of the is_G type tables
-- =============================================
CREATE PROCEDURE [dbo].[is_G_LoadStateChange] 
	-- Add the parameters for the stored procedure here
	(
	@OldLoadState	TINYINT,
	@NewLoadState	TINYINT,
	@RecordDate		DATETIME = NULL
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	-- Need to add code to handle RecordDate
	IF @RecordDate IS NOT NULL 
	BEGIN
		UPDATE [dbo].[is_GAccountAttribute] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState

		UPDATE [dbo].[is_GAccountTotal] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState

		UPDATE [dbo].[is_GCollateralSecuritiesDetails] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState
		
		UPDATE [dbo].[is_GCollateralSecuritiesMovement] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState
		
		UPDATE [dbo].[is_GRealizedProfitLossDetails] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState
		
		UPDATE [dbo].[is_GReceiptPaymentDetails] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState
		
		UPDATE [dbo].[is_GTradeDetails] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState
		
		UPDATE [dbo].[is_GUnclosedContractDetails] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState
	END

	IF @RecordDate IS NULL 
	BEGIN

		UPDATE [dbo].[is_GAccountAttribute] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState

		UPDATE [dbo].[is_GAccountTotal] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState

		UPDATE [dbo].[is_GCollateralSecuritiesDetails] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState
		
		UPDATE [dbo].[is_GCollateralSecuritiesMovement] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState
		
		UPDATE [dbo].[is_GRealizedProfitLossDetails] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState
		
		UPDATE [dbo].[is_GReceiptPaymentDetails] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState
		
		UPDATE [dbo].[is_GTradeDetails] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState
		
		UPDATE [dbo].[is_GUnclosedContractDetails] SET LoadState = @NewLoadState   WHERE LoadState= @OldLoadState

	END


END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Report_GetReportsPaginateAndSortableCount]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Report_GetReportsPaginateAndSortableCount]
	@SiteID int = NULL
	, @StartDate DateTime = NULL
	, @EndDate DateTime = NULL
	, @ReportType VARCHAR(50) = NULL
	, @UserId UNIQUEIDENTIFIER
AS
SET NOCOUNT ON

-- Returns the count of the records from Reports table by filtering them.

--	05 Aug 2006		laur	Creation
--	17 Jan 2011		amk		MBAL-17233: for all sites, only show reports on sites user has access to

SELECT COUNT(ReportId) 
FROM [dbo].[ib_Report] r
	JOIN [dbo].[ib_Site] s ON s.SiteId = r.SiteId
	JOIN ib_SiteUser su ON su.UserId = @UserId AND su.SiteId = r.SiteId
WHERE (@SiteID IS NULL OR @SiteID = s.SiteId)
	AND (@ReportType IS NULL OR r.ReportType = @ReportType)
	AND (@StartDate IS NULL OR @EndDate IS NULL OR r.CreateDate BETWEEN @StartDate AND @EndDate)
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_ImportFile_Delete]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_ImportFile_Delete]
	@ImportFileId INT
AS
BEGIN
	--	21 Apr 2010		AAJM	Creation

	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	DELETE FROM ib_ImportFile
	WHERE [ImportFileId] = @ImportFileId
	
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[GetThirdWednesdayOfTheMonth]''
');

GO
EXECUTE ('CREATE FUNCTION [dbo].[GetThirdWednesdayOfTheMonth]
(
	@Date DATETIME
)
RETURNS DATETIME
AS
BEGIN
-- Description: return 3rd Wednesday of the month
-- 10 Sep 2014  ED  EIB 25943 - created
	DECLARE @NewDate DATETIME
	
	SET @NewDate = DATEADD(d, 1 - DATEPART(d, @Date), @Date)
	WHILE (LOWER(DATENAME(dw, @NewDate)) <> ''wednesday'')
	BEGIN
		SET @NewDate = DATEADD(day, 1, @NewDate)
	END
	SET @NewDate = DATEADD(day, 14, @NewDate)
	
	RETURN @NewDate
END
');

GO
EXECUTE ('PRINT N''Creating [stage].[LmePosition_Load]''
');

GO
EXECUTE ('CREATE PROCEDURE [stage].[LmePosition_Load]
(
	@LocationPath VARCHAR(100)
	,@ReceiveLocationSysId INT
	,@RunId INT
)
AS
SET NOCOUNT ON

-- Description:	This stored procedure pulls data from the stage.LmePosition temp
-- table and inserts it into ib_Trx
-- Whilst iterating through the records in stage.LmePosition, all 
-- of these inserts are wrapped in a transaction so that any failure causes
-- the changes to not commit.
--
-- 20 Jun 2014	ED	EIB 25759 - Creation
-- 25 Jun 2014  ED	EIB 25778 - use Contract instead of Commodity
-- 26 Jun 2014	ED	EIB 25783 - Set StrikePrice to null for F records
-- 10 Sep 2014	ED	EIB 25943 - Fix Option PromptDate
-- 18 Mar 2019	CH	IBAL 169	- Allow LMEswaps to be inserted into the Position table
BEGIN

	DECLARE @Message			VARCHAR(1024)
	DECLARE @AddCount			INT
	SET @AddCount = 0
					
	DECLARE @DataSourceCode VARCHAR(100), @ExchangeCode VARCHAR(100), @FirmCode VARCHAR(100)
	DECLARE @DataSourceId INT
	DECLARE @Code VARCHAR(100)
	DECLARE @Code2 VARCHAR(100)
	DECLARE @ReturnValue INT
	DECLARE @Output INT
	DECLARE @Output2 INT
	DECLARE @DefaultCurrencyId INT
			
	DECLARE @receiveLocationName VARCHAR(100) = (SELECT ReceiveLocationName FROM ReceiveLocation WHERE ReceiveLocationSysId = @ReceiveLocationSysId)		

	-- Get Datasource
	SET @DataSourceCode = ''LME''
	SET @ExchangeCode = CASE WHEN @receiveLocationName = ''LMP-POS'' THEN ''LMP'' ELSE ''LME'' END
	SET @FirmCode = CASE WHEN @receiveLocationName = ''LMP-POS'' THEN ''MFP (LMP)'' ELSE ''MFL (LME)'' END
	
	SET @Code = @DataSourceCode
	EXEC @ReturnValue= [_ib_DataSource_GetByCodeForOutput] @Code,@OutPut output,@Output2 output	
	SET @DataSourceId = @Output
	SET @DefaultCurrencyId = @Output2	

	-- Duplicate file check										
	DECLARE @IsFileAlreadyLoaded INT
	EXEC @IsFileALreadyLoaded = HasFileBeenLoaded @LocationPath, @DataSourceId

	IF @IsFileAlreadyLoaded = 1
	BEGIN
		UPDATE stage.LmePosition
		SET LoadState = 3
		WHERE LoadState = 1
			AND FileName = @LocationPath		
		RETURN
	END
	
	DECLARE @CheckAsOfDate DATETIME
	SET @CheckAsOfDate = (SELECT MIN(ReportDate) AS CheckRunDate 
				FROM stage.LmePosition 
				WHERE LoadState = 1 AND Filename = @LocationPath AND ContractTypeCode NOT IN (''LMESwap''))
	IF (@CheckAsOfDate IS NOT NULL)
	BEGIN		
		DECLARE @IsAcceptable bit
		EXECUTE [dbo].[Load_IsFileTooOld] @DataSourceId,@LocationPath,@CheckAsOfDate,@IsAcceptable OUTPUT, @ReceiveLocationSysId, @RunId
		IF (@IsAcceptable = 0)
		BEGIN
			
			UPDATE stage.LmePosition SET LoadState = 3 WHERE LoadState = 1 AND FileName = @LocationPath	
			RAISERROR (''File is too old.'', 18, 0)
			RETURN
		END									
	END

	-- Store ImportFile record for use
	DECLARE @ImportFileId INT
	EXEC ib_ImportFile_Add @DataSourceId, @LocationPath, @ImportFileId output
	
	--Gets the defaultStrikePriceDivisor
	DECLARE	@DefaultStrikePriceDivisor	DECIMAL(19,6)
	SET @DefaultStrikePriceDivisor = [dbo].[udf_GetDefaultStrikePriceDivisor](@DataSourceId, NULL)


	SET XACT_ABORT ON 

	BEGIN TRAN T1

		-- BizTalk''s SQL Adapter uses more restrictive read serializable
		-- so this is necessary to relax it to something that is default
		-- and perfectly acceptable!
		SET TRANSACTION ISOLATION LEVEL READ COMMITTED

		BEGIN TRY
			DECLARE @LmePositionId INT
			DECLARE @ReportDate DATETIME  
			DECLARE @AccountCode VARCHAR(100)  
			DECLARE @Contract VARCHAR(3)  
			DECLARE @CurrencyCode VARCHAR(3)  
			DECLARE @ContractTypeCode VARCHAR(25)  
			DECLARE @SubContractType VARCHAR(1)  
			DECLARE @ForwardDate DATETIME 
			DECLARE @ForwardMonth VARCHAR(6)
			DECLARE @UniqueProductId VARCHAR(100)
			DECLARE @StrikePrice MONEY 
			DECLARE @LongQuantity INT
			DECLARE @ShortQuantity INT
			DECLARE @FuturesMarketValue MONEY 
			DECLARE @OptionsMarketValue MONEY 
			DECLARE @UTI VARCHAR(100)  
			DECLARE @ClosingPrice MONEY
			DECLARE @TradePrice MONEY
			DECLARE @ForwardValue MONEY

			DECLARE pos_cursor CURSOR FOR
			SELECT [LmePositionId]
				  ,[ReportDate]
				  ,[AccountCode]
				  ,[Contract]
				  ,[CurrencyCode]
				  ,[ContractTypeCode]
				  ,[SubContractType]
				  ,[ForwardDate]
				  ,[ForwardMonth]
				  ,[UniqueProductId]
				  ,[StrikePrice]
				  ,[LongQuantity]
				  ,[ShortQuantity]
				  ,[FuturesMarketValue]
				  ,[OptionsMarketValue]
				  ,[UTI]
				  ,[ClosingPrice]
				  ,[TradePrice]
				  ,[ForwardValue]
			FROM					
			stage.LmePosition WHERE LoadState = 1 AND Filename = @LocationPath

			OPEN pos_cursor

			FETCH NEXT FROM pos_cursor
			INTO 
				   @LmePositionId
				  ,@ReportDate
				  ,@AccountCode
				  ,@Contract
				  ,@CurrencyCode
				  ,@ContractTypeCode
				  ,@SubContractType
				  ,@ForwardDate
				  ,@ForwardMonth
				  ,@UniqueProductId
				  ,@StrikePrice
				  ,@LongQuantity
				  ,@ShortQuantity
				  ,@FuturesMarketValue
				  ,@OptionsMarketValue
				  ,@UTI
				  ,@ClosingPrice
				  ,@TradePrice
				  ,@ForwardValue
				-- Check @@FETCH_STATUS to see IF there are any more rows to fetch.
				WHILE @@FETCH_STATUS = 0
				BEGIN
					DECLARE		@InstrumentCd			VARCHAR(100)
					DECLARE		@InstrumentTypeCd		VARCHAR(100)
					DECLARE		@SignedQuantity			DECIMAL(19,4)
					DECLARE		@ExpYr					SMALLINT
					DECLARE		@ExpMth					SMALLINT
					DECLARE		@ExpDay					SMALLINT
					DECLARE		@MarketValueDec			DECIMAL(19,4)
					DECLARE		@MarketValueDivisor		DECIMAL(19,4)
					DECLARE		@StrikePriceDivisor		DECIMAL(19,4)

			SET @MarketValueDec = NULL		
			SET @InstrumentTypeCd = NULL	
			-- Set InstrumentTypeCd
			IF @ContractTypeCode = ''LMEOption'' OR @ContractTypeCode = ''LMETAPO'' 
				BEGIN
					SET @InstrumentTypeCd = ''O''
					SET @MarketValueDec = @OptionsMarketValue
				END	
			ELSE
				BEGIN
					SET @InstrumentTypeCd = ''F''
					--IF @FuturesMarketValue != 0
					--	SET @MarketValueDec = @FuturesMarketValue
					--ELSE IF @ForwardValue IS NOT NULL
						SET @MarketValueDec = @ForwardValue
						
				END

			--IF @InstrumentTypeCd = ''F'' AND @ForwardDate IS NOT NULL AND @ForwardDate = dbo.GetNextBusinessDay(@TradeDate)
			--	CONTINUE

			-- We prefix the Instruments with the IntrumentTypeCode
			SET @InstrumentCd = @InstrumentTypeCd + ''_'' + @ExchangeCode + ''_'' + @Contract			
					
			SET @SignedQuantity = @LongQuantity - @ShortQuantity
			SET @ExpDay = NULL
			SET @ExpMth = NULL
			SET @ExpYr = NULL	
			-- Set ExpiryDate	
			IF @InstrumentTypeCd = ''O''
			BEGIN
				DECLARE @ExpiryDate CHAR(8), @TempDate DATETIME
				SET @ExpiryDate = SUBSTRING(@UniqueProductId,10,8)
				SET @TempDate = CONVERT(datetime, @ExpiryDate, 112)
				IF @TempDate != dbo.GetLastBusinessDayOfTheMonth(@TempDate)
					SET @TempDate = dbo.GetThirdWednesdayOfTheMonth(@TempDate)
				SET @ExpYr = YEAR(@TempDate)
				SET @ExpMth = MONTH(@TempDate)
				SET @ExpDay = DAY(@TempDate)
			END
			ELSE 	
			IF @ForwardDate IS NOT NULL		
			BEGIN
				SET @ExpYr = YEAR(@ForwardDate)
				SET @ExpMth = MONTH(@ForwardDate)
				SET @ExpDay = DAY(@ForwardDate)
			END
			ELSE
			IF @ForwardMonth IS NOT NULL	
			BEGIN
				SET @TempDate = dbo.GetLastBusinessDayOfTheMonth(CONVERT(datetime, @ForwardMonth+''01'', 112))	
				SET @ExpYr = YEAR(@TempDate)
				SET @ExpMth = MONTH(@TempDate)
				SET @ExpDay = DAY(@TempDate)
			END

			DECLARE @PositionId INT		
			SET @PositionId = NULL
			SET @MarketValueDivisor = NULL
			SET @StrikePriceDivisor = NULL

			SELECT @MarketValueDivisor = MarketValueDivisor, @StrikePriceDivisor = StrikePriceDivisor
				FROM [dbo].[ib_InstrumentDataSource] WHERE DataSourceId = @DataSourceId AND DataSourceInstrumentCode = @InstrumentCd 

			SET @MarketValueDec = @MarketValueDec / ISNULL(@MarketValueDivisor, 1)
			
			IF @InstrumentTypeCd = ''O''
				SET @StrikePrice = @StrikePrice / ISNULL(@StrikePriceDivisor, ISNULL(@DefaultStrikePriceDivisor, 1))
			ELSE
				SET @StrikePrice = NULL
			
			IF NOT EXISTS(SELECT 1 FROM ib_TrxType WHERE DataSourceId = @DataSourceId AND Code = @ContractTypeCode)
				INSERT INTO ib_TrxType (DataSourceId, Code, Description, IsAutoMatched)
					VALUES(@DataSourceId, @ContractTypeCode, @ContractTypeCode, 1)	

			EXEC [ib_Position_Load]
			@DataSourceCode			
			, @ExchangeCode
			, @FirmCode -- Firm will be added if not present					
			, @AccountCode
			, @ReportDate				
			, @InstrumentCd			
			, @SignedQuantity			
			, @MarketValueDec			
			, @ExpYr					
			, @ExpMth					
			, @ExpDay	
			, @StrikePrice			
			, @ContractTypeCode				
			, @SubContractType	
			, NULL -- @TrxDate 			
			, NULL --@SettlementPrice -- This value is NOT actually used in the ib_Position_Load Stored Procedure, should be removed ?			
			, @LmePositionId
			, @InstrumentTypeCd		
			, @LocationPath
			, @CurrencyCode
			, @LongQuantity = @LongQuantity
			, @ShortQuantity = @ShortQuantity
			, @TradedLongQuantity = NULL
			, @TradedShortQuantity = NULL
			, @ClassId = NULL
			, @UseNetForCloseOut = 0
			, @PositionId = @PositionId output
			, @ReceiveLocationSysId = @ReceiveLocationSysId
			, @RunId = @RunId
			, @UTI = @UTI
			--flip processed flag in source table.
			UPDATE stage.LmePosition WITH (ROWLOCK) SET [LoadState] = 2 WHERE LmePositionId = @LmePositionId AND [LoadState] = 1
			IF (@PositionId IS NOT NULL AND @PositionId > 0)
				BEGIN
					SET @AddCount = @AddCount + 1
					EXEC ib_Price_AddFromPositionLoad @PositionId, @ImportFileId, @ClosingPrice 	
				END
			
			FETCH NEXT FROM pos_cursor
			INTO 
					@LmePositionId
				  ,@ReportDate
				  ,@AccountCode
				  ,@Contract
				  ,@CurrencyCode
				  ,@ContractTypeCode
				  ,@SubContractType
				  ,@ForwardDate
				  ,@ForwardMonth
				  ,@UniqueProductId
				  ,@StrikePrice
				  ,@LongQuantity
				  ,@ShortQuantity
				  ,@FuturesMarketValue
				  ,@OptionsMarketValue
				  ,@UTI
				  ,@ClosingPrice
				  ,@TradePrice
				  ,@ForwardValue
		END
			
		CLOSE pos_cursor
		DEALLOCATE pos_cursor

			-- Now update state of any left-over temporary transaction records
			-- so there are no ''left-overs''
			UPDATE stage.LmePosition WITH (ROWLOCK) SET [LoadState] = 2 WHERE [LoadState] = 1 AND [FileName] = @LocationPath

			SET @Message = @DataSourceCode + '' position loader ended ('' + CONVERT(VARCHAR(10), @AddCount) + '' added).'' 
		
			EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @Message, ''Success'', '''', @RunId

			UPDATE ib_ImportFile SET AsOfDate = @CheckAsOfDate WHERE ImportFileId = @ImportFileId
			
		COMMIT TRAN T1
	
	END TRY
	BEGIN CATCH 

		IF XACT_STATE() = -1 
			ROLLBACK TRANSACTION
	
		SET @Message = @DataSourceCode + '' position loader failed.'' 		
		EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @Message, ''Error'', '''', @RunId
	
		EXEC [dbo].[sp_RethrowError]
		
	END CATCH 

	SET XACT_ABORT OFF

END

RETURN 0
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Broker_GetBrokerById]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Broker_GetBrokerById] @BrokerId INT
AS 
SET NOCOUNT ON

SELECT
    b.*
   ,CASE WHEN d.Code = d.[Name] THEN d.Code
         ELSE d.Code + ''('' + d.Name + '')''
    END AS [DataSourceCodeName]
FROM
    [dbo].[ib_Broker] AS [b]
LEFT OUTER JOIN [dbo].[ib_DataSource] AS [d]
ON  [d].DataSourceId = [b].DataSourceId
WHERE
    BrokerId = @BrokerId
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Adjustment_MatchAdjustments]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Adjustment_MatchAdjustments]
(
	@AdjustmentIdsCommaSeparated NVARCHAR(MAX)
	,@CreateUsername VARCHAR(50)
)
AS
SET NOCOUNT ON
BEGIN TRY
	BEGIN TRAN

	-- Match Multiple Adjustments
	-- 26 May 2010	ED		Created
	-- 27 May 2010	ED		MBAL-15666 Set also MatchingAdjustmentId
	-- 30 Jun 2010	ED		MBAL-15949 Fix description
	-- 29 Jul 2010	AAJM	MBAL-16331 Allow multiple entries for manual matching

	CREATE TABLE #TempList
	(
		AdjustmentId int
	)
	
	INSERT INTO #TempList (AdjustmentId)
	SELECT Id
	FROM [dbo].[ReturnIdsFromCommaSeparatedString](@AdjustmentIdsCommaSeparated)	
	
	DECLARE @MatchedAdjustmentStatusId INT
	SELECT @MatchedAdjustmentStatusId = AdjustmentStatusId FROM ib_AdjustmentStatus WHERE Code=''M''
	
	DECLARE @Notes VARCHAR(255)
	SET @Notes = ''Manually Matched (''+@CreateUsername+'', ''+CONVERT(CHAR(10), CURRENT_TIMESTAMP, 103)+'' ''+CONVERT(CHAR(5), CURRENT_TIMESTAMP, 114)+'') ''

	-- Get the ''first'' AdjustmentID
	DECLARE @MatchedAdjustmentId INT
	SET @MatchedAdjustmentId = (SELECT TOP(1) AdjustmentId FROM #TempList ORDER BY AdjustmentId ASC)
	
	-- Mark each Adjustment as Matched to this Adjustment
	UPDATE a
		SET AdjustmentStatusId = @MatchedAdjustmentStatusId,
			[Description] = @Notes+ISNULL([Description],''''),
			MatchingAdjustmentId = @MatchedAdjustmentId,
			UpdateUsername = @CreateUsername,
			UpdateDate = GETDATE()
		FROM ib_Adjustment a
		INNER JOIN #TempList t ON t.AdjustmentId = a.AdjustmentId
		
	COMMIT TRAN
END TRY
BEGIN CATCH
	ROLLBACK TRAN
	EXEC [dbo].[sp_RethrowError]
END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[aspnet_UnRegisterSchemaVersion]''
');

GO
SET QUOTED_IDENTIFIER OFF

GO
EXECUTE ('
CREATE PROCEDURE [dbo].[aspnet_UnRegisterSchemaVersion]
    @Feature                   nvarchar(128),
    @CompatibleSchemaVersion   nvarchar(128)
AS
SET NOCOUNT ON
BEGIN
    DELETE FROM dbo.aspnet_SchemaVersions
        WHERE   Feature = LOWER(@Feature) AND @CompatibleSchemaVersion = CompatibleSchemaVersion
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[is_G_Purge]''
');

GO
SET QUOTED_IDENTIFIER ON

GO
EXECUTE ('


-- =============================================
-- Author:		Lee Manifold
-- Create date: 11 Jul 2006
-- Description:	Deletes from all is_G type files where the LoadState is 0
-- =============================================
CREATE PROCEDURE [dbo].[is_G_Purge]
	(
	@LoadState		TINYINT = 0,
	@RecordDate		DATETIME = NULL
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	
	--raiserror (''Lee doing specific raiserror in stored proc for testing'', 19, 1) with log
	
	IF @RecordDate IS NOT NULL 
	BEGIN
		--****Need to Add code here to factor in @RecordDate into table fields 
		DELETE FROM [dbo].[is_GAccountAttribute] WHERE LoadState= @LoadState

		DELETE FROM [dbo].[is_GAccountTotal] WHERE LoadState= @LoadState

		DELETE FROM [dbo].[is_GCollateralSecuritiesDetails] WHERE LoadState= @LoadState

		DELETE FROM [dbo].[is_GCollateralSecuritiesMovement] WHERE LoadState= @LoadState
	
		DELETE FROM [dbo].[is_GProductTotal] WHERE LoadState= @LoadState

		DELETE FROM [dbo].[is_GRealizedProfitLossDetails] WHERE LoadState= @LoadState

		DELETE FROM [dbo].[is_GReceiptPaymentDetails] WHERE LoadState= @LoadState

		DELETE FROM [dbo].[is_GTradeDetails] WHERE LoadState= @LoadState		

		DELETE FROM [dbo].[is_GUnclosedContractDetails] WHERE LoadState= @LoadState
	END
	
	IF @RecordDate IS NULL 
	BEGIN
	
		DELETE FROM [dbo].[is_GAccountAttribute] WHERE LoadState= @LoadState

		DELETE FROM [dbo].[is_GAccountTotal] WHERE LoadState= @LoadState

		DELETE FROM [dbo].[is_GCollateralSecuritiesDetails] WHERE LoadState= @LoadState

		DELETE FROM [dbo].[is_GCollateralSecuritiesMovement] WHERE LoadState= @LoadState
	
		DELETE FROM [dbo].[is_GProductTotal] WHERE LoadState= @LoadState

		DELETE FROM [dbo].[is_GRealizedProfitLossDetails] WHERE LoadState= @LoadState

		DELETE FROM [dbo].[is_GReceiptPaymentDetails] WHERE LoadState= @LoadState

		DELETE FROM [dbo].[is_GTradeDetails] WHERE LoadState= @LoadState		

		DELETE FROM [dbo].[is_GUnclosedContractDetails] WHERE LoadState= @LoadState


	END
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Report_GetReportTypes]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Report_GetReportTypes]
AS
SET NOCOUNT ON
	SELECT DISTINCT reporttype FROM  [dbo].[ib_Report] 
RETURN 0
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_ImportFile_GetRecent]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_ImportFile_GetRecent]
AS
BEGIN
	--	19 Nov 2010		amk		Creation
	--	21 Nov 2010		amk		no lock importfile table

	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	SELECT TOP 25 Filename, ds.Code as DataSource, f.CreateDate, f.AsOfDate
		, RIGHT(Filename, CHARINDEX(''\'', REVERSE(Filename)) - 1) AS BaseFilename
	FROM ib_ImportFile f WITH (NOLOCK)
		JOIN ib_DataSource ds ON ds.DataSourceId = f.DataSourceId
	ORDER BY f.CreateDate DESC
END
');

GO
EXECUTE ('PRINT N''Creating [stage].[LmePositionsRealisedCash_Load]''
');

GO
EXECUTE ('CREATE PROCEDURE [stage].[LmePositionsRealisedCash_Load]
(
	@LocationPath VARCHAR(100)
	,@ReceiveLocationSysId INT
	,@RunId INT
)
AS
SET NOCOUNT ON

-- Description:	This stored procedure pulls data from the stage.LmePositionsRealisedCash temp
-- table and inserts it into PositionsRealisedCash
-- Whilst iterating through the records in stage.LmePositionsRealisedCash, all 
-- of these inserts are wrapped in a transaction so that any failure causes
-- the changes to not commit.
--
-- 01 Jul 2014	ED	EIB 25781 - Creation
-- 09 Sep 2014	ED	EIB 25981 - add logic for F records
-- 12 Sep 2014	ED	EIB 25981 - map to P instead of O for InstrumentType

BEGIN

	DECLARE @Message			VARCHAR(1024)
	DECLARE @AddCount			INT
	SET @AddCount = 0
					
	DECLARE @DataSourceCode VARCHAR(100), @ExchangeCode VARCHAR(100), @FirmCode VARCHAR(100)
	DECLARE @DataSourceId INT
	DECLARE @Code VARCHAR(100)
	DECLARE @Code2 VARCHAR(100)
	DECLARE @ReturnValue INT
	DECLARE @Output INT
	DECLARE @Output2 INT
	DECLARE @DefaultCurrencyId INT
	
	DECLARE @FutureProducts TABLE(Product VARCHAR(5))
	INSERT INTO @FutureProducts(Product) VALUES(''SR''), (''SC''), (''AU''), (''AG'')
			
	DECLARE @receiveLocationName VARCHAR(100) = (SELECT ReceiveLocationName FROM ReceiveLocation WHERE ReceiveLocationSysId = @ReceiveLocationSysId)		

	-- Get Datasource
	SET @DataSourceCode = ''LME''
	SET @ExchangeCode = CASE WHEN @receiveLocationName = ''LMP-POS-RC'' THEN ''LMP'' ELSE ''LME'' END
	SET @FirmCode = CASE WHEN @receiveLocationName = ''LMP-POS-RC'' THEN ''MFP (LMP)'' ELSE ''MFL (LME)'' END
	
	SET @Code = @DataSourceCode
	EXEC @ReturnValue= [_ib_DataSource_GetByCodeForOutput] @Code,@OutPut OUTPUT,@Output2 OUTPUT	
	SET @DataSourceId = @Output
	SET @DefaultCurrencyId = @Output2	


	-- Duplicate file check										
	DECLARE @IsFileAlreadyLoaded INT
	EXEC @IsFileALreadyLoaded = HasFileBeenLoaded @LocationPath, @DataSourceId

	IF @IsFileAlreadyLoaded = 1
	BEGIN
		UPDATE stage.LmePositionsRealisedCash
		SET LoadState = 3
		WHERE LoadState = 1
			AND FileName = @LocationPath		
		RETURN
	END
	
	DECLARE @CheckAsOfDate DATETIME
	SET @CheckAsOfDate = 
		(SELECT MIN(ReportDate) AS CheckRunDate FROM stage.LmePositionsRealisedCash 
			WHERE LoadState = 1 AND Filename = @LocationPath AND TransactionType IN (''REALISED_PL'', ''PREMIUM'') AND CollateralAccount = ''CASH'')
	IF (@CheckAsOfDate IS NOT NULL)
	BEGIN		
		DECLARE @IsAcceptable BIT
		EXECUTE [dbo].[Load_IsFileTooOld] @DataSourceId,@LocationPath,@CheckAsOfDate,@IsAcceptable OUTPUT, @ReceiveLocationSysId, @RunId
		IF (@IsAcceptable = 0)
		BEGIN
			
			UPDATE stage.LmePositionsRealisedCash SET LoadState = 3 WHERE LoadState = 1 AND FileName = @LocationPath	
			RAISERROR (''File is too old.'', 18, 0)
			RETURN
		END									
	END

	-- Store ImportFile record for use
	DECLARE @ImportFileId INT
	EXEC ib_ImportFile_Add @DataSourceId, @LocationPath, @ImportFileId OUTPUT
	
	--Gets the defaultStrikePriceDivisor
	DECLARE	@DefaultStrikePriceDivisor	DECIMAL(19,6)
	SET @DefaultStrikePriceDivisor = [dbo].[udf_GetDefaultStrikePriceDivisor](@DataSourceId, NULL)


	SET XACT_ABORT ON 

	BEGIN TRAN T1

		-- BizTalk''s SQL Adapter uses more restrictive read serializable
		-- so this is necessary to relax it to something that is default
		-- and perfectly acceptable!
		SET TRANSACTION ISOLATION LEVEL READ COMMITTED

		BEGIN TRY
			DECLARE @LmePositionsRealisedCashId INT
			DECLARE @ReportDate DATETIME  
			DECLARE @AccountCode VARCHAR(100)  
			DECLARE @Product VARCHAR(5)  
			DECLARE @Currency CHAR(3)  
			DECLARE @TransactionType VARCHAR(100)
			DECLARE @PromptDate DATE
			DECLARE @Strike MONEY 
			DECLARE @CallOrPut VARCHAR(5) 
			DECLARE @TransactionValue MONEY 

			DECLARE pos_cursor CURSOR FOR
			SELECT  LmePositionsRealisedCashId,
					ReportDate,
					AccountCode,  
					Product,
					Currency,
					TransactionType,
					PromptDate,
					Strike,
					CallOrPut,
					TransactionValue
			FROM stage.LmePositionsRealisedCash 
			WHERE LoadState = 1 AND Filename = @LocationPath AND TransactionType IN (''REALISED_PL'', ''PREMIUM'')  AND CollateralAccount = ''CASH''

			OPEN pos_cursor

			FETCH NEXT FROM pos_cursor
			INTO 
				    @LmePositionsRealisedCashId,
					@ReportDate,
					@AccountCode,  
					@Product,
					@Currency,
					@TransactionType,
					@PromptDate,
					@Strike,
					@CallOrPut,
					@TransactionValue
				-- Check @@FETCH_STATUS to see IF there are any more rows to fetch.
				WHILE @@FETCH_STATUS = 0
				BEGIN
					DECLARE @Contract	VARCHAR(5)
					DECLARE @IsCall		BIT
					DECLARE @InstrumentTypeCode CHAR(1)
					DECLARE @InstrumentCode VARCHAR(100)
					DECLARE @RecordDate DATETIME
			SET @RecordDate = @ReportDate
			DECLARE @CurrencyId INT, @DataSourceCurrencyCode VARCHAR(100)
				SET @DataSourceCurrencyCode = (SELECT DataSourceCurrencyCode FROM 
					ib_CurrencyDataSource WHERE CurrencyId = (SELECT CurrencyId FROM ib_Currency WHERE Code = @Currency)
							AND DataSourceId = (SELECT DataSourceId FROM ib_DataSource WHERE Code = ''LME'')
							AND LEN(DataSourceCurrencyCode) = 1)
				SET @Contract = @Product + @DataSourceCurrencyCode
			IF @TransactionType = ''PREMIUM''
			BEGIN
				SET @InstrumentTypeCode = ''P''
				IF @ExchangeCode = ''LME''
				BEGIN
					SET @InstrumentCode = ''O_LME_'' + @Contract
				END
				ELSE
				BEGIN
					SET @InstrumentCode = ''O_LMP_'' + @Contract
				END
			END
			ELSE
			BEGIN
				IF NOT EXISTS(SELECT 1 FROM @FutureProducts WHERE Product = @Product)
					SET @RecordDate = dbo.GetNextBusinessDay(@ReportDate)
				ELSE -- future and SR/SC, then it should be last day
				BEGIN
					IF @Product NOT IN (''AU'', ''AG'')
					BEGIN 
						SET @PromptDate = dbo.GetLastBusinessDayOfTheMonth(@PromptDate)
					END
				END
				SET @InstrumentTypeCode = ''F''
				IF @ExchangeCode = ''LME''
				BEGIN
					SET @InstrumentCode = ''F_LME_'' + @Contract
				END
				ELSE
				BEGIN
					SET @InstrumentCode = ''F_LMP_'' + @Contract
				END
			END
			
			SET @IsCall = CASE WHEN @CallOrPut = ''CALL'' THEN 1 ELSE 0 END
			DECLARE @PositionsRealisedCashId INT = NULL
			EXEC dbo.PositionsRealisedCash_Load @RecordDate, @AccountCode, @Product, @Currency, @Contract, @PromptDate, @Strike, @IsCall,
					@TransactionValue, @DataSourceCode, @ExchangeCode, @FirmCode, @InstrumentTypeCode, @InstrumentCode, @LmePositionsRealisedCashId,
					@LocationPath, @ReceiveLocationSysId, @RunId, @PositionsRealisedCashId OUTPUT
			IF (@PositionsRealisedCashId IS NOT NULL AND @PositionsRealisedCashId > 0)
					SET @AddCount = @AddCount + 1		

			--flip processed flag in source table.
			UPDATE stage.LmePositionsRealisedCash WITH (ROWLOCK) SET [LoadState] = 2 WHERE LmePositionsRealisedCashId = @LmePositionsRealisedCashId AND [LoadState] = 1
			
			
			FETCH NEXT FROM pos_cursor
			INTO 
					@LmePositionsRealisedCashId,
					@ReportDate,
					@AccountCode,  
					@Product,
					@Currency,
					@TransactionType,
					@PromptDate,
					@Strike,
					@CallOrPut,
					@TransactionValue
		END
			
		CLOSE pos_cursor
		DEALLOCATE pos_cursor

			-- Now update state of any left-over temporary transaction records
			-- so there are no ''left-overs''
			UPDATE stage.LmePositionsRealisedCash WITH (ROWLOCK) SET [LoadState] = 2 WHERE [LoadState] = 1 AND [FileName] = @LocationPath

			SET @Message = @DataSourceCode + '' PositionsRealisedCash loader ended ('' + CONVERT(VARCHAR(10), @AddCount) + '' added).'' 
		
			EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @Message, ''Success'', '''', @RunId

			UPDATE ib_ImportFile SET AsOfDate = @CheckAsOfDate WHERE ImportFileId = @ImportFileId
			
		COMMIT TRAN T1
	
	END TRY
	BEGIN CATCH 

		IF XACT_STATE() = -1 
			ROLLBACK TRANSACTION
	
		SET @Message = @DataSourceCode + '' PositionsRealisedCash loader failed.'' 		
		EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @Message, ''Error'', '''', @RunId
	
		EXEC [dbo].[sp_RethrowError]
		
	END CATCH 

	SET XACT_ABORT OFF

END

RETURN 0
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Broker_GetBrokerCodeAndIdForAllBrokers]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Broker_GetBrokerCodeAndIdForAllBrokers]
AS
SET NOCOUNT ON
SELECT b.[Code] AS [BrokerCode], b.[BrokerId]
	FROM [dbo].[ib_Broker] b
');

GO
EXECUTE ('PRINT N''Creating [dbo].[is_GAccountAttribute_Add]''
');

GO
EXECUTE ('

/*
<Details>
<Summary>Inserts an item into the GAccountAttribute table</Summary>
<Created author="laurentiu.macovei" date="04/05/2006 16:33:05" />
</Details>
*/
CREATE PROCEDURE [dbo].[is_GAccountAttribute_Add]
	@CorporationCode varchar(4) = NULL,
	@PrincipalBrokerageID varchar(1) = NULL,
	@OfficeCode varchar(4) = NULL,
	@ACNumber varchar(10) = NULL,
	@RecordID varchar(2) = NULL,
	@BaseDate datetime = NULL,
	@CalculationDate datetime = NULL,
	@CalculationStartTime datetime = NULL,
	@SettlementCycle varchar(1) = NULL,
	@SettlementType varchar(2) = NULL,
	@Remarks varchar(45) = NULL,
	@AccountOpenIDTSE varchar(1) = NULL,
	@AccountOpenIDOSE varchar(1) = NULL,
	@DailyStatementID varchar(1) = NULL,
	@DailyStatementIDTradeDetails varchar(1) = NULL,
	@DailyStatementIDAccountTotal varchar(1) = NULL,
	@DailyStatementIDUnclosedContract varchar(1) = NULL,
	@DailyStatementIDReceiptRepaymentMovement varchar(1) = NULL,
	@DailyStatementIDCollateralSecuritiesMovement varchar(1) = NULL,
	@DailyStatementIDCollateralSecuritiesDetails varchar(1) = NULL,
	@BusinessID varchar(2) = NULL,
	@TrustBankBranchCode varchar(4) = NULL,
	@FundNumber int = NULL,
	@FundName varchar(20) = NULL
AS
SET NOCOUNT ON

	SET NOCOUNT OFF

	DECLARE	@CalculationDateStartTime DATETIME

	IF @BaseDate = ''01/01/1900 00:00:00'' 
		SET @BaseDate = NULL

	IF @CalculationDate = ''01/01/1900 00:00:00'' 
		SET @CalculationDate = NULL

	IF @CalculationStartTime = ''01/01/1900 00:00:00'' 
		SET @CalculationStartTime = NULL

	SET @CalculationDateStartTime = CONVERT(DATETIME,CONVERT(VARCHAR(12), CONVERT(DATETIME,@CalculationDate,112)) + '' '' + CONVERT(VARCHAR(8),RIGHT(@CalculationStartTime,8)))

	INSERT INTO is_GAccountAttribute 
	(
		[CorporationCode], 
		[PrincipalBrokerageID], 
		[OfficeCode], 
		[ACNumber], 
		[RecordID], 
		[BaseDate], 
		[CalculationDate], 
		[CalculationStartTime], 
		[CalculationDateStartTime],
		[SettlementCycle], 
		[SettlementType], 
		[Remarks], 
		[AccountOpenIDTSE], 
		[AccountOpenIDOSE], 
		[DailyStatementID], 
		[DailyStatementIDTradeDetails], 
		[DailyStatementIDAccountTotal], 
		[DailyStatementIDUnclosedContract], 
		[DailyStatementIDReceiptRepaymentMovement], 
		[DailyStatementIDCollateralSecuritiesMovement], 
		[DailyStatementIDCollateralSecuritiesDetails], 
		[BusinessID], 
		[TrustBankBranchCode], 
		[FundNumber], 
		[FundName]
	) 
		
	VALUES
	(
		@CorporationCode, 
		@PrincipalBrokerageID, 
		@OfficeCode, 
		@ACNumber, 
		@RecordID, 
		@BaseDate, 
		@CalculationDate, 
		@CalculationStartTime,
		@CalculationDateStartTime, 
		@SettlementCycle, 
		@SettlementType, 
		@Remarks, 
		@AccountOpenIDTSE, 
		@AccountOpenIDOSE, 
		@DailyStatementID, 
		@DailyStatementIDTradeDetails, 
		@DailyStatementIDAccountTotal, 
		@DailyStatementIDUnclosedContract, 
		@DailyStatementIDReceiptRepaymentMovement, 
		@DailyStatementIDCollateralSecuritiesMovement, 
		@DailyStatementIDCollateralSecuritiesDetails, 
		@BusinessID, 
		@TrustBankBranchCode, 
		@FundNumber, 
		@FundName
	);

--raiserror (''krip doing specific raiserror in stored proc for testing'', 19, 1) with log


Return Scope_Identity()
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Report_UpdateReportStatus]''
');

GO
EXECUTE ('
-- Description: Updates the status, stage, error message and error details of a
-- specific report in the ib_Report. If one of these parameters are not specified
-- (NULL) the old value is kept.
--
-- History
-- 04 Aug 2006	LM		Creation
-- 07 Aug 2006	LM		Allows updating only when ErrorMessage is null. This is useful to catch the very first error only and prevents later updates
--
-- 07 Aug 2006	LM		Added the URL parameter to update the report url as well
-- 08 Aug 2006	LM		Changed the Fields length
-- 03 Aug 2009	AAJM	Added WebReportURL 

CREATE PROCEDURE [dbo].[ib_Report_UpdateReportStatus]
	@ReportId int
	, @Status varchar(50)=NULL
	, @Stage varchar(512)=NULL
	, @ErrorMessage varchar(512)=NULL
	, @ErrorDetails text=NULL
	, @Notes text=NULL
	, @Url varchar(512) = NULL
	, @WebReportURL varchar(256) = NULL
AS
SET NOCOUNT ON

IF @Status IS NULL
	SELECT @Status = Status FROM [dbo].[ib_Report] WHERE ReportId = @ReportId

IF @Stage IS NULL
	SELECT @Stage = Stage FROM [dbo].[ib_Report] WHERE ReportId = @ReportId

IF @Notes IS NULL
	SELECT @Notes = Notes FROM [dbo].[ib_Report] WHERE ReportId = @ReportId

IF @ErrorMessage IS NULL
	SELECT @ErrorMessage = ErrorMessage FROM [dbo].[ib_Report] WHERE ReportId = @ReportId

IF @ErrorDetails IS NULL
	SELECT @ErrorDetails = ErrorDetails FROM [dbo].[ib_Report] WHERE ReportId = @ReportId

IF @Url IS NULL
	SELECT @Url = Url FROM [dbo].[ib_Report] WHERE ReportId = @ReportId

IF @WebReportURL IS NULL
	SELECT @WebReportURL = WebReportURL FROM [dbo].[ib_Report] WHERE ReportId = @ReportId
	
UPDATE [dbo].[ib_Report]
           SET [Status] = @Status
           ,[Stage] = @Stage
           ,[Notes] = @Notes
           ,[ErrorMessage] = @ErrorMessage
           ,[ErrorDetails] = @ErrorDetails
		   ,[Url] = @Url
		   ,[WebReportURL] = @WebReportURL
WHERE ReportId = @ReportId
	AND [ErrorMessage] IS NULL
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_ImportMonitor_Add]''
');

GO
EXECUTE ('-----------------------------------------------------------------
-- Adds an entry to the ib_ImportMonitor Table
-- 20131001 GC Created
-----------------------------------------------------------------

CREATE PROCEDURE [dbo].[ib_ImportMonitor_Add]
	@DataSourceId INT,
	@FileName VARCHAR(255),
	@Message VARCHAR(500),
	@Status VARCHAR(10)
AS

BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	INSERT INTO [dbo].[ib_ImportMonitor] (DataSourceId, [Filename], [Message], [Status], CreateDate, CreateUserName)
	VALUES (@DataSourceId,  @FileName, @Message, @Status, GETDATE(), SUSER_NAME())

END
');

GO
EXECUTE ('PRINT N''Creating [stage].[LmeTrade_Load]''
');

GO
EXECUTE ('CREATE PROCEDURE [stage].[LmeTrade_Load]
(
	@LocationPath VARCHAR(100)
	,@ReceiveLocationSysId INT
	,@RunId INT
)
AS
SET NOCOUNT ON

-- Description:	This stored procedure pulls data from the stage.LmeTrade temp
-- table and inserts it into ib_Trx
-- Whilst iterating through the records in stage.LmeTrade, all 
-- of these inserts are wrapped in a transaction so that any failure causes
-- the changes to not commit.
--
-- 20 Jun 2014	ED	EIB 25759 - Creation
-- 26 Jun 2014	ED	EIB 25783 - Set StrikePrice to null for F records
-- 10 Sep 2014	ED	EIB 25943 - Fix Option PromptDate

BEGIN

	DECLARE @Message			VARCHAR(1024)
	DECLARE @AddCount			INT
	SET @AddCount = 0
					
	DECLARE @DataSourceCode VARCHAR(100), @ExchangeCode VARCHAR(100), @FirmCode VARCHAR(100)
	DECLARE @DataSourceId INT
	DECLARE @Code VARCHAR(100)
	DECLARE @Code2 VARCHAR(100)
	DECLARE @ReturnValue INT
	DECLARE @Output INT
	DECLARE @Output2 INT
	DECLARE @DefaultCurrencyId INT
			
			
	DECLARE @receiveLocationName VARCHAR(100) = (SELECT ReceiveLocationName FROM ReceiveLocation WHERE ReceiveLocationSysId = @ReceiveLocationSysId)	

	-- Get Datasource
	SET @DataSourceCode = ''LME''
	SET @ExchangeCode = CASE WHEN @receiveLocationName = ''LMP-TRA'' THEN ''LMP'' ELSE ''LME'' END
	SET @FirmCode = CASE WHEN @receiveLocationName = ''LMP-TRA'' THEN ''MFP (LMP)'' ELSE ''MFL (LME)'' END
	
	SET @Code = @DataSourceCode
	EXEC @ReturnValue= [_ib_DataSource_GetByCodeForOutput] @Code,@OutPut output,@Output2 output	
	SET @DataSourceId = @Output
	SET @DefaultCurrencyId = @Output2	

	-- Duplicate file check										
	DECLARE @IsFileAlreadyLoaded INT
	EXEC @IsFileALreadyLoaded = HasFileBeenLoaded @LocationPath, @DataSourceId

	IF @IsFileAlreadyLoaded = 1
	BEGIN
		UPDATE stage.LmeTrade
		SET LoadState = 3
		WHERE LoadState = 1
			AND FileName = @LocationPath		
		RETURN
	END
	
	DECLARE @CheckAsOfDate DATETIME
	SET @CheckAsOfDate = (
		SELECT MIN(ReportDate) AS CheckRunDate 
		FROM stage.LmeTrade 
		WHERE LoadState = 1 AND Filename = @LocationPath AND TradeStatus IN(''AC'',''IN'') )
	IF (@CheckAsOfDate IS NOT NULL)
	BEGIN		
		DECLARE @IsAcceptable bit
		EXECUTE [dbo].[Load_IsFileTooOld] @DataSourceId,@LocationPath,@CheckAsOfDate,@IsAcceptable OUTPUT, @ReceiveLocationSysId, @RunId
		IF (@IsAcceptable = 0)
		BEGIN
			
			UPDATE stage.LmeTrade SET LoadState = 3 WHERE LoadState = 1 AND FileName = @LocationPath	
			RAISERROR (''File is too old.'', 18, 0)
			RETURN
		END									
	END

	-- Store ImportFile record for use
	DECLARE @ImportFileId INT
	EXEC ib_ImportFile_Add @DataSourceId, @LocationPath, @ImportFileId output

	--Gets the defaultStrikePriceDivisor
	DECLARE	@DefaultStrikePriceDivisor	DECIMAL(19,6)
	SET @DefaultStrikePriceDivisor = [dbo].[udf_GetDefaultStrikePriceDivisor](@DataSourceId, NULL)

	SET XACT_ABORT ON 

	BEGIN TRAN T1

		-- BizTalk''s SQL Adapter uses more restrictive read serializable
		-- so this is necessary to relax it to something that is default
		-- and perfectly acceptable!
		SET TRANSACTION ISOLATION LEVEL READ COMMITTED

		BEGIN TRY
			DECLARE @LmeTradeId INT
			DECLARE @ReportDate DATETIME  
			DECLARE @AccountCode VARCHAR(100)  
			DECLARE @Contract VARCHAR(3)  
			DECLARE @CurrencyCode VARCHAR(3)  
			DECLARE @ContractTypeCode VARCHAR(25)  
			DECLARE @SubContractType VARCHAR(1)  
			DECLARE @ForwardDate DATETIME 
			DECLARE @ForwardMonth VARCHAR(6)
			DECLARE @UniqueProductId VARCHAR(100)
			DECLARE @TradeDate DATETIME  
			DECLARE @TradePrice DECIMAL(19,5)  
			DECLARE @StrikePrice DECIMAL(19,5) 
			DECLARE @IsBuy BIT 
			DECLARE @Lots INT  
			DECLARE @UTI VARCHAR(100)  
			
			DECLARE trx_cursor CURSOR FOR
			SELECT [LmeTradeId]
				  ,[ReportDate]
				  ,[AccountCode]
				  ,[Contract]
				  ,[CurrencyCode]
				  ,[ContractTypeCode]
				  ,[SubContractType]
				  ,[ForwardDate]
				  ,[ForwardMonth]
				  ,[UniqueProductId]
				  ,[TradeDate]
				  ,[TradePrice]
				  ,[StrikePrice]
				  ,[IsBuy]
				  ,[Lots]
				  ,[UTI]
			FROM					
			stage.LmeTrade WHERE LoadState = 1 AND Filename = @LocationPath AND TradeStatus IN(''AC'',''IN'')
			
			OPEN trx_cursor

			FETCH NEXT FROM trx_cursor
			INTO 
				   @LmeTradeId
				  ,@ReportDate
				  ,@AccountCode
				  ,@Contract
				  ,@CurrencyCode
				  ,@ContractTypeCode
				  ,@SubContractType
				  ,@ForwardDate
				  ,@ForwardMonth
				  ,@UniqueProductId
				  ,@TradeDate
				  ,@TradePrice
				  ,@StrikePrice
				  ,@IsBuy
				  ,@Lots
				  ,@UTI

				-- Check @@FETCH_STATUS to see IF there are any more rows to fetch.
				WHILE @@FETCH_STATUS = 0
				BEGIN
					DECLARE		@InstrumentCd			VARCHAR(100)
					DECLARE		@InstrumentTypeCd		VARCHAR(100)
					DECLARE		@Quantity				DECIMAL(19,4)
					DECLARE		@QuantityLong			DECIMAL(19,4)
					DECLARE		@QuantityShort			DECIMAL(19,4)
					DECLARE		@SignedQuantity			DECIMAL(19,4)
					DECLARE		@ExpYr					SMALLINT
					DECLARE		@ExpMth					SMALLINT
					DECLARE		@ExpDay					SMALLINT
					DECLARE		@StrikePriceValue		DECIMAL(19,4)
					DECLARE		@TradePriceValue		DECIMAL(24,10)
					DECLARE		@TradePriceDivisor		DECIMAL(19,4)
					DECLARE		@StrikePriceDivisor		DECIMAL(19,4)
			--default to Future				
			SET @InstrumentTypeCd = ''F''						
			-- Set InstrumentTypeCd
			IF @ContractTypeCode = ''LMEOption'' OR @ContractTypeCode = ''LMETAPO'' 
				SET @InstrumentTypeCd = ''O''

			-- We prefix the Instruments with the IntrumentTypeCode
			SET @InstrumentCd = @InstrumentTypeCd + ''_'' + @ExchangeCode + ''_'' + @Contract			
					
			-- Set Quantity 
			SET @Quantity = 0
			SET @QuantityLong = 0
			SET @QuantityShort = 0
			
			-- Set Quantity (throw an error if not convertible)
			SET @Quantity = CONVERT(DECIMAL(19,4), @Lots)
						
			-- Set QuantityLong
			IF (@IsBuy = 1)
				BEGIN
					SET @QuantityLong = @Quantity
					SET @SignedQuantity = @Quantity 
				END
			ELSE					
			-- Set QuantityShort
				BEGIN
					SET @QuantityShort = @Quantity
					SET @SignedQuantity = @Quantity * (-1)
				END	
			-- Set ExpiryDate		
			SET @ExpDay = NULL
			SET @ExpMth = NULL
			SET @ExpYr = NULL	

			IF @InstrumentTypeCd = ''O''
			BEGIN
				DECLARE @ExpiryDate CHAR(8), @TempDate DATETIME
				SET @ExpiryDate = SUBSTRING(@UniqueProductId,10,8)
				SET @TempDate = CONVERT(datetime, @ExpiryDate, 112)
				IF @TempDate != dbo.GetLastBusinessDayOfTheMonth(@TempDate)
					SET @TempDate = dbo.GetThirdWednesdayOfTheMonth(@TempDate)
				SET @ExpYr = YEAR(@TempDate)
				SET @ExpMth = MONTH(@TempDate)
				SET @ExpDay = DAY(@TempDate)
				
			END
			ELSE IF @ForwardDate IS NOT NULL		
			BEGIN
				SET @ExpYr = YEAR(@ForwardDate)
				SET @ExpMth = MONTH(@ForwardDate)
				SET @ExpDay = DAY(@ForwardDate)
			END
			ELSE
			IF @ForwardMonth IS NOT NULL	
			BEGIN
				SET @TempDate = dbo.GetLastBusinessDayOfTheMonth(CONVERT(datetime, @ForwardMonth+''01'', 112))	
				SET @ExpYr = YEAR(@TempDate)
				SET @ExpMth = MONTH(@TempDate)
				SET @ExpDay = DAY(@TempDate)
			END

				-- Get Divisors						
			SET @StrikePriceDivisor = NULL
			SET @TradePriceDivisor = NULL
								
			SELECT @StrikePriceDivisor = ids.StrikePriceDivisor
					, @TradePriceDivisor = ids.PriceDivisor
			FROM [dbo].[ib_InstrumentDataSource] ids
			WHERE ids.DataSourceId = @DataSourceId
				AND ids.DataSourceInstrumentCode = @InstrumentCd

			-- Set Price	
			SET @TradePriceValue = NULL
					
			SET @TradePriceValue = CONVERT(DECIMAL(24,10), @TradePrice) / ISNULL(@TradePriceDivisor, 1)
			-- Set StrikePrice
			SET @StrikePriceValue = NULL	
			IF (@InstrumentTypeCd = ''O'')
				SET @StrikePriceValue = ISNULL(@StrikePrice, @TradePrice * @Lots)
			
			SET @StrikePriceValue = @StrikePriceValue / ISNULL(@StrikePriceDivisor, ISNULL(@DefaultStrikePriceDivisor, 1))
			
			IF NOT EXISTS(SELECT 1 FROM ib_TrxType WHERE DataSourceId = @DataSourceId AND Code = @ContractTypeCode)
				INSERT INTO ib_TrxType (DataSourceId, Code, Description, IsAutoMatched)
					VALUES(@DataSourceId, @ContractTypeCode, @ContractTypeCode, 1)
						
			DECLARE @TrxId INT		
			EXEC [ib_Trx_Load]
				@DataSourceCode			
				, @ExchangeCode -- exchange				
				, @FirmCode
				, @AccountCode	
				, NULL -- DetailAccountCd		
				, @InstrumentCd			
				, @ExpYr					
				, @ExpMth 					
				, @ExpDay 					
				, @StrikePriceValue			
				, @ContractTypeCode				
				, @SubContractType
				, @SignedQuantity			
				, @TradeDate				
				, @TradePriceValue
				, @LmeTradeId
				, @InstrumentTypeCd
				, @ReportDate		
				, @LocationPath
				, NULL -- marketValue
				, @CurrencyCode
				, @TrxId = @TrxId OUTPUT
				, @QuantityLong = @QuantityLong 
				, @QuantityShort = @QuantityShort
				, @ReceiveLocationSysId = @ReceiveLocationSysId
				, @RunId = @RunId
				, @UTI = @UTI		
			--flip processed flag in source table.
			UPDATE stage.LmeTrade WITH (ROWLOCK) SET [LoadState] = 2 WHERE LmeTradeId = @LmeTradeId AND [LoadState] = 1
			IF (@TrxId IS NOT NULL AND @TrxId > 0)
				SET @AddCount = @AddCount + 1
			
			FETCH NEXT FROM trx_cursor
			INTO 
					@LmeTradeId
				  ,@ReportDate
				  ,@AccountCode
				  ,@Contract
				  ,@CurrencyCode
				  ,@ContractTypeCode
				  ,@SubContractType
				  ,@ForwardDate
				  ,@ForwardMonth
				  ,@UniqueProductId
				  ,@TradeDate
				  ,@TradePrice
				  ,@StrikePrice
				  ,@IsBuy
				  ,@Lots
				  ,@UTI
		END
			
		CLOSE trx_cursor
		DEALLOCATE trx_cursor

			-- Now update state of any left-over temporary transaction records
			-- so there are no ''left-overs''
			UPDATE stage.LmeTrade
			WITH (ROWLOCK)
			SET [LoadState] = 2
			WHERE [LoadState] = 1 AND [FileName] = @LocationPath

			SET @Message = @DataSourceCode + '' transaction loader ended ('' + CONVERT(VARCHAR(10), @AddCount) + '' added).'' 
		
			EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @Message, ''Success'', '''', @RunId

			UPDATE ib_ImportFile SET AsOfDate = @CheckAsOfDate WHERE ImportFileId = @ImportFileId
			
		COMMIT TRAN T1
	
	END TRY
	BEGIN CATCH 

		IF XACT_STATE() = -1 
			ROLLBACK TRANSACTION
	
		SET @Message = @DataSourceCode + '' transaction loader failed.'' 		
		EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @Message, ''Error'', '''', @RunId
	
		EXEC [dbo].[sp_RethrowError]
		
	END CATCH 

	SET XACT_ABORT OFF

END

RETURN 0
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Broker_GetBrokerCodesHintByKeyword]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Broker_GetBrokerCodesHintByKeyword]
    @BrokerCode VARCHAR(100)
   ,@HintByStartOnly BIT = 0
   ,@HintLength INT = 1
AS 
SET NOCOUNT ON

DECLARE @len INT
SET @len = LEN(@BrokerCode)
IF @HintByStartOnly = 1 
    BEGIN
        SELECT DISTINCT
            SUBSTRING([Code], @len, @HintLength) x
        FROM
            [dbo].[ib_Broker]
        WHERE
            [Code] LIKE @BrokerCode + ''%''
        ORDER BY
            x

    END
ELSE 
    BEGIN
        SELECT DISTINCT
            SUBSTRING([Code], PATINDEX(''%'' + @BrokerCode + ''%'', [Code]) + @len,
                      @HintLength) x
        FROM
            [dbo].[ib_Broker]
        WHERE
            [Code] LIKE ''%'' + @BrokerCode + ''%''
        ORDER BY
            x
    END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[is_GAccountTotal_Add]''
');

GO
EXECUTE ('


/*
<Details>
<Summary>Inserts an item into the GAccountTotal table</Summary>
<Created author="laurentiu.macovei" date="04/05/2006 16:33:05" />
</Details>
*/
CREATE PROCEDURE [dbo].[is_GAccountTotal_Add]
	@CorporationCode varchar(4) = NULL,
	@PrincipalBrokerageId varchar(1) = NULL,
	@OfficeCode varchar(4) = NULL,
	@ACNo varchar(10) = NULL,
	@RecordId varchar(2) = NULL,
	@BaseDate datetime = NULL,
	@CalculationDate datetime = NULL,
	@CalculationStartTime datetime = NULL,
	@PreviousDaySFinalCashBalanceSign varchar(1) = NULL,
	@PreviousDaySFinalCashBalance decimal(15,0) = NULL,
	@PreviousDaySSettlementAmountSign varchar(1) = NULL,
	@PreviousDaySSettlementAmount decimal(15,0) = NULL,
	@PreviousDaySReportedCashBalanceSign varchar(1) = NULL,
	@PreviousDaySReportedCashBalance decimal(15,0) = NULL,
	@AdjustmentFPDAmountSign varchar(1) = NULL,
	@AdjustmentFPDAmount decimal(15,0) = NULL,
	@AdjustmentFPDFuturesRealizedPLSign varchar(1) = NULL,
	@AdjustmentFPDFuturesRealizedPL decimal(15,0) = NULL,
	@AdjustmentFPDOptionsPremiumAmountBuySign varchar(1) = NULL,
	@AdjustmentFPDOptionsPremiumAmountBuy decimal(15,0) = NULL,
	@AdjustmentFPDOptionsPremiumAmountSellSign varchar(1) = NULL,
	@AdjustmentFPDOptionsPremiumAmountSell decimal(15,0) = NULL,
	@AdjustmentFPDNetStrikePriceForExerciseSign varchar(1) = NULL,
	@AdjustmentFPDNetStrikePriceForExercise decimal(15,0) = NULL,
	@AdjustmentFPDNetStrikePriceForAllotmentSign varchar(1) = NULL,
	@AdjustmentFPDNetStrikePriceForAllotment decimal(15,0) = NULL,
	@AdjustmentFPDDomesticCommissionSign varchar(1) = NULL,
	@AdjustmentFPDDomesticCommission decimal(15,0) = NULL,
	@AdjustmentFPDConsumptionTaxOnCommissionSign varchar(1) = NULL,
	@AdjustmentFPDConsumptionTaxOnCommission decimal(15,0) = NULL,
	@AdjustmentFPDExchangeTaxSign varchar(1) = NULL,
	@AdjustmentFPDExchangeTax decimal(15,0) = NULL,
	@AdjustmentFPDReceiptPaymentAmountSign varchar(1) = NULL,
	@AdjustmentFPDReceiptPaymentAmount decimal(15,0) = NULL,
	@ReceiptPaymentAmountFCDSign varchar(1) = NULL,
	@ReceiptPaymentAmountFCD decimal(15,0) = NULL,
	@FinalCashBalanceFCDSign varchar(1) = NULL,
	@FinalCashBalanceFCD decimal(15,0) = NULL,
	@SettlementAmountFCDTradingSign varchar(1) = NULL,
	@SettlementAmountFCDTrading decimal(15,0) = NULL,
	@RealizedPLFCDFuturesTradingSign varchar(1) = NULL,
	@RealizedPLFCDFuturesTrading decimal(15,0) = NULL,
	@OptionsPremiumFCDTradingBuySign varchar(1) = NULL,
	@OptionsPremiumFCDTradingBuy decimal(15,0) = NULL,
	@OptionsPremiumFCDTradingSellSign varchar(1) = NULL,
	@OptionsPremiumFCDTradingSell decimal(15,0) = NULL,
	@NetStrikePriceFCDTradingForExerciseSign varchar(1) = NULL,
	@NetStrikePriceFCDTradingForExercise decimal(15,0) = NULL,
	@NetStrikePriceFCDTradingForAllotmentSign varchar(1) = NULL,
	@NetStrikePriceFCDTradingForAllotment decimal(15,0) = NULL,
	@DomesticCommissionFCDTradingSign varchar(1) = NULL,
	@DomesticCommissionFCDTrading decimal(15,0) = NULL,
	@ConsumptionTaxOnCommissionFCDTradingSign varchar(1) = NULL,
	@ConsumptionTaxOnCommissionFCDTrading decimal(15,0) = NULL,
	@ExchangeTaxFCDTradingSign varchar(1) = NULL,
	@ExchangeTaxFCDTrading decimal(15,0) = NULL,
	@CashBalanceReportedOnCurrentDaySign varchar(1) = NULL,
	@CashBalanceReportedOnCurrentDay decimal(15,0) = NULL,
	@UnrealizedPLSign varchar(1) = NULL,
	@UnrealizedPL decimal(15,0) = NULL,
	@UnrealizedPLNonCalculableFlag varchar(1) = NULL,
	@TotalMarginCashSign varchar(1) = NULL,
	@TotalMarginCash decimal(15,0) = NULL,
	@CollateralValueFCDTseDirectDeposit decimal(15,0) = NULL,
	@CollateralValueFCDOseDirectDeposit decimal(15,0) = NULL,
	@CollateralValueFCDMemberDirectDeposit decimal(15,0) = NULL,
	@CollateralValueFCDDepositForReplacement decimal(15,0) = NULL,
	@CollateralValueFCDTotal decimal(15,0) = NULL,
	@ScheduledCollateralMovementAmountFFDSignTseDirectDeposit varchar(1) = NULL,
	@ScheduledCollateralMovementAmountFFDTseDirectDeposit decimal(15,0) = NULL,
	@ScheduledCollateralMovementAmountFFDSignOseDirectDeposit varchar(1) = NULL,
	@CollateralMovementScheduledAmountFFDOseDirectDeposit decimal(15,0) = NULL,
	@ScheduledCollateralMovementAmountFFDSignMemberDirect varchar(1) = NULL,
	@ScheduledCollateralMovementAmountFFDMemberDirectDeposit decimal(15,0) = NULL,
	@ScheduledCollateralMovementAmountFFDSignDepositForReplacement varchar(1) = NULL,
	@ScheduledCollateralMovementAmountFFDDepositForReplacement decimal(15,0) = NULL,
	@ScheduledCollateralMovementAmountFFDSignTotal varchar(1) = NULL,
	@ScheduledCollateralMovementAmountFFDTotal decimal(15,0) = NULL,
	@CollateralNonCalculableFlagTotal varchar(1) = NULL,
	@TotalMarginMoneySign varchar(1) = NULL,
	@TotalMarginMoney decimal(15,0) = NULL,
	@MarginRequirementTse decimal(15,0) = NULL,
	@MarginRequirementOse decimal(15,0) = NULL,
	@MarginRequirementExchangeTotal decimal(15,0) = NULL,
	@RequiredAmountNonCalculableFlagTotal varchar(1) = NULL,
	@MarginDeficitExcessAmountTotalSign varchar(1) = NULL,
	@MarginDeficitExcessAmountTotal decimal(15,0) = NULL,
	@MarginDeficitExcessAmountCashSign varchar(1) = NULL,
	@MarginDeficitExcessAmountCash decimal(15,0) = NULL,
	@MarginDeficitExcessAmountCollateralSign varchar(1) = NULL,
	@MarginDeficitExcessAmountCollateral decimal(15,0) = NULL,
	@StandardReceiptPaymentAmountSign varchar(1) = NULL,
	@StandardReceiptPaymentAmount decimal(15,0) = NULL,
	@ReceiptPaymentDate datetime = NULL,
	@ScheduledReceiptPaymentAmountFFDSign varchar(1) = NULL,
	@ScheduledReceiptPaymentAmountFFD decimal(15,0) = NULL,
	@ScheduledReceiptPaymentAmountForDayAfterNextSign varchar(1) = NULL,
	@ScheduledReceiptPaymentAmountForDayAfterNext decimal(15,0) = NULL,
	@ScheduledCollateralMovementAmountForDayAfterNextSign varchar(1) = NULL,
	@ScheduledCollateralMovementAmountForDayAfterNext decimal(15,0) = NULL,
	@LongOptionValue decimal(15,0) = NULL,
	@ShortOptionValue decimal(15,0) = NULL
AS
SET NOCOUNT ON

SET NOCOUNT OFF

	DECLARE	@CalculationDateStartTime												DATETIME
	DECLARE @PreviousDaySFinalCashBalanceSigned										DECIMAL(15,0)
	DECLARE @PreviousDaySSettlementAmountSigned										DECIMAL(15,0)
	DECLARE @PreviousDaySReportedCashBalanceSigned									DECIMAL(15,0)
	DECLARE @AdjustmentFPDAmountSigned												DECIMAL(15,0)
	DECLARE @AdjustmentFPDFuturesRealizedPLSigned									DECIMAL(15,0)
	DECLARE @AdjustmentFPDOptionsPremiumAmountBuySigned								DECIMAL(15,0)
	DECLARE @AdjustmentFPDOptionsPremiumAmountSellSigned							DECIMAL(15,0)
	DECLARE @AdjustmentFPDNetStrikePriceForExerciseSigned							DECIMAL(15,0)
	DECLARE @AdjustmentFPDNetStrikePriceForAllotmentSigned							DECIMAL(15,0)
	DECLARE @AdjustmentFPDDomesticCommissionSigned									DECIMAL(15,0)
	DECLARE @AdjustmentFPDConsumptionTaxOnCommissionSigned							DECIMAL(15,0)
	DECLARE @AdjustmentFPDExchangeTaxSigned											DECIMAL(15,0)
	DECLARE @AdjustmentFPDReceiptPaymentAmountSigned								DECIMAL(15,0)
	DECLARE @ReceiptPaymentAmountFCDSigned											DECIMAL(15,0)
	DECLARE @FinalCashBalanceFCDSigned												DECIMAL(15,0)
	DECLARE @SettlementAmountFCDTradingSigned										DECIMAL(15,0)
	DECLARE @RealizedPLFCDFuturesTradingSigned										DECIMAL(15,0)
	DECLARE @OptionsPremiumFCDTradingBuySigned										DECIMAL(15,0)
	DECLARE @OptionsPremiumFCDTradingSellSigned										DECIMAL(15,0)
	DECLARE @NetStrikePriceFCDTradingForExerciseSigned								DECIMAL(15,0)
	DECLARE @NetStrikePriceFCDTradingForAllotmentSigned								DECIMAL(15,0)
	DECLARE @DomesticCommissionFCDTradingSigned										DECIMAL(15,0)
	DECLARE @ConsumptionTaxOnCommissionFCDTradingSigned								DECIMAL(15,0)
	DECLARE @ExchangeTaxFCDTradingSigned											DECIMAL(15,0)
	DECLARE @CashBalanceReportedOnCurrentDaySigned									DECIMAL(15,0)
	DECLARE @UnrealizedPLSigned														DECIMAL(15,0)
	DECLARE @TotalMarginCashSigned													DECIMAL(15,0)
	DECLARE @ScheduledCollateralMovementAmountFFDSignTseDirectDepositSigned			DECIMAL(15,0)
	DECLARE @ScheduledCollateralMovementAmountFFDSignOseDirectDepositSigned			DECIMAL(15,0)
	DECLARE @ScheduledCollateralMovementAmountFFDSignMemberDirectSigned				DECIMAL(15,0)
	DECLARE @ScheduledCollateralMovementAmountFFDSignDepositForReplacementSigned	DECIMAL(15,0)
	DECLARE @ScheduledCollateralMovementAmountFFDSignTotalSigned					DECIMAL(15,0)
	DECLARE @TotalMarginMoneySigned													DECIMAL(15,0)
	DECLARE @MarginDeficitExcessAmountTotalSigned									DECIMAL(15,0)
	DECLARE @MarginDeficitExcessAmountCashSigned									DECIMAL(15,0)
	DECLARE @MarginDeficitExcessAmountCollateralSigned								DECIMAL(15,0)
	DECLARE @StandardReceiptPaymentAmountSigned										DECIMAL(15,0)
	DECLARE @ScheduledReceiptPaymentAmountFFDSigned									DECIMAL(15,0)
	DECLARE @ScheduledReceiptPaymentAmountForDayAfterNextSigned						DECIMAL(15,0)
	DECLARE @ScheduledCollateralMovementAmountForDayAfterNextSigned					DECIMAL(15,0)

	IF @PreviousDaySFinalCashBalanceSign = ''-'' 	
		SET @PreviousDaySFinalCashBalanceSigned = @PreviousDaySFinalCashBalance * -1 
	ELSE	
		SET @PreviousDaySFinalCashBalanceSigned = @PreviousDaySFinalCashBalance

	IF @PreviousDaySSettlementAmountSign = ''-'' 	
		SET @PreviousDaySSettlementAmountSigned = @PreviousDaySSettlementAmount * -1 
	ELSE	
		SET @PreviousDaySSettlementAmountSigned = @PreviousDaySSettlementAmount

	IF @PreviousDaySReportedCashBalanceSign= ''-'' 	
		SET @PreviousDaySReportedCashBalanceSigned= @PreviousDaySReportedCashBalance * -1 
	ELSE	
		SET @PreviousDaySReportedCashBalanceSigned= @PreviousDaySReportedCashBalance

	IF @AdjustmentFPDAmountSign = ''-'' 	
		SET @AdjustmentFPDAmountSigned= @AdjustmentFPDAmount*-1 
	ELSE	
		SET @AdjustmentFPDAmountSigned= @AdjustmentFPDAmount

	IF @AdjustmentFPDFuturesRealizedPLSign = ''-'' 	
		SET @AdjustmentFPDFuturesRealizedPLSigned = @AdjustmentFPDFuturesRealizedPL * -1 
	ELSE	
		SET @AdjustmentFPDFuturesRealizedPLSigned = @AdjustmentFPDFuturesRealizedPL

	IF @AdjustmentFPDOptionsPremiumAmountBuySign = ''-'' 	
		SET @AdjustmentFPDOptionsPremiumAmountBuySigned = @AdjustmentFPDOptionsPremiumAmountBuy * -1 
	ELSE	
		SET @AdjustmentFPDOptionsPremiumAmountBuySigned = @AdjustmentFPDOptionsPremiumAmountBuy

	IF @AdjustmentFPDOptionsPremiumAmountSellSign = ''-'' 	
		SET @AdjustmentFPDOptionsPremiumAmountSellSigned= @AdjustmentFPDOptionsPremiumAmountSell * -1 
	ELSE	
		SET @AdjustmentFPDOptionsPremiumAmountSellSigned = @AdjustmentFPDOptionsPremiumAmountSell

	IF @AdjustmentFPDNetStrikePriceForExerciseSign = ''-'' 	
		SET @AdjustmentFPDNetStrikePriceForExerciseSigned = @AdjustmentFPDNetStrikePriceForExercise*-1 
	ELSE	
		SET @AdjustmentFPDNetStrikePriceForExerciseSigned = @AdjustmentFPDNetStrikePriceForExercise

	IF @AdjustmentFPDNetStrikePriceForAllotmentSign = ''-'' 	
		SET @AdjustmentFPDNetStrikePriceForAllotmentSigned = @AdjustmentFPDNetStrikePriceForAllotment*-1 
	ELSE	
		SET @AdjustmentFPDNetStrikePriceForAllotmentSigned = @AdjustmentFPDNetStrikePriceForAllotment

	IF @AdjustmentFPDDomesticCommissionSign = ''-'' 	
		SET @AdjustmentFPDDomesticCommissionSigned = @AdjustmentFPDDomesticCommission*-1 
	ELSE	
		SET @AdjustmentFPDDomesticCommissionSigned = @AdjustmentFPDDomesticCommission

	IF @AdjustmentFPDConsumptionTaxOnCommissionSign = ''-'' 	
		SET @AdjustmentFPDConsumptionTaxOnCommissionSigned = @AdjustmentFPDConsumptionTaxOnCommission*-1 
	ELSE	
		SET @AdjustmentFPDConsumptionTaxOnCommissionSigned = @AdjustmentFPDConsumptionTaxOnCommission

	IF @AdjustmentFPDExchangeTaxSign = ''-'' 	
		SET @AdjustmentFPDExchangeTaxSigned = @AdjustmentFPDExchangeTax * -1 
	ELSE	
		SET @AdjustmentFPDExchangeTaxSigned = @AdjustmentFPDExchangeTax

	IF @AdjustmentFPDReceiptPaymentAmountSign= ''-'' 	
		SET @AdjustmentFPDReceiptPaymentAmountSigned = @AdjustmentFPDReceiptPaymentAmount * -1 
	ELSE	
		SET @AdjustmentFPDReceiptPaymentAmountSigned = @AdjustmentFPDReceiptPaymentAmount

	IF @ReceiptPaymentAmountFCDSign= ''-'' 	
		SET @ReceiptPaymentAmountFCDSigned = @ReceiptPaymentAmountFCD * -1 
	ELSE	
		SET @ReceiptPaymentAmountFCDSigned = @ReceiptPaymentAmountFCD

	IF @FinalCashBalanceFCDSign = ''-'' 	
		SET @FinalCashBalanceFCDSigned = @FinalCashBalanceFCD * -1 
	ELSE	
		SET @FinalCashBalanceFCDSigned = @FinalCashBalanceFCD

	IF @SettlementAmountFCDTradingSign = ''-'' 	
		SET @SettlementAmountFCDTradingSigned = @SettlementAmountFCDTrading * -1 
	ELSE	
		SET @SettlementAmountFCDTradingSigned = @SettlementAmountFCDTrading

	IF @RealizedPLFCDFuturesTradingSign = ''-'' 	
		SET @RealizedPLFCDFuturesTradingSigned = @RealizedPLFCDFuturesTrading * -1 
	ELSE	
		SET @RealizedPLFCDFuturesTradingSigned = @RealizedPLFCDFuturesTrading

	IF @OptionsPremiumFCDTradingBuySign= ''-'' 	
		SET @OptionsPremiumFCDTradingBuySigned = @OptionsPremiumFCDTradingBuy * -1 
	ELSE	
		SET @OptionsPremiumFCDTradingBuySigned = @OptionsPremiumFCDTradingBuy

	IF @OptionsPremiumFCDTradingSellSign = ''-'' 	
		SET @OptionsPremiumFCDTradingSellSigned = @OptionsPremiumFCDTradingSell * -1 
	ELSE	
		SET @OptionsPremiumFCDTradingSellSigned = @OptionsPremiumFCDTradingSell

	IF @NetStrikePriceFCDTradingForExerciseSign = ''-'' 	
		SET @NetStrikePriceFCDTradingForExerciseSigned = @NetStrikePriceFCDTradingForExercise * -1 
	ELSE	
		SET @NetStrikePriceFCDTradingForExerciseSigned = @NetStrikePriceFCDTradingForExercise

	IF @NetStrikePriceFCDTradingForAllotmentSign = ''-'' 	
		SET @NetStrikePriceFCDTradingForAllotmentSigned = @NetStrikePriceFCDTradingForAllotment * -1 
	ELSE	
		SET @NetStrikePriceFCDTradingForAllotmentSigned = @NetStrikePriceFCDTradingForAllotment

	IF @DomesticCommissionFCDTradingSign = ''-'' 	
		SET @DomesticCommissionFCDTradingSigned = @DomesticCommissionFCDTrading * -1 
	ELSE	
		SET @DomesticCommissionFCDTradingSigned = @DomesticCommissionFCDTrading

	IF @ConsumptionTaxOnCommissionFCDTradingSign = ''-'' 	
		SET @ConsumptionTaxOnCommissionFCDTradingSigned = @ConsumptionTaxOnCommissionFCDTrading * -1 
	ELSE	
		SET @ConsumptionTaxOnCommissionFCDTradingSigned = @ConsumptionTaxOnCommissionFCDTrading

	IF @ExchangeTaxFCDTradingSign = ''-'' 	
		SET @ExchangeTaxFCDTradingSigned = @ExchangeTaxFCDTrading * -1 
	ELSE	
		SET @ExchangeTaxFCDTradingSigned = @ExchangeTaxFCDTrading

	IF @CashBalanceReportedOnCurrentDaySign = ''-'' 	
		SET @CashBalanceReportedOnCurrentDaySigned= @CashBalanceReportedOnCurrentDay * -1 
	ELSE	
		SET @CashBalanceReportedOnCurrentDaySigned = @CashBalanceReportedOnCurrentDay

	IF @UnrealizedPLSign = ''-'' 	
		SET @UnrealizedPLSigned= @UnrealizedPL * -1 
	ELSE	
		SET @UnrealizedPLSigned = @UnrealizedPL

	IF @TotalMarginCashSign = ''-'' 	
		SET @TotalMarginCashSigned= @TotalMarginCash * -1 
	ELSE	
		SET @TotalMarginCashSigned = @TotalMarginCash

	IF @ScheduledCollateralMovementAmountFFDSignTseDirectDeposit = ''-'' 	
		SET @ScheduledCollateralMovementAmountFFDSignTseDirectDepositSigned = @ScheduledCollateralMovementAmountFFDTseDirectDeposit * -1 
	ELSE	
		SET @ScheduledCollateralMovementAmountFFDSignTseDirectDepositSigned = @ScheduledCollateralMovementAmountFFDTseDirectDeposit

	IF @ScheduledCollateralMovementAmountFFDSignOseDirectDeposit = ''-'' 	
		SET @ScheduledCollateralMovementAmountFFDSignOseDirectDepositSigned = @CollateralMovementScheduledAmountFFDOseDirectDeposit * -1 
	ELSE	
		SET @ScheduledCollateralMovementAmountFFDSignOseDirectDepositSigned = @CollateralMovementScheduledAmountFFDOseDirectDeposit

	IF @ScheduledCollateralMovementAmountFFDSignMemberDirect = ''-'' 	
		SET @ScheduledCollateralMovementAmountFFDSignMemberDirectSigned = @ScheduledCollateralMovementAmountFFDMemberDirectDeposit * -1 
	ELSE	
		SET @ScheduledCollateralMovementAmountFFDSignMemberDirectSigned = @ScheduledCollateralMovementAmountFFDMemberDirectDeposit

	IF @ScheduledCollateralMovementAmountFFDSignDepositForReplacement = ''-'' 	
		SET @ScheduledCollateralMovementAmountFFDSignDepositForReplacementSigned = @ScheduledCollateralMovementAmountFFDDepositForReplacement * -1 
	ELSE	
		SET @ScheduledCollateralMovementAmountFFDSignDepositForReplacementSigned = @ScheduledCollateralMovementAmountFFDDepositForReplacement

	IF @ScheduledCollateralMovementAmountFFDSignTotal= ''-'' 	
		SET @ScheduledCollateralMovementAmountFFDSignTotalSigned = @ScheduledCollateralMovementAmountFFDTotal * -1 
	ELSE	
		SET @ScheduledCollateralMovementAmountFFDSignTotalSigned = @ScheduledCollateralMovementAmountFFDTotal

	IF @TotalMarginMoneySign = ''-'' 	
		SET @TotalMarginMoneySigned = @TotalMarginMoney * -1 
	ELSE	
		SET @TotalMarginMoneySigned = @TotalMarginMoney

	IF @MarginDeficitExcessAmountTotalSign = ''-'' 	
		SET @MarginDeficitExcessAmountTotalSigned = @MarginDeficitExcessAmountTotal * -1 
	ELSE	
		SET @MarginDeficitExcessAmountTotalSigned = @MarginDeficitExcessAmountTotal

	IF @MarginDeficitExcessAmountCashSign = ''-'' 	
		SET @MarginDeficitExcessAmountCashSigned = @MarginDeficitExcessAmountCash * -1 
	ELSE	
		SET @MarginDeficitExcessAmountCashSigned = @MarginDeficitExcessAmountCash

	IF @MarginDeficitExcessAmountCollateralSign = ''-'' 	
		SET @MarginDeficitExcessAmountCollateralSigned = @MarginDeficitExcessAmountCollateral * -1 
	ELSE	
		SET @MarginDeficitExcessAmountCollateralSigned = @MarginDeficitExcessAmountCollateral

	IF @StandardReceiptPaymentAmountSign = ''-'' 	
		SET @StandardReceiptPaymentAmountSigned = @StandardReceiptPaymentAmount * -1 
	ELSE	
		SET @StandardReceiptPaymentAmountSigned = @StandardReceiptPaymentAmount

	IF @ScheduledReceiptPaymentAmountFFDSign = ''-'' 	
		SET @ScheduledReceiptPaymentAmountFFDSigned = @ScheduledReceiptPaymentAmountFFD * -1 
	ELSE	
		SET @ScheduledReceiptPaymentAmountFFDSigned = @ScheduledReceiptPaymentAmountFFD

	IF @ScheduledReceiptPaymentAmountForDayAfterNextSign = ''-'' 	
		SET @ScheduledReceiptPaymentAmountForDayAfterNextSigned = @ScheduledReceiptPaymentAmountForDayAfterNext * -1 
	ELSE	
		SET @ScheduledReceiptPaymentAmountForDayAfterNextSigned = @ScheduledReceiptPaymentAmountForDayAfterNext

	IF @ScheduledCollateralMovementAmountForDayAfterNextSign = ''-'' 	
		SET @ScheduledCollateralMovementAmountForDayAfterNextSigned = @ScheduledCollateralMovementAmountForDayAfterNext * -1 
	ELSE	
		SET @ScheduledCollateralMovementAmountForDayAfterNextSigned = @ScheduledCollateralMovementAmountForDayAfterNext



	IF @BaseDate = ''01/01/1900 00:00:00'' 
		SET @BaseDate = NULL

	IF @CalculationDate = ''01/01/1900 00:00:00'' 
		SET @CalculationDate = NULL

	IF @CalculationStartTime = ''01/01/1900 00:00:00'' 
		SET @CalculationStartTime = NULL

	IF @ReceiptPaymentDate = ''01/01/1900 00:00:00'' 
		SET @ReceiptPaymentDate = NULL

	--raiserror (''problem'', 19, 1) with log

	SET @CalculationDateStartTime = CONVERT(DATETIME,CONVERT(VARCHAR(12), CONVERT(DATETIME,@CalculationDate,112)) + '' '' + CONVERT(VARCHAR(8),RIGHT(@CalculationStartTime,8)))

	INSERT INTO is_GAccountTotal 
		(
			[CorporationCode], 
			[PrincipalBrokerageId], 
			[OfficeCode], 
			[ACNo], 
			[RecordId], 
			[BaseDate], 
			[CalculationDate], 
			[CalculationStartTime], 
			[CalculationDateStartTime],
			[PreviousDaySFinalCashBalanceSign], 
			[PreviousDaySFinalCashBalance], 
			[PreviousDaySFinalCashBalanceSigned],
			[PreviousDaySSettlementAmountSign], 
			[PreviousDaySSettlementAmount], 
			[PreviousDaySSettlementAmountSigned],
			[PreviousDaySReportedCashBalanceSign], 
			[PreviousDaySReportedCashBalance], 
			[PreviousDaySReportedCashBalanceSigned],
			[AdjustmentFPDAmountSign], 
			[AdjustmentFPDAmount], 
			[AdjustmentFPDAmountSigned], 
			[AdjustmentFPDFuturesRealizedPLSign], 
			[AdjustmentFPDFuturesRealizedPL], 
			[AdjustmentFPDFuturesRealizedPLSigned], 
			[AdjustmentFPDOptionsPremiumAmountBuySign], 
			[AdjustmentFPDOptionsPremiumAmountBuy], 
			[AdjustmentFPDOptionsPremiumAmountBuySigned], 
			[AdjustmentFPDOptionsPremiumAmountSellSign], 
			[AdjustmentFPDOptionsPremiumAmountSell], 
			[AdjustmentFPDOptionsPremiumAmountSellSigned], 
			[AdjustmentFPDNetStrikePriceForExerciseSign], 
			[AdjustmentFPDNetStrikePriceForExercise], 
			[AdjustmentFPDNetStrikePriceForExerciseSigned],
			[AdjustmentFPDNetStrikePriceForAllotmentSign], 
			[AdjustmentFPDNetStrikePriceForAllotment], 
			[AdjustmentFPDNetStrikePriceForAllotmentSigned], 
			[AdjustmentFPDDomesticCommissionSign], 
			[AdjustmentFPDDomesticCommission], 
			[AdjustmentFPDDomesticCommissionSigned],
			[AdjustmentFPDConsumptionTaxOnCommissionSign], 
			[AdjustmentFPDConsumptionTaxOnCommission], 
			[AdjustmentFPDConsumptionTaxOnCommissionSigned], 
			[AdjustmentFPDExchangeTaxSign], 
			[AdjustmentFPDExchangeTax], 
			[AdjustmentFPDExchangeTaxSigned], 
			[AdjustmentFPDReceiptPaymentAmountSign], 
			[AdjustmentFPDReceiptPaymentAmount], 
			[AdjustmentFPDReceiptPaymentAmountSigned], 
			[ReceiptPaymentAmountFCDSign], 
			[ReceiptPaymentAmountFCD], 
			[ReceiptPaymentAmountFCDSigned], 
			[FinalCashBalanceFCDSign], 
			[FinalCashBalanceFCD], 
			[FinalCashBalanceFCDSigned], 
			[SettlementAmountFCDTradingSign], 
			[SettlementAmountFCDTrading], 
			[SettlementAmountFCDTradingSigned], 
			[RealizedPLFCDFuturesTradingSign], 
			[RealizedPLFCDFuturesTrading], 
			[RealizedPLFCDFuturesTradingSigned], 
			[OptionsPremiumFCDTradingBuySign], 
			[OptionsPremiumFCDTradingBuy], 
			[OptionsPremiumFCDTradingBuySigned], 
			[OptionsPremiumFCDTradingSellSign], 
			[OptionsPremiumFCDTradingSell],
			[OptionsPremiumFCDTradingSellSigned],  
			[NetStrikePriceFCDTradingForExerciseSign], 
			[NetStrikePriceFCDTradingForExercise],
			[NetStrikePriceFCDTradingForExerciseSigned],  
			[NetStrikePriceFCDTradingForAllotmentSign], 
			[NetStrikePriceFCDTradingForAllotment],
			[NetStrikePriceFCDTradingForAllotmentSigned],  
			[DomesticCommissionFCDTradingSign], 
			[DomesticCommissionFCDTrading],
			[DomesticCommissionFCDTradingSigned],  
			[ConsumptionTaxOnCommissionFCDTradingSign], 
			[ConsumptionTaxOnCommissionFCDTrading],
			[ConsumptionTaxOnCommissionFCDTradingSigned],  
			[ExchangeTaxFCDTradingSign], 
			[ExchangeTaxFCDTrading], 
			[ExchangeTaxFCDTradingSigned],
			[CashBalanceReportedOnCurrentDaySign], 
			[CashBalanceReportedOnCurrentDay],
			[CashBalanceReportedOnCurrentDaySigned],  
			[UnrealizedPLSign], 
			[UnrealizedPL], 
			[UnrealizedPLSigned], 
			[UnrealizedPLNonCalculableFlag], 
			[TotalMarginCashSign], 
			[TotalMarginCash], 
			[TotalMarginCashSigned], 
			[CollateralValueFCDTseDirectDeposit], 
			[CollateralValueFCDOseDirectDeposit], 
			[CollateralValueFCDMemberDirectDeposit], 
			[CollateralValueFCDDepositForReplacement], 
			[CollateralValueFCDTotal], 
			[ScheduledCollateralMovementAmountFFDSignTseDirectDeposit], 
			[ScheduledCollateralMovementAmountFFDTseDirectDeposit], 
			[ScheduledCollateralMovementAmountFFDSignTseDirectDepositSigned], 
			[ScheduledCollateralMovementAmountFFDSignOseDirectDeposit], 
			[CollateralMovementScheduledAmountFFDOseDirectDeposit], 
			[ScheduledCollateralMovementAmountFFDSignOseDirectDepositSigned], 
			[ScheduledCollateralMovementAmountFFDSignMemberDirect], 
			[ScheduledCollateralMovementAmountFFDMemberDirectDeposit], 
			[ScheduledCollateralMovementAmountFFDSignMemberDirectSigned],
			[ScheduledCollateralMovementAmountFFDSignDepositForReplacement], 
			[ScheduledCollateralMovementAmountFFDDepositForReplacement], 
			[ScheduledCollateralMovementAmountFFDSignDepositForReplacementSigned], 
			[ScheduledCollateralMovementAmountFFDSignTotal], 
			[ScheduledCollateralMovementAmountFFDTotal], 
			[ScheduledCollateralMovementAmountFFDSignTotalSigned], 
			[CollateralNonCalculableFlagTotal], 
			[TotalMarginMoneySign], 
			[TotalMarginMoney], 
			[TotalMarginMoneySigned], 
			[MarginRequirementTse], 
			[MarginRequirementOse], 
			[MarginRequirementExchangeTotal], 
			[RequiredAmountNonCalculableFlagTotal], 
			[MarginDeficitExcessAmountTotalSign], 
			[MarginDeficitExcessAmountTotal], 
			[MarginDeficitExcessAmountTotalSigned], 
			[MarginDeficitExcessAmountCashSign], 
			[MarginDeficitExcessAmountCash], 
			[MarginDeficitExcessAmountCashSigned],
			[MarginDeficitExcessAmountCollateralSign], 
			[MarginDeficitExcessAmountCollateral], 
			[MarginDeficitExcessAmountCollateralSigned], 
			[StandardReceiptPaymentAmountSign], 
			[StandardReceiptPaymentAmount], 
			[StandardReceiptPaymentAmountSigned], 
			[ReceiptPaymentDate], 
			[ScheduledReceiptPaymentAmountFFDSign], 
			[ScheduledReceiptPaymentAmountFFD], 
			[ScheduledReceiptPaymentAmountFFDSigned], 
			[ScheduledReceiptPaymentAmountForDayAfterNextSign], 
			[ScheduledReceiptPaymentAmountForDayAfterNext], 
			[ScheduledReceiptPaymentAmountForDayAfterNextSigned], 
			[ScheduledCollateralMovementAmountForDayAfterNextSign], 
			[ScheduledCollateralMovementAmountForDayAfterNext], 
			[ScheduledCollateralMovementAmountForDayAfterNextSigned], 
			[LongOptionValue], 
			[ShortOptionValue]
		) 
		VALUES
		(
			@CorporationCode, 
			@PrincipalBrokerageId, 
			@OfficeCode, 
			@ACNo, 
			@RecordId, 
			@BaseDate, 
			@CalculationDate, 
			@CalculationStartTime,
			@CalculationDateStartTime, 
			@PreviousDaySFinalCashBalanceSign, 
			@PreviousDaySFinalCashBalance, 
			@PreviousDaySFinalCashBalanceSigned,
			@PreviousDaySSettlementAmountSign, 
			@PreviousDaySSettlementAmount,
			@PreviousDaySSettlementAmountSigned,
			@PreviousDaySReportedCashBalanceSign, 
			@PreviousDaySReportedCashBalance, 
			@PreviousDaySReportedCashBalanceSigned,
			@AdjustmentFPDAmountSign, 
			@AdjustmentFPDAmount, 
			@AdjustmentFPDAmountSigned, 
			@AdjustmentFPDFuturesRealizedPLSign, 
			@AdjustmentFPDFuturesRealizedPL, 
			@AdjustmentFPDFuturesRealizedPLSigned, 
			@AdjustmentFPDOptionsPremiumAmountBuySign, 
			@AdjustmentFPDOptionsPremiumAmountBuy, 
			@AdjustmentFPDOptionsPremiumAmountBuySigned, 
			@AdjustmentFPDOptionsPremiumAmountSellSign, 
			@AdjustmentFPDOptionsPremiumAmountSell, 
			@AdjustmentFPDOptionsPremiumAmountSellSigned, 
			@AdjustmentFPDNetStrikePriceForExerciseSign, 
			@AdjustmentFPDNetStrikePriceForExercise, 
			@AdjustmentFPDNetStrikePriceForExerciseSigned,
			@AdjustmentFPDNetStrikePriceForAllotmentSign, 
			@AdjustmentFPDNetStrikePriceForAllotment, 
			@AdjustmentFPDNetStrikePriceForAllotmentSigned, 
			@AdjustmentFPDDomesticCommissionSign, 
			@AdjustmentFPDDomesticCommission, 
			@AdjustmentFPDDomesticCommissionSigned,
			@AdjustmentFPDConsumptionTaxOnCommissionSign, 
			@AdjustmentFPDConsumptionTaxOnCommission, 
			@AdjustmentFPDConsumptionTaxOnCommissionSigned, 
			@AdjustmentFPDExchangeTaxSign, 
			@AdjustmentFPDExchangeTax, 
			@AdjustmentFPDExchangeTaxSigned, 
			@AdjustmentFPDReceiptPaymentAmountSign, 
			@AdjustmentFPDReceiptPaymentAmount, 
			@AdjustmentFPDReceiptPaymentAmountSigned, 
			@ReceiptPaymentAmountFCDSign, 
			@ReceiptPaymentAmountFCD, 
			@ReceiptPaymentAmountFCDSigned, 
			@FinalCashBalanceFCDSign, 
			@FinalCashBalanceFCD, 
			@FinalCashBalanceFCDSigned, 
			@SettlementAmountFCDTradingSign, 
			@SettlementAmountFCDTrading, 
			@SettlementAmountFCDTradingSigned, 
			@RealizedPLFCDFuturesTradingSign, 
			@RealizedPLFCDFuturesTrading, 
			@RealizedPLFCDFuturesTradingSigned, 
			@OptionsPremiumFCDTradingBuySign, 
			@OptionsPremiumFCDTradingBuy, 
			@OptionsPremiumFCDTradingBuySigned, 
			@OptionsPremiumFCDTradingSellSign, 
			@OptionsPremiumFCDTradingSell,
			@OptionsPremiumFCDTradingSellSigned,  
			@NetStrikePriceFCDTradingForExerciseSign, 
			@NetStrikePriceFCDTradingForExercise,
			@NetStrikePriceFCDTradingForExerciseSigned,  
			@NetStrikePriceFCDTradingForAllotmentSign, 
			@NetStrikePriceFCDTradingForAllotment,
			@NetStrikePriceFCDTradingForAllotmentSigned,  
			@DomesticCommissionFCDTradingSign, 
			@DomesticCommissionFCDTrading,
			@DomesticCommissionFCDTradingSigned,  
			@ConsumptionTaxOnCommissionFCDTradingSign, 
			@ConsumptionTaxOnCommissionFCDTrading,
			@ConsumptionTaxOnCommissionFCDTradingSigned,  
			@ExchangeTaxFCDTradingSign, 
			@ExchangeTaxFCDTrading, 
			@ExchangeTaxFCDTradingSigned,
			@CashBalanceReportedOnCurrentDaySign, 
			@CashBalanceReportedOnCurrentDay,
			@CashBalanceReportedOnCurrentDaySigned,  
			@UnrealizedPLSign, 
			@UnrealizedPL, 
			@UnrealizedPLSigned, 
			@UnrealizedPLNonCalculableFlag, 
			@TotalMarginCashSign, 
			@TotalMarginCash, 
			@TotalMarginCashSigned, 
			@CollateralValueFCDTseDirectDeposit, 
			@CollateralValueFCDOseDirectDeposit, 
			@CollateralValueFCDMemberDirectDeposit, 
			@CollateralValueFCDDepositForReplacement, 
			@CollateralValueFCDTotal, 
			@ScheduledCollateralMovementAmountFFDSignTseDirectDeposit, 
			@ScheduledCollateralMovementAmountFFDTseDirectDeposit, 
			@ScheduledCollateralMovementAmountFFDSignTseDirectDepositSigned, 
			@ScheduledCollateralMovementAmountFFDSignOseDirectDeposit, 
			@CollateralMovementScheduledAmountFFDOseDirectDeposit, 
			@ScheduledCollateralMovementAmountFFDSignOseDirectDepositSigned, 
			@ScheduledCollateralMovementAmountFFDSignMemberDirect, 
			@ScheduledCollateralMovementAmountFFDMemberDirectDeposit, 
			@ScheduledCollateralMovementAmountFFDSignMemberDirectSigned,
			@ScheduledCollateralMovementAmountFFDSignDepositForReplacement, 
			@ScheduledCollateralMovementAmountFFDDepositForReplacement, 
			@ScheduledCollateralMovementAmountFFDSignDepositForReplacementSigned, 
			@ScheduledCollateralMovementAmountFFDSignTotal, 
			@ScheduledCollateralMovementAmountFFDTotal, 
			@ScheduledCollateralMovementAmountFFDSignTotalSigned, 
			@CollateralNonCalculableFlagTotal, 
			@TotalMarginMoneySign, 
			@TotalMarginMoney, 
			@TotalMarginMoneySigned, 
			@MarginRequirementTse, 
			@MarginRequirementOse, 
			@MarginRequirementExchangeTotal, 
			@RequiredAmountNonCalculableFlagTotal, 
			@MarginDeficitExcessAmountTotalSign, 
			@MarginDeficitExcessAmountTotal, 
			@MarginDeficitExcessAmountTotalSigned, 
			@MarginDeficitExcessAmountCashSign, 
			@MarginDeficitExcessAmountCash, 
			@MarginDeficitExcessAmountCashSigned,
			@MarginDeficitExcessAmountCollateralSign, 
			@MarginDeficitExcessAmountCollateral, 
			@MarginDeficitExcessAmountCollateralSigned, 
			@StandardReceiptPaymentAmountSign, 
			@StandardReceiptPaymentAmount, 
			@StandardReceiptPaymentAmountSigned, 
			@ReceiptPaymentDate, 
			@ScheduledReceiptPaymentAmountFFDSign, 
			@ScheduledReceiptPaymentAmountFFD, 
			@ScheduledReceiptPaymentAmountFFDSigned, 
			@ScheduledReceiptPaymentAmountForDayAfterNextSign, 
			@ScheduledReceiptPaymentAmountForDayAfterNext, 
			@ScheduledReceiptPaymentAmountForDayAfterNextSigned, 
			@ScheduledCollateralMovementAmountForDayAfterNextSign, 
			@ScheduledCollateralMovementAmountForDayAfterNext, 
			@ScheduledCollateralMovementAmountForDayAfterNextSigned, 
			@LongOptionValue, 
			@ShortOptionValue
		);

Return Scope_Identity()
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Report_UpdateTargetReport]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Report_UpdateTargetReport]
	@ReportId INT,
	@TargetReportId INT
AS
SET NOCOUNT ON
BEGIN

UPDATE [dbo].[ib_Report] SET TargetReportId = @TargetReportId
WHERE ReportId = @ReportId

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[Peoplesoft_UnMatching_OpenBalances]''
');

GO
EXECUTE ('CREATE TABLE [dbo].[Peoplesoft_UnMatching_OpenBalances]
(
[Peoplesoft_UnMatching_OpenBalancesID] [int] NOT NULL IDENTITY(1, 1),
[OpeningBalance] [varchar] (50) NULL,
[AccountNumber] [varchar] (35) NULL,
[TransactionDate] [varchar] (8) NULL,
[ValueDate] [varchar] (8) NULL,
[Narrative] [varchar] (34) NULL,
[InternalReference] [varchar] (16) NULL,
[ExternalReference] [varchar] (16) NULL,
[Type] [varchar] (4) NULL,
[Department] [varchar] (50) NULL,
[UserField1] [varchar] (10) NULL,
[UserField2] [varchar] (10) NULL,
[UserField3] [varchar] (10) NULL,
[BusinessUnit] [varchar] (10) NULL,
[UserField5] [varchar] (19) NULL,
[UserField6] [varchar] (10) NULL,
[Currency] [varchar] (3) NULL,
[OriginalAmount] [varchar] (20) NULL,
[ReceiptAmount] [varchar] (20) NULL,
[PaymentAmount] [varchar] (20) NULL,
[Quantity] [varchar] (12) NULL,
[Percent] [varchar] (3) NULL,
[UnitPrice] [varchar] (20) NULL,
[UserDateA] [varchar] (50) NULL,
[UserDateB] [varchar] (50) NULL,
[UserId] [varchar] (50) NULL,
[UserField8] [varchar] (50) NULL,
[FlagA] [varchar] (1) NULL,
[FlagB] [varchar] (1) NULL,
[FlagC] [varchar] (1) NULL,
[FlagD] [varchar] (1) NULL,
[FlagE] [varchar] (1) NULL,
[FlagF] [varchar] (1) NULL,
[FlagG] [varchar] (1) NULL,
[FlagH] [varchar] (1) NULL,
[IsStatement] [varchar] (1) NULL,
[IsHolding] [varchar] (1) NULL,
[wf_Ref] [varchar] (20) NULL,
[Period] [varchar] (25) NULL,
[UserField9] [varchar] (25) NULL,
[UserField10] [varchar] (25) NULL,
[FiscalYear] [varchar] (4) NULL,
[AccountingPeriodOfFiscalYear] [varchar] (2) NULL,
[UserField13] [varchar] (25) NULL,
[UserField14] [varchar] (25) NULL,
[UserField15] [varchar] (25) NULL,
[UserField16] [varchar] (25) NULL,
[UserDateC] [varchar] (12) NULL,
[UserDateD] [varchar] (12) NULL,
[UserDecimalB] [varchar] (25) NULL,
[UserDecimalC] [varchar] (25) NULL,
[UserDecimalD] [varchar] (25) NULL,
[ClosingBalance] [varchar] (25) NULL,
[LoadState] [tinyint] NOT NULL CONSTRAINT [DF_Peoplesoft_UnMatching_OpenBalances_LoadState] DEFAULT ((0)),
[CreateDate] [datetime] NOT NULL CONSTRAINT [DF_Peoplesoft_UnMatching_OpenBalances_CreateDate] DEFAULT (getdate()),
[FileName] [varchar] (512) NULL CONSTRAINT [DF__Peoplesof__FileN__4402926E] DEFAULT (NULL)
)
');

GO
EXECUTE ('PRINT N''Creating primary key [PK_Peoplesoft_UnMatching_OpenBalances] on [dbo].[Peoplesoft_UnMatching_OpenBalances]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[Peoplesoft_UnMatching_OpenBalances] ADD CONSTRAINT [PK_Peoplesoft_UnMatching_OpenBalances] PRIMARY KEY CLUSTERED  ([Peoplesoft_UnMatching_OpenBalancesID])
');

GO
EXECUTE ('PRINT N''Creating index [IX_FileName_AccountNumber_TransactionDate] on [dbo].[Peoplesoft_UnMatching_OpenBalances]''
');

GO
EXECUTE ('CREATE NONCLUSTERED INDEX [IX_FileName_AccountNumber_TransactionDate] ON [dbo].[Peoplesoft_UnMatching_OpenBalances] ([FileName], [AccountNumber], [TransactionDate]) INCLUDE ([ClosingBalance], [OpeningBalance], [PaymentAmount], [ReceiptAmount])
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_ImportProgress_Get]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_ImportProgress_Get]
AS
BEGIN
	--	14 Nov 2006		amk		Creation
	--	27 Nov 2006		amk		Add in gmi_mnyf1 and gmi_futm
	--	09 Jan 2006		amk		Add in ''order by''
	--	20 Aug 2009		amk		Add in peoplesoft, swift940, swift950, c21, broker, r&n
	--	26 Aug 2009		amk		Show loadstate 3 also
	--	11 Aug 2010		amk		Add in ICE and gmi_extf1; replace rolfenolancodes with account
	--							remove all unused gmi files
	--  08 Apr 2011		AAJM	Add Credit Suisse
	--  03 May 2012		ED		MBAL-20696 - Add DGCX
	--  15 Jan 2013		MJP		MBAL-22629 Added new Liffe adapter
	--  15 Jan 2013		MJP		MBAL-22633 Added Banco Santander code retrospectively
	
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
	set transaction isolation level read uncommitted
	
	select ''broker_position'' as [table]
		, sum(case when loadstate = 0 then 1 else 0 end) as state0
		, sum(case when loadstate = 1 then 1 else 0 end) as state1
		, sum(case when loadstate = 2 then 1 else 0 end) as state2
		, sum(case when loadstate = 3 then 1 else 0 end) as state3
		, max(createdate) as last_added
	from broker_position
	union
	select ''broker_transaction'' as [table]
		, sum(case when loadstate = 0 then 1 else 0 end) as state0
		, sum(case when loadstate = 1 then 1 else 0 end) as state1
		, sum(case when loadstate = 2 then 1 else 0 end) as state2
		, sum(case when loadstate = 3 then 1 else 0 end) as state3
		, max(createdate) as last_added
	from broker_transaction
	union
	select ''c21_detailLine'' as [table]
		, sum(case when loadstate = 0 then 1 else 0 end) as state0
		, sum(case when loadstate = 1 then 1 else 0 end) as state1
		, sum(case when loadstate = 2 then 1 else 0 end) as state2
		, sum(case when loadstate = 3 then 1 else 0 end) as state3
		, max(createdate) as last_added
	from c21_detailline
	union
	select ''c21_footer'' as [table]
		, sum(case when loadstate = 0 then 1 else 0 end) as state0
		, sum(case when loadstate = 1 then 1 else 0 end) as state1
		, sum(case when loadstate = 2 then 1 else 0 end) as state2
		, sum(case when loadstate = 3 then 1 else 0 end) as state3
		, max(createdate) as last_added
	from c21_footer
	union
	select ''c21_header'' as [table]
		, sum(case when loadstate = 0 then 1 else 0 end) as state0
		, sum(case when loadstate = 1 then 1 else 0 end) as state1
		, sum(case when loadstate = 2 then 1 else 0 end) as state2
		, sum(case when loadstate = 3 then 1 else 0 end) as state3
		, max(createdate) as last_added
	from c21_header
	union
	select ''c21_previousDayLine'' as [table]
		, sum(case when loadstate = 0 then 1 else 0 end) as state0
		, sum(case when loadstate = 1 then 1 else 0 end) as state1
		, sum(case when loadstate = 2 then 1 else 0 end) as state2
		, sum(case when loadstate = 3 then 1 else 0 end) as state3
		, max(createdate) as last_added
	from c21_previousdayline
	union
	select ''c21_resumeLine'' as [table]
		, sum(case when loadstate = 0 then 1 else 0 end) as state0
		, sum(case when loadstate = 1 then 1 else 0 end) as state1
		, sum(case when loadstate = 2 then 1 else 0 end) as state2
		, sum(case when loadstate = 3 then 1 else 0 end) as state3
		, max(createdate) as last_added
	from c21_resumeline
	union
	select ''eu_cb010grp'' as [table]
		, sum(case when loadstate = 0 then 1 else 0 end) as state0
		, sum(case when loadstate = 1 then 1 else 0 end) as state1
		, sum(case when loadstate = 2 then 1 else 0 end) as state2
		, sum(case when loadstate = 3 then 1 else 0 end) as state3
		, max(createdate) as last_added
	from eu_cb010grp
	union
	select ''ice_asgnRpt'' as [table]
		, sum(case when loadstate = 0 then 1 else 0 end) as state0
		, sum(case when loadstate = 1 then 1 else 0 end) as state1
		, sum(case when loadstate = 2 then 1 else 0 end) as state2
		, sum(case when loadstate = 3 then 1 else 0 end) as state3
		, max(createdate) as last_added
	from ice_asgnrpt
	union
	select ''ice_posRpt'' as [table]
		, sum(case when loadstate = 0 then 1 else 0 end) as state0
		, sum(case when loadstate = 1 then 1 else 0 end) as state1
		, sum(case when loadstate = 2 then 1 else 0 end) as state2
		, sum(case when loadstate = 3 then 1 else 0 end) as state3
		, max(createdate) as last_added
	from ice_posrpt
	union
	select ''ice_trdCaptRpt'' as [table]
		, sum(case when loadstate = 0 then 1 else 0 end) as state0
		, sum(case when loadstate = 1 then 1 else 0 end) as state1
		, sum(case when loadstate = 2 then 1 else 0 end) as state2
		, sum(case when loadstate = 3 then 1 else 0 end) as state3
		, max(createdate) as last_added
	from ice_trdCaptRpt
	union
	select ''lch_typeps_0101'' as [table]
		, sum(case when loadstate = 0 then 1 else 0 end) as state0
		, sum(case when loadstate = 1 then 1 else 0 end) as state1
		, sum(case when loadstate = 2 then 1 else 0 end) as state2
		, sum(case when loadstate = 3 then 1 else 0 end) as state3
		, max(createdate) as last_added
	from lch_typeps_0101
	union
	select ''lch_typetr'' as [table]
		, sum(case when loadstate = 0 then 1 else 0 end) as state0
		, sum(case when loadstate = 1 then 1 else 0 end) as state1
		, sum(case when loadstate = 2 then 1 else 0 end) as state2
		, sum(case when loadstate = 3 then 1 else 0 end) as state3
		, max(createdate) as last_added
	from lch_typetr
	union
	select ''peoplesoft'' as [table]
		, sum(case when loadstate = 0 then 1 else 0 end) as state0
		, sum(case when loadstate = 1 then 1 else 0 end) as state1
		, sum(case when loadstate = 2 then 1 else 0 end) as state2
		, sum(case when loadstate = 3 then 1 else 0 end) as state3
		, max(createdate) as last_added
	from peoplesoft
	union
	select ''peoplesoft_unmatching_openBalances'' as [table]
		, sum(case when loadstate = 0 then 1 else 0 end) as state0
		, sum(case when loadstate = 1 then 1 else 0 end) as state1
		, sum(case when loadstate = 2 then 1 else 0 end) as state2
		, sum(case when loadstate = 3 then 1 else 0 end) as state3
		, max(createdate) as last_added
	from peoplesoft_unmatching_openbalances
	union
	select ''account'' as [table]
		, sum(case when loadstate = 0 then 1 else 0 end) as state0
		, sum(case when loadstate = 1 then 1 else 0 end) as state1
		, sum(case when loadstate = 2 then 1 else 0 end) as state2
		, sum(case when loadstate = 3 then 1 else 0 end) as state3
		, max(createdate) as last_added
	from account
	union
	select ''rolfeNolan_hostOpn'' as [table]
		, sum(case when loadstate = 0 then 1 else 0 end) as state0
		, sum(case when loadstate = 1 then 1 else 0 end) as state1
		, sum(case when loadstate = 2 then 1 else 0 end) as state2
		, sum(case when loadstate = 3 then 1 else 0 end) as state3
		, max(createdate) as last_added
	from rolfenolan_hostopn
	union
	select ''rolfeNolan_hostTrn'' as [table]
		, sum(case when loadstate = 0 then 1 else 0 end) as state0
		, sum(case when loadstate = 1 then 1 else 0 end) as state1
		, sum(case when loadstate = 2 then 1 else 0 end) as state2
		, sum(case when loadstate = 3 then 1 else 0 end) as state3
		, max(createdate) as last_added
	from rolfenolan_hostTrn
	union
	select ''swift_mt940'' as [table]
		, sum(case when loadstate = 0 then 1 else 0 end) as state0
		, sum(case when loadstate = 1 then 1 else 0 end) as state1
		, sum(case when loadstate = 2 then 1 else 0 end) as state2
		, sum(case when loadstate = 3 then 1 else 0 end) as state3
		, max(createdate) as last_added
	from swift_mt940
	union
	select ''swift_mt950'' as [table]
		, sum(case when loadstate = 0 then 1 else 0 end) as state0
		, sum(case when loadstate = 1 then 1 else 0 end) as state1
		, sum(case when loadstate = 2 then 1 else 0 end) as state2
		, sum(case when loadstate = 3 then 1 else 0 end) as state3
		, max(createdate) as last_added
	from swift_mt950
	union
	select ''gmi_extf1'' as [table]
		, sum(case when loadstate = 0 then 1 else 0 end) as state0
		, sum(case when loadstate = 1 then 1 else 0 end) as state1
		, sum(case when loadstate = 2 then 1 else 0 end) as state2
		, sum(case when loadstate = 3 then 1 else 0 end) as state3
		, max(createdate) as last_added
	from gmi_extf1
	union
	select ''creditsuisse_position'' as [table]
		, sum(case when loadstate = 0 then 1 else 0 end) as state0
		, sum(case when loadstate = 1 then 1 else 0 end) as state1
		, sum(case when loadstate = 2 then 1 else 0 end) as state2
		, sum(case when loadstate = 3 then 1 else 0 end) as state3
		, max(createdate) as last_added
	from CreditSuisse_Position
	union
	select ''creditsuisse_transaction'' as [table]
		, sum(case when loadstate = 0 then 1 else 0 end) as state0
		, sum(case when loadstate = 1 then 1 else 0 end) as state1
		, sum(case when loadstate = 2 then 1 else 0 end) as state2
		, sum(case when loadstate = 3 then 1 else 0 end) as state3
		, max(createdate) as last_added
	from CreditSuisse_Transaction
	union
	select ''DGCX_Position'' as [table]
		, sum(case when loadstate = 0 then 1 else 0 end) as state0
		, sum(case when loadstate = 1 then 1 else 0 end) as state1
		, sum(case when loadstate = 2 then 1 else 0 end) as state2
		, sum(case when loadstate = 3 then 1 else 0 end) as state3
		, max(createdate) as last_added
	from DGCX_Position
	union
	select ''DGCX_Transaction'' as [table]
		, sum(case when loadstate = 0 then 1 else 0 end) as state0
		, sum(case when loadstate = 1 then 1 else 0 end) as state1
		, sum(case when loadstate = 2 then 1 else 0 end) as state2
		, sum(case when loadstate = 3 then 1 else 0 end) as state3
		, max(createdate) as last_added
	from DGCX_Transaction
	union
	select ''Liffe_Notification'' as [table]
		, sum(case when loadstate = 0 then 1 else 0 end) as state0
		, sum(case when loadstate = 1 then 1 else 0 end) as state1
		, sum(case when loadstate = 2 then 1 else 0 end) as state2
		, sum(case when loadstate = 3 then 1 else 0 end) as state3
		, max(createdate) as last_added
	from Liffe_Notification
	union
	select ''Liffe_Position'' as [table]
		, sum(case when loadstate = 0 then 1 else 0 end) as state0
		, sum(case when loadstate = 1 then 1 else 0 end) as state1
		, sum(case when loadstate = 2 then 1 else 0 end) as state2
		, sum(case when loadstate = 3 then 1 else 0 end) as state3
		, max(createdate) as last_added
	from Liffe_Position
	union
	select ''Liffe_TradeReport'' as [table]
		, sum(case when loadstate = 0 then 1 else 0 end) as state0
		, sum(case when loadstate = 1 then 1 else 0 end) as state1
		, sum(case when loadstate = 2 then 1 else 0 end) as state2
		, sum(case when loadstate = 3 then 1 else 0 end) as state3
		, max(createdate) as last_added
	from Liffe_TradeReport
	union
	select ''BancoSantander_HOSTOPN'' as [table]
		, sum(case when loadstate = 0 then 1 else 0 end) as state0
		, sum(case when loadstate = 1 then 1 else 0 end) as state1
		, sum(case when loadstate = 2 then 1 else 0 end) as state2
		, sum(case when loadstate = 3 then 1 else 0 end) as state3
		, max(createdate) as last_added
	from BancoSantander_HOSTOPN
	union
	select ''BancoSantander_HOSTTRN'' as [table]
		, sum(case when loadstate = 0 then 1 else 0 end) as state0
		, sum(case when loadstate = 1 then 1 else 0 end) as state1
		, sum(case when loadstate = 2 then 1 else 0 end) as state2
		, sum(case when loadstate = 3 then 1 else 0 end) as state3
		, max(createdate) as last_added
	from BancoSantander_HOSTTRN
	order by [table]
	set transaction isolation level read committed

END
');

GO
EXECUTE ('PRINT N''Creating [stage].[MacquariePosition_Load]''
');

GO
EXECUTE ('CREATE PROCEDURE [stage].[MacquariePosition_Load]
(
	@LocationPath VARCHAR(100)
	,@ReceiveLocationSysId INT
	,@RunId INT
)
AS
SET NOCOUNT ON

-- Description:	This stored procedure pulls data from the stage.MacquariePosition temp
-- table and inserts it into ib_Trx
-- Whilst iterating through the records in stage.MacquariePosition, all 
-- of these inserts are wrapped in a transaction so that any failure causes
-- the changes to not commit.
--
-- 11 Jun 2015	ED	EIB 27111 - Creation

BEGIN

	DECLARE @Message			VARCHAR(1024)
	DECLARE @AddCount			INT
	SET @AddCount = 0
					
	DECLARE @DataSourceCode VARCHAR(100), @ExchangeCode VARCHAR(100), @FirmCode VARCHAR(100)
	DECLARE @DataSourceId INT
	DECLARE @Code VARCHAR(100)
	DECLARE @Code2 VARCHAR(100)
	DECLARE @ReturnValue INT
	DECLARE @Output INT
	DECLARE @Output2 INT
	DECLARE @DefaultCurrencyId INT
			
	-- Get Datasource
	SET @DataSourceCode = ''MAQ''
	SET @ExchangeCode = ''SFE''
	SET @FirmCode = ''MAQ''
	
	SET @Code = @DataSourceCode
	EXEC @ReturnValue= [_ib_DataSource_GetByCodeForOutput] @Code,@OutPut output,@Output2 output	
	SET @DataSourceId = @Output
	SET @DefaultCurrencyId = @Output2	

	-- Duplicate file check										
	DECLARE @IsFileAlreadyLoaded INT
	EXEC @IsFileALreadyLoaded = HasFileBeenLoaded @LocationPath, @DataSourceId

	IF @IsFileAlreadyLoaded = 1
	BEGIN
		UPDATE stage.MacquariePosition
		SET LoadState = 3
		WHERE LoadState = 1
			AND FileName = @LocationPath		
		RETURN
	END
	
	-- Set AsOfDate from Filename
	DECLARE @AsOfDate DATETIME
	EXEC [dbo].[TryParseYYYYMMDDFromEndOfFilename] @LocationPath, @AsOfDate OUTPUT
	
	DECLARE @IsAcceptable bit
	EXECUTE [dbo].[Load_IsFileTooOld] @DataSourceId, @LocationPath, @AsOfDate, @IsAcceptable OUTPUT, @ReceiveLocationSysId, @RunId
	IF (@IsAcceptable = 0)
	BEGIN
			
		UPDATE stage.MacquariePosition SET LoadState = 3 WHERE LoadState = 1 AND FileName = @LocationPath	
		RAISERROR (''File is too old.'', 18, 0)
		RETURN
	END									

	-- Store ImportFile record for use
	DECLARE @ImportFileId INT
	EXEC ib_ImportFile_Add @DataSourceId, @LocationPath, @ImportFileId output
	
	--Gets the defaultStrikePriceDivisor
	DECLARE	@DefaultStrikePriceDivisor	DECIMAL(19,6)
	SET @DefaultStrikePriceDivisor = [dbo].[udf_GetDefaultStrikePriceDivisor](@DataSourceId, NULL)


	SET XACT_ABORT ON 

	BEGIN TRAN T1

		-- BizTalk''s SQL Adapter uses more restrictive read serializable
		-- so this is necessary to relax it to something that is default
		-- and perfectly acceptable!
		SET TRANSACTION ISOLATION LEVEL READ COMMITTED

		BEGIN TRY
			DECLARE @MacquariePositionId INT
			DECLARE @GroupCode VARCHAR(100)
			DECLARE @ClientCode VARCHAR(100)
			DECLARE @CommodityCode VARCHAR(100)
			DECLARE @DeliveryMonth VARCHAR(4)
			DECLARE @ExercisePrice MONEY
			DECLARE @PutCall VARCHAR(1)
			DECLARE @BoughtLots INT
			DECLARE @SoldLots INT
			DECLARE @NetLots INT
			DECLARE @VarMargin MONEY
			DECLARE @CurrentPrice MONEY
			DECLARE @Currency VARCHAR(3)
			DECLARE @ExercisePriceNum MONEY
			DECLARE @TickValue DECIMAL(10,5)

			DECLARE pos_cursor CURSOR FOR
			SELECT [MacquariePositionId]
				  ,[GroupCode]
				  ,[ClientCode]
				  ,[CommodityCode]
				  ,[DeliveryMonth]
				  ,[ExercisePrice]
				  ,[PutCall]
				  ,[BoughtLots]
				  ,[SoldLots]
				  ,[NetLots]
				  ,[VarMargin]
				  ,[CurrentPrice]
				  ,[Currency]
				  ,[ExercisePriceNum]
				  ,[TickValue]
			FROM					
			stage.MacquariePosition WHERE LoadState = 1 AND Filename = @LocationPath

			OPEN pos_cursor

			FETCH NEXT FROM pos_cursor
			INTO 
				 @MacquariePositionId
				,@GroupCode
				,@ClientCode
				,@CommodityCode
				,@DeliveryMonth
				,@ExercisePrice
				,@PutCall
				,@BoughtLots
				,@SoldLots
				,@NetLots
				,@VarMargin
				,@CurrentPrice
				,@Currency
				,@ExercisePriceNum
				,@TickValue
				-- Check @@FETCH_STATUS to see IF there are any more rows to fetch.
				WHILE @@FETCH_STATUS = 0
				BEGIN
					DECLARE		@InstrumentCd			VARCHAR(100)
					DECLARE		@InstrumentTypeCd		VARCHAR(100)
					DECLARE		@ExpYr					SMALLINT
					DECLARE		@ExpMth					SMALLINT
					DECLARE		@ExpDay					SMALLINT
					DECLARE		@MarketValueDec			DECIMAL(19,4)
					DECLARE		@MarketValueDivisor		DECIMAL(19,4)
					DECLARE		@StrikePriceDivisor		DECIMAL(19,4)
					DECLARE		@StrikePrice			DECIMAL(19,4)

					SET @MarketValueDec = NULL		
					SET @InstrumentTypeCd = NULL	
			
					-- Set InstrumentTypeCd
					IF @PutCall IN (''P'', ''C'')
						SET @InstrumentTypeCd = ''O''
					ELSE
						SET @InstrumentTypeCd = ''F''

					-- We prefix the Instruments with the IntrumentTypeCode
					SET @InstrumentCd = @InstrumentTypeCd + ''_'' + @ExchangeCode + ''_'' + @CommodityCode			
					
					SET @ExpDay = NULL
					SET @ExpMth = NULL
					SET @ExpYr = NULL	
					-- Set ExpiryDate
					SET @ExpYr = ''20''+LEFT(@DeliveryMonth, 2)
					SET @ExpMth = RIGHT(@DeliveryMonth, 2)
					SET @ExpDay = dbo.udf_OnLoad_ExpiryDate_Get_Day(@ExpYr,@ExpMth,NULL)

					DECLARE @PositionId INT		
					SET @PositionId = NULL
					SET @MarketValueDivisor = NULL
					SET @StrikePriceDivisor = NULL

					SELECT @MarketValueDivisor = MarketValueDivisor, @StrikePriceDivisor = StrikePriceDivisor
						FROM [dbo].[ib_InstrumentDataSource] WHERE DataSourceId = @DataSourceId AND DataSourceInstrumentCode = @InstrumentCd 

					SET @MarketValueDec = @VarMargin / ISNULL(@MarketValueDivisor, 1)
			
					SET @StrikePrice = NULL
					IF (@InstrumentTypeCd = ''O'')
						SET @StrikePrice = @ExercisePrice / ISNULL(@StrikePriceDivisor, ISNULL(@DefaultStrikePriceDivisor, 1))
			
			
					EXEC [ib_Position_Load]
					@DataSourceCode			
					, @ExchangeCode
					, @FirmCode -- Firm will be added if not present					
					, @ClientCode -- account code
					, @AsOfDate				
					, @InstrumentCd			
					, @NetLots			
					, @MarketValueDec			
					, @ExpYr					
					, @ExpMth					
					, @ExpDay	
					, @StrikePrice			
					, ''POSITION'' -- trxTypeCode				
					, @PutCall -- @OptionTypeCode
					, NULL -- @TrxDate 			
					, NULL --@SettlementPrice -- This value is NOT actually used in the ib_Position_Load Stored Procedure, should be removed ?			
					, @MacquariePositionId
					, @InstrumentTypeCd		
					, @LocationPath
					, @Currency
					, @LongQuantity = @BoughtLots
					, @ShortQuantity = @SoldLots
					, @TradedLongQuantity = NULL
					, @TradedShortQuantity = NULL
					, @ClassId = NULL
					, @UseNetForCloseOut = 0
					, @PositionId = @PositionId output
					, @ReceiveLocationSysId = @ReceiveLocationSysId
					, @RunId = @RunId
			
					--flip processed flag in source table.
					UPDATE stage.MacquariePosition WITH (ROWLOCK) SET [LoadState] = 2 WHERE MacquariePositionId = @MacquariePositionId AND [LoadState] = 1
					IF (@PositionId IS NOT NULL AND @PositionId > 0)
						BEGIN
							SET @AddCount = @AddCount + 1
							EXEC ib_Price_AddFromPositionLoad @PositionId, @ImportFileId, @CurrentPrice 	
						END
			
					FETCH NEXT FROM pos_cursor
					INTO 
						 @MacquariePositionId
						,@GroupCode
						,@ClientCode
						,@CommodityCode
						,@DeliveryMonth
						,@ExercisePrice
						,@PutCall
						,@BoughtLots
						,@SoldLots
						,@NetLots
						,@VarMargin
						,@CurrentPrice
						,@Currency
						,@ExercisePriceNum
						,@TickValue
				END
			
		CLOSE pos_cursor
		DEALLOCATE pos_cursor

			-- Now update state of any left-over temporary transaction records
			-- so there are no ''left-overs''
			UPDATE stage.MacquariePosition WITH (ROWLOCK) SET [LoadState] = 2 WHERE [LoadState] = 1 AND [FileName] = @LocationPath

			SET @Message = @DataSourceCode + '' position loader ended ('' + CONVERT(VARCHAR(10), @AddCount) + '' added).'' 
		
			EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @Message, ''Success'', '''', @RunId

			UPDATE ib_ImportFile SET AsOfDate = @AsOfDate WHERE ImportFileId = @ImportFileId
			
		COMMIT TRAN T1
	
	END TRY
	BEGIN CATCH 

		IF XACT_STATE() = -1 
			ROLLBACK TRANSACTION
	
		SET @Message = @DataSourceCode + '' position loader failed.'' 		
		EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @Message, ''Error'', '''', @RunId
	
		EXEC [dbo].[sp_RethrowError]
		
	END CATCH 

	SET XACT_ABORT OFF

END

RETURN 0
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Broker_GetBrokerNamesHintByKeyword]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Broker_GetBrokerNamesHintByKeyword]
    @BrokerName VARCHAR(100)
   ,@HintByStartOnly BIT = 0
   ,@HintLength INT = 1
AS 
SET NOCOUNT ON

DECLARE @len INT
SET @len = LEN(@BrokerName)
IF @HintByStartOnly = 1 
    BEGIN
        SELECT DISTINCT
            SUBSTRING([Name], @len, @HintLength) x
        FROM
            [dbo].[ib_Broker]
        WHERE
            [Code] LIKE @BrokerName + ''%''
        ORDER BY
            x

    END
ELSE 
    BEGIN
        SELECT DISTINCT
            SUBSTRING([Name], PATINDEX(''%'' + @BrokerName + ''%'', [Code]) + @len,
                      @HintLength) x
        FROM
            [dbo].[ib_Broker]
        WHERE
            [Code] LIKE ''%'' + @BrokerName + ''%''
        ORDER BY
            x
    END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[aspnet_Users_GetReportByMatchCode]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[aspnet_Users_GetReportByMatchCode]
AS
BEGIN
-- Revision history
-- 16 May 2014  ED  EIB 25623 - create sp to get the report

	SET NOCOUNT ON
	SELECT u.UserName, m.Email AS EmailAddress, t.Description AS Template, mc.MatchCode, ar.Code AS ''MatchCodeAccessRight''
		FROM aspnet_users u
			LEFT JOIN aspnet_membership m ON u.userid = m.userid
			LEFT JOIN ib_UserMatchCodeAccess umca ON umca.UserId = u.UserId
			LEFT JOIN ib_MatchCode mc ON mc.MatchCodeId = umca.MatchCodeId
			LEFT JOIN ib_Template t ON t.TemplateId = mc.TemplateId
			LEFT JOIN ib_AccessRight ar ON ar.AccessRightId = umca.AccessRightId
		WHERE m.IsApproved = 1 AND ar.Code != ''None''
		ORDER BY u.UserName, t.Description, mc.MatchCode
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[is_GCollateralSecuritiesDetails_Add]''
');

GO
EXECUTE ('


/*
<Details>
<Summary>Inserts an item into the GCollateralSecuritiesDetails table</Summary>
<Created author="laurentiu.macovei" date="04/05/2006 16:33:05" />
</Details>
*/
CREATE PROCEDURE [dbo].[is_GCollateralSecuritiesDetails_Add]
	@CorporationCode varchar(4) = NULL,
	@PrincipalBrokerageId varchar(1) = NULL,
	@OfficeCode varchar(4) = NULL,
	@ACNo varchar(10) = NULL,
	@RecordId varchar(2) = NULL,
	@BaseDate datetime = NULL,
	@CalculationDate datetime = NULL,
	@CalculationStartTime datetime = NULL,
	@DepositId varchar(2) = NULL,
	@ProductId varchar(2) = NULL,
	@CompanyCode varchar(7) = NULL,
	@SeriesNo varchar(4) = NULL,
	@SubCode varchar(2) = NULL,
	@NewOldId varchar(1) = NULL,
	@DepositDate datetime = NULL,
	@WithdrawalDate datetime = NULL,
	@RecordNo varchar(5) = NULL,
	@Quantity decimal(15,0) = NULL,
	@MarketValue decimal(15,0) = NULL,
	@CollateralRate varchar(3) = NULL,
	@UnitValuePerCollateral decimal(15,0) = NULL,
	@EvaluationOfCollateralSecurities decimal(15,0) = NULL,
	@CustodianCode varchar(3) = NULL,
	@DepositaryReceiptNo varchar(5) = NULL,
	@MemberCodeMemberToWhichCollateralIsPlaced varchar(7) = NULL,
	@DirectCustodian varchar(2) = NULL,
	@CustomerNameAbbreviated varchar(35) = NULL,
	@SecurityNameEnglish varchar(28) = NULL,
	@SecurityNameKana varchar(24) = NULL
AS
SET NOCOUNT ON

SET NOCOUNT OFF

	DECLARE	@CalculationDateStartTime		DATETIME

	IF @BaseDate = ''01/01/1900 00:00:00'' 
		SET @BaseDate = NULL

	IF @CalculationDate = ''01/01/1900 00:00:00'' 
		SET @CalculationDate = NULL

	IF @CalculationStartTime = ''01/01/1900 00:00:00'' 
		SET @CalculationStartTime = NULL

	IF @DepositDate = ''01/01/1900 00:00:00'' 
		SET @DepositDate = NULL

	IF @WithdrawalDate = ''01/01/1900 00:00:00'' 
		SET @WithdrawalDate = NULL

	SET @CalculationDateStartTime = CONVERT(DATETIME,CONVERT(VARCHAR(12), CONVERT(DATETIME,@CalculationDate,112)) + '' '' + CONVERT(VARCHAR(8),RIGHT(@CalculationStartTime,8)))

	INSERT INTO is_GCollateralSecuritiesDetails 
		(
			[CorporationCode], 
			[PrincipalBrokerageId], 
			[OfficeCode], 
			[ACNo], 
			[RecordId], 
			[BaseDate], 
			[CalculationDate], 
			[CalculationStartTime],
			[CalculationDateStartTime], 
			[DepositId], 
			[ProductId], 
			[CompanyCode], 
			[SeriesNo], 
			[SubCode], 
			[NewOldId], 
			[DepositDate], 
			[WithdrawalDate], 
			[RecordNo], 
			[Quantity], 
			[MarketValue], 
			[CollateralRate], 
			[UnitValuePerCollateral], 
			[EvaluationOfCollateralSecurities], 
			[CustodianCode], 
			[DepositaryReceiptNo], 
			[MemberCodeMemberToWhichCollateralIsPlaced], 
			[DirectCustodian], 
			[CustomerNameAbbreviated], 
			[SecurityNameEnglish], 
			[SecurityNameKana]
		) 
		VALUES
		(
			@CorporationCode, 
			@PrincipalBrokerageId, 
			@OfficeCode, 
			@ACNo, 
			@RecordId, 
			@BaseDate, 
			@CalculationDate, 
			@CalculationStartTime,
			@CalculationDateStartTime, 
			@DepositId, 
			@ProductId, 
			@CompanyCode, 
			@SeriesNo, 
			@SubCode, 
			@NewOldId, 
			@DepositDate, 
			@WithdrawalDate, 
			@RecordNo, 
			@Quantity, 
			@MarketValue, 
			@CollateralRate, 
			@UnitValuePerCollateral, 
			@EvaluationOfCollateralSecurities, 
			@CustodianCode, 
			@DepositaryReceiptNo, 
			@MemberCodeMemberToWhichCollateralIsPlaced, 
			@DirectCustodian, 
			@CustomerNameAbbreviated, 
			@SecurityNameEnglish, 
			@SecurityNameKana
		);

Return Scope_Identity()
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Reset]''
');

GO
EXECUTE ('








CREATE proc [dbo].[ib_Reset]
/*
Developer:  McQuien
Date:       06/30/2006

Description:  These truncate and delete statements reset our tables and 
sets the processed flag back to null so in the source data so that 
we can develop more quickly and retest.

Modification:  25/07 McQuien--must delete from 
ib_TemplateCompare since it has a foreign key with
ib_Firm.
--add''l statments to delete:
ib_ImbalanceReport
ib_ImbalanceReportDetail
ib_Adjustment
ib_TemplateGroup

*/
as
SET NOCOUNT ON

--these tables truncate no problem
--truncate table ib_CurrencyDataSource
truncate table ib_FirmDataSource
truncate table ib_InstrumentTypeDataSource
truncate table ib_InstrumentDataSource
truncate table ib_trx
truncate table ib_ImbalanceReportDetail
truncate table ib_Report
delete from  ib_ImbalanceReport
truncate table ib_Adjustment

--these tables only work with delete
delete from ib_position
delete from ib_Instrument
delete from ib_InstrumentType
delete from ib_Account
delete from ib_TemplateCompare
delete from ib_TemplateGroup
delete from ib_Firm
');

GO
EXECUTE ('PRINT N''Creating [stage].[MacquarieTrade_Load]''
');

GO
EXECUTE ('CREATE PROCEDURE [stage].[MacquarieTrade_Load]
(
	@LocationPath VARCHAR(100)
	,@ReceiveLocationSysId INT
	,@RunId INT
)
AS
SET NOCOUNT ON

-- Description:	This stored procedure pulls data from the stage.MacquarieTrade temp
-- table and inserts it into ib_Trx
-- Whilst iterating through the records in stage.MacquarieTrade, all 
-- of these inserts are wrapped in a transaction so that any failure causes
-- the changes to not commit.
--
-- 11 Jun 2015	ED	EIB 27110 - Creation

--TO DO

BEGIN

	DECLARE @Message			VARCHAR(1024)
	DECLARE @AddCount			INT
	SET @AddCount = 0
					
	DECLARE @DataSourceCode VARCHAR(100), @ExchangeCode VARCHAR(100), @FirmCode VARCHAR(100)
	DECLARE @DataSourceId INT
	DECLARE @Code VARCHAR(100)
	DECLARE @Code2 VARCHAR(100)
	DECLARE @ReturnValue INT
	DECLARE @Output INT
	DECLARE @Output2 INT
	DECLARE @DefaultCurrencyId INT
			
	-- Get Datasource
	SET @DataSourceCode = ''MAQ''
	SET @ExchangeCode = ''SFE''
	SET @FirmCode = ''MAQ''
	
	SET @Code = @DataSourceCode
	EXEC @ReturnValue= [_ib_DataSource_GetByCodeForOutput] @Code,@OutPut output,@Output2 output	
	SET @DataSourceId = @Output
	SET @DefaultCurrencyId = @Output2	

	-- Duplicate file check										
	DECLARE @IsFileAlreadyLoaded INT
	EXEC @IsFileALreadyLoaded = HasFileBeenLoaded @LocationPath, @DataSourceId

	IF @IsFileAlreadyLoaded = 1
	BEGIN
		UPDATE stage.MacquarieTrade
		SET LoadState = 3
		WHERE LoadState = 1
			AND FileName = @LocationPath		
		RETURN
	END
	
	-- Set AsOfDate from Filename
	DECLARE @AsOfDate DATETIME
	EXEC [dbo].[TryParseYYYYMMDDFromEndOfFilename] @LocationPath, @AsOfDate OUTPUT
	
	DECLARE @IsAcceptable bit
	EXECUTE [dbo].[Load_IsFileTooOld] @DataSourceId, @LocationPath, @AsOfDate, @IsAcceptable OUTPUT, @ReceiveLocationSysId, @RunId
	IF (@IsAcceptable = 0)
		BEGIN
			
			UPDATE stage.MacquarieTrade SET LoadState = 3 WHERE LoadState = 1 AND FileName = @LocationPath	
			RAISERROR (''File is too old.'', 18, 0)
			RETURN
	END									
	

	-- Store ImportFile record for use
	DECLARE @ImportFileId INT
	EXEC ib_ImportFile_Add @DataSourceId, @LocationPath, @ImportFileId output

	--Gets the defaultStrikePriceDivisor
	DECLARE	@DefaultStrikePriceDivisor	DECIMAL(19,6)
	SET @DefaultStrikePriceDivisor = [dbo].[udf_GetDefaultStrikePriceDivisor](@DataSourceId, NULL)

	SET XACT_ABORT ON 

	BEGIN TRAN T1

		-- BizTalk''s SQL Adapter uses more restrictive read serializable
		-- so this is necessary to relax it to something that is default
		-- and perfectly acceptable!
		SET TRANSACTION ISOLATION LEVEL READ COMMITTED

		BEGIN TRY
			DECLARE @MacquarieTradeId INT
			DECLARE @BusinessDate DATE
			DECLARE @ClientCode VARCHAR(100)
			DECLARE @Description VARCHAR(255)
			DECLARE @GroupCode VARCHAR(100)
			DECLARE @Currency VARCHAR(3)
			DECLARE @Category VARCHAR(10)
			DECLARE @CommodityCode VARCHAR(100)
			DECLARE @DeliveryMonth VARCHAR(4)
			DECLARE @FuturesOrOption VARCHAR(1)
			DECLARE @PutCall VARCHAR(1)
			DECLARE @TradeDate DATE
			DECLARE @BoughtSold VARCHAR(1)
			DECLARE @Quantity INT
			DECLARE @BoughtPrice MONEY
			DECLARE @SoldPrice  MONEY
			DECLARE @CurrentPrice MONEY
			DECLARE @MarginVariance MONEY
			DECLARE @ExecutingBrokerCode VARCHAR(100)
			DECLARE @ExercisePrice MONEY
			DECLARE @InstrumentType VARCHAR(10)
			DECLARE @SettlementAmount MONEY
			
			DECLARE trx_cursor CURSOR FOR
			SELECT MacquarieTradeId
					,BusinessDate
					,ClientCode
					,[Description]
					,GroupCode
					,Currency
					,Category
					,CommodityCode
					,DeliveryMonth
					,FuturesOrOption
					,PutCall
					,TradeDate
					,BoughtSold
					,Quantity
					,BoughtPrice
					,SoldPrice
					,CurrentPrice
					,MarginVariance
					,ExecutingBrokerCode
					,ExercisePrice
					,InstrumentType
					,SettlementAmount
			FROM stage.MacquarieTrade WHERE LoadState = 1 AND Filename = @LocationPath
			
			OPEN trx_cursor

			FETCH NEXT FROM trx_cursor
			INTO 
				    @MacquarieTradeId
					,@BusinessDate
					,@ClientCode
					,@Description
					,@GroupCode
					,@Currency
					,@Category
					,@CommodityCode
					,@DeliveryMonth
					,@FuturesOrOption
					,@PutCall
					,@TradeDate
					,@BoughtSold
					,@Quantity
					,@BoughtPrice
					,@SoldPrice
					,@CurrentPrice
					,@MarginVariance
					,@ExecutingBrokerCode
					,@ExercisePrice
					,@InstrumentType
					,@SettlementAmount

				-- Check @@FETCH_STATUS to see IF there are any more rows to fetch.
				WHILE @@FETCH_STATUS = 0
				BEGIN
					DECLARE		@InstrumentCd			VARCHAR(100)
					DECLARE		@InstrumentTypeCd		VARCHAR(100)
					DECLARE		@QuantityLong			DECIMAL(19,4)
					DECLARE		@QuantityShort			DECIMAL(19,4)
					DECLARE		@SignedQuantity			DECIMAL(19,4)
					DECLARE		@ExpYr					SMALLINT
					DECLARE		@ExpMth					SMALLINT
					DECLARE		@ExpDay					SMALLINT
					DECLARE		@StrikePriceValue		DECIMAL(19,4)
					DECLARE		@TradePriceValue		DECIMAL(24,10)
					DECLARE		@TradePriceDivisor		DECIMAL(19,4)
					DECLARE		@StrikePriceDivisor		DECIMAL(19,4)
					DECLARE		@MarketValueDec			DECIMAL(19,4)
					DECLARE		@MarketValueDivisor		DECIMAL(19,4)
					DECLARE		@TrxTypeCode			VARCHAR(25)
					DECLARE		@TrxTypeDesc			VARCHAR(25)
					
					SET @InstrumentTypeCd = @FuturesOrOption						

					-- We prefix the Instruments with the IntrumentTypeCode
					SET @InstrumentCd = @InstrumentTypeCd + ''_'' + @ExchangeCode + ''_'' + @CommodityCode			
					
					SET @TrxTypeCode = NULL
					SET @TrxTypeDesc = NULL
					SET @TrxTypeCode = @Category
					SET @TrxTypeDesc = CASE @TrxTypeCode 
								WHEN ''A'' THEN ''New Trade'' 
								WHEN ''B'' THEN ''As of Trade'' 
								WHEN ''C'' THEN ''Deletion'' 
								WHEN ''D'' THEN ''Reopen P&L Trade'' 
								WHEN ''E'' THEN ''P&L Trade'' 
								END
					IF (@TrxTypeCode = ''E'')
					BEGIN
						SET @BoughtSold = ''B''
						SET @MarginVariance = @SettlementAmount
					END
					-- Set Quantity 
					SET @QuantityLong = 0
					SET @QuantityShort = 0
			
					-- Set QuantityLong
					IF (@BoughtSold = ''B'')
						BEGIN
							SET @QuantityLong = @Quantity
							SET @SignedQuantity = @Quantity 
						END
					ELSE					
					-- Set QuantityShort
						BEGIN
							SET @QuantityShort = @Quantity
							SET @SignedQuantity = @Quantity * (-1)
						END	
					IF @TrxTypeCode = ''C'' -- deletion so we revert the quantities
					BEGIN
						SET @QuantityLong = -1 * @QuantityLong
						SET @QuantityShort = -1 * @QuantityShort
						SET @SignedQuantity = -1* @SignedQuantity
					END
					-- Set ExpiryDate		
					SET @ExpDay = NULL
					SET @ExpMth = NULL
					SET @ExpYr = NULL	

					SET @ExpDay = NULL
					SET @ExpMth = NULL
					SET @ExpYr = NULL	
					-- Set ExpiryDate
					SET @ExpYr = ''20''+LEFT(@DeliveryMonth, 2)
					SET @ExpMth = RIGHT(@DeliveryMonth, 2)
					SET @ExpDay = dbo.udf_OnLoad_ExpiryDate_Get_Day(@ExpYr,@ExpMth,NULL)

						-- Get Divisors						
					SET @StrikePriceDivisor = NULL
					SET @TradePriceDivisor = NULL
								
					SELECT  @MarketValueDivisor = ids.MarketValueDivisor,
							@StrikePriceDivisor = ids.StrikePriceDivisor
							, @TradePriceDivisor = ids.PriceDivisor
					FROM [dbo].[ib_InstrumentDataSource] ids
					WHERE ids.DataSourceId = @DataSourceId
						AND ids.DataSourceInstrumentCode = @InstrumentCd

					-- Set Price	
					SET @TradePriceValue = NULL
					IF @BoughtSold = ''B''
						SET @TradePriceValue = CONVERT(DECIMAL(24,10), @BoughtPrice) / ISNULL(@TradePriceDivisor, 1)
					ELSE
						SET @TradePriceValue = CONVERT(DECIMAL(24,10), @SoldPrice) / ISNULL(@TradePriceDivisor, 1)
					-- Set StrikePrice
					SET @StrikePriceValue = NULL	
					IF (@InstrumentTypeCd = ''O'')
						SET @StrikePriceValue = @ExercisePrice
			
					SET @StrikePriceValue = @StrikePriceValue / ISNULL(@StrikePriceDivisor, ISNULL(@DefaultStrikePriceDivisor, 1))

					SET @MarketValueDec = @MarginVariance / ISNULL(@MarketValueDivisor, 1)

					
					
					IF NOT EXISTS(SELECT 1 FROM ib_TrxType WHERE DataSourceId = @DataSourceId AND Code = @TrxTypeCode)
						INSERT INTO ib_TrxType (DataSourceId, Code, [Description], IsAutoMatched)
							VALUES(@DataSourceId, @TrxTypeCode, @TrxTypeDesc, 1)
						
					DECLARE @TrxId INT
					SET @TrxId = NULL
					EXEC [ib_Trx_Load]
						@DataSourceCode			
						, @ExchangeCode -- exchange				
						, @FirmCode
						, @ClientCode -- @AccountCode	
						, NULL -- DetailAccountCd		
						, @InstrumentCd			
						, @ExpYr					
						, @ExpMth 					
						, @ExpDay 					
						, @StrikePriceValue			
						, @TrxTypeCode -- trxtypecode
						, @PutCall -- optionTypeCode
						, @SignedQuantity			
						, @TradeDate				
						, @TradePriceValue
						, @MacquarieTradeId
						, @InstrumentTypeCd
						, @AsOfDate		
						, @LocationPath
						, @MarketValueDec -- marketValue
						, @Currency
						, @TrxId = @TrxId OUTPUT
						, @QuantityLong = @QuantityLong 
						, @QuantityShort = @QuantityShort
						, @ReceiveLocationSysId = @ReceiveLocationSysId
						, @RunId = @RunId

					--flip processed flag in source table.
					UPDATE stage.MacquarieTrade WITH (ROWLOCK) SET [LoadState] = 2 WHERE MacquarieTradeId = @MacquarieTradeId AND [LoadState] = 1
					IF (@TrxId IS NOT NULL AND @TrxId > 0)
						SET @AddCount = @AddCount + 1
			
					FETCH NEXT FROM trx_cursor
					INTO 
							@MacquarieTradeId
							,@BusinessDate
							,@ClientCode
							,@Description
							,@GroupCode
							,@Currency
							,@Category
							,@CommodityCode
							,@DeliveryMonth
							,@FuturesOrOption
							,@PutCall
							,@TradeDate
							,@BoughtSold
							,@Quantity
							,@BoughtPrice
							,@SoldPrice
							,@CurrentPrice
							,@MarginVariance
							,@ExecutingBrokerCode
							,@ExercisePrice
							,@InstrumentType
							,@SettlementAmount
				END
			
		CLOSE trx_cursor
		DEALLOCATE trx_cursor

			-- Now update state of any left-over temporary transaction records
			-- so there are no ''left-overs''
			UPDATE stage.MacquarieTrade
			WITH (ROWLOCK)
			SET [LoadState] = 2
			WHERE [LoadState] = 1 AND [FileName] = @LocationPath

			SET @Message = @DataSourceCode + '' transaction loader ended ('' + CONVERT(VARCHAR(10), @AddCount) + '' added).'' 
		
			EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @Message, ''Success'', '''', @RunId

			UPDATE ib_ImportFile SET AsOfDate = @AsOfDate WHERE ImportFileId = @ImportFileId
			
		COMMIT TRAN T1
	
	END TRY
	BEGIN CATCH 

		IF XACT_STATE() = -1 
			ROLLBACK TRANSACTION
	
		SET @Message = @DataSourceCode + '' transaction loader failed.'' 		
		EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @Message, ''Error'', '''', @RunId
	
		EXEC [dbo].[sp_RethrowError]
		
	END CATCH 

	SET XACT_ABORT OFF

END

RETURN 0
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Base_Add]''
');

GO
EXECUTE ('  /*
<details>
 <summary>Updates a base from the ib_Base table by its id</summary>
 <created author="Laurentiu Macovei" Date=" Thursday 14 September 2006 9:26PM GMT" /> 
</details>
-- 23 Jun 2010 ED MBAL 15913 - Tidy up Trade/Settlement Price Corrections for Rounded Prices
*/ 
 CREATE PROCEDURE [dbo].[ib_Base_Add]
(
	@BaseId int,
	@Code varchar(100),
    @Base int,
    @Name varchar(100),
    @UpdateUsername varchar(50)
)
AS 
SET NOCOUNT ON


BEGIN TRY
--check for duplicates 
EXEC [dbo].[ib_Base_CheckForDuplicate] @Code, @BaseId

UPDATE [dbo].[ib_Base]
   SET [Code] = @Code
      ,[Base] = @Base
      ,[Name] = @Name
      ,[UpdateUsername] = @UpdateUsername
 WHERE BaseId = @BaseId
 
 END TRY
BEGIN CATCH
	EXEC [dbo].[sp_RethrowError]
END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[aspnet_Users_GetReportByRole]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[aspnet_Users_GetReportByRole]
AS
BEGIN
-- Revision history
-- 16 May 2014  ED  EIB 24585 - create sp to get the report

	SET NOCOUNT ON
	SELECT u.UserName, m.Email AS EmailAddress, r.RoleName AS Roles, m.LastLoginDate AS ''LastLoginDate''
		FROM aspnet_users u
			LEFT JOIN aspnet_membership m ON u.userid = m.userid
			LEFT JOIN aspnet_usersinroles uir ON u.UserId = uir.UserId
			LEFT JOIN aspnet_roles r ON uir.RoleId = r.RoleId
		WHERE m.IsApproved = 1
		ORDER BY u.UserName, r.RoleName

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[is_GCollateralSecuritiesMovement_Add]''
');

GO
EXECUTE ('


/*
<Details>
<Summary>Inserts an item into the GCollateralSecuritiesMovement table</Summary>
<Created author="laurentiu.macovei" date="04/05/2006 16:33:05" />
</Details>
*/
CREATE PROCEDURE [dbo].[is_GCollateralSecuritiesMovement_Add]
	@CorporationCode varchar(4) = NULL,
	@PrincipalBrokerageId varchar(1) = NULL,
	@OfficeCode varchar(4) = NULL,
	@ACNo varchar(10) = NULL,
	@RecordId varchar(2) = NULL,
	@BaseDate datetime = NULL,
	@CalculationDate datetime = NULL,
	@CalculationStartTime datetime = NULL,
	@DepositId varchar(2) = NULL,
	@DepositWithdrawalDate datetime = NULL,
	@DepositWithdrawalId varchar(1) = NULL,
	@ProductId varchar(2) = NULL,
	@CompanyCode varchar(7) = NULL,
	@SeriesNo varchar(4) = NULL,
	@SubCode varchar(2) = NULL,
	@NewOldId varchar(1) = NULL,
	@DepositDate datetime = NULL,
	@RecordNo varchar(5) = NULL,
	@Quantity decimal(15,0) = NULL,
	@MarketValue decimal(15,0) = NULL,
	@CollateralRate varchar(3) = NULL,
	@UnitValuePerCollateral decimal(15,0) = NULL,
	@EvaluationOfCollateralSecurities decimal(15,0) = NULL,
	@CustodianCode varchar(3) = NULL,
	@DepositaryReceiptNo varchar(5) = NULL,
	@JasdecMemberCodeMemberToWhichCollateralIsPlaced varchar(7) = NULL,
	@DirectCustodian varchar(2) = NULL,
	@CustomerNameAbbreviated varchar(35) = NULL,
	@SecurityNameEnglish varchar(28) = NULL,
	@SecurityNameKana varchar(24) = NULL
AS
SET NOCOUNT ON

SET NOCOUNT OFF

	DECLARE	@CalculationDateStartTime		DATETIME

	IF @BaseDate = ''01/01/1900 00:00:00'' 
		SET @BaseDate = NULL

	IF @CalculationDate = ''01/01/1900 00:00:00'' 
		SET @CalculationDate = NULL

	IF @CalculationStartTime = ''01/01/1900 00:00:00'' 
		SET @CalculationStartTime = NULL

	IF @DepositWithdrawalDate = ''01/01/1900 00:00:00'' 
		SET @DepositWithdrawalDate = NULL

	IF @DepositDate = ''01/01/1900 00:00:00'' 
		SET @DepositDate = NULL

	SET @CalculationDateStartTime = CONVERT(DATETIME,CONVERT(VARCHAR(12), CONVERT(DATETIME,@CalculationDate,112)) + '' '' + CONVERT(VARCHAR(8),RIGHT(@CalculationStartTime,8)))

	INSERT INTO is_GCollateralSecuritiesMovement 
		(
			[CorporationCode], 
			[PrincipalBrokerageId], 
			[OfficeCode], 
			[ACNo], 
			[RecordId], 
			[BaseDate], 
			[CalculationDate], 
			[CalculationStartTime],
			[CalculationDateStartTime], 
			[DepositId], 
			[DepositWithdrawalDate], 
			[DepositWithdrawalId], 
			[ProductId], 
			[CompanyCode], 
			[SeriesNo], 
			[SubCode], 
			[NewOldId], 
			[DepositDate], 
			[RecordNo], 
			[Quantity], 
			[MarketValue], 
			[CollateralRate], 
			[UnitValuePerCollateral], 
			[EvaluationOfCollateralSecurities], 
			[CustodianCode], 
			[DepositaryReceiptNo], 
			[JasdecMemberCodeMemberToWhichCollateralIsPlaced], 
			[DirectCustodian], 
			[CustomerNameAbbreviated], 
			[SecurityNameEnglish], 
			[SecurityNameKana]
		) 
		VALUES
		(
			@CorporationCode, 
			@PrincipalBrokerageId, 
			@OfficeCode, 
			@ACNo, 
			@RecordId, 
			@BaseDate, 
			@CalculationDate, 
			@CalculationStartTime,
			@CalculationDateStartTime, 
			@DepositId, 
			@DepositWithdrawalDate, 
			@DepositWithdrawalId, 
			@ProductId, 
			@CompanyCode, 
			@SeriesNo, 
			@SubCode, 
			@NewOldId, 
			@DepositDate, 
			@RecordNo, 
			@Quantity, 
			@MarketValue, 
			@CollateralRate, 
			@UnitValuePerCollateral, 
			@EvaluationOfCollateralSecurities, 
			@CustodianCode, 
			@DepositaryReceiptNo, 
			@JasdecMemberCodeMemberToWhichCollateralIsPlaced, 
			@DirectCustodian, 
			@CustomerNameAbbreviated, 
			@SecurityNameEnglish, 
			@SecurityNameKana
		);

Return Scope_Identity()
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Instrument_Delete]''
');

GO
EXECUTE ('/*
<details>
 <summary>Deletes an instrument by its id from the ib_Instrument table</summary>
 <created author="Laurentiu Macovei" Date="Sunday, 10 September 2006 12:20AM GMT" /> 
</details>
*/
CREATE PROCEDURE [dbo].[ib_Instrument_Delete]
(
	@InstrumentId int
)
AS
SET NOCOUNT ON
--	31 Mar 2010		amk		Add error handling so front end gets friendlier message
--  27 May 2010     ED      MBAL 15642 - Cascade delete to ib_Price/PriceReportSummary
--  13 May 2014     ED      EIB 25499 - add IsActive flag to ib_Instrument
IF EXISTS(SELECT 1 FROM ib_InstrumentDataSource WHERE InstrumentId = @InstrumentId)
BEGIN
	RAISERROR (''The Instrument should not be associated with any Data Sources.'', 16, 10)
	RETURN
END

DECLARE @SoftDelete BIT
SET @SoftDelete = 0
	BEGIN TRY
	BEGIN TRAN
		--delete where we have instrument from ib_priceReportSummary
		DELETE FROM ib_PriceReportSummary WHERE InstrumentId=@InstrumentId
		--update internal side
		UPDATE ib_PriceReportSummary 
			SET Variation =  -1*ISNULL(External_SettlementPrice,0)
				,Internal_PriceId = NULL
				,Internal_SettlementPrice = NULL
			WHERE Internal_PriceId IN (SELECT PriceId FROM ib_Price WHERE InstrumentId=@InstrumentId)
		--update external side
		UPDATE ib_PriceReportSummary 
			SET Variation =  ISNULL(Internal_SettlementPrice,0)
				,External_PriceId = NULL
				,External_SettlementPrice = NULL
			WHERE External_PriceId IN (SELECT PriceId FROM ib_Price WHERE InstrumentId=@InstrumentId)
		--delete from price
		DELETE FROM ib_Price WHERE  InstrumentId=@InstrumentId
		
		DELETE FROM [dbo].[ib_Instrument]
		WHERE InstrumentId  = @InstrumentId 
	COMMIT TRAN
	END TRY
	BEGIN CATCH
		ROLLBACK TRAN
		DECLARE @ErrorMessage NVARCHAR(4000);
		SET @ErrorMessage = ERROR_MESSAGE()
		IF CHARINDEX(''FK_ib_ImbalanceReportDetail_ib_Instrument'', @ErrorMessage) > 0
			OR CHARINDEX(''FK_ib_ImbalanceReportSummary_ib_Instrument'', @ErrorMessage) > 0
			RAISERROR (''Instrument in use by cached Imbalance Reports.  Try delete again after one or more days when that cache will have been purged.'', 16, 10)
		IF CHARINDEX(''FK_ib_TradeReconciliationDetail_ib_Instrument'', @ErrorMessage) > 0
			OR CHARINDEX(''FK_ib_TradeReconciliationSummary_ib_Instrument'', @ErrorMessage) > 0
			RAISERROR (''Instrument in use by cached Trade Recs.  Try delete again after one or more days when that cache will have been purged.'', 16, 10)
		ELSE IF CHARINDEX(''FK_Trx_Instrument'', @ErrorMessage) > 0
			RAISERROR (''Instrument in use on trades.  Try delete again after one or more days when older trades will have been purged.'', 16, 10)
		ELSE IF CHARINDEX(''FK_Position_Instrument'', @ErrorMessage) > 0
			RAISERROR (''Instrument in use on positions.  Try delete again after one or more days when older positions will have been purged.'', 16, 10)
		ELSE
			SET @SoftDelete = 1
	END CATCH
	IF @SoftDelete = 1
		UPDATE ib_Instrument SET IsActive = 0 WHERE InstrumentId = @InstrumentId
');

GO
EXECUTE ('PRINT N''Creating [stage].[MGEPosition_Load]''
');

GO
EXECUTE ('CREATE PROCEDURE [stage].[MGEPosition_Load]
	(
		@LocationPath VARCHAR(100)
		,@ReceiveLocationSysId INT
		,@RunId INT
	)
AS
SET NOCOUNT ON

-- Description:	This stored procedure pulls data from the MGEPosition staging
-- table and inserts it into ib_Position
-- Whilst iterating through the records in MGEPosition, all 
-- of these inserts are wrapped in a transaction so that any failure causes
-- the changes to not commit.

-- 16 Jan 2019	KIR	Creation based on ib credit suisse load (IBAL12)
BEGIN

	DECLARE @Message			VARCHAR(1024)
	DECLARE @AddCount			INT
	SET @AddCount = 0
					
	DECLARE @DataSourceCode VARCHAR(100) = ''MGEX''

	DECLARE @Output INT
	DECLARE @Output2 INT
	DECLARE @ReturnValue INT
	DECLARE @DataSourceId INT

	IF @LocationPath IS NULL SET @LocationPath = @DataSourceCode
	EXEC @ReturnValue= [_ib_DataSource_GetByCodeForOutput] @DataSourceCode, @OutPut output, @Output2 output
	SET @DataSourceId = @Output

	-- Duplicate file check										
	DECLARE @IsFileAlreadyLoaded INT
	EXEC @IsFileALreadyLoaded = HasFileBeenLoaded @LocationPath, @DataSourceId

	IF @IsFileAlreadyLoaded = 1
	BEGIN
		UPDATE [MGEPosition]
		SET LoadState = 3
		WHERE LoadState = 1
			AND FileName = @LocationPath		
		RETURN
	END
	
	-- Set AsOfDate from Filename
	DECLARE @AsOfDate DATETIME
	EXEC [dbo].[TryParseYYYYMMDDFromEndOfFilename] @LocationPath, @AsOfDate OUTPUT
	
	--rd - make sure the As Of Date is not older than acceptable
	DECLARE @IsAcceptable bit
	EXECUTE [dbo].[Load_IsFileTooOld] @DataSourceId,@LocationPath,@AsOfDate,@IsAcceptable OUTPUT, @ReceiveLocationSysId, @RunId
	IF (@IsAcceptable = 0)
	BEGIN
		UPDATE [MGEPosition] SET [LoadState] = 3 WHERE [Filename] = @LocationPath
		RAISERROR (''File is too old.'', 18, 0)
		RETURN 0
	END

	-- Store ImportFile record to be associated with Settlement Price load
	DECLARE @ImportFileId INT
	EXEC ib_ImportFile_Add @DataSourceId, @LocationPath, @ImportFileId output
	
	--Gets the defaultStrikePriceDivisor
	DECLARE	@DefaultStrikePriceDivisor	DECIMAL(19,6)
	SET @DefaultStrikePriceDivisor = [dbo].[udf_GetDefaultStrikePriceDivisor](@DataSourceId, NULL)
	
	IF OBJECT_ID(''tempdb..#tempMGEP'') IS NOT NULL 
		DROP TABLE #tempMGEP
		
	CREATE TABLE #tempMGEP
	(
		MGEPositionId				INT
		, FirmCode					VARCHAR(3)
		, Account					VARCHAR(1)
		, Currency					VARCHAR(3)
		, InstrumentCode			VARCHAR(2)
		, QuantityShortChr			INT
		, QuantityLongChr			INT
		, PayChr					DECIMAL(20,10)
		, CollectChr				DECIMAL(20,10)
		, ContractYear				VARCHAR(4)
		, ContractMonth				VARCHAR(2)
		, StrikePriceChr			DECIMAL(13,8)
		, StrikeSign				VARCHAR(1)
		, OptionTypeCode			VARCHAR(1)
		, InstrumentTypeCode		VARCHAR(1)
	)

	INSERT INTO #tempMGEP
	(
		MGEPositionId
		, FirmCode
		, Account
		, Currency
		, InstrumentCode
		, QuantityShortChr
		, QuantityLongChr
		, PayChr
		, CollectChr
		, ContractYear
		, ContractMonth
		, StrikePriceChr
		, StrikeSign
		, OptionTypeCode
		, InstrumentTypeCode
	)
	SELECT 	
		[MGEPositionId]
		, [FirmCode]
		, [CustomerHouse]
		, [Currency]
		, [CommodityCode]
		, [Short]
		, [Long]
		, [Pay]
		, [Collect]
		, [ContractYear]
		, [ContractMonth]
		, [StrikePrice]
		, [StrikeSign]
		, [PutCall]
		, [FuturesOptions]
	FROM [stage].[MGEPosition]
	WHERE LoadState = 1
		AND [Filename] = @LocationPath

	SET XACT_ABORT ON 
	
	BEGIN TRAN T1

		-- BizTalk''s SQL Adapter uses more restrictive read serializable
		-- so this is necessary to relax it to something that is default
		-- and perfectly acceptable!
		SET TRANSACTION ISOLATION LEVEL READ COMMITTED

		BEGIN TRY

			DECLARE @MGEPositionId			INT
			DECLARE @FirmCode					VARCHAR(3)
			DECLARE @Account					VARCHAR(1)
			DECLARE @Currency					VARCHAR(3)
			DECLARE @InstrumentCode				VARCHAR(2)
			DECLARE @QuantityShortChr			INT
			DECLARE @QuantityLongChr			INT
			DECLARE @PayChr						DECIMAL(20,10)
			DECLARE @CollectChr					DECIMAL(20,10)
			DECLARE @ContractYear				VARCHAR(4)
			DECLARE @ContractMonth				VARCHAR(2)
			DECLARE @StrikePriceChr				DECIMAL(13,8)
			DECLARE @StrikeSign					VARCHAR(1)
			DECLARE @OptionTypeCode				VARCHAR(1)
			DECLARE @InstrumentTypeCode			VARCHAR(1)

			DECLARE pos_cursor CURSOR FOR
			SELECT	MGEPositionId
				    , FirmCode
					, Account
					, Currency
					, InstrumentCode
					, QuantityShortChr
					, QuantityLongChr
					, PayChr
					, CollectChr
					, ContractYear
					, ContractMonth
					, StrikePriceChr
					, StrikeSign
					, OptionTypeCode
					, InstrumentTypeCode
			FROM	#tempMGEP

			OPEN pos_cursor

			FETCH NEXT FROM pos_cursor
			INTO 
					@MGEPositionId
				    , @FirmCode
					, @Account
					, @Currency
					, @InstrumentCode
					, @QuantityShortChr
					, @QuantityLongChr
					, @PayChr
					, @CollectChr
					, @ContractYear
					, @ContractMonth
					, @StrikePriceChr
					, @StrikeSign
					, @OptionTypeCode
					, @InstrumentTypeCode

			-- Check @@FETCH_STATUS to see IF there are any more rows to fetch.
			WHILE @@FETCH_STATUS = 0

			BEGIN
					DECLARE		@AccountCd				VARCHAR(100)
					DECLARE		@ExchangeCd				VARCHAR(25)
					DECLARE		@AsOfDateFromRecord		DATETIME
					DECLARE		@InstrumentCd			VARCHAR(100)
					DECLARE		@Quantity				DECIMAL(19,4)
					DECLARE		@MarketValueDec			DECIMAL(19,4)
					DECLARE		@ExpYr					SMALLINT
					DECLARE		@ExpMth					SMALLINT
					DECLARE		@ExpDay					SMALLINT
					DECLARE		@ExpDate				DATETIME
					DECLARE     @ContractDay            VARCHAR(2) = ''01''
					DECLARE		@StrikePrice			DECIMAL(19,4)
					DECLARE		@PriceDivisor			DECIMAL(19,4)
					DECLARE		@StrikePriceDivisor		DECIMAL(19,4)
					DECLARE		@MarketValueDivisor		DECIMAL(19,4)
					DECLARE		@SettlementPrice		DECIMAL(24,10)
					DECLARE		@TrxTypeCd				VARCHAR(25)
					DECLARE		@TrxDate				DATETIME
					DECLARE     @ErrorMessageForRecord	VARCHAR(1024)
					DECLARE		@ErrorSeverity			INT
					DECLARE		@ErrorState				INT
					DECLARE		@QuantityLong			DECIMAL(19,4)
					DECLARE		@QuantityShort			DECIMAL(19,4)
					DECLARE		@SignedQuantity			DECIMAL(19,4)
					
					-- Temporary variables
                    DECLARE     @TempDate DATETIME
					DECLARE 	@Code VARCHAR(100), @Code2 VARCHAR(100)

			SET @AccountCd = @Account

			-- Set Exchange Code
			SET	@ExchangeCd = ''MGEX''	

			-- Set ExpiryDate
			SET @ExpDate =  CONVERT(DATETIME, @ContractMonth + ''/'' + @ContractDay + ''/'' + @ContractYear);
			SET @ExpYr =  YEAR(@ExpDate)
			SET @ExpMth = MONTH(@ExpDate)
			SET @ContractDay = ''0''

			IF NULLIF(@ContractDay,'''') IS NULL OR @ContractDay = ''0''
				BEGIN
					-- Get the last day of the month
					SET @ExpDay = dbo.udf_OnLoad_ExpiryDate_Get_Day(@ExpYr,@ExpMth,@ContractDay)
				END
			ELSE
				SET @ExpDay = CAST(@ContractDay AS SMALLINT)
			
			-- We prefix the Instruments with the IntrumentTypeCode
			SET @InstrumentCd = @InstrumentTypeCode + ''_'' + @ExchangeCd + ''_'' + @InstrumentCode

			-- Get Divisors						
			SET @StrikePriceDivisor = NULL
			SET	@PriceDivisor = NULL
			SET	@MarketValueDivisor = NULL
								
			SELECT @StrikePriceDivisor = ids.StrikePriceDivisor
					, @PriceDivisor = ids.PriceDivisor
					, @MarketValueDivisor = ids.MarketValueDivisor
			FROM [dbo].[ib_InstrumentDataSource] ids
			WHERE ids.DataSourceId = @DataSourceId
			AND ids.DataSourceInstrumentCode = @InstrumentCd

			-- Set Settlement Price				
			IF @PriceDivisor IS NULL 
				SET @PriceDivisor = 1				

			SET @SettlementPrice = 0 / @PriceDivisor

			-- Set StrikePrice
			SET @StrikePrice = NULL
			
			IF @StrikePriceDivisor IS NULL
				BEGIN
					SET @StrikePrice = CAST(@StrikePriceChr AS DECIMAL(19,4)) / ISNULL(@DefaultStrikePriceDivisor, 1)
				END
			ELSE
				BEGIN
					SET @StrikePrice = CAST(@StrikePriceChr AS DECIMAL(19,4)) / @StrikePriceDivisor
				END						
			IF @StrikeSign = ''-''
				SET @StrikePrice = @StrikePrice * (-1)

			-- Set TrxTypeCd
			SET @TrxTypeCd = ''POSITION''

			-- Set Quantity 
			SET @Quantity = 0
			SET @QuantityLong = 0
			SET @QuantityShort = 0
			

			SET @Quantity = CONVERT(DECIMAL(19,4), @QuantityLongChr)
			SET @QuantityLong = @Quantity
			IF(@QuantityLongChr = 0) 
				BEGIN
					SET @Quantity = CONVERT(DECIMAL(19,4), @QuantityShortChr)
					SET @QuantityShort = @Quantity
				END

			SET @SignedQuantity = @Quantity

			-- Set Market Value
			IF @MarketValueDivisor IS NULL 
				SET @MarketValueDivisor = 1
			
			SET @MarketValueDec = CONVERT(DECIMAL(19,4), @PayChr)  / @MarketValueDivisor 
			IF(@QuantityLongChr = 0)
				BEGIN
					SET @MarketValueDec = CONVERT(DECIMAL(19,4), @CollectChr)  / @MarketValueDivisor 
				END

			-- TrxDate
			SET @TrxDate = @AsOfDate  -- This is not actually used

			
			DECLARE @PositionId INT
			SET @PositionId = NULL

			EXEC [ib_Position_Load]
			@DataSourceCode			
			, @ExchangeCd
			, @FirmCode -- Firm will be added if not present					
			, @AccountCd				
			, @AsOfDate				
			, @InstrumentCd			
			, @SignedQuantity			
			, @MarketValueDec			
			, @ExpYr					
			, @ExpMth					
			, @ExpDay	
			, @StrikePrice			
			, @TrxTypeCd				
			, @OptionTypeCode	
			, @TrxDate 			
			, @SettlementPrice -- This value is NOT actually used in the ib_Position_Load Stored Procedure, should be removed ?			
			, @MGEPositionId
			, @InstrumentTypeCode		
			, @LocationPath
			, @Currency
			, @LongQuantity = @QuantityLong
			, @ShortQuantity = @QuantityShort
			, @PositionId = @PositionId output
			, @ReceiveLocationSysId = @ReceiveLocationSysId
			, @RunId = @RunId
			
			-- Add Settlement Price											
			EXEC ib_Price_AddFromPositionLoad
				@PositionId
				, @ImportFileId
				, @SettlementPrice 	

			--flip processed flag in source table.
			UPDATE [stage].[MGEPosition] 
			WITH (ROWLOCK)
			SET [LoadState] = 2
			WHERE [MGEPositionID] = @MGEPositionID 
				AND [LoadState] = 1
				
			SET @AddCount = @AddCount + 1

			FETCH NEXT FROM pos_cursor
			INTO 
					@MGEPositionId
				    , @FirmCode
					, @Account
					, @Currency
					, @InstrumentCode
					, @QuantityShortChr
					, @QuantityLongChr
					, @PayChr
					, @CollectChr
					, @ContractYear
					, @ContractMonth
					, @StrikePriceChr
					, @StrikeSign
					, @OptionTypeCode
					, @InstrumentTypeCode
		END
			
			CLOSE pos_cursor
			DEALLOCATE pos_cursor

			SET @Message = @DataSourceCode + '' position loader ended ('' 
				+ CONVERT(VARCHAR(10), @AddCount) + '' added)'' 
		
			EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @Message, ''Success'', '''', @RunId
			
			UPDATE ib_ImportFile
			SET AsOfDate = @AsOfDate
			WHERE ImportFileId = @ImportFileId
			
		COMMIT TRAN T1

	DROP TABLE #tempMGEP

		END TRY
	BEGIN CATCH 

		IF XACT_STATE() = -1 
			ROLLBACK TRANSACTION
	
		SET @Message = @DataSourceCode + '' position loader failed'' 		
		
		EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @Message, ''Error'', '''', @RunId
		
		EXEC [dbo].[sp_RethrowError]
		
	END CATCH 

	SET XACT_ABORT OFF
	
END

RETURN 0
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Base_Delete]''
');

GO
EXECUTE ('/*
<details>
 <summary>Deletes a base by its id from the ib_Base table</summary>
 <created author="Laurentiu Macovei" Date=" Thursday 14 September 2006 9:26PM GMT" /> 
</details>
*/
create PROCEDURE [dbo].[ib_Base_Delete]
@BaseId int
AS
SET NOCOUNT ON

BEGIN TRY
DELETE FROM ib_Base
	WHERE BaseId =  @BaseId
END TRY
BEGIN CATCH
	EXEC [dbo].[sp_RethrowError] ''Base is currently in use!''	
END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[aspnet_UsersInRoles_AddUsersToRoles]''
');

GO
SET QUOTED_IDENTIFIER OFF

GO
EXECUTE ('
CREATE PROCEDURE [dbo].[aspnet_UsersInRoles_AddUsersToRoles]
	@ApplicationName  nvarchar(256),
	@UserNames		  nvarchar(4000),
	@RoleNames		  nvarchar(4000),
	@CurrentTimeUtc   datetime
AS
SET NOCOUNT ON
BEGIN
	DECLARE @AppId uniqueidentifier
	SELECT  @AppId = NULL
	SELECT  @AppId = ApplicationId FROM aspnet_Applications WHERE LOWER(@ApplicationName) = LoweredApplicationName
	IF (@AppId IS NULL)
		RETURN(2)
	DECLARE @TranStarted   bit
	SET @TranStarted = 0

	IF( @@TRANCOUNT = 0 )
	BEGIN
		BEGIN TRANSACTION
		SET @TranStarted = 1
	END

	DECLARE @tbNames	table(Name nvarchar(256) NOT NULL PRIMARY KEY)
	DECLARE @tbRoles	table(RoleId uniqueidentifier NOT NULL PRIMARY KEY)
	DECLARE @tbUsers	table(UserId uniqueidentifier NOT NULL PRIMARY KEY)
	DECLARE @Num		int
	DECLARE @Pos		int
	DECLARE @NextPos	int
	DECLARE @Name		nvarchar(256)

	SET @Num = 0
	SET @Pos = 1
	WHILE(@Pos <= LEN(@RoleNames))
	BEGIN
		SELECT @NextPos = CHARINDEX(N'','', @RoleNames,  @Pos)
		IF (@NextPos = 0 OR @NextPos IS NULL)
			SELECT @NextPos = LEN(@RoleNames) + 1
		SELECT @Name = RTRIM(LTRIM(SUBSTRING(@RoleNames, @Pos, @NextPos - @Pos)))
		SELECT @Pos = @NextPos+1

		INSERT INTO @tbNames VALUES (@Name)
		SET @Num = @Num + 1
	END

	INSERT INTO @tbRoles
	  SELECT RoleId
	  FROM   dbo.aspnet_Roles ar, @tbNames t
	  WHERE  LOWER(t.Name) = ar.LoweredRoleName AND ar.ApplicationId = @AppId

	IF (@@ROWCOUNT <> @Num)
	BEGIN
		SELECT TOP 1 Name
		FROM   @tbNames
		WHERE  LOWER(Name) NOT IN (SELECT ar.LoweredRoleName FROM dbo.aspnet_Roles ar,  @tbRoles r WHERE r.RoleId = ar.RoleId)
		IF( @TranStarted = 1 )
			ROLLBACK TRANSACTION
		RETURN(2)
	END

	DELETE FROM @tbNames WHERE 1=1
	SET @Num = 0
	SET @Pos = 1

	WHILE(@Pos <= LEN(@UserNames))
	BEGIN
		SELECT @NextPos = CHARINDEX(N'','', @UserNames,  @Pos)
		IF (@NextPos = 0 OR @NextPos IS NULL)
			SELECT @NextPos = LEN(@UserNames) + 1
		SELECT @Name = RTRIM(LTRIM(SUBSTRING(@UserNames, @Pos, @NextPos - @Pos)))
		SELECT @Pos = @NextPos+1

		INSERT INTO @tbNames VALUES (@Name)
		SET @Num = @Num + 1
	END

	INSERT INTO @tbUsers
	  SELECT UserId
	  FROM   dbo.aspnet_Users ar, @tbNames t
	  WHERE  LOWER(t.Name) = ar.LoweredUserName AND ar.ApplicationId = @AppId

	IF (@@ROWCOUNT <> @Num)
	BEGIN
		DELETE FROM @tbNames
		WHERE LOWER(Name) IN (SELECT LoweredUserName FROM dbo.aspnet_Users au,  @tbUsers u WHERE au.UserId = u.UserId)

		INSERT dbo.aspnet_Users (ApplicationId, UserId, UserName, LoweredUserName, IsAnonymous, LastActivityDate)
		  SELECT @AppId, NEWID(), Name, LOWER(Name), 0, @CurrentTimeUtc
		  FROM   @tbNames

		INSERT INTO @tbUsers
		  SELECT  UserId
		  FROM	dbo.aspnet_Users au, @tbNames t
		  WHERE   LOWER(t.Name) = au.LoweredUserName AND au.ApplicationId = @AppId
	END

	IF (EXISTS (SELECT * FROM dbo.aspnet_UsersInRoles ur, @tbUsers tu, @tbRoles tr WHERE tu.UserId = ur.UserId AND tr.RoleId = ur.RoleId))
	BEGIN
		SELECT TOP 1 UserName, RoleName
		FROM		 dbo.aspnet_UsersInRoles ur, @tbUsers tu, @tbRoles tr, aspnet_Users u, aspnet_Roles r
		WHERE		u.UserId = tu.UserId AND r.RoleId = tr.RoleId AND tu.UserId = ur.UserId AND tr.RoleId = ur.RoleId

		IF( @TranStarted = 1 )
			ROLLBACK TRANSACTION
		RETURN(3)
	END

	INSERT INTO dbo.aspnet_UsersInRoles (UserId, RoleId)
	SELECT UserId, RoleId
	FROM @tbUsers, @tbRoles

	IF( @TranStarted = 1 )
		COMMIT TRANSACTION
	RETURN(0)
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[is_GProductTotal_Add]''
');

GO
SET QUOTED_IDENTIFIER ON

GO
EXECUTE ('


/*
<Details>
<Summary>Inserts an item into the GProductTotal table</Summary>
<Created author="laurentiu.macovei" date="04/05/2006 16:33:05" />
</Details>
*/
CREATE PROCEDURE [dbo].[is_GProductTotal_Add]
	@CorporationCode varchar(4) = NULL,
	@PrincipalBrokerageID varchar(1) = NULL,
	@OfficeCode varchar(4) = NULL,
	@ACNumber varchar(10) = NULL,
	@RecordID varchar(2) = NULL,
	@BaseDate datetime = NULL,
	@CalculationDate datetime = NULL,
	@CalculationStartTime datetime = NULL,
	@FuturesSubId varchar(3) = NULL,
	@DerivativesCode varchar(10) = NULL,
	@BuyContractQuantity int = NULL,
	@SellContractQuantity int = NULL,
	@Yen01 varchar(10) = NULL,
	@Yen02 varchar(15) = NULL,
	@Yen03 varchar(1) = NULL,
	@UnrealizedPLSign varchar(1) = NULL,
	@UnrealizedPL decimal(15,0) = NULL,
	@UnrealizedPLNonCalculableFlag varchar(1) = NULL,
	@AdjustmentFPDAmountSign varchar(1) = NULL,
	@AdjustmentFPDAmount decimal(15,0) = NULL,
	@AdjustmentFPDFuturesRealizedPLSign varchar(1) = NULL,
	@AdjustmentFPDFuturesRealizedPL decimal(15,0) = NULL,
	@AdjustmentFPDOptionsPremiumAmountBuySign varchar(1) = NULL,
	@AdjustmentFPDOptionsPremiumAmount decimal(15,0) = NULL,
	@AdjustmentFPDOptionsPremiumAmountSellSign varchar(1) = NULL,
	@AdjustmentFPDOptionsPremiumAmountSell decimal(15,0) = NULL,
	@AdjustmentFPDNetStrikePriceForExerciseSign varchar(1) = NULL,
	@AdjustmentFPDNetStrikePriceForExercise decimal(15,0) = NULL,
	@AdjustmentFPDNetStrikePriceForAllotmentSign varchar(1) = NULL,
	@AdjustmentFPDNetStrikePriceForAllotment decimal(15,0) = NULL,
	@AdjustmentFPDCommissionAmountSign varchar(1) = NULL,
	@AdjustmentFPDCommissionAmount decimal(15,0) = NULL,
	@AdjustmentFPDConsumptionTaxAmountSign varchar(1) = NULL,
	@AdjustmentFPDConsumptionTaxAmount decimal(15,0) = NULL,
	@AdjustmentFPDExchangeTaxAmountSign varchar(1) = NULL,
	@AdjustmentFPDExchangeTaxAmount decimal(15,0) = NULL,
	@SettlementAmountFCDTradingSign varchar(1) = NULL,
	@SettlementAmountFCDTrading decimal(15,0) = NULL,
	@RealizedPLFCDFuturesTradingSign varchar(1) = NULL,
	@RealizedPLFCDFuturesTrading decimal(15,0) = NULL,
	@OptionsPremiumFCDTradingBuySign varchar(1) = NULL,
	@OptionsPremiumFCDTradingBuy decimal(15,0) = NULL,
	@OptionsPremiumFCDTradingSellSign varchar(1) = NULL,
	@OptionsPremiumFCDTradingSell decimal(15,0) = NULL,
	@NetStrikePriceFCDTradingForExerciseSign varchar(1) = NULL,
	@NetStrikePriceFCDTradingForExercise decimal(15,0) = NULL,
	@NetStrikePriceFCDTradingForAllotmentSign varchar(1) = NULL,
	@NetStrikePriceFCDTradingForAllotment decimal(15,0) = NULL,
	@CommissionAmountFCDTradingSign varchar(1) = NULL,
	@CommissionAmountFCDTrading decimal(15,0) = NULL,
	@ConsumptionTaxAmountFCDTradingSign varchar(1) = NULL,
	@ConsumptionTaxAmountFCDTrading decimal(15,0) = NULL,
	@ExchangeTaxAmountFCDTradingSign varchar(1) = NULL,
	@ExchangeTaxAmountFCDTrading decimal(15,0) = NULL,
	@ProductNameEnglish varchar(28) = NULL,
	@ProductNameKan varchar(24) = NULL,
	@LongOptionValue decimal(15,0) = NULL,
	@ShortOptionValue decimal(15,0) = NULL
AS
SET NOCOUNT ON

SET NOCOUNT OFF

	DECLARE	@CalculationDateStartTime						DATETIME
	DECLARE	@UnrealizedPLSigned								DECIMAL(15,0)
	DECLARE	@AdjustmentFPDAmountSigned						DECIMAL(15,0)
	DECLARE @AdjustmentFPDFuturesRealizedPLSigned			DECIMAL(15,0)
	DECLARE	@AdjustmentFPDOptionsPremiumAmountBuySigned		DECIMAL(15,0)
	DECLARE	@AdjustmentFPDOptionsPremiumAmountSellSigned	DECIMAL(15,0)
	DECLARE	@AdjustmentFPDNetStrikePriceForExerciseSigned	DECIMAL(15,0)
	DECLARE	@AdjustmentFPDNetStrikePriceForAllotmentSigned	DECIMAL(15,0)
	DECLARE	@AdjustmentFPDCommissionAmountSigned			DECIMAL(15,0)
	DECLARE	@AdjustmentFPDConsumptionTaxAmountSigned		DECIMAL(15,0)
	DECLARE	@AdjustmentFPDExchangeTaxAmountSigned			DECIMAL(15,0)
	DECLARE	@SettlementAmountFCDTradingSigned				DECIMAL(15,0)
	DECLARE	@RealizedPLFCDFuturesTradingSigned				DECIMAL(15,0)
	DECLARE	@OptionsPremiumFCDTradingBuySigned				DECIMAL(15,0)
	DECLARE	@OptionsPremiumFCDTradingSellSigned				DECIMAL(15,0)
	DECLARE	@NetStrikePriceFCDTradingForExerciseSigned		DECIMAL(15,0)
	DECLARE	@NetStrikePriceFCDTradingForAllotmentSigned		DECIMAL(15,0)
	DECLARE	@CommissionAmountFCDTradingSigned				DECIMAL(15,0)
	DECLARE	@ConsumptionTaxAmountFCDTradingSigned			DECIMAL(15,0)
	DECLARE	@ExchangeTaxAmountFCDTradingSigned				DECIMAL(15,0)


	IF @BaseDate = ''01/01/1900 00:00:00'' 
		SET @BaseDate = NULL

	IF @CalculationDate = ''01/01/1900 00:00:00'' 
		SET @CalculationDate = NULL

	IF @CalculationStartTime = ''01/01/1900 00:00:00'' 
		SET @CalculationStartTime = NULL

	SET @CalculationDateStartTime = CONVERT(DATETIME,CONVERT(VARCHAR(12), CONVERT(DATETIME,@CalculationDate,112)) + '' '' + CONVERT(VARCHAR(8),RIGHT(@CalculationStartTime,8)))

	IF @UnrealizedPLSign = ''-'' 	
		SET @UnrealizedPLSigned = @UnrealizedPL * -1 
	ELSE	
		SET @UnrealizedPLSigned = @UnrealizedPL

	IF @AdjustmentFPDAmountSign = ''-'' 	
		SET @AdjustmentFPDAmountSigned = @AdjustmentFPDAmount * -1 
	ELSE	
		SET @AdjustmentFPDAmountSigned = @AdjustmentFPDAmount

	
	IF @AdjustmentFPDFuturesRealizedPLSign = ''-'' 	
		SET @AdjustmentFPDFuturesRealizedPLSigned = @AdjustmentFPDFuturesRealizedPL * -1 
	ELSE	
		SET @AdjustmentFPDFuturesRealizedPLSigned = @AdjustmentFPDFuturesRealizedPL


	IF @AdjustmentFPDOptionsPremiumAmountBuySign = ''-'' 	
		SET @AdjustmentFPDOptionsPremiumAmountBuySigned = @AdjustmentFPDOptionsPremiumAmount * -1 
	ELSE	
		SET @AdjustmentFPDOptionsPremiumAmountBuySigned = @AdjustmentFPDOptionsPremiumAmount

	IF @AdjustmentFPDOptionsPremiumAmountSellSign = ''-'' 	
		SET @AdjustmentFPDOptionsPremiumAmountSellSigned = @AdjustmentFPDOptionsPremiumAmountSell * -1 
	ELSE	
		SET @AdjustmentFPDOptionsPremiumAmountSellSigned = @AdjustmentFPDOptionsPremiumAmountSell

	IF @AdjustmentFPDNetStrikePriceForExerciseSign = ''-'' 	
		SET @AdjustmentFPDNetStrikePriceForExerciseSigned = @AdjustmentFPDNetStrikePriceForExercise * -1 
	ELSE	
		SET @AdjustmentFPDNetStrikePriceForExerciseSigned = @AdjustmentFPDNetStrikePriceForAllotment

	IF @AdjustmentFPDNetStrikePriceForAllotmentSign = ''-'' 	
		SET @AdjustmentFPDNetStrikePriceForAllotmentSigned = @AdjustmentFPDNetStrikePriceForAllotment * -1 
	ELSE	
		SET @AdjustmentFPDNetStrikePriceForAllotmentSigned = @AdjustmentFPDNetStrikePriceForExercise

	IF @AdjustmentFPDCommissionAmountSign = ''-'' 	
		SET @AdjustmentFPDCommissionAmountSigned = @AdjustmentFPDCommissionAmount * -1 
	ELSE	
		SET @AdjustmentFPDCommissionAmountSigned = @AdjustmentFPDCommissionAmount

	IF @AdjustmentFPDConsumptionTaxAmountSign = ''-'' 	
		SET @AdjustmentFPDConsumptionTaxAmountSigned = @AdjustmentFPDConsumptionTaxAmount * -1 
	ELSE	
		SET @AdjustmentFPDConsumptionTaxAmountSigned = @AdjustmentFPDConsumptionTaxAmount

	IF @AdjustmentFPDExchangeTaxAmountSign = ''-'' 	
		SET @AdjustmentFPDExchangeTaxAmountSigned = @AdjustmentFPDExchangeTaxAmount * -1 
	ELSE	
		SET @AdjustmentFPDExchangeTaxAmountSigned = @AdjustmentFPDExchangeTaxAmount

	IF @SettlementAmountFCDTradingSign = ''-'' 	
		SET @SettlementAmountFCDTradingSigned = @SettlementAmountFCDTrading * -1 
	ELSE	
		SET @SettlementAmountFCDTradingSigned = @SettlementAmountFCDTrading

	IF @RealizedPLFCDFuturesTradingSign = ''-'' 	
		SET @RealizedPLFCDFuturesTradingSigned = @RealizedPLFCDFuturesTrading * -1 
	ELSE	
		SET @RealizedPLFCDFuturesTradingSigned = @RealizedPLFCDFuturesTrading

	IF @OptionsPremiumFCDTradingBuySign = ''-'' 	
		SET @OptionsPremiumFCDTradingBuySigned = @OptionsPremiumFCDTradingBuy * -1 
	ELSE	
		SET @OptionsPremiumFCDTradingBuySigned = @OptionsPremiumFCDTradingBuy

	IF @OptionsPremiumFCDTradingSellSign = ''-'' 	
		SET @OptionsPremiumFCDTradingSellSigned = @OptionsPremiumFCDTradingSell * -1 
	ELSE	
		SET @OptionsPremiumFCDTradingSellSigned = @OptionsPremiumFCDTradingSell

	IF @NetStrikePriceFCDTradingForExerciseSign = ''-'' 	
		SET @NetStrikePriceFCDTradingForExerciseSigned = @NetStrikePriceFCDTradingForExercise * -1 
	ELSE	
		SET @NetStrikePriceFCDTradingForExerciseSigned = @NetStrikePriceFCDTradingForExercise

	IF @NetStrikePriceFCDTradingForAllotmentSign = ''-'' 	
		SET @NetStrikePriceFCDTradingForAllotmentSigned = @NetStrikePriceFCDTradingForAllotment * -1 
	ELSE	
		SET @NetStrikePriceFCDTradingForAllotmentSigned = @NetStrikePriceFCDTradingForAllotment

	IF @CommissionAmountFCDTradingSign = ''-'' 	
		SET @CommissionAmountFCDTradingSigned = @CommissionAmountFCDTrading * -1 
	ELSE	
		SET @CommissionAmountFCDTradingSigned = @CommissionAmountFCDTrading

	IF @ConsumptionTaxAmountFCDTradingSign = ''-'' 	
		SET @ConsumptionTaxAmountFCDTradingSigned = @ConsumptionTaxAmountFCDTrading * -1 
	ELSE	
		SET @ConsumptionTaxAmountFCDTradingSigned = @ConsumptionTaxAmountFCDTrading

	IF @ExchangeTaxAmountFCDTradingSign = ''-'' 	
		SET @ExchangeTaxAmountFCDTradingSigned = @ExchangeTaxAmountFCDTrading * -1 
	ELSE	
		SET @ExchangeTaxAmountFCDTradingSigned = @ExchangeTaxAmountFCDTrading




	INSERT INTO is_GProductTotal 
		(
			[CorporationCode], 
			[PrincipalBrokerageID], 
			[OfficeCode], 
			[ACNumber], 
			[RecordID], 
			[BaseDate], 
			[CalculationDate], 
			[CalculationStartTime],
			[CalculationDateStartTime], 
			[FuturesSubId], 
			[DerivativesCode], 
			[BuyContractQuantity], 
			[SellContractQuantity], 
			[Yen01], 
			[Yen02], 
			[Yen03], 
			[UnrealizedPLSign], 
			[UnrealizedPL],
			[UnrealizedPLSigned], 
			[UnrealizedPLNonCalculableFlag], 
			[AdjustmentFPDAmountSign], 
			[AdjustmentFPDAmount],
			[AdjustmentFPDAmountSigned],
			[AdjustmentFPDFuturesRealizedPLSign], 
			[AdjustmentFPDFuturesRealizedPL],
			[AdjustmentFPDFuturesRealizedPLSigned], 
			[AdjustmentFPDOptionsPremiumAmountBuySign], 
			[AdjustmentFPDOptionsPremiumAmount], 
			[AdjustmentFPDOptionsPremiumAmountBuySigned], 
			[AdjustmentFPDOptionsPremiumAmountSellSign], 
			[AdjustmentFPDOptionsPremiumAmountSell], 
			[AdjustmentFPDOptionsPremiumAmountSellSigned], 
			[AdjustmentFPDNetStrikePriceForExerciseSign], 
			[AdjustmentFPDNetStrikePriceForExercise], 
			[AdjustmentFPDNetStrikePriceForExerciseSigned],
			[AdjustmentFPDNetStrikePriceForAllotmentSign], 
			[AdjustmentFPDNetStrikePriceForAllotment],
			[AdjustmentFPDNetStrikePriceForAllotmentSigned], 
			[AdjustmentFPDCommissionAmountSign], 
			[AdjustmentFPDCommissionAmount],
			[AdjustmentFPDCommissionAmountSigned], 
			[AdjustmentFPDConsumptionTaxAmountSign], 
			[AdjustmentFPDConsumptionTaxAmount], 
			[AdjustmentFPDConsumptionTaxAmountSigned],
			[AdjustmentFPDExchangeTaxAmountSign], 
			[AdjustmentFPDExchangeTaxAmount],
			[AdjustmentFPDExchangeTaxAmountSigned], 
			[SettlementAmountFCDTradingSign], 
			[SettlementAmountFCDTrading],
			[SettlementAmountFCDTradingSigned], 
			[RealizedPLFCDFuturesTradingSign], 
			[RealizedPLFCDFuturesTrading], 
			[RealizedPLFCDFuturesTradingSigned],
			[OptionsPremiumFCDTradingBuySign], 
			[OptionsPremiumFCDTradingBuy], 
			[OptionsPremiumFCDTradingBuySigned],
			[OptionsPremiumFCDTradingSellSign], 
			[OptionsPremiumFCDTradingSell],
			[OptionsPremiumFCDTradingSellSigned], 
			[NetStrikePriceFCDTradingForExerciseSign], 
			[NetStrikePriceFCDTradingForExercise],
			[NetStrikePriceFCDTradingForExerciseSigned], 
			[NetStrikePriceFCDTradingForAllotmentSign], 
			[NetStrikePriceFCDTradingForAllotment], 
			[NetStrikePriceFCDTradingForAllotmentSigned],
			[CommissionAmountFCDTradingSign], 
			[CommissionAmountFCDTrading],
			[CommissionAmountFCDTradingSigned], 
			[ConsumptionTaxAmountFCDTradingSign], 
			[ConsumptionTaxAmountFCDTrading], 
			[ConsumptionTaxAmountFCDTradingSigned],
			[ExchangeTaxAmountFCDTradingSign], 
			[ExchangeTaxAmountFCDTrading],
			[ExchangeTaxAmountFCDTradingSigned], 
			[ProductNameEnglish], 
			[ProductNameKan], 
			[LongOptionValue], 
			[ShortOptionValue]
		) 
		VALUES
		(
			@CorporationCode, 
			@PrincipalBrokerageID, 
			@OfficeCode, 
			@ACNumber, 
			@RecordID, 
			@BaseDate, 
			@CalculationDate, 
			@CalculationStartTime,
			@CalculationDateStartTime, 
			@FuturesSubId, 
			@DerivativesCode, 
			@BuyContractQuantity, 
			@SellContractQuantity, 
			@Yen01, 
			@Yen02, 
			@Yen03, 
			@UnrealizedPLSign, 
			@UnrealizedPL, 
			@UnrealizedPLSigned, 
			@UnrealizedPLNonCalculableFlag, 
			@AdjustmentFPDAmountSign, 
			@AdjustmentFPDAmount, 
			@AdjustmentFPDAmountSigned,
			@AdjustmentFPDFuturesRealizedPLSign, 
			@AdjustmentFPDFuturesRealizedPL, 
			@AdjustmentFPDFuturesRealizedPLSigned, 
			@AdjustmentFPDOptionsPremiumAmountBuySign, 
			@AdjustmentFPDOptionsPremiumAmount, 
			@AdjustmentFPDOptionsPremiumAmountBuySigned,
			@AdjustmentFPDOptionsPremiumAmountSellSign, 
			@AdjustmentFPDOptionsPremiumAmountSell, 
			@AdjustmentFPDOptionsPremiumAmountSellSigned,
			@AdjustmentFPDNetStrikePriceForExerciseSign, 
			@AdjustmentFPDNetStrikePriceForExercise, 
			@AdjustmentFPDNetStrikePriceForExerciseSigned,
			@AdjustmentFPDNetStrikePriceForAllotmentSign, 
			@AdjustmentFPDNetStrikePriceForAllotment, 
			@AdjustmentFPDNetStrikePriceForAllotmentSigned,
			@AdjustmentFPDCommissionAmountSign, 
			@AdjustmentFPDCommissionAmount, 
			@AdjustmentFPDCommissionAmountSigned, 
			@AdjustmentFPDConsumptionTaxAmountSign, 
			@AdjustmentFPDConsumptionTaxAmount, 
			@AdjustmentFPDConsumptionTaxAmountSigned,			
			@AdjustmentFPDExchangeTaxAmountSign, 
			@AdjustmentFPDExchangeTaxAmount, 
			@AdjustmentFPDExchangeTaxAmountSigned, 
			@SettlementAmountFCDTradingSign, 
			@SettlementAmountFCDTrading, 
			@SettlementAmountFCDTradingSigned,
			@RealizedPLFCDFuturesTradingSign, 
			@RealizedPLFCDFuturesTrading, 
			@RealizedPLFCDFuturesTradingSigned,
			@OptionsPremiumFCDTradingBuySign, 
			@OptionsPremiumFCDTradingBuy, 
			@OptionsPremiumFCDTradingBuySigned, 
			@OptionsPremiumFCDTradingSellSign, 
			@OptionsPremiumFCDTradingSell, 
			@OptionsPremiumFCDTradingSellSigned,
			@NetStrikePriceFCDTradingForExerciseSign, 
			@NetStrikePriceFCDTradingForExercise, 
			@NetStrikePriceFCDTradingForExerciseSigned,
			@NetStrikePriceFCDTradingForAllotmentSign, 
			@NetStrikePriceFCDTradingForAllotment, 
			@NetStrikePriceFCDTradingForAllotmentSigned,
			@CommissionAmountFCDTradingSign, 
			@CommissionAmountFCDTrading, 
			@CommissionAmountFCDTradingSigned,
			@ConsumptionTaxAmountFCDTradingSign, 
			@ConsumptionTaxAmountFCDTrading, 
			@ConsumptionTaxAmountFCDTradingSigned, 		
			@ExchangeTaxAmountFCDTradingSign, 
			@ExchangeTaxAmountFCDTrading, 
			@ExchangeTaxAmountFCDTradingSigned, 
			@ProductNameEnglish, 
			@ProductNameKan, 
			@LongOptionValue, 
			@ShortOptionValue
		);

Return Scope_Identity()
');

GO
EXECUTE ('PRINT N''Creating [stage].[MGETrade_Load]''
');

GO
EXECUTE ('CREATE PROCEDURE [stage].[MGETrade_Load] 
	-- Add the parameters for the stored procedure here
	(
		@LocationPath VARCHAR(100)
		,@ReceiveLocationSysId INT
		,@RunId INT
	)
AS
SET NOCOUNT ON

-- Description:	This stored procedure pulls data from the MGETrade staging
-- table and inserts it into ib_Trx
-- Whilst iterating through the records in MGETrade, all 
-- of these inserts are wrapped in a transaction so that any failure causes
-- the changes to not commit.

-- 17 Jan 2019	KIR	Creation based on ib credit suisse load (IBAL12)

BEGIN

	DECLARE @Message			VARCHAR(1024)
	DECLARE @AddCount			INT
	SET @AddCount = 0
		
	DECLARE @DataSourceCode VARCHAR(100) = ''MGEX''
	DECLARE @Currency VARCHAR(3) = ''USD''

	DECLARE @Output INT
	DECLARE @Output2 INT
	DECLARE @ReturnValue INT
	DECLARE @DataSourceId INT

	IF @LocationPath IS NULL SET @LocationPath = @DataSourceCode
	EXEC @ReturnValue = [_ib_DataSource_GetByCodeForOutput] @DataSourceCode, @OutPut output, @Output2 output
	SET @DataSourceId = @Output

	-- Duplicate file check										
	DECLARE @IsFileAlreadyLoaded INT
	EXEC @IsFileALreadyLoaded = HasFileBeenLoaded @LocationPath, @DataSourceId

	IF @IsFileAlreadyLoaded = 1
	BEGIN
		UPDATE [MGETrade]
		SET LoadState = 3
		WHERE LoadState = 1
			AND FileName = @LocationPath		
		RETURN
	END
	
	-- Set AsOfDate from Filename
	DECLARE @AsOfDate DATETIME
	EXEC [dbo].[TryParseYYYYMMDDFromEndOfFilename] @LocationPath, @AsOfDate OUTPUT
	
	--rd - make sure the As Of Date is not older than acceptable
	DECLARE @IsAcceptable bit
	EXECUTE [dbo].[Load_IsFileTooOld] @DataSourceId,@LocationPath,@AsOfDate,@IsAcceptable OUTPUT, @ReceiveLocationSysId, @RunId
	IF (@IsAcceptable = 0)
	BEGIN
		UPDATE [MGETrade] SET [LoadState] = 3 WHERE [Filename] = @LocationPath
		RAISERROR (''File is too old.'', 18, 0)
		RETURN 0
	END

	-- Store ImportFile record
	DECLARE @ImportFileId INT
	EXEC ib_ImportFile_Add @DataSourceId, @LocationPath, @ImportFileId output
	
	--Gets the defaultStrikePriceDivisor
	DECLARE	@DefaultStrikePriceDivisor	DECIMAL(19,6)
	SET @DefaultStrikePriceDivisor = [dbo].[udf_GetDefaultStrikePriceDivisor](@DataSourceId, NULL)
	
	
	IF OBJECT_ID(''tempdb..#tempMGET'') IS NOT NULL 
	DROP TABLE #tempMGET
		
	CREATE TABLE #tempMGET
	(
		MGETradeID		INT
		, FirmCode					VARCHAR(5)
		, Account					VARCHAR(10)
		, TrxDateChr				DATE
		, Exchange					VARCHAR(5)
		, InstrumentCode			VARCHAR(5)
		, QuantityChr				INT
		, BuySell					VARCHAR(1)
		, ContractYearMonth			VARCHAR(6)
		, StrikePriceChr			DECIMAL(16,8)
		, StrikeSign				VARCHAR(1)
		, OptionTypeCode			VARCHAR(1)
		, TradePrice				DECIMAL(24,10)
		, PriceSign					VARCHAR(1)
		, APSIndicator				VARCHAR(1)
		, APSGroupId				VARCHAR(5)
	)

	INSERT INTO #tempMGET
	(
		MGETradeID
		, FirmCode
		, Account
		, TrxDateChr	
		, Exchange
		, InstrumentCode
		, QuantityChr
		, BuySell
		, ContractYearMonth
		, StrikePriceChr
		, StrikeSign
		, OptionTypeCode
		, TradePrice
		, PriceSign
		, APSIndicator
		, APSGroupId
	)
	SELECT 	
		[MGETradeID]
		, [ClearingFirm]
		, [AccountNumber]
		, [TradeDate]
		, [ExchangeId]
		, [CommodityCode]
		, [Quantity]
		, [BuySell]
		, [ContractYearMonth]
		, [StrikePrice]
		, [StrikeSign]
		, [PutCall]
		, [TradePrice]
		, [PriceSign]
		, [APSIndicator]
		, [APSGroupId]
	FROM [stage].[MGETrade]
	WHERE LoadState = 1
		AND [Filename] = @LocationPath
		AND [BlockA8] IS NULL
	SET XACT_ABORT ON 

		BEGIN TRAN T1

		-- BizTalk''s SQL Adapter uses more restrictive read serializable
		-- so this is necessary to relax it to something that is default
		-- and perfectly acceptable!
		SET TRANSACTION ISOLATION LEVEL READ COMMITTED

		BEGIN TRY

			DECLARE @MGETradeID	INT
			DECLARE @FirmCode					VARCHAR(5)
			DECLARE @Account					VARCHAR(10)
			DECLARE @TrxDateChr					DATE
			DECLARE @Exchange					VARCHAR(5)
			DECLARE @InstrumentCode				VARCHAR(5)
			DECLARE @QuantityChr				INT
			DECLARE @BuySell					VARCHAR(1)
			DECLARE @ContractYearMonth			VARCHAR(6)
			DECLARE @StrikePriceChr				DECIMAL(16,8)
			DECLARE @StrikeSign					VARCHAR(1)
			DECLARE @OptionTypeCode				VARCHAR(1)
			DECLARE @TradePrice					DECIMAL(24,10)
			DECLARE @PriceSign					VARCHAR(1)
			DECLARE @APSIndicator				VARCHAR(1)
			DECLARE @APSGroupId					VARCHAR(5)

			DECLARE trx_cursor CURSOR FOR
			SELECT MGETradeID
					, FirmCode
					, Account
					, TrxDateChr	
					, Exchange
					, InstrumentCode
					, QuantityChr
					, BuySell
					, ContractYearMonth
					, StrikePriceChr
					, StrikeSign
					, OptionTypeCode
					, TradePrice
					, PriceSign
					, APSIndicator
					, APSGroupId
			FROM #tempMGET

			OPEN trx_cursor

			FETCH NEXT FROM trx_cursor
			INTO 
					@MGETradeID
					, @FirmCode
					, @Account
					, @TrxDateChr	
					, @Exchange
					, @InstrumentCode
					, @QuantityChr
					, @BuySell
					, @ContractYearMonth
					, @StrikePriceChr
					, @StrikeSign
					, @OptionTypeCode
					, @TradePrice
					, @PriceSign
					, @APSIndicator
					, @APSGroupId

				-- Check @@FETCH_STATUS to see IF there are any more rows to fetch.
				WHILE @@FETCH_STATUS = 0
				BEGIN
					DECLARE		@AccountCd				VARCHAR(100)
					DECLARE		@ExchangeCd				VARCHAR(25)
					DECLARE		@InstrumentCd			VARCHAR(100)
					DECLARE		@Quantity				DECIMAL(19,4)
					DECLARE		@MarketValueDec			DECIMAL(19,4)
					DECLARE		@ExpYr					SMALLINT
					DECLARE		@ExpMth					SMALLINT
					DECLARE		@ExpDay					SMALLINT
					DECLARE		@ContractDay			SMALLINT
					DECLARE		@StrikePrice			DECIMAL(19,4)
					DECLARE		@PriceDivisor			DECIMAL(19,4)
					DECLARE		@StrikePriceDivisor		DECIMAL(19,4)
					DECLARE		@MarketValueDivisor		DECIMAL(19,4)
					DECLARE		@Price					DECIMAL(24,10)
					DECLARE		@TrxDate				DATETIME
					DECLARE		@InstrumentTypeCd		VARCHAR(100)
					DECLARE     @ErrorMessageForRecord	VARCHAR(1024)
					DECLARE		@ErrorSeverity			INT
					DECLARE		@ErrorState				INT
					DECLARE		@QuantityLong			DECIMAL(19,4)
					DECLARE		@QuantityShort			DECIMAL(19,4)
					DECLARE		@SignedQuantity			DECIMAL(19,4)
					DECLARE		@ExtendedPrice			DECIMAL(28,12)
					
					-- Temporary variables
                    DECLARE     @TempDate DATETIME
					DECLARE 	@Code VARCHAR(100), @Code2 VARCHAR(100)
					
			SET @AccountCd = @Account
			SET	@ExchangeCd = @Exchange

			
			-- Set ExpiryDate
			SET @ExpYr = LEFT(@ContractYearMonth, 4)
			SET @ExpMth = RIGHT(@ContractYearMonth, 2)
			
			SET @ContractDay = ''0''
			
			IF NULLIF(@ContractDay,'''') IS NULL OR @ContractDay = ''0''
				BEGIN
					-- Get the last day of the month
					SET @ExpDay = dbo.udf_OnLoad_ExpiryDate_Get_Day(@ExpYr,@ExpMth,@ContractDay)
				END
			ELSE
				SET @ExpDay = CAST(@ContractDay AS SMALLINT)
				
			-- Set InstrumentTypeCd
			IF @OptionTypeCode IN (''P'', ''C'')
				SET @InstrumentTypeCd = ''O''
			ELSE -- It will be blank
				SET @InstrumentTypeCd = ''F''
	

			-- We prefix the Instruments with the IntrumentTypeCode
			SET @InstrumentCd = @InstrumentTypeCd + ''_'' + @ExchangeCd + ''_'' + @InstrumentCode

			-- Get Divisors						
			SET @StrikePriceDivisor = NULL
			SET	@PriceDivisor = NULL
			SET	@MarketValueDivisor = NULL
								
			SELECT @StrikePriceDivisor = ids.StrikePriceDivisor
					, @PriceDivisor = ids.PriceDivisor
					, @MarketValueDivisor = ids.MarketValueDivisor
			FROM [dbo].[ib_InstrumentDataSource] ids
			WHERE ids.DataSourceId = @DataSourceId
				AND ids.DataSourceInstrumentCode = @InstrumentCd

			-- IF APSIndicator is Blank or I take the extended price value 

			IF @APSIndicator = ''I'' OR @APSIndicator IS NULL OR @APSIndicator =''''
			BEGIN
				SET @ExtendedPrice = NULL

				SELECT @ExtendedPrice = ExtendedPrice
				FROM [stage].[MGETrade]
				WHERE GroupCode = @APSGroupId

				--Set TradePrice
				IF @ExtendedPrice IS NOT NULL
					SET @TradePrice = CONVERT(DECIMAL(24,10), @ExtendedPrice)
			END

			-- Set TradePrice based on Price sign 
			IF @PriceSign = ''-''
				SET @TradePrice = @TradePrice * (-1)

			-- Set Price				
			IF @PriceDivisor IS NULL 
				SET @PriceDivisor = 1				

			SET @Price = @TradePrice / @PriceDivisor
				
			-- Set StrikePrice
			SET @StrikePrice = NULL
			
			IF @StrikePriceDivisor IS NULL
				BEGIN
					SET @StrikePrice = CAST(@StrikePriceChr AS DECIMAL(19,4)) / ISNULL(@DefaultStrikePriceDivisor, 1)
				END
			ELSE
				BEGIN
					SET @StrikePrice = CAST(@StrikePriceChr AS DECIMAL(19,4)) / @StrikePriceDivisor
				END	
				
			-- Set StrikeSign
			IF @StrikeSign = ''-''
				SET @StrikePrice = @StrikePrice * (-1)		
				
			-- Set Quantity 
			SET @Quantity = 0
			SET @QuantityLong = 0
			SET @QuantityShort = 0
			
			-- Set Quantity (throw an error if not convertible)
			
			SET @Quantity = CONVERT(DECIMAL(19,4), @QuantityChr)
			
			SET @SignedQuantity = @Quantity
						
			-- Set QuantityLong
			IF (@BuySell = ''B'')
				BEGIN
					SET @QuantityLong = @Quantity
				END
			ELSE
					SET @QuantityLong = 0
								
			-- Set QuantityShort
			IF (@BuySell = ''S'')
				BEGIN
					SET @QuantityShort = @Quantity
					SET @SignedQuantity = @Quantity * (-1)
				END	
			ELSE
				SET @QuantityShort = 0
						
			-- Set Market Value
			IF @MarketValueDivisor IS NULL 
				SET @MarketValueDivisor = 1
			
			SET @MarketValueDec = (@Quantity * @TradePrice) / @MarketValueDivisor
			
			-- TrxDate
			
			SET @TrxDate = CONVERT(DATETIME, @TrxDateChr, 112)
					
			EXEC [ib_Trx_Load]
				@DataSourceCode			
				, @ExchangeCd				
				, @FirmCode -- Firm will be added if not present					
				, @AccountCd	
				, NULL -- DetailAccountCd		
				, @InstrumentCd			
				, @ExpYr					
				, @ExpMth 					
				, @ExpDay 					
				, @StrikePrice			
				, ''T'' -- TrxTypeCode 		
				, @OptionTypeCode
				, @SignedQuantity			
				, @TrxDate				
				, @Price 
				, @MGETradeID
				, @InstrumentTypeCd
				, @AsOfDate		
				, @LocationPath
				, @MarketValueDec
				, @Currency
				, @QuantityLong = @QuantityLong 
				, @QuantityShort = @QuantityShort
				, @ReceiveLocationSysId = @ReceiveLocationSysId
				, @RunId = @RunId
			
			--flip processed flag in source table.
			UPDATE [MGETrade]
			WITH (ROWLOCK)
			SET [LoadState] = 2
			WHERE [MGETradeId] = @MGETradeID
				AND [LoadState] = 1

			SET @AddCount = @AddCount + 1
			
			FETCH NEXT FROM trx_cursor
			INTO 
					@MGETradeID
					, @FirmCode
					, @Account
					, @TrxDateChr	
					, @Exchange
					, @InstrumentCode
					, @QuantityChr
					, @BuySell
					, @ContractYearMonth
					, @StrikePriceChr
					, @StrikeSign
					, @OptionTypeCode
					, @TradePrice
					, @PriceSign
					, @APSIndicator
					, @APSGroupId
		END
			
		CLOSE trx_cursor
		DEALLOCATE trx_cursor

			-- Now update state of any left-over temporary transaction records
			-- so there are no ''left-overs''
			UPDATE [MGETrade]
			WITH (ROWLOCK)
			SET [LoadState] = 2
			WHERE [LoadState] = 1 AND [FileName] = @LocationPath

			SET @Message = @DataSourceCode + '' transaction loader ended ('' 
			+ CONVERT(VARCHAR(10), @AddCount) + '' added)'' 
		
			EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @Message, ''Success'', '''', @RunId

			UPDATE ib_ImportFile
			SET AsOfDate = @AsOfDate
			WHERE ImportFileId = @ImportFileId
			
		COMMIT TRAN T1

		DROP TABLE #tempMGET
	
	END TRY
	BEGIN CATCH 

		IF XACT_STATE() = -1 
			ROLLBACK TRANSACTION
	
		SET @Message = @DataSourceCode + '' transaction loader failed'' 		
		EXEC Log_Insert @ReceiveLocationSysId, @LocationPath, ''Orchestrated'', @Message, ''Error'', '''', @RunId
	
		EXEC [dbo].[sp_RethrowError]
		
	END CATCH 

	SET XACT_ABORT OFF
END

RETURN 0
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Broker_GetBrokerUserCodesHintByKeyword]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Broker_GetBrokerUserCodesHintByKeyword]
    @BrokerUserCode VARCHAR(100)
   ,@HintByStartOnly BIT = 0
   ,@HintLength INT = 1
AS 
SET NOCOUNT ON

DECLARE @len INT
SET @len = LEN(@BrokerUserCode)
IF @HintByStartOnly = 1 
    BEGIN
        SELECT DISTINCT
            SUBSTRING([Code], @len, @HintLength) x
        FROM
            [dbo].[ib_Broker]
        WHERE
            [Code] LIKE @BrokerUserCode + ''%''
        ORDER BY
            x

    END
ELSE 
    BEGIN
        SELECT DISTINCT
            SUBSTRING([UserCode],
                      PATINDEX(''%'' + @BrokerUserCode + ''%'', [Code]) + @len,
                      @HintLength) x
        FROM
            [dbo].[ib_Broker]
        WHERE
            [Code] LIKE ''%'' + @BrokerUserCode + ''%''
        ORDER BY
            x
    END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Broker_Add]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Broker_Add]
(
 @Code VARCHAR(100)
,@Name VARCHAR(100)
,@UserCode VARCHAR(100)
,@IsActive BIT = 1
,@DataSourceId INT
,@CreateUsername VARCHAR(50)
,@@BrokerId INT OUTPUT
)
AS 
SET NOCOUNT ON

BEGIN TRY

    IF @CreateUserName IS NULL 
        BEGIN
            SET @CreateUserName = ( SUSER_SNAME() )
        END

    IF EXISTS ( SELECT
                    BrokerId
                FROM
                    ib_Broker
                WHERE
                    DataSourceId = @DataSourceId ) 
        BEGIN
            DECLARE @DataSourceCode VARCHAR(100)
            SELECT
                @DataSourceCode = Code
            FROM
                ib_DataSource
            WHERE
                DataSourceId = @DataSourceId
            RAISERROR
	(N''There is already another Broker using the same Data Source ("%s"). Please specify other data source!'', 11, 1, @DataSourceCode)
        END
    ELSE 
        BEGIN
            INSERT  INTO [dbo].[ib_Broker]
                    ( [Code]
                    ,[Name]
                    ,[UserCode]
                    ,[IsActive]
                    ,[DataSourceId]
                    ,[CreateUsername]
                    )
            VALUES
                    ( @Code
                    ,@Name
                    ,@UserCode
                    ,@IsActive
                    ,@DataSourceId
                    ,@CreateUsername
                    )
            SELECT
                @@BrokerId = SCOPE_IDENTITY()
        END
END TRY
BEGIN CATCH
    EXEC [dbo].[sp_RethrowError]
END CATCH
');

GO
EXECUTE ('PRINT N''Creating [dbo].[aspnet_UsersInRoles_FindUsersInRole]''
');

GO
SET QUOTED_IDENTIFIER OFF

GO
EXECUTE ('
CREATE PROCEDURE [dbo].[aspnet_UsersInRoles_FindUsersInRole]
    @ApplicationName  nvarchar(256),
    @RoleName         nvarchar(256),
    @UserNameToMatch  nvarchar(256)
AS
SET NOCOUNT ON
BEGIN
    DECLARE @ApplicationId uniqueidentifier
    SELECT  @ApplicationId = NULL
    SELECT  @ApplicationId = ApplicationId FROM aspnet_Applications WHERE LOWER(@ApplicationName) = LoweredApplicationName
    IF (@ApplicationId IS NULL)
        RETURN(1)
     DECLARE @RoleId uniqueidentifier
     SELECT  @RoleId = NULL

     SELECT  @RoleId = RoleId
     FROM    dbo.aspnet_Roles
     WHERE   LOWER(@RoleName) = LoweredRoleName AND ApplicationId = @ApplicationId

     IF (@RoleId IS NULL)
         RETURN(1)

    SELECT u.UserName
    FROM   dbo.aspnet_Users u, dbo.aspnet_UsersInRoles ur
    WHERE  u.UserId = ur.UserId AND @RoleId = ur.RoleId AND u.ApplicationId = @ApplicationId AND LoweredUserName LIKE LOWER(@UserNameToMatch)
    ORDER BY u.UserName
    RETURN(0)
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ConvertFromBase10]''
');

GO
SET QUOTED_IDENTIFIER ON

GO
EXECUTE ('CREATE FUNCTION [dbo].[ConvertFromBase10]
(
	@FractionValue DECIMAL(24, 10)
	, @Base INT
)
RETURNS DECIMAL(24, 10)
AS
BEGIN
	--	26 May 2010		AAJM		Creation

	DECLARE @BaseXValue DECIMAL(24, 10)

	IF @Base IS NULL OR @Base = 10
		SET @BaseXValue = @FractionValue
	ELSE
		SET @BaseXValue = FLOOR(@FractionValue) + ((@FractionValue - FLOOR(@FractionValue)) * @Base / 100)
			
	-- Return the result of the function
	RETURN @BaseXValue

END
');

GO
EXECUTE ('PRINT N''Creating [admin].[ReindexAndShrink]''
');

GO
EXECUTE ('CREATE PROCEDURE [admin].[ReindexAndShrink]
AS
-- =============================================
-- Author:		daviesr
-- Create date: 24 Nov 2013
-- Description:	put job sql into sp''s for easier management. 
-- 24 Nov 2013   RD   Create
-- =============================================
BEGIN
	SET NOCOUNT ON;

	DECLARE @sql NVARCHAR(MAX)
	-- Rebuild indexes
	RAISERROR(''Rebuilding database indexes...'', 10, 1) WITH NOWAIT;
	SET @sql = '''';

	SELECT @sql = @sql + ''ALTER INDEX ALL ON ['' + SCHEMA_NAME(schema_id) + ''].['' + [name] + ''] REBUILD; '' + CHAR(13)
	FROM sys.tables
	ORDER BY SCHEMA_NAME(schema_id) ASC, [name] ASC;

	EXEC sp_executesql @sql;
	CHECKPOINT;
	RAISERROR(''Rebuilt database indexes.'', 10, 1) WITH NOWAIT;

END
');

GO
EXECUTE ('PRINT N''Creating [admin].[SSISDB_PurgeData]''
');

GO
EXECUTE ('CREATE PROCEDURE [admin].[SSISDB_PurgeData]
	
AS
BEGIN

	-- =============================================
	-- Author:		daviesr
	-- Create date: 07 Nov 2013
	-- Description:	Purges data on SSISDB. Will be run from a job.
	-- Modification History
	-- 04 Jul 2014   ED   EIB 25753 - keep last week data
	-- =============================================

	SET NOCOUNT ON;
	declare @end datetime

	set @end = DATEADD(d, -7, GETDATE())

	DELETE e 
	FROM SSISDB.internal.execution_parameter_values e
	INNER JOIN SSISDB.internal.executions ex on ex.execution_id=e.execution_id
	INNER JOIN SSISDB.internal.operations op on op.operation_id=ex.execution_id
	WHERE
	op.end_time < @end

	DELETE ex 
	FROM SSISDB.internal.executions ex 
	INNER JOIN SSISDB.internal.operations op on op.operation_id=ex.execution_id
	WHERE
	op.end_time < @end

	DELETE op
	FROM SSISDB.internal.operations op 
	WHERE
	op.end_time < @end

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[BancoSantander_HOSTOPN_LoadStateChange]''
');

GO
EXECUTE ('-- =============================================
-- Author:		A McLeod
-- Create date: 09 Oct 2012
-- Description:	Changes the LoadState of the BancoSantander_HOSTOPN type table (Copied from RolfeNolan)
-- Revision History:
-- =============================================
CREATE PROCEDURE [dbo].[BancoSantander_HOSTOPN_LoadStateChange] 
	-- Add the parameters for the stored procedure here
	(
		@OldLoadState	TINYINT,
		@NewLoadState	TINYINT,
		@RecordDate		DATETIME = NULL
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[C21_LoadStateChange]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[C21_LoadStateChange] 
	-- Add the parameters for the stored procedure here
	(
	@OldLoadState TINYINT
	, @NewLoadState	TINYINT
	, @RecordDate DATETIME = NULL
	)
AS
BEGIN
	-- 12 Jul 2006	lm		Creation
	-- 10 Aug 2010	amk		MBAL-16415: since it doesn''t take filename into account it can collide 
	--						with other files causing deadlock so just update state from 0 to 1 
	--						at start of load stored proc instead

	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[Config_GetPaged]''
');

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Gets records from the Config table passing page index and page count parameters
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[Config_GetPaged]
(

	@WhereClause varchar (2000)  ,

	@OrderBy varchar (2000)  ,

	@PageIndex int   ,

	@PageSize int   
)
AS


				
				BEGIN
				DECLARE @PageLowerBound int
				DECLARE @PageUpperBound int
				
				-- Set the page bounds
				SET @PageLowerBound = @PageSize * @PageIndex
				SET @PageUpperBound = @PageLowerBound + @PageSize

				IF (@OrderBy IS NULL OR LEN(@OrderBy) < 1)
				BEGIN
					-- default order by to first column
					SET @OrderBy = ''[ConfigId]''
				END

				-- SQL Server 2005 Paging
				DECLARE @SQL AS nvarchar(MAX)
				SET @SQL = ''WITH PageIndex AS (''
				SET @SQL = @SQL + '' SELECT''
				IF @PageSize > 0
				BEGIN
					SET @SQL = @SQL + '' TOP '' + CONVERT(nvarchar, @PageUpperBound)
				END
				SET @SQL = @SQL + '' ROW_NUMBER() OVER (ORDER BY '' + @OrderBy + '') as RowIndex''
				SET @SQL = @SQL + '', [ConfigId]''
				SET @SQL = @SQL + '', [Key]''
				SET @SQL = @SQL + '', [Value]''
				SET @SQL = @SQL + '', [CreateDate]''
				SET @SQL = @SQL + '', [CreateUsername]''
				SET @SQL = @SQL + '', [UpdateDate]''
				SET @SQL = @SQL + '', [UpdateUsername]''
				SET @SQL = @SQL + '' FROM [dbo].[Config]''
				IF LEN(@WhereClause) > 0
				BEGIN
					SET @SQL = @SQL + '' WHERE '' + @WhereClause
				END
				SET @SQL = @SQL + '' ) SELECT''
				SET @SQL = @SQL + '' [ConfigId],''
				SET @SQL = @SQL + '' [Key],''
				SET @SQL = @SQL + '' [Value],''
				SET @SQL = @SQL + '' [CreateDate],''
				SET @SQL = @SQL + '' [CreateUsername],''
				SET @SQL = @SQL + '' [UpdateDate],''
				SET @SQL = @SQL + '' [UpdateUsername]''
				SET @SQL = @SQL + '' FROM PageIndex''
				SET @SQL = @SQL + '' WHERE RowIndex > '' + CONVERT(nvarchar, @PageLowerBound)
				IF @PageSize > 0
				BEGIN
					SET @SQL = @SQL + '' AND RowIndex <= '' + CONVERT(nvarchar, @PageUpperBound)
				END
				SET @SQL = @SQL + '' ORDER BY '' + @OrderBy
				EXEC sp_executesql @SQL
				
				-- get row count
				SET @SQL = ''SELECT COUNT(*) AS TotalRowCount''
				SET @SQL = @SQL + '' FROM [dbo].[Config]''
				IF LEN(@WhereClause) > 0
				BEGIN
					SET @SQL = @SQL + '' WHERE '' + @WhereClause
				END
				EXEC sp_executesql @SQL
			
				END
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[LCH_TypePS_0101_LoadStateChange]''
');

GO
EXECUTE ('-- =============================================
-- Author:		Lee Manifold
-- Create date: 12 Jul 2006
-- Description:	Changes the LoadState of the LCH_TypePS_0101 type tables
-- Revision History:
-- ----------------
-- 31 Mar 2010	amk		MBAL-15029: since it doesn''t take filename into account it can collide with other files causing deadlock
--						so just update state from 0 to 1 at start of load stored proc instead
-- =============================================
CREATE PROCEDURE [dbo].[LCH_TypePS_0101_LoadStateChange] 
	-- Add the parameters for the stored procedure here
	(
	@OldLoadState	TINYINT,
	@NewLoadState	TINYINT,
	@RecordDate		DATETIME = NULL
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[LCH_TypePS_0201_Add]''
');

GO
EXECUTE ('
-- =============================================
-- Author:		Lee Manifold
-- Create date: 22 Jun 2006
-- Description:	Insert into the LCH_TypePS_0201 table
-- =============================================
CREATE PROCEDURE [dbo].[LCH_TypePS_0201_Add] 
	(
	@Exchange						varchar(3),
	@DownloadNumber					varchar(4),
	@TradingDay						varchar(6),
	@TenderDeletionDay				varchar(6),
	@OriginatingClearerName			varchar(3),
	@OriginatingMemberName			varchar(3),
	@OriginatingTraderName			varchar(3),
	@AccountCode					varchar(1),
	@MarginingAccount				varchar(1),
	@SubAccount						varchar(3),
	@PhysicalCommodity				varchar(3),
	@LogicalCommodity				varchar(3),
	@ContractType					varchar(1),
	@GenericContractType			varchar(1),
	@ExpiryDate						varchar(5),
	@ExercisePrice					varchar(9),
	@ValuationPrice					varchar(9),
	@AccountVolume					varchar(7),
	@AdjustedVolume					varchar(7),
	@NonMarginableVolume			varchar(7),
	@AdjustedNonMarginableVolume	varchar(7),
	@PayCollect						varchar(15),
	@ContractsTraded				varchar(7),
	@LotsTraded						varchar(7),
	@ContingentMargin				varchar(15),
	@RevaluationType				varchar(1),
	@PremiumPayCollect				varchar(15),
	@ContigentPrice					varchar(9),
	@ExpiredVolume					varchar(7),
	@AccountFlag					varchar(1)
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

  INSERT INTO	[dbo].[LCH_TypePS_0201]
           (
			[Exchange]
           ,[DownloadNumber]
           ,[TradingDay]
           ,[TenderDeletionDay]
           ,[OriginatingClearerName]
           ,[OriginatingMemberName]
           ,[OriginatingTraderName]
           ,[AccountCode]
           ,[MarginingAccount]
		   ,[SubAccount]	
           ,[PhysicalCommodity]
           ,[LogicalCommodity]
           ,[ContractType]
           ,[GenericContractType]
           ,[ExpiryDate]
           ,[ExercisePrice]
           ,[ValuationPrice]
           ,[AccountVolume]
           ,[AdjustedVolume]
           ,[NonMarginableVolume]
           ,[AdjustedNonMarginableVolume]
           ,[PayCollect]
           ,[ContractsTraded]
           ,[LotsTraded]
           ,[ContingentMargin]
		   ,[RevaluationType]
           ,[PremiumPayCollect]
           ,[ContigentPrice]
		   ,[ExpiredVolume]	
           ,[AccountFlag]
           )
     VALUES
           (
			@Exchange						,
			@DownloadNumber					,
			@TradingDay						,
			@TenderDeletionDay				,
			@OriginatingClearerName			,
			@OriginatingMemberName			,
			@OriginatingTraderName			,
			@AccountCode					,
			@MarginingAccount				,
			@SubAccount						,
			@PhysicalCommodity				,
			@LogicalCommodity				,
			@ContractType					,
			@GenericContractType			,
			@ExpiryDate						,
			@ExercisePrice					,
			@ValuationPrice					,
			@AccountVolume					,
			@AdjustedVolume					,
			@NonMarginableVolume			,
			@AdjustedNonMarginableVolume	,
			@PayCollect						,
			@ContractsTraded				,
			@LotsTraded						,
			@ContingentMargin				,
			@RevaluationType				,
			@PremiumPayCollect				,
			@ContigentPrice					,
			@ExpiredVolume					,
			@AccountFlag	
			)
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[LCH_TypePS_0201_Delete]''
');

GO
EXECUTE ('

-- =============================================
-- Author:		Lee Manifold
-- Create date: 21 Jun 2006
-- Description:	Deletes from the LCH_PS_0101 table
-- =============================================
CREATE PROCEDURE [dbo].[LCH_TypePS_0201_Delete]
	(
	@Exchange		Varchar(3)
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	DELETE 
	FROM	[dbo].[LCH_TypePS_0201] 
	WHERE	[Exchange] = @Exchange
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[LCH_TypeTR_LoadStateChange]''
');

GO
EXECUTE ('-- =============================================
-- Author:		Lee Manifold
-- Create date: 12 Jul 2006
-- Description:	Changes the LoadState of the LCH_TypePS_0101 type tables
-- Revision History:
-- ----------------
-- 31 Mar 2010	amk		MBAL-15029: since it doesn''t take filename into account it can collide with other files causing deadlock
--						so just update state from 0 to 1 at start of load stored proc instead
-- =============================================
CREATE PROCEDURE [dbo].[LCH_TypeTR_LoadStateChange] 
	-- Add the parameters for the stored procedure here
	(
	@OldLoadState	TINYINT,
	@NewLoadState	TINYINT,
	@RecordDate		DATETIME = NULL
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[Liffe_Position_LoadStateChange]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[Liffe_Position_LoadStateChange]
	(
	@OldLoadState	TINYINT,
	@NewLoadState	TINYINT,
	@RecordDate		DATETIME = NULL
	)
AS

-- =============================================
-- Author:		Alister McLeod
-- Create date: 14 Dec 2012
-- Description:	Changes the LoadState of the Liffe_Position type tables
-- Revision History:
-- ----------------
-- =============================================

BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	-- Don''t do anything at the moment.
	
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[Liffe_TradeReport_LoadStateChange]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[Liffe_TradeReport_LoadStateChange]
	(
	@OldLoadState	TINYINT,
	@NewLoadState	TINYINT,
	@RecordDate		DATETIME = NULL
	)
AS

-- =============================================
-- Author:		Alister McLeod
-- Create date: 14 Dec 2012
-- Description:	Changes the LoadState of the Liffe_TradeReport type tables
-- Revision History:
-- ----------------
-- =============================================

BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	-- Don''t do anything at the moment.
	
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[Package_GetPaged]''
');

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Gets records from the Package table passing page index and page count parameters
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[Package_GetPaged]
(

	@WhereClause varchar (2000)  ,

	@OrderBy varchar (2000)  ,

	@PageIndex int   ,

	@PageSize int   
)
AS


				
				BEGIN
				DECLARE @PageLowerBound int
				DECLARE @PageUpperBound int
				
				-- Set the page bounds
				SET @PageLowerBound = @PageSize * @PageIndex
				SET @PageUpperBound = @PageLowerBound + @PageSize

				IF (@OrderBy IS NULL OR LEN(@OrderBy) < 1)
				BEGIN
					-- default order by to first column
					SET @OrderBy = ''[PackageSysId]''
				END

				-- SQL Server 2005 Paging
				DECLARE @SQL AS nvarchar(MAX)
				SET @SQL = ''WITH PageIndex AS (''
				SET @SQL = @SQL + '' SELECT''
				IF @PageSize > 0
				BEGIN
					SET @SQL = @SQL + '' TOP '' + CONVERT(nvarchar, @PageUpperBound)
				END
				SET @SQL = @SQL + '' ROW_NUMBER() OVER (ORDER BY '' + @OrderBy + '') as RowIndex''
				SET @SQL = @SQL + '', [PackageSysId]''
				SET @SQL = @SQL + '', [PackageCode]''
				SET @SQL = @SQL + '', [PackageName]''
				SET @SQL = @SQL + '', [SSISPackagePath]''
				SET @SQL = @SQL + '', [ProjectName]''
				SET @SQL = @SQL + '', [JobName]''
				SET @SQL = @SQL + '', [IsActive]''
				SET @SQL = @SQL + '', [CreateDateTimeUtc]''
				SET @SQL = @SQL + '', [CreateUsername]''
				SET @SQL = @SQL + '', [UpdateDateTimeUtc]''
				SET @SQL = @SQL + '', [UpdateUsername]''
				SET @SQL = @SQL + '', [DeleteDateTimeUtc]''
				SET @SQL = @SQL + '', [DeleteUsername]''
				SET @SQL = @SQL + '', [IsMisc]''
				SET @SQL = @SQL + '' FROM [dbo].[Package]''
				IF LEN(@WhereClause) > 0
				BEGIN
					SET @SQL = @SQL + '' WHERE '' + @WhereClause
				END
				SET @SQL = @SQL + '' ) SELECT''
				SET @SQL = @SQL + '' [PackageSysId],''
				SET @SQL = @SQL + '' [PackageCode],''
				SET @SQL = @SQL + '' [PackageName],''
				SET @SQL = @SQL + '' [SSISPackagePath],''
				SET @SQL = @SQL + '' [ProjectName],''
				SET @SQL = @SQL + '' [JobName],''
				SET @SQL = @SQL + '' [IsActive],''
				SET @SQL = @SQL + '' [CreateDateTimeUtc],''
				SET @SQL = @SQL + '' [CreateUsername],''
				SET @SQL = @SQL + '' [UpdateDateTimeUtc],''
				SET @SQL = @SQL + '' [UpdateUsername],''
				SET @SQL = @SQL + '' [DeleteDateTimeUtc],''
				SET @SQL = @SQL + '' [DeleteUsername],''
				SET @SQL = @SQL + '' [IsMisc]''
				SET @SQL = @SQL + '' FROM PageIndex''
				SET @SQL = @SQL + '' WHERE RowIndex > '' + CONVERT(nvarchar, @PageLowerBound)
				IF @PageSize > 0
				BEGIN
					SET @SQL = @SQL + '' AND RowIndex <= '' + CONVERT(nvarchar, @PageUpperBound)
				END
				SET @SQL = @SQL + '' ORDER BY '' + @OrderBy
				EXEC sp_executesql @SQL
				
				-- get row count
				SET @SQL = ''SELECT COUNT(*) AS TotalRowCount''
				SET @SQL = @SQL + '' FROM [dbo].[Package]''
				IF LEN(@WhereClause) > 0
				BEGIN
					SET @SQL = @SQL + '' WHERE '' + @WhereClause
				END
				EXEC sp_executesql @SQL
			
				END
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[Peoplesoft_Purge]''
');

GO
EXECUTE ('-- =============================================
-- Author:		Petru Konrad Bercea
-- Create date: 04.02.2009
-- Description:	Deletes from all Peoplesoft type files where the LoadState is 0
-- 16 Sep 2009	amk		No need to delete
-- =============================================
CREATE PROCEDURE [dbo].[Peoplesoft_Purge] 
	(
		@LoadState		TINYINT = 0,
		@FileName       VARCHAR (512)= NULL
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
	--don''t do delete for now
	--DELETE FROM [dbo].[Peoplesoft] WHERE LoadState= @LoadState

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ReceiveLocation_GetPaged]''
');

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Gets records from the ReceiveLocation table passing page index and page count parameters
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[ReceiveLocation_GetPaged]
(

	@WhereClause varchar (2000)  ,

	@OrderBy varchar (2000)  ,

	@PageIndex int   ,

	@PageSize int   
)
AS


				
				BEGIN
				DECLARE @PageLowerBound int
				DECLARE @PageUpperBound int
				
				-- Set the page bounds
				SET @PageLowerBound = @PageSize * @PageIndex
				SET @PageUpperBound = @PageLowerBound + @PageSize

				IF (@OrderBy IS NULL OR LEN(@OrderBy) < 1)
				BEGIN
					-- default order by to first column
					SET @OrderBy = ''[ReceiveLocationSysId]''
				END

				-- SQL Server 2005 Paging
				DECLARE @SQL AS nvarchar(MAX)
				SET @SQL = ''WITH PageIndex AS (''
				SET @SQL = @SQL + '' SELECT''
				IF @PageSize > 0
				BEGIN
					SET @SQL = @SQL + '' TOP '' + CONVERT(nvarchar, @PageUpperBound)
				END
				SET @SQL = @SQL + '' ROW_NUMBER() OVER (ORDER BY '' + @OrderBy + '') as RowIndex''
				SET @SQL = @SQL + '', [ReceiveLocationSysId]''
				SET @SQL = @SQL + '', [ReceiveLocationName]''
				SET @SQL = @SQL + '', [PackageSysId]''
				SET @SQL = @SQL + '', [FileMask]''
				SET @SQL = @SQL + '', [InputFolder]''
				SET @SQL = @SQL + '', [OutputFolder]''
				SET @SQL = @SQL + '', [ErrorFolder]''
				SET @SQL = @SQL + '', [DataSourceId]''
				SET @SQL = @SQL + '', [Priority]''
				SET @SQL = @SQL + '', [IsActive]''
				SET @SQL = @SQL + '', [IsRunning]''
				SET @SQL = @SQL + '', [CreateDateTimeUtc]''
				SET @SQL = @SQL + '', [CreateUsername]''
				SET @SQL = @SQL + '', [UpdateDateTimeUtc]''
				SET @SQL = @SQL + '', [UpdateUsername]''
				SET @SQL = @SQL + '', [DeleteDateTimeUtc]''
				SET @SQL = @SQL + '', [DeleteUsername]''
				SET @SQL = @SQL + '' FROM [dbo].[ReceiveLocation]''
				IF LEN(@WhereClause) > 0
				BEGIN
					SET @SQL = @SQL + '' WHERE '' + @WhereClause
				END
				SET @SQL = @SQL + '' ) SELECT''
				SET @SQL = @SQL + '' [ReceiveLocationSysId],''
				SET @SQL = @SQL + '' [ReceiveLocationName],''
				SET @SQL = @SQL + '' [PackageSysId],''
				SET @SQL = @SQL + '' [FileMask],''
				SET @SQL = @SQL + '' [InputFolder],''
				SET @SQL = @SQL + '' [OutputFolder],''
				SET @SQL = @SQL + '' [ErrorFolder],''
				SET @SQL = @SQL + '' [DataSourceId],''
				SET @SQL = @SQL + '' [Priority],''
				SET @SQL = @SQL + '' [IsActive],''
				SET @SQL = @SQL + '' [IsRunning],''
				SET @SQL = @SQL + '' [CreateDateTimeUtc],''
				SET @SQL = @SQL + '' [CreateUsername],''
				SET @SQL = @SQL + '' [UpdateDateTimeUtc],''
				SET @SQL = @SQL + '' [UpdateUsername],''
				SET @SQL = @SQL + '' [DeleteDateTimeUtc],''
				SET @SQL = @SQL + '' [DeleteUsername]''
				SET @SQL = @SQL + '' FROM PageIndex''
				SET @SQL = @SQL + '' WHERE RowIndex > '' + CONVERT(nvarchar, @PageLowerBound)
				IF @PageSize > 0
				BEGIN
					SET @SQL = @SQL + '' AND RowIndex <= '' + CONVERT(nvarchar, @PageUpperBound)
				END
				SET @SQL = @SQL + '' ORDER BY '' + @OrderBy
				EXEC sp_executesql @SQL
				
				-- get row count
				SET @SQL = ''SELECT COUNT(*) AS TotalRowCount''
				SET @SQL = @SQL + '' FROM [dbo].[ReceiveLocation]''
				IF LEN(@WhereClause) > 0
				BEGIN
					SET @SQL = @SQL + '' WHERE '' + @WhereClause
				END
				EXEC sp_executesql @SQL
			
				END
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[RolfeNolan_HOSTOPN_LoadStateChange]''
');

GO
EXECUTE ('-- =============================================
-- Author:		Petru Konrad Bercea
-- Create date: 10.02.2009
-- Description:	Changes the LoadState of the RolfeNolan_HOSTOPN type table
-- Revision History:
-- ----------------
-- 31 Mar 2010	amk		MBAL-15029: since it doesn''t take filename into account it can collide with other files causing deadlock
--						so just update state from 0 to 1 at start of load stored proc instead
-- =============================================
CREATE PROCEDURE [dbo].[RolfeNolan_HOSTOPN_LoadStateChange] 
	-- Add the parameters for the stored procedure here
	(
		@OldLoadState	TINYINT,
		@NewLoadState	TINYINT,
		@RecordDate		DATETIME = NULL
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[SWIFT_MT940_LoadStateChange]''
');

GO
EXECUTE ('-- =============================================
-- Author:		Petru Konrad Bercea
-- Create date: 16.01.2009
-- Description:	Changes the LoadState of the SWIFT_MT940 type tables
-- 05.06.2012		ED			MBAL 20952 move change load state to load file and adding (nolock) to avoid deadlocks
-- =============================================
CREATE PROCEDURE [dbo].[SWIFT_MT940_LoadStateChange] 
	-- Add the parameters for the stored procedure here
	(
		@OldLoadState	TINYINT,
		@NewLoadState	TINYINT,
		@RecordDate		DATETIME = NULL
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[SWIFT_MT940_Purge]''
');

GO
EXECUTE ('
-- =============================================
-- Author:		Petru Konrad Bercea
-- Create date: 21.01.2009
-- Description:	Deletes from all SWIFT MT940 type files where the LoadState is 0
-- =============================================
CREATE PROCEDURE [dbo].[SWIFT_MT940_Purge] 
	(
		@LoadState		TINYINT = 0,
		@FileName       VARCHAR (512)= NULL
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
		--DELETE FROM [dbo].[SWIFT_MT940] WHERE LoadState= @LoadState

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[SWIFT_MT950_LoadStateChange]''
');

GO
EXECUTE ('-- =============================================
-- Author:		Petru Konrad Bercea
-- Create date: 16.01.2009
-- Description:	Changes the LoadState of the SWIFT_MT950 type tables
-- 05.06.2012		ED			MBAL 20952 move change load state to load file and adding (nolock) to avoid deadlocks
-- =============================================
CREATE PROCEDURE [dbo].[SWIFT_MT950_LoadStateChange] 
	-- Add the parameters for the stored procedure here
	(
		@OldLoadState	TINYINT,
		@NewLoadState	TINYINT,
		@RecordDate		DATETIME = NULL
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[SWIFT_MT950_Purge]''
');

GO
EXECUTE ('
-- =============================================
-- Author:		Petru Konrad Bercea
-- Create date: 16.01.2009
-- Description:	Deletes from all SWIFT_MT950 type files where the LoadState is 0
-- =============================================
CREATE PROCEDURE [dbo].[SWIFT_MT950_Purge] 
	(
		@LoadState		TINYINT = 0,
		@FileName       VARCHAR (512)= NULL
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
		--DELETE FROM [dbo].[SWIFT_MT950] WHERE LoadState= @LoadState

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[_ReceiveLocation_GetReceiveLocationsSortableAndPaginate]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[_ReceiveLocation_GetReceiveLocationsSortableAndPaginate]
    @ReceiveLocationName VARCHAR(100) = NULL
   ,@PackageName VARCHAR(100) = NULL
   ,@DataSourceName VARCHAR(100) = NULL
   ,@FilterByStartOnly BIT = 1
   ,@@OrderBy VARCHAR(100) = NULL
   ,@@StartRowIndex INT = NULL
   ,@@MaximumRows INT = NULL
AS 
-- Revision History:
-- 20 May 2014  ED  EIB 25641 - created

SET NOCOUNT ON

IF ( ISNULL(@@OrderBy, '''') = '''' ) 
    SET @@OrderBy = ''DataSourceName, FileMask'' 

	--fix the top
IF ISNULL(@@MaximumRows, 0) <= 0 
    SET @@MaximumRows = 0
	
IF ISNULL(@@StartRowIndex, -1) <= -1 OR
    @@MaximumRows = 0 
    SET @@StartRowIndex = 0

DECLARE @SQL NVARCHAR(MAX)
DECLARE @WHERE NVARCHAR(MAX)

DECLARE @PrefixFilter NVARCHAR(10)
IF @FilterByStartOnly = 1 
	SET @PrefixFilter = ''''
ELSE
	SET @PrefixFilter = ''%''

SET @WHERE = ''WHERE 1=1''

IF ISNULL(@ReceiveLocationName, '''') != '''' 
	SET @WHERE = @WHERE + '' AND ReceiveLocationName LIKE '''''' + @PrefixFilter + @ReceiveLocationName + ''%''''''

IF ISNULL(@PackageName, '''') != '''' 
	SET @WHERE = @WHERE + '' AND p.PackageName LIKE '''''' + @PrefixFilter + @PackageName + ''%''''''

IF ISNULL(@DataSourceName, '''') != '''' 
	SET @WHERE = @WHERE + '' AND ds.Name LIKE '''''' + @PrefixFilter + @DataSourceName + ''%''''''
	
IF @@MaximumRows > 0 
    SET @sql = ''SELECT ReceiveLocationSysId, ReceiveLocationName, PackageName, FileMask, InputFolder, OutputFolder
		   , ErrorFolder, DataSourceName, IsActive
	 FROM
	   (SELECT TOP('' + CONVERT(NVARCHAR(10), @@StartRowIndex + @@MaximumRows) +
        '')''
ELSE 
    SET @sql = ''SELECT''

--build the query
SET @sql = @sql +
    '' ReceiveLocationSysId, ReceiveLocationName, p.PackageName, FileMask, InputFolder, OutputFolder
		   , ErrorFolder, ds.Name AS DataSourceName, rl.IsActive ''

IF @@MaximumRows > 0 
    SET @sql = @sql + '', ROW_NUMBER() OVER(ORDER BY '' + @@OrderBy +
        '') as RowNum''
ELSE 
    SET @Sql = @sql + ''''
SET @sql = @sql + ''
 FROM ReceiveLocation rl (nolock)
	INNER JOIN Package p ON rl.PackageSysId = p.PackageSysId
	  INNER JOIN ib_DataSource ds ON rl.DataSourceId = ds.DataSourceId 
 '' + @where 

IF @@MaximumRows = 0 
    SET @sql = @sql + ''
 ORDER BY '' + @@OrderBy 

IF @@MaximumRows > 0 
    SET @sql = @sql + '') as x
WHERE RowNum > '' + CONVERT(NVARCHAR(10), @@StartRowIndex) + '' ORDER BY RowNum''

-- Execute the query
EXEC sp_executesql @sql

SELECT ''Required For NetTiers otherwise when build it returns void rather than a dataset''
');

GO
EXECUTE ('PRINT N''Creating [dbo].[_ReceiveLocation_GetReceiveLocationsSortableAndPaginate_Count]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[_ReceiveLocation_GetReceiveLocationsSortableAndPaginate_Count]
    @ReceiveLocationName VARCHAR(100) = NULL
   ,@PackageName VARCHAR(100) = NULL
   ,@DataSourceName VARCHAR(100) = NULL
   ,@FilterByStartOnly BIT = 1
AS
-- Revision History:
-- 20 May 2014  ED  EIB 25641 - created

SET NOCOUNT ON

DECLARE @SQL NVARCHAR(MAX)
DECLARE @WHERE NVARCHAR(MAX)

DECLARE @PrefixFilter NVARCHAR(10)
IF @FilterByStartOnly = 1 
	SET @PrefixFilter = ''''
ELSE
	SET @PrefixFilter = ''%''

SET @WHERE = ''WHERE 1=1''

IF ISNULL(@ReceiveLocationName, '''') != '''' 
	SET @WHERE = @WHERE + '' AND ReceiveLocationName LIKE '''''' + @PrefixFilter + @ReceiveLocationName + ''%''''''

IF ISNULL(@PackageName, '''') != '''' 
	SET @WHERE = @WHERE + '' AND p.PackageName LIKE '''''' + @PrefixFilter + @PackageName + ''%''''''

IF ISNULL(@DataSourceName, '''') != '''' 
	SET @WHERE = @WHERE + '' AND ds.Name LIKE '''''' + @PrefixFilter + @DataSourceName + ''%''''''

SET @sql = ''SELECT COUNT(ReceiveLocationSysId) 
	FROM ReceiveLocation rl (nolock)
	INNER JOIN Package p ON rl.PackageSysId = p.PackageSysId
	  INNER JOIN ib_DataSource ds ON rl.DataSourceId = ds.DataSourceId 
'' + @WHERE

EXEC sp_executesql @sql

SELECT ''Required For NetTiers otherwise when build it returns void rather than a dataset''
');

GO
EXECUTE ('PRINT N''Creating [dbo].[aspnet_Setup_RemoveAllRoleMembers]''
');

GO
SET QUOTED_IDENTIFIER OFF

GO
EXECUTE ('
CREATE PROCEDURE [dbo].[aspnet_Setup_RemoveAllRoleMembers]
    @name   sysname
AS
SET NOCOUNT ON
BEGIN
    CREATE TABLE #aspnet_RoleMembers
    (
        Group_name      sysname,
        Group_id        smallint,
        Users_in_group  sysname,
        User_id         smallint
    )

    INSERT INTO #aspnet_RoleMembers
    EXEC sp_helpuser @name

    DECLARE @user_id smallint
    DECLARE @cmd nvarchar(500)
    DECLARE c1 cursor FORWARD_ONLY FOR
        SELECT User_id FROM #aspnet_RoleMembers

    OPEN c1

    FETCH c1 INTO @user_id
    WHILE (@@fetch_status = 0)
    BEGIN
        SET @cmd = ''EXEC sp_droprolemember '' + '''''''' + @name + '''''', '''''' + USER_NAME(@user_id) + ''''''''
        EXEC (@cmd)
        FETCH c1 INTO @user_id
    END

    CLOSE c1
    DEALLOCATE c1
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[aspnet_Setup_RestorePermissions]''
');

GO
EXECUTE ('
CREATE PROCEDURE [dbo].[aspnet_Setup_RestorePermissions]
    @name   sysname
AS
SET NOCOUNT ON
BEGIN
    DECLARE @object sysname
    DECLARE @protectType char(10)
    DECLARE @action varchar(20)
    DECLARE @grantee sysname
    DECLARE @cmd nvarchar(500)
    DECLARE c1 cursor FORWARD_ONLY FOR
        SELECT Object, ProtectType, [Action], Grantee FROM #aspnet_Permissions where Object = @name

    OPEN c1

    FETCH c1 INTO @object, @protectType, @action, @grantee
    WHILE (@@fetch_status = 0)
    BEGIN
        SET @cmd = @protectType + '' '' + @action + '' on '' + @object + '' TO ['' + @grantee + '']''
        EXEC (@cmd)
        FETCH c1 INTO @object, @protectType, @action, @grantee
    END

    CLOSE c1
    DEALLOCATE c1
END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Account_GetAccountsSortableAndPaginate]''
');

GO
SET QUOTED_IDENTIFIER ON

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Account_GetAccountsSortableAndPaginate]
	@AccountName varchar(100) = NULL,
	@AccountCode varchar(100) = NULL,
	@AccountTypeCodeId varchar(100) = NULL,
	@AccountClassId varchar(100) = NULL,
	@FamilyCode varchar(100) = NULL,
	@FilterByStartOnly bit=1,
	@@OrderBy varchar(100) = NULL,
	@@StartRowIndex int = NULL,
	@@MaximumRows int = NULL

AS
SET NOCOUNT ON


/*
<details>
	<summary>Returns the Accounts sortable and paginate. </summary>
	<created author="emilian.damian" date="7 Feb 2007 10:33:45 GMT"/>
</details>
*/
-- Revision History
--
-- 11.06.2009 Konrad Added ClassId and ClassCode to the output fields and also fixed the Where condition
-- 12.06.2009 Konrad Fixed the sorting
-- 28.04.2010 AAJM	 MBAL-15315 Return IsImported
-- 09.12.2011 GC     MBAL-19528 Add Class filter to the Administration > Accounts page
-- 01.05.2012 ED     MBAL-20400 add FamilyCode and IsOmnibus
-- 22.05.2012 ED	 MBAL 20398 - add filter for family code
-- 13.05.2014 ED	 EIB 24627 - return StatementNumberSeed

--fix orderby
IF (ISNULL(@@OrderBy, '''')='''')
	SET @@OrderBy = ''i.Code ASC'' 

	--fix the top
IF IsNull(@@MaximumRows, 0) <= 0
	SET @@MaximumRows = 0
IF IsNull(@@StartRowIndex, -1) <= -1 OR @@MaximumRows = 0 
	SET @@StartRowIndex = 0

DECLARE @SQL nvarchar(1000)
DECLARE @WHERE nvarchar(1000)

SET @WHERE = ''WHERE 1=1''
SET @SQL = ''''

IF @AccountName IS NOT NULL
BEGIN
	IF @FilterByStartOnly = 1
		SET @WHERE = @WHERE + '' AND [i].[Name] LIKE '''''' + @AccountName + ''%''''''
	ELSE SET @WHERE = @WHERE + '' AND [i].[Name] LIKE ''''%'' + @AccountName + ''%''''''
END

IF @AccountCode IS NOT NULL
BEGIN
	IF @FilterByStartOnly = 1
		SET @WHERE = @WHERE + '' AND [i].[Code] LIKE '''''' + @AccountCode + ''%''''''
	ELSE SET @WHERE = @WHERE + '' AND [i].[Code] LIKE ''''%'' + @AccountCode + ''%''''''
END

IF ISNULL(@AccountTypeCodeId, 0) > 0 
	SET @WHERE = @WHERE + '' AND [it].[FirmId] = '' + Cast(@AccountTypeCodeId as varchar(100)) 
	
IF ISNULL(@AccountClassId, 0) > 0 
	SET @WHERE = @WHERE + '' AND [i].[ClassId] = '' + Cast(@AccountClassId as varchar(100)) 

IF ISNULL(@FamilyCode, '''') != ''''
BEGIN
	IF @FilterByStartOnly = 1
		SET @WHERE = @WHERE + '' AND [i].[FamilyCode] LIKE '''''' + @FamilyCode + ''%''''''
	ELSE SET @WHERE = @WHERE + '' AND [i].[FamilyCode] LIKE ''''%'' + @FamilyCode + ''%''''''
END

IF @@MaximumRows >0
	SET @sql = ''SELECT [AccountId], [FirmId], [FirmCode], [Code], [Name], [IsApproved], [ClassCode], [IsImported], [FamilyCode], [IsOmnibus], StatementNumberSeed, MinStatementNumber
	 FROM
	   (SELECT TOP('' + CONVERT(nvarchar(10), @@StartRowIndex + @@MaximumRows) + '')''
ELSE SET @sql = ''SELECT''

--build the query
SET @sql = @sql + '' i.[AccountId], i.[FirmId], it.[Code] as FirmCode, i.[Code], i.[Name], i.[IsApproved], 
i.ClassId, cl.[Code] as ClassCode, i.[IsImported], i.FamilyCode, i.IsOmnibus, sss.StatementNumberSeed,
ISNULL((SELECT MAX(StatementNumber) FROM ib_SwiftStatement WHERE AccountId = i.AccountId), 0) AS MinStatementNumber ''

IF @@MaximumRows >0
	SET @sql = @sql+'', ROW_NUMBER() OVER(ORDER BY '' + @@OrderBy + '') as RowNum''
ELSE SET @Sql = @sql + '' ''
SET @sql = @sql + ''
 FROM [ib_Account] i (nolock)   
	INNER JOIN [ib_Firm] it ON it.FirmId = i.FirmId
	LEFT JOIN [ib_Class] cl ON cl.ClassId = i.ClassId 
	LEFT JOIN ib_SwiftStatementSeed sss ON sss.AccountId = i.AccountId
      '' + @where 

IF @@MaximumRows = 0
	SET @sql = @sql+''
 ORDER BY '' + @@OrderBy 

IF @@MaximumRows >0
	SET @sql = @sql +  '') as x
WHERE RowNum > '' + CONVERT(nvarchar(10), @@StartRowIndex) + '' ORDER BY RowNum''

-- Execute the query
EXEC sp_executesql @sql
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Account_GetAccountsSortableAndPaginate_Count]''
');

GO
EXECUTE ('/*
<details>
	<summary>Returns Accounts count</summary>
	<created author="Emilian Damian" Date="7 Feb 2007" /> 
</details>
*/
-- Revision History
--
-- 09.12.2011 GC     MBAL-19528 Add Class filter to the Administration > Accounts page
-- 22.05.2012 ED	 MBAL 20398 - add filter for family code

CREATE PROCEDURE [dbo].[ib_Account_GetAccountsSortableAndPaginate_Count]
	@AccountName varchar(100) = NULL,
	@AccountCode varchar(100) = NULL,
	@AccountTypeCodeId int = NULL,
	@AccountClassId int = NULL,
	@FamilyCode varchar(100) = NULL,
	@FilterByStartOnly bit=1
AS
SET NOCOUNT ON
	
DECLARE @SQL nvarchar(1000)
DECLARE @WHERE nvarchar(1000)

SET @WHERE = ''''

IF ISNULL(@AccountName, '''') != ''''
BEGIN
	IF @FilterByStartOnly = 1
		SET @WHERE = @WHERE + '' AND [i].[Name] LIKE '''''' + @AccountName + ''%''''''
	ELSE SET @WHERE = @WHERE + '' AND [i].[Name] LIKE ''''%'' + @AccountName + ''%''''''
END

IF ISNULL(@AccountCode, '''') != ''''
BEGIN
	IF @FilterByStartOnly = 1
		SET @WHERE = @WHERE + '' AND [i].[Code] LIKE '''''' + @AccountCode + ''%''''''
	ELSE SET @WHERE = @WHERE + '' AND [i].[Code] LIKE ''''%'' + @AccountCode + ''%''''''
END

IF ISNULL(@AccountTypeCodeId, 0) > 0 
	SET @WHERE = @WHERE + '' AND [it].[FirmId] = '' + Cast(@AccountTypeCodeId as varchar(100)) 

IF ISNULL(@AccountClassId, 0) > 0 
	SET @WHERE = @WHERE + '' AND [i].[ClassId] = '' + Cast(@AccountClassId as varchar(100)) 

IF ISNULL(@FamilyCode, '''') != ''''
BEGIN
	IF @FilterByStartOnly = 1
		SET @WHERE = @WHERE + '' AND [i].[FamilyCode] LIKE '''''' + @FamilyCode + ''%''''''
	ELSE SET @WHERE = @WHERE + '' AND [i].[FamilyCode] LIKE ''''%'' + @FamilyCode + ''%''''''
END

	SET @sql = ''SELECT COUNT(AccountId) 
	FROM [ib_Account] i (nolock)  
INNER JOIN [ib_Firm] it ON it.FirmId = i.FirmId 
'' + @WHERE

EXEC sp_executesql @sql
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Account_GetItemIndex_For_AccountId_When_SortableAndPaginate]''
');

GO
EXECUTE ('
   /*
<details>
	<summary>Returns the item index for a given Regen Account Id when sortable and paginate. A filter may be set</summary>
	<created author="Emilian Damian" Date="7 Feb 2007" /> 
</details>
-- 06 May 2014	ED	EIB 25594 - fix sql when no firm selected
*/
CREATE PROCEDURE [dbo].[ib_Account_GetItemIndex_For_AccountId_When_SortableAndPaginate]
	@AccountName varchar(100) = NULL,
	@AccountCode varchar(100) = NULL,
	@AccountTypeCodeId int,
	@FilterByStartOnly bit=1,
	@GetItemIndexForAccountId int,
	@@OrderBy varchar(100) = NULL

AS
SET NOCOUNT ON
--fix @GetItemIndexForAccountId

--fix orderby
IF (ISNULL(@@OrderBy, '''')='''')
	SET @@OrderBy = ''i.Code ASC'' 

BEGIN

DECLARE @SQL nvarchar(1000)
DECLARE @WHERE nvarchar(1000)

SET @WHERE = ''''

IF ISNULL(@AccountName, '''') != ''''
BEGIN
	IF @FilterByStartOnly = 1
		SET @WHERE =  '' [i].[Name] LIKE '''''' + @AccountName + ''%''''''
	ELSE SET @WHERE = '' [i].[Name] LIKE ''''%'' + @AccountName + ''%''''''
END
IF ISNULL(@AccountCode, '''') != ''''
BEGIN
	IF ISNULL(@WHERE, '''') != ''''
	BEGIN
		SET @WHERE = @WHERE + '' AND '' ;
	END
	IF @FilterByStartOnly = 1
		SET @WHERE = @WHERE  + '' [i].[Code] LIKE '''''' + @AccountCode + ''%''''''
	ELSE SET @WHERE = @WHERE + '' [i].[Code] LIKE ''''%'' + @AccountCode + ''%''''''
END

IF ISNULL(@AccountTypeCodeId, 0) > 0 
BEGIN
	IF ISNULL(@WHERE, '''') != ''''
		SET @WHERE = @WHERE + '' AND '' ;
	
	SET @WHERE = @WHERE + '' [i].[FirmId] = '' + Cast(@AccountTypeCodeId as varchar(100)) 
END

SET @sql = ''
DECLARE @Value int
SET @Value = -1
SELECT @Value = RowNum -1 
	 FROM
	   (SELECT''

--build the query
SET @sql = @sql + '' [AccountId] ''

SET @sql = @sql+'', ROW_NUMBER() OVER(ORDER BY '' + @@OrderBy + '') as RowNum''
IF ISNULL(@WHERE, '''') != ''''
	BEGIN
		SET @WHERE = '' WHERE '' + @WHERE
	END
SET @sql = @sql + ''
  
 FROM [ib_Account] i  
LEFT JOIN [ib_Firm] f ON f.FirmId=i.FirmId 
	'' + @where 
	SET @sql = @sql +  '') x
WHERE [AccountId] = '' + CONVERT(nvarchar(10), @GetItemIndexForAccountId)
+ ''; SELECT @Value''

-- Execute the query
EXEC sp_executesql @sql

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Adjustment_ExportToCSV]''
');

GO
EXECUTE ('/*
<details>
	<summary></summary>
	<created author="Laurentiu Macovei" Date="Thursday, 14 September 2006, 1:37AM GMT" />
	<updated author="Alister McLeod" Date="09 February 2010"> 
	Added IsBuy
	</updated>		
</details>
*/
CREATE PROCEDURE [dbo].[ib_Adjustment_ExportToCSV]
	@TemplateId int = NULL,
	@StartDate DateTime = NULL,
	@EndDate DateTime = NULL,
	@@OrderBy varchar(100) = NULL

AS
SET NOCOUNT ON
--fix orderby
IF (ISNULL(@@OrderBy, '''')='''')
	SET @@OrderBy = ''a.CreateDate DESC'' 
	
	
DECLARE @SQL nvarchar(2000)
DECLARE @WHERE nvarchar(1000)

SET @WHERE = ''''

IF ISNULL(@TemplateId,0)>0
	SET @WHERE = @WHERE + '' AND a.TemplateID = '' + Cast(@TemplateId as nvarchar)

--fix the dates
IF @StartDate IS NOT NULL AND @EndDate IS NOT NULL AND @StartDate > @EndDate
BEGIN
	DECLARE @Date DATETIME
	SET @Date = @StartDate
	SET @StartDate = @EndDate
	SET @EndDAte = @Date
END

	
IF @StartDate IS NOT NULL
	SET @WHERE = @WHERE + '' AND a.CreateDate >= '''''' + Convert(nvarchar, @StartDate, 109)+''''''''

IF @EndDate IS NOT NULL
	SET @WHERE = @WHERE + '' AND a.CreateDate <= '''''' + Convert(nvarchar, @EndDate, 109)+''''''''

SET @sql = ''
SELECT ''

--build the query
SET @sql = @sql + 
''e.[Code] as [ExchangeCode],
e.[Name] as [ExchangeDescription],
tg.[Description] as [MatchCode],
i.[Code] as [InstrumentCode],
i.[Name] as [InstrumentDescription],
a.[InternalExternalCode] as [InternalExternalCode],
a.[TradeDate] as [TradeDate],
CASE a.[IsBuy]
	WHEN 1 THEN ''''Buy''''
	ELSE ''''Sell''''
END as [BuySell], 
a.[AdjustmentDate] as [AdjustmentDate],
a.[Quantity] as [Quantity], 
c.[Code] as [CurrencyCode],
a.[ExpiryYear] as [ExpiryYear], 
a.[ExpiryMonth] as [ExpiryMonth], 
a.[ExpiryDay] as [ExpiryDay], 
a.[StrikePrice] as [StrikePrice], 
a.[TradePrice] as [TradePrice], 
a.[SettlementPrice] as [SettlementPrice], 
a.[OptionTypeCode] as [OptionTypeCode], 
a.[Description] as [Description], 
a.[Value] as [Value],
a.[CreateDate] as [DateEntered] 
''

SET @sql = @sql + ''
 FROM [ib_Adjustment] a  INNER JOIN ib_Instrument i ON i.InstrumentId = a.InstrumentId 
	INNER JOIN ib_TemplateGroup tg ON tg.TemplateGroupId = a.TemplateGroupId 
	INNER JOIN ib_Exchange e ON e.ExchangeId = a.ExchangeId
	INNER JOIN ib_Currency c ON c.CurrencyId = a.CurrencyId
	'' 
+ @where 

SET @sql = @sql+''
 ORDER BY '' + @@OrderBy 

-- Execute the query
EXEC sp_executesql @sql
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Adjustment_GetAdjustmentsWithAccountsMissingOrUnapproved]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Adjustment_GetAdjustmentsWithAccountsMissingOrUnapproved]
	@param1 int = 0, 
	@param2 int
AS
SET NOCOUNT ON
	SELECT @param1, @param2
RETURN 0
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Adjustment_GetPaged]''
');

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Gets records from the ib_Adjustment table passing page index and page count parameters
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[ib_Adjustment_GetPaged]
(

	@WhereClause varchar (2000)  ,

	@OrderBy varchar (2000)  ,

	@PageIndex int   ,

	@PageSize int   
)
AS


				
				BEGIN
				DECLARE @PageLowerBound int
				DECLARE @PageUpperBound int
				
				-- Set the page bounds
				SET @PageLowerBound = @PageSize * @PageIndex
				SET @PageUpperBound = @PageLowerBound + @PageSize

				IF (@OrderBy IS NULL OR LEN(@OrderBy) < 1)
				BEGIN
					-- default order by to first column
					SET @OrderBy = ''[AdjustmentId]''
				END

				-- SQL Server 2005 Paging
				DECLARE @SQL AS nvarchar(MAX)
				SET @SQL = ''WITH PageIndex AS (''
				SET @SQL = @SQL + '' SELECT''
				IF @PageSize > 0
				BEGIN
					SET @SQL = @SQL + '' TOP '' + CONVERT(nvarchar, @PageUpperBound)
				END
				SET @SQL = @SQL + '' ROW_NUMBER() OVER (ORDER BY '' + @OrderBy + '') as RowIndex''
				SET @SQL = @SQL + '', [AdjustmentId]''
				SET @SQL = @SQL + '', [TemplateId]''
				SET @SQL = @SQL + '', [ExchangeId]''
				SET @SQL = @SQL + '', [InstrumentId]''
				SET @SQL = @SQL + '', [InternalExternalCode]''
				SET @SQL = @SQL + '', [TradeDate]''
				SET @SQL = @SQL + '', [AdjustmentDate]''
				SET @SQL = @SQL + '', [Quantity]''
				SET @SQL = @SQL + '', [CurrencyId]''
				SET @SQL = @SQL + '', [ExpiryYear]''
				SET @SQL = @SQL + '', [ExpiryMonth]''
				SET @SQL = @SQL + '', [ExpiryDay]''
				SET @SQL = @SQL + '', [StrikePrice]''
				SET @SQL = @SQL + '', [TradePrice]''
				SET @SQL = @SQL + '', [SettlementPrice]''
				SET @SQL = @SQL + '', [OptionTypeCode]''
				SET @SQL = @SQL + '', [Value]''
				SET @SQL = @SQL + '', [PremiumValue]''
				SET @SQL = @SQL + '', [OptionValue]''
				SET @SQL = @SQL + '', [Description]''
				SET @SQL = @SQL + '', [TemplateGroupId]''
				SET @SQL = @SQL + '', [CreateDate]''
				SET @SQL = @SQL + '', [CreateUsername]''
				SET @SQL = @SQL + '', [UpdateDate]''
				SET @SQL = @SQL + '', [UpdateUsername]''
				SET @SQL = @SQL + '', [IsBuy]''
				SET @SQL = @SQL + '', [MatchCodeId]''
				SET @SQL = @SQL + '', [AdjustmentHeaderId]''
				SET @SQL = @SQL + '', [DataSourceId]''
				SET @SQL = @SQL + '', [FirmId]''
				SET @SQL = @SQL + '', [QuantityLong]''
				SET @SQL = @SQL + '', [QuantityShort]''
				SET @SQL = @SQL + '', [DetailAccountId]''
				SET @SQL = @SQL + '', [AccountId]''
				SET @SQL = @SQL + '', [ClassId]''
				SET @SQL = @SQL + '', [AdjustmentStatusId]''
				SET @SQL = @SQL + '', [AdjustmentReasonId]''
				SET @SQL = @SQL + '', [TrxTypeCode]''
				SET @SQL = @SQL + '', [AdjustmentUserStatusId]''
				SET @SQL = @SQL + '', [MatchingAdjustmentId]''
				SET @SQL = @SQL + '', [ReplacesAdjustmentId]''
				SET @SQL = @SQL + '' FROM [dbo].[ib_Adjustment]''
				IF LEN(@WhereClause) > 0
				BEGIN
					SET @SQL = @SQL + '' WHERE '' + @WhereClause
				END
				SET @SQL = @SQL + '' ) SELECT''
				SET @SQL = @SQL + '' [AdjustmentId],''
				SET @SQL = @SQL + '' [TemplateId],''
				SET @SQL = @SQL + '' [ExchangeId],''
				SET @SQL = @SQL + '' [InstrumentId],''
				SET @SQL = @SQL + '' [InternalExternalCode],''
				SET @SQL = @SQL + '' [TradeDate],''
				SET @SQL = @SQL + '' [AdjustmentDate],''
				SET @SQL = @SQL + '' [Quantity],''
				SET @SQL = @SQL + '' [CurrencyId],''
				SET @SQL = @SQL + '' [ExpiryYear],''
				SET @SQL = @SQL + '' [ExpiryMonth],''
				SET @SQL = @SQL + '' [ExpiryDay],''
				SET @SQL = @SQL + '' [StrikePrice],''
				SET @SQL = @SQL + '' [TradePrice],''
				SET @SQL = @SQL + '' [SettlementPrice],''
				SET @SQL = @SQL + '' [OptionTypeCode],''
				SET @SQL = @SQL + '' [Value],''
				SET @SQL = @SQL + '' [PremiumValue],''
				SET @SQL = @SQL + '' [OptionValue],''
				SET @SQL = @SQL + '' [Description],''
				SET @SQL = @SQL + '' [TemplateGroupId],''
				SET @SQL = @SQL + '' [CreateDate],''
				SET @SQL = @SQL + '' [CreateUsername],''
				SET @SQL = @SQL + '' [UpdateDate],''
				SET @SQL = @SQL + '' [UpdateUsername],''
				SET @SQL = @SQL + '' [IsBuy],''
				SET @SQL = @SQL + '' [MatchCodeId],''
				SET @SQL = @SQL + '' [AdjustmentHeaderId],''
				SET @SQL = @SQL + '' [DataSourceId],''
				SET @SQL = @SQL + '' [FirmId],''
				SET @SQL = @SQL + '' [QuantityLong],''
				SET @SQL = @SQL + '' [QuantityShort],''
				SET @SQL = @SQL + '' [DetailAccountId],''
				SET @SQL = @SQL + '' [AccountId],''
				SET @SQL = @SQL + '' [ClassId],''
				SET @SQL = @SQL + '' [AdjustmentStatusId],''
				SET @SQL = @SQL + '' [AdjustmentReasonId],''
				SET @SQL = @SQL + '' [TrxTypeCode],''
				SET @SQL = @SQL + '' [AdjustmentUserStatusId],''
				SET @SQL = @SQL + '' [MatchingAdjustmentId],''
				SET @SQL = @SQL + '' [ReplacesAdjustmentId]''
				SET @SQL = @SQL + '' FROM PageIndex''
				SET @SQL = @SQL + '' WHERE RowIndex > '' + CONVERT(nvarchar, @PageLowerBound)
				IF @PageSize > 0
				BEGIN
					SET @SQL = @SQL + '' AND RowIndex <= '' + CONVERT(nvarchar, @PageUpperBound)
				END
				SET @SQL = @SQL + '' ORDER BY '' + @OrderBy
				EXEC sp_executesql @SQL
				
				-- get row count
				SET @SQL = ''SELECT COUNT(*) AS TotalRowCount''
				SET @SQL = @SQL + '' FROM [dbo].[ib_Adjustment]''
				IF LEN(@WhereClause) > 0
				BEGIN
					SET @SQL = @SQL + '' WHERE '' + @WhereClause
				END
				EXEC sp_executesql @SQL
			
				END
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Adjustment_GetPaginableCount]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Adjustment_GetPaginableCount]
(
	@AsOfDate DATETIME = NULL
	, @DataSourceId INT = NULL
	, @ExchangeId INT = NULL
	, @InstrumentId INT = NULL
	, @AdjustmentTypeId INT = NULL
	, @AdjustmentStatusId INT = NULL
	, @AdjustmentUserStatusId INT = NULL
	, @TemplateId INT = NULL
	, @UserId UNIQUEIDENTIFIER
	, @ExpiryYear SMALLINT = NULL
	, @ExpiryMonth SMALLINT = NULL
	, @MatchCodeId INT = NULL
)
AS
SET NOCOUNT ON
/*
<details>
	<summary> Returns the count of the records from ib_Adjustment table by filtering them. </summary>
	<created author="Laurentiu Macovei" Date="Saturday,30 Aug 2006 02:14AM GMT" />
	<updated author="Laurentiu Macovei" Date="Saturday,31 Aug 2006 02:10AM GMT">
		Moved TemplateId to TemplateGroup
	</updated>
	<updated author="Anil Kripalani" Date="27 Nov 2006">
		Bug Fix! Added alias to TemplateId to avoid Ambiguous TemplateId error
	</updated>
</details>
*/
-- 11 JAN 2012  CG      MBAL 19535 - @AsOfDateFrom,@AsOfDateTo added
-- 24 MAY 2010	ED		redone it
-- 27 May 2010	ED		MBAL 15671 - join on adjustment status not adjustment header status
-- 05 Jan 2011	amk		MBAL-17214: 1) return template description too  2) filter on template
-- 17 Jan 2011	amk		MBAL-17296: Restrict to templates user has rights
-- 15 Apr 2014  ED		EIB 25496 - Add MatchCode filtering
-- 06 Aug 2014  ED		EIB 25844 - add ''No status''
DECLARE @SQL NVARCHAR(4000)
DECLARE @WHERE NVARCHAR(4000)

SET @WHERE = ''''

IF ISNULL(@DataSourceId, 0) > 0
	SET @WHERE = @WHERE + '' AND a.DataSourceId = '' + CAST(@DataSourceId AS NVARCHAR)

IF ISNULL(@ExchangeId, 0) > 0
	SET @WHERE = @WHERE + '' AND a.ExchangeId = '' + CAST(@ExchangeId AS NVARCHAR)
	
IF ISNULL(@InstrumentId, 0) > 0
	SET @WHERE = @WHERE + '' AND a.InstrumentId = '' + CAST(@InstrumentId AS NVARCHAR)
	
IF ISNULL(@AdjustmentTypeId, 0) > 0
	SET @WHERE = @WHERE + '' AND ah.AdjustmentTypeId = '' + CAST(@AdjustmentTypeId AS NVARCHAR)

IF ISNULL(@AdjustmentStatusId, 0) > 0
	SET @WHERE = @WHERE + '' AND a.AdjustmentStatusId = '' + CAST(@AdjustmentStatusId AS NVARCHAR)
IF @AdjustmentStatusId = -1 --means all open
	SET @WHERE = @WHERE + '' AND (a.AdjustmentStatusId IS NULL OR ast.Code=''''U'''') ''

IF ISNULL(@AdjustmentUserStatusId, 0) > 0
	SET @WHERE = @WHERE + '' AND ah.AdjustmentUserStatusId = '' + CAST(@AdjustmentUserStatusId AS NVARCHAR)
IF @AdjustmentUserStatusId = -1 --means no status	
	SET @WHERE = @WHERE + '' AND ah.AdjustmentUserStatusId IS NULL ''	

IF @AsOfDate IS NOT NULL
	SET @WHERE = @WHERE + '' AND a.AdjustmentDate = '''''' + CONVERT(NVARCHAR, @AsOfDate, 109)+''''''''
	
IF @ExpiryYear IS NOT NULL
	SET @WHERE = @WHERE + '' AND a.ExpiryYear = '' + CAST(@ExpiryYear AS NVARCHAR)

IF @ExpiryMonth IS NOT NULL
	SET @WHERE = @WHERE + '' AND a.ExpiryMonth = '' + CAST(@ExpiryMonth AS NVARCHAR)

IF ISNULL(@TemplateId, 0) > 0
	SET @WHERE = @WHERE + '' AND a.TemplateId = '' + CAST(@TemplateId AS NVARCHAR)

IF ISNULL(@MatchCodeId, 0) > 0
	SET @WHERE = @WHERE + '' AND a.MatchCodeId = '' + CAST(@MatchCodeId AS NVARCHAR)

SET @sql = ''SELECT COUNT(AdjustmentId) 
	FROM [dbo].[ib_Adjustment] a
		INNER JOIN ib_AdjustmentHeader ah ON ah.AdjustmentHeaderId = a.AdjustmentHeaderId	
		LEFT JOIN ib_AdjustmentStatus ast ON ast.AdjustmentStatusId = a.AdjustmentStatusId 
	WHERE EXISTS (SELECT * 
					FROM ib_SiteTemplate st 
						JOIN ib_SiteUser su ON su.SiteId = st.SiteId
					WHERE st.TemplateId = a.TemplateId
						AND su.UserId = '''''' + CONVERT(NVARCHAR(100), @UserId) + ''''''''
					+ '') ''
	+ @WHERE

EXEC sp_executesql @sql
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Adjustment_GetPaginable]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Adjustment_GetPaginable]
(
	@AsOfDate DATETIME = NULL
	, @DataSourceId INT = NULL
	, @ExchangeId INT = NULL
	, @InstrumentId INT = NULL
	, @AdjustmentTypeId INT = NULL
	, @AdjustmentStatusId INT = NULL
	, @AdjustmentUserStatusId INT = NULL
	, @@OrderBy VARCHAR(100) = NULL
	, @@StartRowIndex INT = NULL
	, @@MaximumRows INT = NULL
	, @TemplateId INT = NULL
	, @UserId UNIQUEIDENTIFIER
	, @ExpiryYear SMALLINT = NULL
	, @ExpiryMonth SMALLINT = NULL
	, @MatchCodeId INT = NULL
)
AS
SET NOCOUNT ON
/*
<details>
	<summary>Deletes an adjustment</summary>
	<created author="Laurentiu Macovei" Date="Wednesday, 30 august 2006, 1:37AM GMT" />		
	<updated author="Laurentiu Macovei" Date="Saturday,31 Aug 2006 02:11AM GMT">
		Moved TemplateId to TemplateGroup
	</updated>
	<updated author="Alister McLeod" Date="09 Feb 2010">
		Add IsBuy
	</updated>
</details>
*/
-- 11 JAN 2012  CG      MBAL 19535 - @AsOfDateFrom,@AsOfDateTo added
-- 24 MAY 2010	ED		redone it
-- 06 Jul 2010	ED		MBAL-15626: code for swap adjustments
-- 08 Sep 2010	amk		MBAL-1651 : get trade date too
-- 25 Nov 2010	amk		MBAL-17084: new col that converts trade price back to native base
-- 21 Dec 2010	amk		MBAL-17083: swap long/short columns on export (so change order in dataset returned)
-- 05 Jan 2011	amk		MBAL-17214: 1) return template description too  2) filter on template
-- 17 Jan 2011	amk		MBAL-17296: Restrict to templates user has rights
-- 30 Jul 2012  ED		MBAL 21261 - fix the issue with order by
-- 15 Apr 2014  ED		EIB 25495 - Add IsActive to ib_MatchCode table
-- 15 Apr 2014  ED		EIB 25496 - Add MatchCode filtering
-- 25 Apr 2014  ED		EIB 25494 - Add new columns to use on import
-- 23 May 2014  ED		EIB 25492 - get isOpen flag
-- 06 Aug 2014  ED		EIB 25844 - add ''No status''
IF (ISNULL(@@OrderBy, '''')='''')
	SET @@OrderBy = ''a.CreateDate DESC'' 
	
	--fix the top
IF ISNULL(@@MaximumRows, 0) <= 0
	SET @@MaximumRows = 0
IF ISNULL(@@StartRowIndex, -1) <= -1 OR @@MaximumRows = 0 
	SET @@StartRowIndex = 0

DECLARE @SQL NVARCHAR(4000)
DECLARE @WHERE NVARCHAR(4000)

SET @WHERE = '' WHERE 1 = 1 ''

IF ISNULL(@DataSourceId, 0) > 0
	SET @WHERE = @WHERE + '' AND a.DataSourceId = '' + CAST(@DataSourceId AS NVARCHAR)

IF ISNULL(@ExchangeId, 0) > 0
	SET @WHERE = @WHERE + '' AND a.ExchangeId = '' + CAST(@ExchangeId AS NVARCHAR)
	
IF ISNULL(@InstrumentId, 0) > 0
	SET @WHERE = @WHERE + '' AND a.InstrumentId = '' + CAST(@InstrumentId AS NVARCHAR)

IF ISNULL(@MatchCodeId, 0) > 0
	SET @WHERE = @WHERE + '' AND a.MatchCodeId = '' + CAST(@MatchCodeId AS NVARCHAR)
		
IF ISNULL(@AdjustmentTypeId, 0) > 0
	SET @WHERE = @WHERE + '' AND ah.AdjustmentTypeId = '' + CAST(@AdjustmentTypeId AS NVARCHAR)

IF ISNULL(@AdjustmentStatusId, 0) > 0
	SET @WHERE = @WHERE + '' AND a.AdjustmentStatusId = '' + CAST(@AdjustmentStatusId AS NVARCHAR)
IF @AdjustmentStatusId = -1 --means all open
	SET @WHERE = @WHERE + '' AND (a.AdjustmentStatusId IS NULL OR ast.Code=''''U'''') ''

IF ISNULL(@AdjustmentUserStatusId, 0) > 0
	SET @WHERE = @WHERE + '' AND ah.AdjustmentUserStatusId = '' + CAST(@AdjustmentUserStatusId AS NVARCHAR)
IF @AdjustmentUserStatusId = -1 --means no status	
	SET @WHERE = @WHERE + '' AND ah.AdjustmentUserStatusId IS NULL ''

IF @AsOfDate IS NOT NULL
	SET @WHERE = @WHERE + '' AND a.AdjustmentDate = '''''' + CONVERT(NVARCHAR, @AsOfDate, 109)+''''''''
	
IF @ExpiryYear IS NOT NULL
	SET @WHERE = @WHERE + '' AND a.ExpiryYear = '' + CAST(@ExpiryYear AS NVARCHAR)

IF @ExpiryMonth IS NOT NULL
	SET @WHERE = @WHERE + '' AND a.ExpiryMonth = '' + CAST(@ExpiryMonth AS NVARCHAR)
	
	

IF ISNULL(@TemplateId, 0) > 0
	SET @WHERE = @WHERE + '' AND a.TemplateId = '' + CAST(@TemplateId AS NVARCHAR)

IF @@MaximumRows >0
	SET @sql = ''SELECT TradePriceNativeBase, TradeDate, [AdjustmentId], [CreateDate], [CreateUsername], [InternalExternalCode], [AdjustmentDate]
	, DataSourceCode ,FirmCode, Matchcode, Exchange,AccountCode,DetailAccountCode,CurrencyCode,InstrumentCode
	,ExpiryMonth,ExpiryYear,ExpiryDay,OptionTypeCode, StrikePrice, TradePrice, QuantityLong, QuantityShort
	,[Value],AdjustmentTypeCode,AdjustmentReasonCode,Description,AdjustmentUserStatusCode,AdjustmentStatusCode
	,NoOfItemsInGroup, TradeReconciliationSummaryId, Template, TemplateId, SettlementPrice, IsBuy, IsOpen
	 FROM
	   (SELECT TOP('' + CONVERT(NVARCHAR(10), @@StartRowIndex + @@MaximumRows) + '')''
ELSE SET @sql = ''SELECT''

--build the query
SET @sql = @sql + '' dbo.ConvertFromBase10(a.tradeprice, b.base) AS TradePriceNativeBase, a.TradeDate, a.[AdjustmentId], a.[CreateDate], a.[CreateUsername], a.[InternalExternalCode], a.AdjustmentDate
			, ds.Code DataSourceCode,f.Code FirmCode, mc.MatchCode, e.Code Exchange, ac.Code AccountCode, da.Code DetailAccountCode, c.Code CurrencyCode, i.Code InstrumentCode
			, a.ExpiryMonth, a.ExpiryYear, a.ExpiryDay, a.OptionTypeCode, a.StrikePrice, a.TradePrice, a.QuantityLong, a.QuantityShort
			, a.Value,at.Code AdjustmentTypeCode, ar.Code AdjustmentReasonCode, ISNULL(a.Description, '''''''') + '''' '''' + ISNULL(ah.Description,'''''''') Description, aus.Code AdjustmentUserStatusCode
			, ISNULL(ast.Code,ahst.Code) AdjustmentStatusCode, t.Description as Template, t.TemplateId, a.SettlementPrice, a.IsBuy
			, (SELECT COUNT(*) FROM ib_Adjustment h1 WHERE h1.AdjustmentHeaderId=a.AdjustmentHeaderId) AS NoOfItemsInGroup, ah.TradeReconciliationSummaryId
			, CASE WHEN a.AdjustmentStatusId IS NULL OR ast.Code=''''U'''' THEN 1 ELSE 0 END As IsOpen
''			

IF @@MaximumRows >0
	SET @sql = @sql+'', ROW_NUMBER() OVER(ORDER BY '' + @@OrderBy + '') as RowNum''

SET @sql = @sql + ''
 FROM [ib_Adjustment] a  
	LEFT JOIN ib_DataSource ds ON ds.DataSourceId = a.DataSourceId
	LEFT JOIN ib_Firm f ON f.FirmId = a.FirmId
	INNER JOIN ib_MatchCode mc ON mc.matchCodeId = a.MatchCodeId 
	INNER JOIN ib_Exchange e ON e.ExchangeId = a.ExchangeId
	LEFT JOIN ib_Account ac ON ac.AccountId = a.AccountId
	LEFT JOIN ib_Account da ON da.AccountId = a.DetailAccountId
	INNER JOIN ib_Currency	c ON c.CurrencyId = a.CurrencyId
	INNER JOIN ib_Instrument i ON i.InstrumentId = a.InstrumentId 
	INNER JOIN ib_AdjustmentHeader ah ON ah.AdjustmentHeaderId = a.AdjustmentHeaderId
	INNER JOIN ib_AdjustmentType at ON at.AdjustmentTypeId = ah.AdjustmentTypeId
	LEFT JOIN ib_AdjustmentReason ar ON ar.AdjustmentReasonId = ah.AdjustmentReasonId
	LEFT JOIN ib_AdjustmentUserStatus aus ON aus.AdjustmentUserStatusId = ah.AdjustmentUserStatusId
	LEFT JOIN ib_AdjustmentStatus ahst ON ahst.AdjustmentStatusId = ah.AdjustmentStatusId
	LEFT JOIN ib_AdjustmentStatus ast ON ast.AdjustmentStatusId = a.AdjustmentStatusId
	LEFT JOIN ib_instrumentdatasource ids ON ids.instrumentid = a.instrumentid 
		AND ids.datasourceid = a.datasourceid and ids.CurrencyId = a.CurrencyId AND ids.BaseId is not null
	LEFT JOIN ib_base b ON b.baseid = ids.baseid
	INNER JOIN ib_Template t ON t.TemplateId = a.TemplateId
		AND EXISTS (SELECT * 
					FROM ib_SiteTemplate st 
						JOIN ib_SiteUser su ON su.SiteId = st.SiteId
					WHERE st.TemplateId = t.TemplateId
						AND su.UserId = '''''' + CONVERT(NVARCHAR(100), @UserId) + ''''''''
					+ '') ''
+ @where 

IF @@MaximumRows = 0
	SET @sql = @sql+''
 ORDER BY '' + @@OrderBy 

IF @@MaximumRows >0
	SET @sql = @sql +  '') x
WHERE RowNum > '' + CONVERT(NVARCHAR(10), @@StartRowIndex) + '' ORDER BY RowNum''

-- Execute the query
EXEC sp_executesql @sql
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Assembly_GetAssembliesSortableAndPaginate]''
');

GO
EXECUTE ('--exec [dbo].[ib_Assembly_GetAssembliesSortableAndPaginate]
CREATE PROCEDURE [dbo].[ib_Assembly_GetAssembliesSortableAndPaginate]
   @@OrderBy VARCHAR(100) = NULL
   ,@@StartRowIndex INT = NULL
   ,@@MaximumRows INT = NULL
AS 
SET NOCOUNT ON


IF ( ISNULL(@@OrderBy, '''') = '''' ) 
    SET @@OrderBy = ''A.ShortName ASC'' 

	--fix the top
IF ISNULL(@@MaximumRows, 0) <= 0 
    SET @@MaximumRows = 0
IF ISNULL(@@StartRowIndex, -1) <= -1 OR
    @@MaximumRows = 0 
    SET @@StartRowIndex = 0

DECLARE @SQL NVARCHAR(1000)
DECLARE @WHERE NVARCHAR(1000)

SET @WHERE = ''WHERE Bin IS NOT NULL''

IF @@MaximumRows > 0 
    SET @sql = ''SELECT *
	 FROM
	   (SELECT TOP('' + CONVERT(NVARCHAR(10), @@StartRowIndex + @@MaximumRows) +
        '')''
ELSE 
    SET @sql = ''SELECT''


--build the query
SET @sql = @sql + '' A.[FullName], A.[ShortName], A.AssemblyId, CAST(CASE WHEN Bin IS NULL THEN 0 ELSE 1 END AS BIT) IsStored ''

IF @@MaximumRows > 0 
    SET @sql = @sql + '', ROW_NUMBER() OVER(ORDER BY '' + @@OrderBy +
        '') as RowNum''
ELSE 
    SET @Sql = @sql + ''''
SET @sql = @sql + ''
 FROM [ib_Assembly] A (nolock)'' + @where 

IF @@MaximumRows = 0 
    SET @sql = @sql + ''
 ORDER BY '' + @@OrderBy 

IF @@MaximumRows > 0 
    SET @sql = @sql + '') as x
WHERE RowNum > '' + CONVERT(NVARCHAR(10), @@StartRowIndex) + '' ORDER BY RowNum''

-- Execute the query
EXEC sp_executesql @sql
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Assembly_GetAssembliesSortableAndPaginate_Count]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Assembly_GetAssembliesSortableAndPaginate_Count]
AS
SET NOCOUNT ON
DECLARE @SQL nvarchar(1000)
DECLARE @WHERE nvarchar(1000)

SET @WHERE = ''WHERE BIN IS NOT NULL''
	
	SET @sql = ''SELECT COUNT(AssemblyId) 
	FROM [ib_Assembly] AA (nolock) 
'' + @WHERE


EXEC sp_executesql @sql
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Broker_GetBrokersSortableAndPaginate]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Broker_GetBrokersSortableAndPaginate]
    @BrokerName VARCHAR(100) = NULL
   ,@BrokerCode VARCHAR(100) = NULL
   ,@BrokerUserCode VARCHAR(100) = NULL
   ,@FilterByStartOnly BIT = 1
   ,@@OrderBy VARCHAR(100) = NULL
   ,@@StartRowIndex INT = NULL
   ,@@MaximumRows INT = NULL
AS 
SET NOCOUNT ON

IF ( ISNULL(@@OrderBy, '''') = '''' ) 
    SET @@OrderBy = ''b.Code ASC'' 

	--fix the top
IF ISNULL(@@MaximumRows, 0) <= 0 
    SET @@MaximumRows = 0
	
IF ISNULL(@@StartRowIndex, -1) <= -1 OR
    @@MaximumRows = 0 
    SET @@StartRowIndex = 0

DECLARE @SQL NVARCHAR(1000)
DECLARE @WHERE NVARCHAR(1000)

SET @WHERE = ''WHERE 1=1''

IF ISNULL(@BrokerName, '''') != '''' 
    BEGIN
        IF @FilterByStartOnly = 1 
            SET @WHERE = @WHERE + '' AND [b].[Name] LIKE '''''' + @BrokerName +
                ''%''''''
        ELSE 
            SET @WHERE = @WHERE + '' AND [b].[Name] LIKE ''''%'' + @BrokerName +
                ''%''''''
    END

IF ISNULL(@BrokerCode, '''') != '''' 
    BEGIN
        IF @FilterByStartOnly = 1 
            SET @WHERE = @WHERE + '' AND [b].[Code] LIKE '''''' + @BrokerCode +
                ''%''''''
        ELSE 
            SET @WHERE = @WHERE + '' AND [b].[Code] LIKE ''''%'' + @BrokerCode +
                ''%''''''
    END

IF ISNULL(@BrokerUserCode, '''') != '''' 
    BEGIN
        IF @FilterByStartOnly = 1 
            SET @WHERE = @WHERE + '' AND [b].[UserCode] LIKE '''''' +
                @BrokerUserCode + ''%''''''
        ELSE 
            SET @WHERE = @WHERE + '' AND [b].[UserCode] LIKE ''''%'' +
                @BrokerUserCode + ''%''''''
    END

---------
--select * from ib_Broker
--select * from ib_DataSource
---------

IF @@MaximumRows > 0 
    SET @sql = ''SELECT [BrokerId], [Code], [Name], [UserCode], [DataSourceCodeName], [IsActive]
	 FROM
	   (SELECT TOP('' + CONVERT(NVARCHAR(10), @@StartRowIndex + @@MaximumRows) +
        '')''
ELSE 
    SET @sql = ''SELECT''

--build the query
SET @sql = @sql +
    '' b.[BrokerId], b.[Code], b.[Name], b.[UserCode], b.[IsActive]
	, CASE WHEN d.[Code] = d.[Name] THEN d.[Name] ELSE d.[Code]+''''(''''+d.[Name]+'''')'''' END AS DataSourceCodeName ''

IF @@MaximumRows > 0 
    SET @sql = @sql + '', ROW_NUMBER() OVER(ORDER BY '' + @@OrderBy +
        '') as RowNum''
ELSE 
    SET @Sql = @sql + ''''
SET @sql = @sql + ''
 FROM [ib_Broker] b (nolock)
 LEFT OUTER JOIN
	[ib_DataSource] d ON [b].[DataSourceId] = [d].[DataSourceId]
 '' + @where 

IF @@MaximumRows = 0 
    SET @sql = @sql + ''
 ORDER BY '' + @@OrderBy 

IF @@MaximumRows > 0 
    SET @sql = @sql + '') as x
WHERE RowNum > '' + CONVERT(NVARCHAR(10), @@StartRowIndex) + '' ORDER BY RowNum''

-- Execute the query
EXEC sp_executesql @sql
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Broker_GetBrokersSortableAndPaginate_Count]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Broker_GetBrokersSortableAndPaginate_Count]
    @BrokerName VARCHAR(100) = NULL
   ,@BrokerCode VARCHAR(100) = NULL
   ,@BrokerUserCode VARCHAR(100) = NULL
   ,@FilterByStartOnly BIT = 1
AS 
SET NOCOUNT ON

DECLARE @SQL NVARCHAR(1000)
DECLARE @WHERE NVARCHAR(1000)

SET @WHERE = ''WHERE 1=1''
	
IF ISNULL(@BrokerName, '''') != '''' 
    BEGIN
        IF @FilterByStartOnly = 1 
            SET @WHERE = @WHERE + '' AND [b].[Name] LIKE '''''' + @BrokerName +
                ''%''''''
        ELSE 
            SET @WHERE = @WHERE + '' AND [b].[Name] LIKE ''''%'' + @BrokerName +
                ''%''''''
    END

IF ISNULL(@BrokerCode, '''') != '''' 
    BEGIN
        IF @FilterByStartOnly = 1 
            SET @WHERE = @WHERE + '' AND [b].[Code] LIKE '''''' + @BrokerCode +
                ''%''''''
        ELSE 
            SET @WHERE = @WHERE + '' AND [b].[Code] LIKE ''''%'' + @BrokerCode +
                ''%''''''
    END

IF ISNULL(@BrokerUserCode, '''') != '''' 
    BEGIN
        IF @FilterByStartOnly = 1 
            SET @WHERE = @WHERE + '' AND [b].[UserCode] LIKE '''''' +
                @BrokerUserCode + ''%''''''
        ELSE 
            SET @WHERE = @WHERE + '' AND [b].[UserCode] LIKE ''''%'' +
                @BrokerUserCode + ''%''''''
    END

SET @sql = ''SELECT COUNT(BrokerId) 
	FROM [ib_Broker] b (nolock)  
'' + @WHERE

EXEC sp_executesql @sql
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Class_GetClassesSortableAndPaginate]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Class_GetClassesSortableAndPaginate]
    @ClassDescription VARCHAR(100) = NULL
   ,@ClassCode VARCHAR(100) = NULL
   ,@FilterByStartOnly BIT = 1
   ,@@OrderBy VARCHAR(100) = NULL
   ,@@StartRowIndex INT = NULL
   ,@@MaximumRows INT = NULL
AS 
SET NOCOUNT ON


-- Description:	Returns list of Classes sorted and paginated

-- 22 Feb 2011	shillink	Creation
-- 09 Mar 2011	shillink	Code review changes
-- 19 Apr 2011	AAJM		Fix aliases to fix sort

IF ( ISNULL(@@OrderBy, '''') = '''' ) 
    SET @@OrderBy = ''c.Code ASC'' 

	--fix the top
IF ISNULL(@@MaximumRows, 0) <= 0 
    SET @@MaximumRows = 0
IF ISNULL(@@StartRowIndex, -1) <= -1 OR
    @@MaximumRows = 0 
    SET @@StartRowIndex = 0

DECLARE @SQL NVARCHAR(1000)
DECLARE @WHERE NVARCHAR(1000)

SET @WHERE = ''WHERE 1=1''

IF ISNULL(@ClassDescription, '''') != '''' 
    BEGIN
        IF @FilterByStartOnly = 1 
            SET @WHERE = @WHERE + '' AND [c].[Description] LIKE '''''' +
                @ClassDescription + ''%''''''
        ELSE 
            SET @WHERE = @WHERE + '' AND [c].[Description] LIKE ''''%'' +
                @ClassDescription + ''%''''''
    END

IF ISNULL(@ClassCode, '''') != '''' 
    BEGIN
        IF @FilterByStartOnly = 1 
            SET @WHERE = @WHERE + '' AND [c].[Code] LIKE '''''' + @ClassCode +
                ''%''''''
        ELSE 
            SET @WHERE = @WHERE + '' AND [c].[Code] LIKE ''''%'' + @ClassCode +
                ''%''''''
    END

IF @@MaximumRows > 0 
    SET @sql = ''SELECT [ClassId], [Code], [Description] 
	 FROM
	   (SELECT TOP('' + CONVERT(NVARCHAR(10), @@StartRowIndex + @@MaximumRows) +
        '')''
ELSE 
    SET @sql = ''SELECT''

--build the query
SET @sql = @sql + '' c.[ClassId], c.[Code], c.[Description] ''

IF @@MaximumRows > 0 
    SET @sql = @sql + '', ROW_NUMBER() OVER(ORDER BY '' + @@OrderBy +
        '') as RowNum''
ELSE 
    SET @Sql = @sql + ''''
SET @sql = @sql + ''
 FROM [ib_Class] c (nolock)'' + @where 

IF @@MaximumRows = 0 
    SET @sql = @sql + ''
 ORDER BY '' + @@OrderBy 

IF @@MaximumRows > 0 
    SET @sql = @sql + '') as x
WHERE RowNum > '' + CONVERT(NVARCHAR(10), @@StartRowIndex) + '' ORDER BY RowNum''

-- Execute the query
EXEC sp_executesql @sql
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Class_GetClassesSortableAndPaginate_Count]''
');

GO
EXECUTE ('/*
<details>
 <summary> Returns the Classes hint for a specific code /summary>
 <created author="shilin" date="22 Feb 2011"/>  
 <tasks>
 </tasks>
</details>
*/
CREATE PROCEDURE [dbo].[ib_Class_GetClassesSortableAndPaginate_Count]
@ClassDescription VARCHAR (100)=NULL, @ClassCode VARCHAR (100)=NULL, @FilterByStartOnly BIT=1
AS
SET NOCOUNT ON
DECLARE @SQL nvarchar(1000)
DECLARE @WHERE nvarchar(1000)

SET @WHERE = ''WHERE 1=1''
	
IF ISNULL(@ClassDescription, '''') != ''''
BEGIN
	IF @FilterByStartOnly = 1
		SET @WHERE = @WHERE + '' AND [d].[Description] LIKE '''''' + @ClassDescription + ''%''''''
	ELSE SET @WHERE = @WHERE + '' AND [d].[Description] LIKE ''''%'' + @ClassDescription + ''%''''''
END

IF ISNULL(@ClassCode, '''') != ''''
BEGIN
	IF @FilterByStartOnly = 1
		SET @WHERE = @WHERE + '' AND [d].[Code] LIKE '''''' + @ClassCode + ''%''''''
	ELSE SET @WHERE = @WHERE + '' AND [d].[Code] LIKE ''''%'' + @ClassCode + ''%''''''
END

	SET @sql = ''SELECT COUNT(ClassId) 
	FROM [ib_Class] d (nolock)  
'' + @WHERE

EXEC sp_executesql @sql
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_CurrencyDataSource_GetCurrencyDataSourcesSortableAndPaginate]''
');

GO
EXECUTE ('/*
<details>
	<summary>Returns the currency datasources sortable and paginate. A filter on the currencyId may be set</summary>
	<created author="Laurentiu Macovei" Date="Tuesday, 12 september 2006, 13:03PM GMT" />		
	<updated author="Anil Kripalani" Date="28 November 2006">Nolock to avoid collission with imports</updated> 
</details>
*/
CREATE PROCEDURE [dbo].[ib_CurrencyDataSource_GetCurrencyDataSourcesSortableAndPaginate]
	@CurrencyID int = NULL,
	@@OrderBy varchar(100) = NULL,
	@@StartRowIndex int = NULL,
	@@MaximumRows int = NULL

AS
SET NOCOUNT ON
--fix orderby
IF (ISNULL(@@OrderBy, '''')='''')
	SET @@OrderBy = ''ds.Code ASC'' 

	--fix the top
IF IsNull(@@MaximumRows, 0) <= 0
	SET @@MaximumRows = 0
IF IsNull(@@StartRowIndex, -1) <= -1 OR @@MaximumRows = 0 
	SET @@StartRowIndex = 0

DECLARE @SQL nvarchar(1000)
DECLARE @WHERE nvarchar(1000)

SET @WHERE = ''''
IF @CurrencyID IS NOT NULL
	SET @WHERE = @WHERE + '' AND cds.CurrencyID = '' + cast(@CurrencyId as varchar(100))

IF @@MaximumRows >0
	SET @sql = ''SELECT [CurrencyDataSourceId], [CurrencyCode], [DataSourceCode], [DataSourceCurrencyCode]
	 FROM
	   (SELECT TOP('' + CONVERT(nvarchar(10), @@StartRowIndex + @@MaximumRows) + '')''
ELSE SET @sql = ''SELECT''

--build the query
SET @sql = @sql + '' cds.[CurrencyDataSourceId], c.[Code] as [CurrencyCode], ds.[Code] as DataSourceCode, cds.[DataSourceCurrencyCode] ''

IF @@MaximumRows >0
	SET @sql = @sql+'', ROW_NUMBER() OVER(ORDER BY '' + @@OrderBy + '') as RowNum''

SET @sql = @sql + ''
 FROM [ib_CurrencyDataSource] cds (nolock)  
	INNER JOIN [ib_Currency] c (nolock) ON cds.CurrencyId = c.CurrencyId
	INNER JOIN [ib_DataSource] ds ON cds.DataSourceID = ds.DataSourceId
      '' + @where 

IF @@MaximumRows = 0
	SET @sql = @sql+''
 ORDER BY '' + @@OrderBy 

IF @@MaximumRows >0
	SET @sql = @sql +  '') x
WHERE RowNum > '' + CONVERT(nvarchar(10), @@StartRowIndex) + '' ORDER BY RowNum''

-- Execute the query
EXEC sp_executesql @sql
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_CurrencyDataSource_GetCurrencyDataSourcesSortableAndPaginate_Count]''
');

GO
EXECUTE ('/*
<details>
	<summary>Returns the currency datasources count. A filter on the currencyId may be set</summary>
	<created author="Laurentiu Macovei" Date="Wednesday, 13 september 2006, 12:36AM GMT" />		
	<updated author="Anil Kripalani" Date="28 November 2006">Nolock to avoid collission with imports</updated> 
</details>
*/
CREATE PROCEDURE [dbo].[ib_CurrencyDataSource_GetCurrencyDataSourcesSortableAndPaginate_Count]
	@CurrencyID int = NULL
AS
SET NOCOUNT ON
	
DECLARE @SQL nvarchar(1000)
DECLARE @WHERE nvarchar(1000)

SET @WHERE = ''''
	
IF @CurrencyID IS NOT NULL
	SET @WHERE = @WHERE + '' AND cds.CurrencyID = '' + cast(@CurrencyId as varchar(100))

	SET @sql = ''SELECT COUNT(CurrencyDataSourceId) 
	FROM [ib_CurrencyDataSource] cds (nolock)  
	INNER JOIN [ib_Currency] c (nolock) ON cds.CurrencyId = c.CurrencyId
	INNER JOIN [ib_DataSource] ds ON cds.DataSourceID = ds.DataSourceId '' + @WHERE

EXEC sp_executesql @sql
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_CurrencyDataSource_GetItemIndex_For_CurrencyDataSourceId_When_SortableAndPaginate]''
');

GO
EXECUTE (' /*
<details>
	<summary>Returns the item index for a given currency datasource id when sortable and paginate. A filter on the currencyId may be set</summary>
	<created author="Laurentiu Macovei" Date="Tuesday, 12 september 2006, 07:04PM GMT" />
</details>
*/
create PROCEDURE [dbo].[ib_CurrencyDataSource_GetItemIndex_For_CurrencyDataSourceId_When_SortableAndPaginate]
	@CurrencyID int,
	@GetItemIndexForCurrencyDataSourceId int,
	@@OrderBy varchar(100) = NULL

AS
SET NOCOUNT ON
--fix @GetItemIndexForCurrencyDataSourceId

--fix orderby
IF (ISNULL(@@OrderBy, '''')='''')
	SET @@OrderBy = ''ds.Code ASC'' 

BEGIN

DECLARE @SQL nvarchar(1000)
DECLARE @WHERE nvarchar(1000)

SET @WHERE = ''''
IF ISNULL(@CurrencyID, -1)>0
	SET @WHERE = @WHERE + '' AND cds.CurrencyID = '' + cast(@CurrencyId as varchar(100))

SET @sql = ''
DECLARE @Value int
SET @Value = -1
SELECT @Value = RowNum -1
	 FROM
	   (SELECT''

--build the query
SET @sql = @sql + '' [CurrencyDataSourceId] ''

SET @sql = @sql+'', ROW_NUMBER() OVER(ORDER BY '' + @@OrderBy + '') as RowNum''

SET @sql = @sql + ''
 FROM [ib_CurrencyDataSource] cds  
	INNER JOIN [ib_Currency] c ON cds.CurrencyId = c.CurrencyId
	INNER JOIN [ib_DataSource] ds ON cds.DataSourceID = ds.DataSourceId
      '' + @where 
	SET @sql = @sql +  '') x
WHERE [CurrencyDataSourceId] = '' + CONVERT(nvarchar(10), @GetItemIndexForCurrencyDataSourceId)
+ ''; SELECT @Value''

-- Execute the query
EXEC sp_executesql @sql

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Currency_GetCurrenciesSortable]''
');

GO
EXECUTE (' /*
<details>
 <summary>Selects records from the ib_Currency table and allows to specify the sorting column</summary>
 <created author="Laurentiu Macovei" Date="Monday, 5 September 2006 1:00AM GMT" /> 
 <updated author="Anil Kripalani" Date="28 November 2006">Nolock to avoid collission with imports</updated> 
</details>
--	16 Apr 2014		ED			EIB 25500 - deactivate currencies
*/
CREATE PROCEDURE [dbo].[ib_Currency_GetCurrenciesSortable]
@OrderBy varchar(100) = ''Code''
AS
SET NOCOUNT ON
--fix orderby
IF @OrderBy IS NULL OR RTrim(@OrderBy) = ''''
	SET @OrderBy = ''Code''
DECLARE @SQL NVARCHAR(4000)
SET @SQL = ''
 SELECT [CurrencyId]
      ,[Code]
      ,[Description]
      ,[IsApproved]
      ,[CreateDate]
      ,[CreateUsername]
      ,[UpdateDate]
      ,[UpdateUsername]
	  , (SELECT Count(CurrencyId) FROM ib_CurrencyDataSource cds (nolock) WHERE cds.CurrencyId = c.CurrencyId) CurrencyDataSources
  FROM [dbo].[ib_Currency] c (nolock)
  WHERE c.IsActive = 1
  ORDER BY ''+Replace(@OrderBy,'''''''','''''''''''')
 EXEC sp_executesql @SQL
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_DataSourceExchange_GetDataSourceExchangesSortableAndPaginateCount]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_DataSourceExchange_GetDataSourceExchangesSortableAndPaginateCount]
	@ExchangeId INT = NULL
AS
-- Description: Gets the count of the data source exchanges who match the specified criteria

-- 17 May 2010	ED	Creation
 
-- SET NOCOUNT ON added to prevent extra result sets from
-- interfering with SELECT statements.
SET NOCOUNT ON

DECLARE @SQL NVARCHAR(1000)
DECLARE @WHERE NVARCHAR(1000)

SET @WHERE = ''''

IF ISNULL(@ExchangeId, '''') != ''''
	SET @WHERE = @WHERE + '' AND dse.ExchangeId = '' + CONVERT(NVARCHAR(10),@ExchangeId)

SET @SQL = ''SELECT COUNT(dse.DataSourceExchangeId)
	 FROM ib_DataSourceExchange dse ''

SET @SQL = @SQL + '' WHERE 1 = 1'' + @WHERE

-- Execute the query
EXEC sp_executesql @SQL
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_DataSourceExchange_GetDataSourceExchangesSortableAndPaginate]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_DataSourceExchange_GetDataSourceExchangesSortableAndPaginate]
(
	@ExchangeId INT = NULL,
	@@OrderBy VARCHAR(100) = NULL,
	@@StartRowIndex INT = NULL,
	@@MaximumRows INT = NULL
)
AS
-- Description: Gets data sources exchanges "sortable and paginate" matching the specified criteria

-- 17 May 2010	ED	Creation
 

-- SET NOCOUNT ON added to prevent extra result sets from
-- interfering with SELECT statements.
SET NOCOUNT ON

IF (ISNULL(@@OrderBy, '''')='''')
	SET @@OrderBy = ''dse.DataSourceExchangeCode ASC'' 

IF ISNULL(@@MaximumRows, 0) <= 0
	SET @@MaximumRows = 0
IF ISNULL(@@StartRowIndex, -1) <= -1 OR @@MaximumRows = 0 
	SET @@StartRowIndex = 0

DECLARE @SQL NVARCHAR(1000)
DECLARE @WHERE NVARCHAR(1000)

SET @WHERE = ''WHERE 1=1 ''

IF ISNULL(@ExchangeId, '''') != ''''
	SET @WHERE = @WHERE + '' AND dse.ExchangeId = '' + CONVERT(NVARCHAR(10),@ExchangeId)


IF @@MaximumRows >0
	SET @sql = ''SELECT DataSourceExchangeId, DataSourceExchangeCode, DataSourceCode,  ExchangeCode, CreateDate
	 FROM
	   (SELECT TOP('' + CONVERT(NVARCHAR(10), @@StartRowIndex + @@MaximumRows) + '')''
ELSE SET @sql = ''SELECT''

--build the query
SET @sql = @sql + '' dse.DataSourceExchangeId, dse.DataSourceExchangeCode, ds.Code DataSourceCode,  e.Code ExchangeCode, dse.CreateDate ''

IF @@MaximumRows >0
	SET @sql = @sql+'', ROW_NUMBER() OVER(ORDER BY '' + @@OrderBy + '') as RowNum''
SET @sql = @sql + ''
	FROM ib_DataSourceExchange dse (nolock) 
	INNER JOIN ib_DataSource ds ON ds.DataSourceId = dse.DataSourceId
	INNER JOIN ib_Exchange e ON e.Exchangeid = dse.ExchangeId
    '' + @where 

IF @@MaximumRows = 0
	SET @sql = @sql+''
 ORDER BY '' + @@OrderBy 

IF @@MaximumRows >0
	SET @sql = @sql +  '') as x
WHERE RowNum > '' + CONVERT(NVARCHAR(10), @@StartRowIndex) + '' ORDER BY RowNum''

-- Execute the query
EXEC sp_executesql @sql
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_DataSourceExchange_GetItemIndex_For_DataSourceExchangeId_When_SortableAndPaginate]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_DataSourceExchange_GetItemIndex_For_DataSourceExchangeId_When_SortableAndPaginate]
	@ExchangeID INT,
	@GetItemIndexForDataSourceExchangeId INT,
	@@OrderBy VARCHAR(100) = NULL

AS
SET NOCOUNT ON
-- Description: Gets data sources exchanges "sortable and paginate" matching the specified criteria
-- 17 May 2010	ED	Creation
--fix orderby
IF (ISNULL(@@OrderBy, '''')='''')
	SET @@OrderBy = ''dse.DataSourceExchangeCode ASC'' 

BEGIN

DECLARE @SQL NVARCHAR(1000)
DECLARE @WHERE NVARCHAR(1000)

SET @WHERE = ''''
IF ISNULL(@ExchangeID, -1)>0
	SET @WHERE = @WHERE + '' AND dse.ExchangeID = '' + CAST(@ExchangeID AS VARCHAR(100))

SET @sql = ''
DECLARE @Value int
SET @Value = -1
SELECT @Value = RowNum -1
	 FROM
	   (SELECT''

--build the query
SET @sql = @sql + '' DataSourceExchangeId ''

SET @sql = @sql+'', ROW_NUMBER() OVER(ORDER BY '' + @@OrderBy + '') as RowNum''

SET @sql = @sql + ''
 FROM [ib_DataSourceExchange] dse  
	INNER JOIN [ib_Exchange] e ON dse.ExchangeId = e.ExchangeId
	INNER JOIN [ib_DataSource] ds ON dse.DataSourceID = ds.DataSourceId
      '' + @where 
	SET @sql = @sql +  '') x
WHERE [DataSourceExchangeId] = '' + CONVERT(NVARCHAR(10), @GetItemIndexForDataSourceExchangeId)
+ ''; SELECT @Value''

-- Execute the query
EXEC sp_executesql @sql

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_DataSourceTrxType_GetItemIndex_For_DataSourceTrxTypeId_When_SortableAndPaginate]''
');

GO
EXECUTE ('
CREATE PROCEDURE [dbo].[ib_DataSourceTrxType_GetItemIndex_For_DataSourceTrxTypeId_When_SortableAndPaginate]
    @TrxTypeId INT
   ,@DataSourceId INT = NULL
   ,@@OrderBy VARCHAR(100) = NULL
AS 
SET NOCOUNT ON

IF ( ISNULL(@@OrderBy, '''') = '''' ) 
    SET @@OrderBy = ''Code ASC'' 

BEGIN

    DECLARE @SQL NVARCHAR(1000)
    DECLARE @WHERE NVARCHAR(1000)

    SET @WHERE = ''''
    IF ISNULL(@DataSourceId, -1) > 0 
        SET @WHERE = @WHERE + '' WHERE DataSourceId = '' +
            CAST(@DataSourceId AS VARCHAR(100))

    SET @sql = ''
DECLARE @Value int
SET @Value = -1
SELECT @Value = RowNum -1
	 FROM
	   (SELECT''

--build the query
    SET @sql = @sql + '' [TrxTypeId] ''

    SET @sql = @sql + '', ROW_NUMBER() OVER(ORDER BY '' + @@OrderBy +
        '') as RowNum''

    SET @sql = @sql + ''
 FROM [ib_TrxType] cds  
      '' + @where 
    SET @sql = @sql + '') x
WHERE [TrxTypeId] = '' + CONVERT(NVARCHAR(10), @TrxTypeId) + ''; SELECT @Value''

    PRINT @sql
-- Execute the query
    EXEC sp_executesql @sql

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_DataSource_GetByFilePath]''
');

GO
EXECUTE ('
-- =============================================
-- Author:		Lee Manifold
-- Create date: 7 Aug 2006
-- Description:	Brings back a Datasource code from a file name and file path 
--				parameters
-- Usage:	
-- DECLARE @codex varchar(20)
-- DECLARE @output varchar(20)
-- DECLARE @rtn int
-- EXEC ib_DataSource_GetByFilePath ''C:\Test\Eurfut'', ''EurFut'',@codex output
-- SELECT @codex
-- ****Note: 
-- This sp is no longer used as all files are being loaded into the same
-- directory. Please refer to ib_GMI_GetDataSource

-- =============================================
CREATE PROCEDURE [dbo].[ib_DataSource_GetByFilePath]
	(
	@FilePath		varchar(100),
	@DataSourceName	varchar(25),	
	@CodeOut		varchar(20) output
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
	DECLARE	@SQL			nvarchar(200)
	DECLARE @ParmDefinition nvarchar(500);
	DECLARE @Code			nvarchar(20)

	SET @ParmDefinition = N''@Code varchar(20) OUTPUT'';

	SET @SQL =			''SELECT @Code = [Code] ''
	SET @SQL = @SQL +	''FROM	[dbo].[ib_datasource] ''
	SET @SQL = @SQL +	''WHERE '''''' + @FilePath + '''''' LIKE ''''%'''' + [Code] + ''''%'''' ''
	SET @SQL = @SQL +	''AND [Name] LIKE ''''%'' + @DataSourceName + ''%''''''

	EXECUTE sp_executesql @SQL, @ParmDefinition, @Code OUTPUT;
	SET @CodeOut = @Code

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_DataSource_GetDataSourcesSortableAndPaginate]''
');

GO
EXECUTE ('
CREATE PROCEDURE [dbo].[ib_DataSource_GetDataSourcesSortableAndPaginate]
    @DataSourceName VARCHAR(100) = NULL
   ,@DataSourceCode VARCHAR(100) = NULL
   ,@FilterByStartOnly BIT = 1
   ,@@OrderBy VARCHAR(100) = NULL
   ,@@StartRowIndex INT = NULL
   ,@@MaximumRows INT = NULL
AS 
SET NOCOUNT ON

IF ( ISNULL(@@OrderBy, '''') = '''' ) 
    SET @@OrderBy = ''ds.Code ASC'' 

	--fix the top
IF ISNULL(@@MaximumRows, 0) <= 0 
    SET @@MaximumRows = 0
IF ISNULL(@@StartRowIndex, -1) <= -1 OR
    @@MaximumRows = 0 
    SET @@StartRowIndex = 0

DECLARE @SQL NVARCHAR(1000)
DECLARE @WHERE NVARCHAR(1000)

SET @WHERE = ''WHERE 1=1''

IF ISNULL(@DataSourceName, '''') != '''' 
    BEGIN
        IF @FilterByStartOnly = 1 
            SET @WHERE = @WHERE + '' AND [d].[Name] LIKE '''''' + @DataSourceName +
                ''%''''''
        ELSE 
            SET @WHERE = @WHERE + '' AND [d].[Name] LIKE ''''%'' + @DataSourceName +
                ''%''''''
    END

IF ISNULL(@DataSourceCode, '''') != '''' 
    BEGIN
        IF @FilterByStartOnly = 1 
            SET @WHERE = @WHERE + '' AND [d].[Code] LIKE '''''' + @DataSourceCode +
                ''%''''''
        ELSE 
            SET @WHERE = @WHERE + '' AND [d].[Code] LIKE ''''%'' + @DataSourceCode +
                ''%''''''
    END

SET @SQL = ''
		SELECT 
			ds.*,
			c.Description [CurrencyDescription],
			COUNT(dt.TrxtypeId) [TrxTypeCount]
		FROM
			(SELECT 
				[DataSourceId], [UseTrxsForTradedOnDay],
				[Code], [IncludeDetailAccountInTradeReconciliation],
				[Name],[DefaultCurrencyId],[ProvidesVariation],[DefaultStrikePriceDivisor] [DefaultStrikePriceDivisor],
				ROW_NUMBER() OVER(ORDER BY d.CreateDate  ASC) as RowNum
			FROM
				[ib_DataSource] d 
			'' + @WHERE +
    '')AS ds
			LEFT OUTER JOIN
				[ib_TrxType] dt ON dt.[DataSourceId] = ds.[DataSourceId] 
			LEFT OUTER JOIN
				[ib_Currency] c on c.CurrencyId = ds.DefaultCurrencyId
				''

IF @@MaximumRows > 0 
    SET @sql = @sql + ''WHERE ds.[RowNum] > '' +
        CONVERT(NVARCHAR(10), @@StartRowIndex) + '' AND ds.[RowNum] <= '' +
        CONVERT(NVARCHAR(10), @@StartRowIndex + @@MaximumRows)
		
SET @sql = @sql +
    ''
		GROUP BY
			ds.[DataSourceId],ds.[Name],ds.[UseTrxsForTradedOnDay],ds.[IncludeDetailAccountInTradeReconciliation],ds.[Code],ds.[RowNum],ds.[DefaultStrikePriceDivisor],c.[Description],ds.[ProvidesVariation],ds.[DefaultCurrencyId]''
			
SET @sql = @sql + ''
		ORDER BY '' + @@OrderBy

PRINT @sql
-- Execute the query
EXEC sp_executesql @sql
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_DataSource_GetDataSourcesSortableAndPaginate_Count]''
');

GO
EXECUTE ('
CREATE PROCEDURE [dbo].[ib_DataSource_GetDataSourcesSortableAndPaginate_Count]
    @DataSourceName VARCHAR(100) = NULL
   ,@DataSourceCode VARCHAR(100) = NULL
   ,@FilterByStartOnly BIT = 1
AS 
SET NOCOUNT ON

DECLARE @SQL NVARCHAR(1000)
DECLARE @WHERE NVARCHAR(1000)

SET @WHERE = ''WHERE 1=1''
	
IF ISNULL(@DataSourceName, '''') != '''' 
    BEGIN
        IF @FilterByStartOnly = 1 
            SET @WHERE = @WHERE + '' AND [d].[Name] LIKE '''''' + @DataSourceName +
                ''%''''''
        ELSE 
            SET @WHERE = @WHERE + '' AND [d].[Name] LIKE ''''%'' + @DataSourceName +
                ''%''''''
    END

IF ISNULL(@DataSourceCode, '''') != '''' 
    BEGIN
        IF @FilterByStartOnly = 1 
            SET @WHERE = @WHERE + '' AND [d].[Code] LIKE '''''' + @DataSourceCode +
                ''%''''''
        ELSE 
            SET @WHERE = @WHERE + '' AND [d].[Code] LIKE ''''%'' + @DataSourceCode +
                ''%''''''
    END

SET @sql = ''SELECT COUNT(DataSourceId) 
	FROM [ib_DataSource] d (nolock)  
'' + @WHERE

EXEC sp_executesql @sql
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_DataSource_GetPaged]''
');

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Gets records from the ib_DataSource table passing page index and page count parameters
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[ib_DataSource_GetPaged]
(

	@WhereClause varchar (2000)  ,

	@OrderBy varchar (2000)  ,

	@PageIndex int   ,

	@PageSize int   
)
AS


				
				BEGIN
				DECLARE @PageLowerBound int
				DECLARE @PageUpperBound int
				
				-- Set the page bounds
				SET @PageLowerBound = @PageSize * @PageIndex
				SET @PageUpperBound = @PageLowerBound + @PageSize

				IF (@OrderBy IS NULL OR LEN(@OrderBy) < 1)
				BEGIN
					-- default order by to first column
					SET @OrderBy = ''[DataSourceId]''
				END

				-- SQL Server 2005 Paging
				DECLARE @SQL AS nvarchar(MAX)
				SET @SQL = ''WITH PageIndex AS (''
				SET @SQL = @SQL + '' SELECT''
				IF @PageSize > 0
				BEGIN
					SET @SQL = @SQL + '' TOP '' + CONVERT(nvarchar, @PageUpperBound)
				END
				SET @SQL = @SQL + '' ROW_NUMBER() OVER (ORDER BY '' + @OrderBy + '') as RowIndex''
				SET @SQL = @SQL + '', [DataSourceId]''
				SET @SQL = @SQL + '', [Code]''
				SET @SQL = @SQL + '', [Name]''
				SET @SQL = @SQL + '', [DefaultCurrencyId]''
				SET @SQL = @SQL + '', [ProvidesVariation]''
				SET @SQL = @SQL + '', [DefaultStrikePriceDivisor]''
				SET @SQL = @SQL + '', [CreateDate]''
				SET @SQL = @SQL + '', [CreateUsername]''
				SET @SQL = @SQL + '', [UpdateDate]''
				SET @SQL = @SQL + '', [UpdateUsername]''
				SET @SQL = @SQL + '', [IncludeDetailAccountInTradeReconciliation]''
				SET @SQL = @SQL + '', [UseTrxsForTradedOnDay]''
				SET @SQL = @SQL + '' FROM [dbo].[ib_DataSource]''
				IF LEN(@WhereClause) > 0
				BEGIN
					SET @SQL = @SQL + '' WHERE '' + @WhereClause
				END
				SET @SQL = @SQL + '' ) SELECT''
				SET @SQL = @SQL + '' [DataSourceId],''
				SET @SQL = @SQL + '' [Code],''
				SET @SQL = @SQL + '' [Name],''
				SET @SQL = @SQL + '' [DefaultCurrencyId],''
				SET @SQL = @SQL + '' [ProvidesVariation],''
				SET @SQL = @SQL + '' [DefaultStrikePriceDivisor],''
				SET @SQL = @SQL + '' [CreateDate],''
				SET @SQL = @SQL + '' [CreateUsername],''
				SET @SQL = @SQL + '' [UpdateDate],''
				SET @SQL = @SQL + '' [UpdateUsername],''
				SET @SQL = @SQL + '' [IncludeDetailAccountInTradeReconciliation],''
				SET @SQL = @SQL + '' [UseTrxsForTradedOnDay]''
				SET @SQL = @SQL + '' FROM PageIndex''
				SET @SQL = @SQL + '' WHERE RowIndex > '' + CONVERT(nvarchar, @PageLowerBound)
				IF @PageSize > 0
				BEGIN
					SET @SQL = @SQL + '' AND RowIndex <= '' + CONVERT(nvarchar, @PageUpperBound)
				END
				SET @SQL = @SQL + '' ORDER BY '' + @OrderBy
				EXEC sp_executesql @SQL
				
				-- get row count
				SET @SQL = ''SELECT COUNT(*) AS TotalRowCount''
				SET @SQL = @SQL + '' FROM [dbo].[ib_DataSource]''
				IF LEN(@WhereClause) > 0
				BEGIN
					SET @SQL = @SQL + '' WHERE '' + @WhereClause
				END
				EXEC sp_executesql @SQL
			
				END
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Department_GetDepartmentsSortableAndPaginate]''
');

GO
EXECUTE ('
/*
<details>
	<summary>Returns the Departments sortable and paginate. </summary>
	<created author="konrad" date="24 Mar 2009 16:33:45 GMT"/>
</details>
*/
--
-- Revision History
--
-- 01.05.09 Konrad Fixing bugs of filtering part, setting correct @where string.
--
CREATE PROCEDURE [dbo].[ib_Department_GetDepartmentsSortableAndPaginate]
	@DepartmentDescription varchar(100) = NULL,
	@DepartmentCode varchar(100) = NULL,
	@FilterByStartOnly bit=1,
	@@OrderBy varchar(100) = NULL,
	@@StartRowIndex int = NULL,
	@@MaximumRows int = NULL

AS
SET NOCOUNT ON
--fix orderby
IF (ISNULL(@@OrderBy, '''')='''')
	SET @@OrderBy = ''d.Code ASC'' 

	--fix the top
IF IsNull(@@MaximumRows, 0) <= 0
	SET @@MaximumRows = 0
IF IsNull(@@StartRowIndex, -1) <= -1 OR @@MaximumRows = 0 
	SET @@StartRowIndex = 0

DECLARE @SQL nvarchar(1000)
DECLARE @WHERE nvarchar(1000)

SET @WHERE = ''WHERE 1=1''

IF ISNULL(@DepartmentDescription, '''') != ''''
BEGIN
	IF @FilterByStartOnly = 1
		SET @WHERE = @WHERE + '' AND [d].[Description] LIKE '''''' + @DepartmentDescription + ''%''''''
	ELSE SET @WHERE = @WHERE + '' AND [d].[Description] LIKE ''''%'' + @DepartmentDescription + ''%''''''
END

IF ISNULL(@DepartmentCode, '''') != ''''
BEGIN
	IF @FilterByStartOnly = 1
		SET @WHERE = @WHERE + '' AND [d].[Code] LIKE '''''' + @DepartmentCode + ''%''''''
	ELSE SET @WHERE = @WHERE + '' AND [d].[Code] LIKE ''''%'' + @DepartmentCode + ''%''''''
END

IF @@MaximumRows >0
	SET @sql = ''SELECT [DepartmentId], [Code], [Description] 
	 FROM
	   (SELECT TOP('' + CONVERT(nvarchar(10), @@StartRowIndex + @@MaximumRows) + '')''
ELSE SET @sql = ''SELECT''

--build the query
SET @sql = @sql + '' d.[DepartmentId], d.[Code], d.[Description] ''

IF @@MaximumRows >0
	SET @sql = @sql+'', ROW_NUMBER() OVER(ORDER BY '' + @@OrderBy + '') as RowNum''
ELSE SET @Sql = @sql + ''''
SET @sql = @sql + ''
 FROM [ib_Department] d (nolock)'' + @where 

IF @@MaximumRows = 0
	SET @sql = @sql+''
 ORDER BY '' + @@OrderBy 

IF @@MaximumRows >0
	SET @sql = @sql +  '') as x
WHERE RowNum > '' + CONVERT(nvarchar(10), @@StartRowIndex) + '' ORDER BY RowNum''

-- Execute the query
EXEC sp_executesql @sql
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Department_GetDepartmentsSortableAndPaginate_Count]''
');

GO
EXECUTE ('
/*
<details>
	<summary>Returns the Departments count</summary>
	<created author="konrad" date="24 March 2009"/>
</details>
*/
--
-- Revision History
--
-- 01.05.09 Konrad Fixing bugs of filtering part, setting correct @where string.
--
CREATE PROCEDURE [dbo].[ib_Department_GetDepartmentsSortableAndPaginate_Count]
	@DepartmentDescription varchar(100) = NULL,
	@DepartmentCode varchar(100) = NULL,
	@FilterByStartOnly bit=1
AS
SET NOCOUNT ON
	
DECLARE @SQL nvarchar(1000)
DECLARE @WHERE nvarchar(1000)

SET @WHERE = ''WHERE 1=1''
	
IF ISNULL(@DepartmentDescription, '''') != ''''
BEGIN
	IF @FilterByStartOnly = 1
		SET @WHERE = @WHERE + '' AND [d].[Description] LIKE '''''' + @DepartmentDescription + ''%''''''
	ELSE SET @WHERE = @WHERE + '' AND [d].[Description] LIKE ''''%'' + @DepartmentDescription + ''%''''''
END

IF ISNULL(@DepartmentCode, '''') != ''''
BEGIN
	IF @FilterByStartOnly = 1
		SET @WHERE = @WHERE + '' AND [d].[Code] LIKE '''''' + @DepartmentCode + ''%''''''
	ELSE SET @WHERE = @WHERE + '' AND [d].[Code] LIKE ''''%'' + @DepartmentCode + ''%''''''
END

	SET @sql = ''SELECT COUNT(DepartmentId) 
	FROM [ib_Department] d (nolock)  
'' + @WHERE

EXEC sp_executesql @sql
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Exchange_GetExchangesSortableAndPaginateCount]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Exchange_GetExchangesSortableAndPaginateCount]
	@ExchangeName varchar(100) = NULL,
	@ExchangeCode varchar(100) = NULL,
	@FilterByStartOnly bit = 1
AS
-- Description: Gets the count of the exchanges who match the specified criteria

-- 19 Apr 2010	AAJM	Creation
 

-- SET NOCOUNT ON added to prevent extra result sets from
-- interfering with SELECT statements.
SET NOCOUNT ON

DECLARE @SQL nvarchar(1000)
DECLARE @WHERE nvarchar(1000)

SET @WHERE = ''''

IF ISNULL(@ExchangeName, '''') != ''''
BEGIN
	IF @FilterByStartOnly = 1
		SET @WHERE = @WHERE + '' AND [e].[Name] LIKE '''''' + @ExchangeName + ''%''''''
	ELSE SET @WHERE = @WHERE + '' AND [e].[Name] LIKE ''''%'' + @ExchangeName + ''%''''''
END

IF ISNULL(@ExchangeCode, '''') != ''''
BEGIN
	IF @FilterByStartOnly = 1
		SET @WHERE = @WHERE + '' AND [e].[Code] LIKE '''''' + @ExchangeCode + ''%''''''
	ELSE SET @WHERE = @WHERE + '' AND [e].[Code] LIKE ''''%'' + @ExchangeCode + ''%''''''
END

SET @SQL = ''SELECT COUNT([e].[ExchangeId])
	 FROM [dbo].[ib_Exchange] e ''

SET @SQL = @SQL + '' WHERE 1 = 1'' + @WHERE

-- Execute the query
EXEC sp_executesql @SQL
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Exchange_GetExchangesSortableAndPaginate]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Exchange_GetExchangesSortableAndPaginate]
	@ExchangeName varchar(100) = NULL,
	@ExchangeCode varchar(100) = NULL,
	@FilterByStartOnly bit=1,
	@@OrderBy varchar(100) = NULL,
	@@StartRowIndex int = NULL,
	@@MaximumRows int = NULL

AS
-- Description: Gets exchanges "sortable and paginate" matching the specified criteria

-- 19 Apr 2010	AAJM	Creation
 

-- SET NOCOUNT ON added to prevent extra result sets from
-- interfering with SELECT statements.
SET NOCOUNT ON

IF (ISNULL(@@OrderBy, '''')='''')
	SET @@OrderBy = ''e.Code ASC'' 

IF IsNull(@@MaximumRows, 0) <= 0
	SET @@MaximumRows = 0
IF IsNull(@@StartRowIndex, -1) <= -1 OR @@MaximumRows = 0 
	SET @@StartRowIndex = 0

DECLARE @SQL nvarchar(1000)
DECLARE @WHERE nvarchar(1000)

SET @WHERE = '' WHERE 1=1 ''

IF ISNULL(@ExchangeName, '''') != ''''
BEGIN
	IF @FilterByStartOnly = 1
		SET @WHERE = @WHERE + '' AND [e].[Name] LIKE '''''' + @ExchangeName + ''%''''''
	ELSE SET @WHERE = @WHERE + '' AND [e].[Name] LIKE ''''%'' + @ExchangeName + ''%''''''
END

IF ISNULL(@ExchangeCode, '''') != ''''
BEGIN
	IF @FilterByStartOnly = 1
		SET @WHERE = @WHERE + '' AND [e].[Code] LIKE '''''' + @ExchangeCode + ''%''''''
	ELSE SET @WHERE = @WHERE + '' AND [e].[Code] LIKE ''''%'' + @ExchangeCode + ''%''''''
END
    
IF @@MaximumRows >0
	SET @sql = ''SELECT [ExchangeId], [Code], [Name], [RunBalanceReport], [RunCloseOutReport], [RunTradeLevelReconciliation],  
						(SELECT Count(DataSourceExchangeId) FROM [dbo].[ib_DataSourceExchange] dse (nolock) WHERE dse.ExchangeId = x.ExchangeId) DataSourceExchangeItems

	 FROM
	   (SELECT TOP('' + CONVERT(nvarchar(10), @@StartRowIndex + @@MaximumRows) + '')''
ELSE SET @sql = ''SELECT''

--build the query
SET @sql = @sql + '' e.[ExchangeId], e.[Code], e.[Name], e.[RunBalanceReport], e.[RunCloseOutReport], e.[RunTradeLevelReconciliation]''

IF @@MaximumRows >0
	SET @sql = @sql+'', ROW_NUMBER() OVER(ORDER BY '' + @@OrderBy + '') as RowNum''
ELSE SET @Sql = @sql + '', 
       (SELECT Count(dse.DataSourecExchangeId) 
			FROM [dbo].[ib_DataSourceExchange] dse (nolock) 
			WHERE dse.ExchangeId = e.ExchangeId) AS DataSourceExchangeItems
''
SET @sql = @sql + ''
 FROM [ib_Exchange] e (nolock) 
      '' + @where 

IF @@MaximumRows = 0
	SET @sql = @sql+''
 ORDER BY '' + @@OrderBy 

IF @@MaximumRows >0
	SET @sql = @sql +  '') as x
WHERE RowNum > '' + CONVERT(nvarchar(10), @@StartRowIndex) + '' ORDER BY RowNum''

-- Execute the query
EXEC sp_executesql @sql
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_FirmDataSource_GetFirmDataSourcesSortableAndPaginate]''
');

GO
EXECUTE ('
/*
<details>
	<summary>Returns the firm datasources sortable and paginate. A filter on the firmId may be set</summary>
	<created author="Laurentiu Macovei" Date="Tuesday, 22 september 2006, 13:03PM GMT" />		
	<updated author="anil.kripalani" date="28 November 2006">Add nolock hints so can run during imports</updated>
</details>
*/
CREATE PROCEDURE [dbo].[ib_FirmDataSource_GetFirmDataSourcesSortableAndPaginate]
	@FirmID int = NULL,
	@@OrderBy varchar(100) = NULL,
	@@StartRowIndex int = NULL,
	@@MaximumRows int = NULL

AS
SET NOCOUNT ON
--fix orderby
IF (ISNULL(@@OrderBy, '''')='''')
	SET @@OrderBy = ''ds.Code ASC'' 

	--fix the top
IF IsNull(@@MaximumRows, 0) <= 0
	SET @@MaximumRows = 0
IF IsNull(@@StartRowIndex, -1) <= -1 OR @@MaximumRows = 0 
	SET @@StartRowIndex = 0

DECLARE @SQL nvarchar(1000)
DECLARE @WHERE nvarchar(1000)

SET @WHERE = ''''
IF @FirmID IS NOT NULL
	SET @WHERE = @WHERE + '' AND fds.FirmID = '' + cast(@FirmId as varchar(100))

IF @@MaximumRows >0
	SET @sql = ''SELECT [FirmDataSourceId], [FirmCode], [DataSourceCode], [DataSourceFirmCode]
	 FROM
	   (SELECT TOP('' + CONVERT(nvarchar(10), @@StartRowIndex + @@MaximumRows) + '')''
ELSE SET @sql = ''SELECT''

--build the query
SET @sql = @sql + '' fds.[FirmDataSourceId], f.[Code] as [FirmCode], ds.[Code] as DataSourceCode, fds.[DataSourceFirmCode] ''

IF @@MaximumRows >0
	SET @sql = @sql+'', ROW_NUMBER() OVER(ORDER BY '' + @@OrderBy + '') as RowNum''

SET @sql = @sql + ''
 FROM [ib_FirmDataSource] fds (nolock)  
	INNER JOIN [ib_Firm] f (nolock) ON fds.FirmId = f.FirmId
	INNER JOIN [ib_DataSource] ds ON fds.DataSourceID = ds.DataSourceId
      '' + @where 

IF @@MaximumRows = 0
	SET @sql = @sql+''
 ORDER BY '' + @@OrderBy 

IF @@MaximumRows >0
	SET @sql = @sql +  '') x
WHERE RowNum > '' + CONVERT(nvarchar(10), @@StartRowIndex) + '' ORDER BY RowNum''

-- Execute the query
EXEC sp_executesql @sql
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_FirmDataSource_GetFirmDataSourcesSortableAndPaginate_Count]''
');

GO
EXECUTE ('
/*
<details>
	<summary>Returns the firm datasources count. A filter on the firmId may be set</summary>
	<created author="Laurentiu Macovei" Date="Wednesday, 22 september 2006, 12:36AM GMT" />		
	<updated author="anil.kripalani" date="28 November 2006">Add nolock hints so can run during imports</updated>
</details>
*/
CREATE PROCEDURE [dbo].[ib_FirmDataSource_GetFirmDataSourcesSortableAndPaginate_Count]
	@FirmID int = NULL
AS
SET NOCOUNT ON
	
DECLARE @SQL nvarchar(1000)
DECLARE @WHERE nvarchar(1000)

SET @WHERE = ''''
	
IF @FirmID IS NOT NULL
	SET @WHERE = @WHERE + '' AND fds.FirmID = '' + cast(@FirmId as varchar(100))

	SET @sql = ''SELECT COUNT(FirmDataSourceId) 
	FROM [ib_FirmDataSource] fds (nolock) 
	INNER JOIN [ib_Firm] f (nolock) ON fds.FirmId = f.FirmId
	INNER JOIN [ib_DataSource] ds ON fds.DataSourceID = ds.DataSourceId '' + @WHERE

EXEC sp_executesql @sql
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_FirmDataSource_GetItemIndex_For_FirmDataSourceId_When_SortableAndPaginate]''
');

GO
EXECUTE ('
 /*
<details>
	<summary>Returns the item index for a given Firm datasource id when sortable and paginate. A filter on the FirmId may be set</summary>
	<created author="Laurentiu Macovei" Date="Tuesday, 12 september 2006, 07:04PM GMT" />
</details>
*/
CREATE PROCEDURE [dbo].[ib_FirmDataSource_GetItemIndex_For_FirmDataSourceId_When_SortableAndPaginate]
	@FirmID int,
	@GetItemIndexForFirmDataSourceId int,
	@@OrderBy varchar(100) = NULL

AS
SET NOCOUNT ON
--fix @GetItemIndexForFirmDataSourceId

--fix orderby
IF (ISNULL(@@OrderBy, '''')='''')
	SET @@OrderBy = ''ds.Code ASC'' 

BEGIN

DECLARE @SQL nvarchar(1000)
DECLARE @WHERE nvarchar(1000)

SET @WHERE = ''''
IF ISNULL(@FirmID, -1)>0
	SET @WHERE = @WHERE + '' AND fds.FirmID = '' + cast(@FirmId as varchar(100))

SET @sql = ''
DECLARE @Value int
SET @Value = -1
SELECT @Value = RowNum -1
	 FROM
	   (SELECT''

--build the query
SET @sql = @sql + '' [FirmDataSourceId] ''

SET @sql = @sql+'', ROW_NUMBER() OVER(ORDER BY '' + @@OrderBy + '') as RowNum''

SET @sql = @sql + ''
 FROM [ib_FirmDataSource] fds  
	INNER JOIN [ib_Firm] f ON fds.FirmId = f.FirmId
	INNER JOIN [ib_DataSource] ds ON fds.DataSourceID = ds.DataSourceId
      '' + @where 
	SET @sql = @sql +  '') x
WHERE [FirmDataSourceId] = '' + CONVERT(nvarchar(10), @GetItemIndexForFirmDataSourceId)
+ ''; SELECT @Value''

-- Execute the query
EXEC sp_executesql @sql

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_FirmDataSource_GetPaged]''
');

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Gets records from the ib_FirmDataSource table passing page index and page count parameters
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[ib_FirmDataSource_GetPaged]
(

	@WhereClause varchar (2000)  ,

	@OrderBy varchar (2000)  ,

	@PageIndex int   ,

	@PageSize int   
)
AS


				
				BEGIN
				DECLARE @PageLowerBound int
				DECLARE @PageUpperBound int
				
				-- Set the page bounds
				SET @PageLowerBound = @PageSize * @PageIndex
				SET @PageUpperBound = @PageLowerBound + @PageSize

				IF (@OrderBy IS NULL OR LEN(@OrderBy) < 1)
				BEGIN
					-- default order by to first column
					SET @OrderBy = ''[FirmDataSourceId]''
				END

				-- SQL Server 2005 Paging
				DECLARE @SQL AS nvarchar(MAX)
				SET @SQL = ''WITH PageIndex AS (''
				SET @SQL = @SQL + '' SELECT''
				IF @PageSize > 0
				BEGIN
					SET @SQL = @SQL + '' TOP '' + CONVERT(nvarchar, @PageUpperBound)
				END
				SET @SQL = @SQL + '' ROW_NUMBER() OVER (ORDER BY '' + @OrderBy + '') as RowIndex''
				SET @SQL = @SQL + '', [FirmDataSourceId]''
				SET @SQL = @SQL + '', [FirmId]''
				SET @SQL = @SQL + '', [DataSourceId]''
				SET @SQL = @SQL + '', [DataSourceFirmCode]''
				SET @SQL = @SQL + '', [CreateDate]''
				SET @SQL = @SQL + '', [CreateUsername]''
				SET @SQL = @SQL + '', [UpdateDate]''
				SET @SQL = @SQL + '', [UpdateUsername]''
				SET @SQL = @SQL + '' FROM [dbo].[ib_FirmDataSource]''
				IF LEN(@WhereClause) > 0
				BEGIN
					SET @SQL = @SQL + '' WHERE '' + @WhereClause
				END
				SET @SQL = @SQL + '' ) SELECT''
				SET @SQL = @SQL + '' [FirmDataSourceId],''
				SET @SQL = @SQL + '' [FirmId],''
				SET @SQL = @SQL + '' [DataSourceId],''
				SET @SQL = @SQL + '' [DataSourceFirmCode],''
				SET @SQL = @SQL + '' [CreateDate],''
				SET @SQL = @SQL + '' [CreateUsername],''
				SET @SQL = @SQL + '' [UpdateDate],''
				SET @SQL = @SQL + '' [UpdateUsername]''
				SET @SQL = @SQL + '' FROM PageIndex''
				SET @SQL = @SQL + '' WHERE RowIndex > '' + CONVERT(nvarchar, @PageLowerBound)
				IF @PageSize > 0
				BEGIN
					SET @SQL = @SQL + '' AND RowIndex <= '' + CONVERT(nvarchar, @PageUpperBound)
				END
				SET @SQL = @SQL + '' ORDER BY '' + @OrderBy
				EXEC sp_executesql @SQL
				
				-- get row count
				SET @SQL = ''SELECT COUNT(*) AS TotalRowCount''
				SET @SQL = @SQL + '' FROM [dbo].[ib_FirmDataSource]''
				IF LEN(@WhereClause) > 0
				BEGIN
					SET @SQL = @SQL + '' WHERE '' + @WhereClause
				END
				EXEC sp_executesql @SQL
			
				END
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Firm_GetFirmsSortableAndPaginate]''
');

GO
EXECUTE ('

/*
<details>
	<summary>Returns the Firms sortable and paginate. </summary>
	<created author="laurentiu.macovei" date="Thu, 22 Sep 2006 16:33:45 GMT"/>
	<updated author="anil.kripalani" date="28 November 2006">Add nolock hints so can run during imports</updated>
</details>
*/
CREATE PROCEDURE [dbo].[ib_Firm_GetFirmsSortableAndPaginate]
	@@OrderBy varchar(100) = NULL,
	@@StartRowIndex int = NULL,
	@@MaximumRows int = NULL

AS
SET NOCOUNT ON
--fix orderby
IF (ISNULL(@@OrderBy, '''')='''')
	SET @@OrderBy = ''f.Code ASC'' 

	--fix the top
IF IsNull(@@MaximumRows, 0) <= 0
	SET @@MaximumRows = 0
IF IsNull(@@StartRowIndex, -1) <= -1 OR @@MaximumRows = 0 
	SET @@StartRowIndex = 0

DECLARE @SQL nvarchar(1000)
DECLARE @WHERE nvarchar(1000)

SET @WHERE = ''''

IF @@MaximumRows >0
	SET @sql = ''SELECT [FirmId], [Code], [Name], [IsApproved], 
				(SELECT Count(FirmDataSourceId) FROM [dbo].[ib_FirmDataSource] ids WHERE ids.FirmId = x.FirmId)  FirmDataSources
	 FROM
	   (SELECT TOP('' + CONVERT(nvarchar(10), @@StartRowIndex + @@MaximumRows) + '')''
ELSE SET @sql = ''SELECT''

--build the query
SET @sql = @sql + '' f.[FirmId], f.[Code], f.[Name], f.[IsApproved] ''

IF @@MaximumRows >0
	SET @sql = @sql+'', ROW_NUMBER() OVER(ORDER BY '' + @@OrderBy + '') as RowNum''
ELSE SET @Sql = @sql + '', 
       (SELECT Count(ids.FirmDataSourceId) 
			FROM [dbo].[ib_FirmDataSource] ids (nolock) 
			WHERE ids.FirmId = f.FirmId) as FirmDataSources
''
SET @sql = @sql + ''
 FROM [ib_Firm] f (nolock) 
      '' + @where 

IF @@MaximumRows = 0
	SET @sql = @sql+''
 ORDER BY '' + @@OrderBy 

IF @@MaximumRows >0
	SET @sql = @sql +  '') as x
WHERE RowNum > '' + CONVERT(nvarchar(10), @@StartRowIndex) + '' ORDER BY RowNum''

-- Execute the query
EXEC sp_executesql @sql
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Firm_GetFirmsSortableAndPaginate_Count]''
');

GO
EXECUTE ('
/*
<details>
	<summary>Returns the Firms count</summary>
	<created author="laurentiu.macovei" date="Thu, 22 Sep 2006 16:44:41 GMT"/>
	<updated author="anil.kripalani" date="28 November 2006">Add nolock hints so can run during imports</updated>
</details>
*/
CREATE PROCEDURE [dbo].[ib_Firm_GetFirmsSortableAndPaginate_Count]
AS
SET NOCOUNT ON
	
DECLARE @SQL nvarchar(1000)
DECLARE @WHERE nvarchar(1000)

SET @WHERE = ''''
	
	SET @sql = ''SELECT COUNT(FirmId) 
	FROM [ib_Firm] f (nolock) '' + @WHERE

EXEC sp_executesql @sql
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Firm_GetItemIndex_For_FirmId_When_SortableAndPaginate]''
');

GO
EXECUTE ('
   /*
<details>
	<summary>Returns the item index for a given Regen Account Id when sortable and paginate. A filter may be set</summary>
	<created author="laurentiu.macovei" date="Thu, 22 Sep 2006 16:48:47 GMT"/>
</details>
*/
CREATE PROCEDURE [dbo].[ib_Firm_GetItemIndex_For_FirmId_When_SortableAndPaginate]
	@GetItemIndexForFirmId int,
	@@OrderBy varchar(100) = NULL

AS
SET NOCOUNT ON
--fix @GetItemIndexForFirmId

--fix orderby
IF (ISNULL(@@OrderBy, '''')='''')
	SET @@OrderBy = ''f.Code ASC'' 

BEGIN

DECLARE @SQL nvarchar(1000)
DECLARE @WHERE nvarchar(1000)

SET @WHERE = ''''

SET @sql = ''
DECLARE @Value int
SET @Value = -1
SELECT @Value = RowNum -1
	 FROM
	   (SELECT''

--build the query
SET @sql = @sql + '' [FirmId] ''

SET @sql = @sql+'', ROW_NUMBER() OVER(ORDER BY '' + @@OrderBy + '') as RowNum''

SET @sql = @sql + ''
 FROM [ib_Firm] f  
      '' + @where 
	SET @sql = @sql +  '') x
WHERE [FirmId] = '' + CONVERT(nvarchar(10), @GetItemIndexForFirmId)
+ ''; SELECT @Value''

-- Execute the query
EXEC sp_executesql @sql

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_GMI_GetBusinessDate]''
');

GO
EXECUTE ('-- =============================================
-- Author:		Lee Manifold
-- Create date: 23 Nov 2006
-- Description:	Pulls back a Businessdate for the file depending
--				on what Datasource and what day the file was submitted.		
--				gmi
-- History
-- Date				Author			Changes
-- 11 Dec 2006		LM				Changed Asiafut to Asafut
-- =============================================
CREATE PROCEDURE [dbo].[ib_GMI_GetBusinessDate]
	(
	@DataSourceCd	varchar(25),
	@AsofDate		datetime	output
	)
AS
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
	SET @AsofDate =			
		CASE 		
			WHEN UPPER(@DataSourceCd) = UPPER(''Asafut'') THEN		
				DATEADD(dd,-1, GETDATE())  	
			WHEN UPPER(@DataSourceCd) = UPPER(''USAfut'') THEN
				DATEADD(dd,-1, GETDATE()) 
			WHEN UPPER(@DataSourceCd) = UPPER(''Eurfut'')  THEN
				DATEADD(dd,-1, GETDATE()) 
			WHEN UPPER(@DataSourceCd) = UPPER(''Ausfut'')  THEN
				GETDATE()
			ELSE
				''Not Found''
		END

	IF DATENAME(Weekday,@AsofDate) = ''Saturday'' 
		BEGIN
			SET @AsOfDate = DATEADD(dd,-1,@AsOfDate)
		END
	IF DATENAME(Weekday,@AsofDate) = ''Sunday'' 
		BEGIN
			SET @AsOfDate = DATEADD(dd,-2,@AsOfDate)
		END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_IDEM_DS13_Load]''
');

GO
EXECUTE ('/*
Developer	:	Lee Manifold
Date		:	15 Sept 2006
Description	:	This stored procedure pulls data from the IDEM_DS13
				table and inserts it into the ib_Position.  Also, any
				new values encountered for firm, account, instrument, and currency create
				new values in the lookups, as well as new values in the data tables for
				these values.

				Whilst iterating through the records in IDEM_DS13, all 
				of these inserts are wrapped in a transaction so that any failure causes
				the changes fail.

Revision History:

06 Aug 2006		amk		Quantity size changed from 18,10 to 19,4
09 Aug 2006		amk		1) Process currency too
						2) New system for instrument codes (concatenate items to assemble)

*/
CREATE procedure [dbo].[ib_IDEM_DS13_Load]
	(
	@LocationPath		varchar(100)=NULL
	)
AS
SET NOCOUNT ON

	--Set the Datasource
	DECLARE @DataSourceCd		varchar(20)
--	DECLARE @DataSourceName		varchar(20)
--	SET @DataSourceName  = ''GMI -''
--	EXEC [dbo].[ib_DataSource_GetByFilePath] @LocationPath ,@DataSourceName , @DataSourceCd
	SET @DataSourceCd = ''xxxx''
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_IDEM_DS14_Load]''
');

GO
EXECUTE ('
/*
Developer	:	Lee Manifold
Date		:	18 Sept 2006
Description	:	This stored procedure pulls data from the IDEM_DS14
				table and inserts it into the ib_Position.  Also, any
				new values encountered for firm, account, instrument, and currency create
				new values in the lookups, as well as new values in the data tables for
				these values.

				Whilst iterating through the records in IDEM_DS13, all 
				of these inserts are wrapped in a transaction so that any failure causes
				the changes fail.

Revision History:

*/
CREATE procedure [dbo].[ib_IDEM_DS14_Load]
	(
	@LocationPath		varchar(100)=NULL
	)
AS
SET NOCOUNT ON

	--Set the Datasource
	DECLARE @DataSourceCd		varchar(20)
--	DECLARE @DataSourceName		varchar(20)
--	SET @DataSourceName  = ''GMI -''
--	EXEC [dbo].[ib_DataSource_GetByFilePath] @LocationPath ,@DataSourceName , @DataSourceCd
	SET @DataSourceCd = ''xxxx''
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_InstrumentDataSource_GetInstrumentDataSourcesSortableAndPaginate]''
');

GO
EXECUTE ('
CREATE PROCEDURE [dbo].[ib_InstrumentDataSource_GetInstrumentDataSourcesSortableAndPaginate]
	@InstrumentID int = NULL,
	@@OrderBy varchar(100) = NULL,
	@@StartRowIndex int = NULL,
	@@MaximumRows int = NULL

AS
SET NOCOUNT ON

/*
<details>
	<summary>Returns the instrument datasources sortable and paginate. A filter on the instrumentId may be set</summary>
	<created author="laurentiu.macovei" date="Thu, 14 Sep 2006 18:04:19 GMT"/>
	<updated author="Anil Kripalani" Date="28 November 2006">Nolock to avoid collission with imports</updated> 
	<updated author="Anil Kripalani" Date="29 October 2009">Return new price divisor too</updated> 
	<updated author="Alister McLeod" Date="23 March 2010">Return Instrument Name too</updated> 
	-- 17 Jun 2010 ED - MBAL 15621 - return BaseCode, too
	-- 23 Jun 2010 ED MBAL 15913 - Tidy up Trade/Settlement Price Corrections for Rounded Prices
</details>
*/

--fix orderby
IF (ISNULL(@@OrderBy, '''')='''')
	SET @@OrderBy = ''ds.Code ASC'' 

	--fix the top
IF IsNull(@@MaximumRows, 0) <= 0
	SET @@MaximumRows = 0
IF IsNull(@@StartRowIndex, -1) <= -1 OR @@MaximumRows = 0 
	SET @@StartRowIndex = 0

DECLARE @SQL nvarchar(2000)
DECLARE @WHERE nvarchar(1000)

SET @WHERE = ''''
IF @InstrumentID IS NOT NULL
	SET @WHERE = @WHERE + '' AND ids.InstrumentID = '' + cast(@InstrumentId as varchar(100))

IF @@MaximumRows >0
	SET @sql = ''SELECT [InstrumentDataSourceId], [InstrumentCode], [DataSourceCode], [CurrencyCode], [DataSourceInstrumentCode], [MarketValueDivisor], [StrikePriceDivisor], [PriceDivisor], [InstrumentName], BaseName, RunCloseOutReport 
	 FROM
	   (SELECT TOP('' + CONVERT(nvarchar(10), @@StartRowIndex + @@MaximumRows) + '')''
ELSE SET @sql = ''SELECT''

--build the query
SET @sql = @sql + '' ids.[InstrumentDataSourceId], i.[Code] as [InstrumentCode], ds.[Code] as [DataSourceCode], c.[Code] as [CurrencyCode], ids.[DataSourceInstrumentCode], ids.[MarketValueDivisor], ids.[StrikePriceDivisor], ids.[PriceDivisor], i.[Name] AS [InstrumentName], b.Name as BaseName, ids.RunCloseOutReport 
''

IF @@MaximumRows >0
	SET @sql = @sql+'', ROW_NUMBER() OVER(ORDER BY '' + @@OrderBy + '') as RowNum''

SET @sql = @sql + ''
 FROM [ib_InstrumentDataSource] ids (nolock)  
	LEFT JOIN [ib_Currency] c (nolock) ON ids.CurrencyID = c.CurrencyID
	LEFT JOIN ib_Base b (nolock) ON ids.BaseId=b.BaseId
	INNER JOIN [ib_Instrument] i (nolock) ON ids.InstrumentId = i.InstrumentId
	INNER JOIN [ib_DataSource] ds ON ids.DataSourceID = ds.DataSourceId
      '' + @where 

IF @@MaximumRows = 0
	SET @sql = @sql+''
 ORDER BY '' + @@OrderBy 

IF @@MaximumRows >0
	SET @sql = @sql +  '') x
WHERE RowNum > '' + CONVERT(nvarchar(10), @@StartRowIndex) + '' ORDER BY RowNum''

-- Execute the query
EXEC sp_executesql @sql
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_InstrumentDataSource_GetInstrumentDataSourcesSortableAndPaginate_Count]''
');

GO
EXECUTE ('/*
<details>
	<summary>Returns the instrument datasources count. A filter on the instrumentId may be set</summary>
	<created author="laurentiu.macovei" date="Thu, 14 Sep 2006 18:04:19 GMT"/>
	<updated author="Anil Kripalani" Date="28 November 2006">Nolock to avoid collission with imports</updated> 
</details>
*/
CREATE PROCEDURE [dbo].[ib_InstrumentDataSource_GetInstrumentDataSourcesSortableAndPaginate_Count]
	@InstrumentID int = NULL
AS
SET NOCOUNT ON
	
DECLARE @SQL nvarchar(2000)
DECLARE @WHERE nvarchar(1000)

SET @WHERE = ''''
	
IF @InstrumentID IS NOT NULL
	SET @WHERE = @WHERE + '' WHERE ids.InstrumentID = '' + cast(@InstrumentId as varchar(100))

	SET @sql = ''SELECT COUNT(InstrumentDataSourceId) 
	FROM [ib_InstrumentDataSource] ids (nolock)  
'' + @WHERE

EXEC sp_executesql @sql
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_InstrumentDataSource_GetItemIndex_For_InstrumentDataSourceId_When_SortableAndPaginate]''
');

GO
EXECUTE (' /*
<details>
	<summary>Returns the item index for a given instrument datasource id when sortable and paginate. A filter on the instrumentId may be set</summary>
	<created author="laurentiu.macovei" date="Thu, 14 Sep 2006 18:04:19 GMT"/>
</details>
-- 07 May 2014	ED	EIB 25600 - fix sorting
*/
create PROCEDURE [dbo].[ib_InstrumentDataSource_GetItemIndex_For_InstrumentDataSourceId_When_SortableAndPaginate]
	@InstrumentID int,
	@GetItemIndexForInstrumentDataSourceId int OUTPUT,
	@@OrderBy varchar(100) = NULL

AS
SET NOCOUNT ON
--fix @GetItemIndexForInstrumentDataSourceId

--fix orderby
IF (ISNULL(@@OrderBy, '''')='''')
	SET @@OrderBy = ''ds.Code ASC'' 

BEGIN

DECLARE @SQL nvarchar(1000)
DECLARE @WHERE nvarchar(1000)

SET @WHERE = ''''
IF ISNULL(@InstrumentID, -1)>0
	SET @WHERE = @WHERE + '' AND ids.InstrumentID = '' + cast(@InstrumentId as varchar(100))

SET @sql = ''
DECLARE @Value int
SET @Value = -1
SELECT @Value = RowNum -1
	 FROM
	   (SELECT''

--build the query
SET @sql = @sql + '' [InstrumentDataSourceId] ''

SET @sql = @sql+'', ROW_NUMBER() OVER(ORDER BY '' + @@OrderBy + '') as RowNum''

SET @sql = @sql + ''
 FROM [ib_InstrumentDataSource] ids (nolock)  
	LEFT JOIN [ib_Currency] c (nolock) ON ids.CurrencyID = c.CurrencyID
	LEFT JOIN ib_Base b (nolock) ON ids.BaseId=b.BaseId
	INNER JOIN [ib_Instrument] i (nolock) ON ids.InstrumentId = i.InstrumentId
	INNER JOIN [ib_DataSource] ds ON ids.DataSourceID = ds.DataSourceId
      '' + @where 
	SET @sql = @sql +  '') x
WHERE [InstrumentDataSourceId] = '' + CONVERT(nvarchar(10), @GetItemIndexForInstrumentDataSourceId)
+ '' SELECT @Value''

-- Execute the query
EXEC sp_executesql @sql

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Instrument_GetInstrumentsSortableAndPaginate]''
');

GO
EXECUTE ('
/*
<details>
	<summary>Returns the Instruments sortable and paginate. </summary>
	<created author="laurentiu.macovei" date="Thu, 14 Sep 2006 16:33:45 GMT"/>
	<updated author="anil.kripalani" date="28 November 2006">Add nolock hints so can run during imports</updated>
</details>
-- 13 May 2014  ED  EIB 25499 - add IsActive flag to ib_Instrument
*/
CREATE PROCEDURE [dbo].[ib_Instrument_GetInstrumentsSortableAndPaginate]
	@InstrumentName varchar(100) = NULL,
	@InstrumentCode varchar(100) = NULL,
	@InstrumentTypeCodeId int = NULL,
	@FilterByStartOnly bit=1,
	@@OrderBy varchar(100) = NULL,
	@@StartRowIndex int = NULL,
	@@MaximumRows int = NULL

AS
SET NOCOUNT ON
--fix orderby
IF (ISNULL(@@OrderBy, '''')='''')
	SET @@OrderBy = ''i.Code ASC'' 

	--fix the top
IF IsNull(@@MaximumRows, 0) <= 0
	SET @@MaximumRows = 0
IF IsNull(@@StartRowIndex, -1) <= -1 OR @@MaximumRows = 0 
	SET @@StartRowIndex = 0

DECLARE @SQL nvarchar(max)
DECLARE @WHERE nvarchar(max)

SET @WHERE = '' AND i.IsActive = 1 ''

IF ISNULL(@InstrumentName, '''') != ''''
BEGIN
	IF @FilterByStartOnly = 1
		SET @WHERE = @WHERE + '' AND [i].[Name] LIKE '''''' + @InstrumentName + ''%''''''
	ELSE SET @WHERE = @WHERE + '' AND [i].[Name] LIKE ''''%'' + @InstrumentName + ''%''''''
END

IF ISNULL(@InstrumentCode, '''') != ''''
BEGIN
	IF @FilterByStartOnly = 1
		SET @WHERE = @WHERE + '' AND [i].[Code] LIKE '''''' + @InstrumentCode + ''%''''''
	ELSE SET @WHERE = @WHERE + '' AND [i].[Code] LIKE ''''%'' + @InstrumentCode + ''%''''''
END

IF ISNULL(@InstrumentTypeCodeId, 0) > 0 
	SET @WHERE = @WHERE + '' AND [it].[InstrumentTypeId] = '' + Cast(@InstrumentTypeCodeId as varchar(100)) 

IF @@MaximumRows >0
	SET @sql = ''SELECT [InstrumentId], [InstrumentTypeId], [InstrumentTypeCode], [Code], [Name], [IsApproved], [LotSize], [TickSize], [BaseId], [BaseCode], 
						(SELECT Count(InstrumentDataSourceId) FROM [dbo].[ib_InstrumentDataSource] ids (nolock) WHERE ids.InstrumentId = x.InstrumentId)  InstrumentDataSources

	 FROM
	   (SELECT TOP('' + CONVERT(nvarchar(10), @@StartRowIndex + @@MaximumRows) + '')''
ELSE SET @sql = ''SELECT''

--build the query
SET @sql = @sql + '' i.[InstrumentId], i.[InstrumentTypeId], it.[Code] as InstrumentTypeCode,  i.[Code], i.[Name], i.[IsApproved], i.[LotSize], i.[TickSize], i.[BaseId], b.[Code] as BaseCode ''

IF @@MaximumRows >0
	SET @sql = @sql+'', ROW_NUMBER() OVER(ORDER BY '' + @@OrderBy + '') as RowNum''
ELSE SET @Sql = @sql + '', 
       (SELECT Count(ids.InstrumentDataSourceId) 
			FROM [dbo].[ib_InstrumentDataSource] ids (nolock) 
			WHERE ids.InstrumentId = i.InstrumentId) as InstrumentDataSources
''
SET @sql = @sql + ''
 FROM [ib_Instrument] i (nolock)   
	LEFT JOIN [ib_Base] b ON i.BaseId = b.BaseId
	INNER JOIN [ib_InstrumentType] it ON it.InstrumentTypeId = i.InstrumentTypeId 
      '' + @where 

IF @@MaximumRows = 0
	SET @sql = @sql+''
 ORDER BY '' + @@OrderBy 

IF @@MaximumRows >0
	SET @sql = @sql +  '') as x
WHERE RowNum > '' + CONVERT(nvarchar(10), @@StartRowIndex) + '' ORDER BY RowNum''

-- Execute the query
EXEC sp_executesql @sql
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Instrument_GetInstrumentsSortableAndPaginate_Count]''
');

GO
EXECUTE ('/*
<details>
	<summary>Returns the Instruments count</summary>
	<created author="laurentiu.macovei" date="Thu, 14 Sep 2006 16:44:41 GMT"/>
	<updated author="anil.kripalani" date="28 November 2006">Add nolock hints so can run during imports</updated>
</details>
-- 13 May 2014  ED  EIB 25499 - add IsActive flag to ib_Instrument
*/
CREATE PROCEDURE [dbo].[ib_Instrument_GetInstrumentsSortableAndPaginate_Count]
	@InstrumentName varchar(100) = NULL,
	@InstrumentCode varchar(100) = NULL,
	@InstrumentTypeCodeId int = NULL,
	@FilterByStartOnly bit=1
AS
SET NOCOUNT ON
	
DECLARE @SQL nvarchar(max)
DECLARE @WHERE nvarchar(max)

SET @WHERE = '' AND i.IsActive = 1 ''
	
IF ISNULL(@InstrumentName, '''') != ''''
BEGIN
	IF @FilterByStartOnly = 1
		SET @WHERE = @WHERE + '' AND [i].[Name] LIKE '''''' + @InstrumentName + ''%''''''
	ELSE SET @WHERE = @WHERE + '' AND [i].[Name] LIKE ''''%'' + @InstrumentName + ''%''''''
END

IF ISNULL(@InstrumentCode, '''') != ''''
BEGIN
	IF @FilterByStartOnly = 1
		SET @WHERE = @WHERE + '' AND [i].[Code] LIKE '''''' + @InstrumentCode + ''%''''''
	ELSE SET @WHERE = @WHERE + '' AND [i].[Code] LIKE ''''%'' + @InstrumentCode + ''%''''''
END

IF ISNULL(@InstrumentTypeCodeId, 0) > 0 
	SET @WHERE = @WHERE + '' AND [it].[InstrumentTypeId] = '' + Cast(@InstrumentTypeCodeId as varchar(100)) 

	SET @sql = ''SELECT COUNT(InstrumentId) 
	FROM [ib_Instrument] i (nolock)  
INNER JOIN [ib_InstrumentType] it ON it.InstrumentTypeId = i.InstrumentTypeId 
'' + @WHERE

EXEC sp_executesql @sql
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Instrument_GetItemIndex_For_InstrumentId_When_SortableAndPaginate]''
');

GO
EXECUTE ('   /*
<details>
	<summary>Returns the item index for a given Regen Account Id when sortable and paginate. A filter may be set</summary>
	<created author="laurentiu.macovei" date="Thu, 14 Sep 2006 16:48:47 GMT"/>
</details>
-- 13 May 2014  ED  EIB 25499 - add IsActive flag to ib_Instrument
*/
CREATE PROCEDURE [dbo].[ib_Instrument_GetItemIndex_For_InstrumentId_When_SortableAndPaginate]
	@InstrumentName varchar(100) = NULL,
	@InstrumentCode varchar(100) = NULL,
	@InstrumentTypeCodeId int = NULL,
	@FilterByStartOnly bit=1,
	@GetItemIndexForInstrumentId int,
	@@OrderBy varchar(100) = NULL

AS
SET NOCOUNT ON
--fix @GetItemIndexForInstrumentId

--fix orderby
IF (ISNULL(@@OrderBy, '''')='''')
	SET @@OrderBy = ''i.Code ASC'' 

BEGIN

DECLARE @SQL nvarchar(max)
DECLARE @WHERE nvarchar(max)

SET @WHERE = '' AND i.IsActive = 1 ''

IF ISNULL(@InstrumentName, '''') != ''''
BEGIN
	IF @FilterByStartOnly = 1
		SET @WHERE = @WHERE + '' AND [i].[Name] LIKE '''''' + @InstrumentName + ''%''''''
	ELSE SET @WHERE = @WHERE + '' AND [i].[Name] LIKE ''''%'' + @InstrumentName + ''%''''''
END

IF ISNULL(@InstrumentCode, '''') != ''''
BEGIN
	IF @FilterByStartOnly = 1
		SET @WHERE = @WHERE + '' AND [i].[Code] LIKE '''''' + @InstrumentCode + ''%''''''
	ELSE SET @WHERE = @WHERE + '' AND [i].[Code] LIKE ''''%'' + @InstrumentCode + ''%''''''
END

IF ISNULL(@InstrumentTypeCodeId, 0) > 0 
	SET @WHERE = @WHERE + '' AND [it].[InstrumentTypeId] = '' + Cast(@InstrumentTypeCodeId as varchar(100)) 


SET @sql = ''
DECLARE @Value int
SET @Value = -1
SELECT @Value = RowNum -1
	 FROM
	   (SELECT''

--build the query
SET @sql = @sql + '' [InstrumentId] ''

SET @sql = @sql+'', ROW_NUMBER() OVER(ORDER BY '' + @@OrderBy + '') as RowNum''

SET @sql = @sql + ''
 FROM [ib_Instrument] i  
	INNER JOIN [ib_InstrumentType] it ON it.InstrumentTypeId = i.InstrumentTypeId 
      '' + @where 
	SET @sql = @sql +  '') x
WHERE [InstrumentId] = '' + CONVERT(nvarchar(10), @GetItemIndexForInstrumentId)
+ ''; SELECT @Value''

-- Execute the query
EXEC sp_executesql @sql

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_MatchCodeTolerance_GetItemIndexForMatchCodeToleranceIdWhenSortableAndPaginate]''
');

GO
EXECUTE ('-- Stored Procedure

/*
----------------------------------------------------------------------------------------------------

-- 24 Feb 09 : ED created
-- Purpose: get list count
*/

CREATE PROCEDURE [dbo].[ib_MatchCodeTolerance_GetItemIndexForMatchCodeToleranceIdWhenSortableAndPaginate]
(
	@GetItemIndexForMatchCodeToleranceId int output,
	@OrderBy varchar(100) = NULL
)
AS
SET NOCOUNT ON
BEGIN
--fix orderby
IF (ISNULL(@OrderBy, '''')='''')
	SET @OrderBy = ''MatchCode ASC'' 

BEGIN

DECLARE @SQL nvarchar(1000)
DECLARE @WHERE nvarchar(1000)

SET @WHERE = ''''

SET @sql = ''
DECLARE @Value int
SET @Value = -1
SELECT @Value = RowNum -1
	 FROM
	   (SELECT''

--build the query
SET @sql = @sql + '' MatchCodeToleranceId ''

SET @sql = @sql+'', ROW_NUMBER() OVER(ORDER BY '' + @OrderBy + '') as RowNum''

SET @sql = @sql + ''
 FROM ib_MatchCodeTolerance 	
      '' + @where 
	SET @sql = @sql +  '') x
WHERE MatchCodeToleranceId = '' + CONVERT(nvarchar(10), @GetItemIndexForMatchCodeToleranceId)
+ '' SELECT @Value''

-- Execute the query
EXEC sp_executesql @sql

END


END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_MatchCodeTolerance_GetTolerancesSortableAndPaginate]''
');

GO
EXECUTE ('/*
----------------------------------------------------------------------------------------------------

-- 24 Feb 09 : ED created
-- Purpose: get list
*/

CREATE PROCEDURE [dbo].[ib_MatchCodeTolerance_GetTolerancesSortableAndPaginate]
(
	@OrderBy varchar(100) = NULL,
	@StartRowIndex int = NULL,
	@MaximumRows int = NULL
)
AS
SET NOCOUNT ON
BEGIN
--fix orderby
IF (ISNULL(@OrderBy, '''')='''')
	SET @OrderBy = ''MatchCode ASC'' 

	--fix the top
IF IsNull(@MaximumRows, 0) <= 0
	SET @MaximumRows = 0
IF IsNull(@StartRowIndex, -1) <= -1 OR @MaximumRows = 0 
	SET @StartRowIndex = 0

DECLARE @SQL nvarchar(1000)
DECLARE @WHERE nvarchar(1000)

SET @WHERE = ''''

IF @MaximumRows >0
	SET @sql = ''SELECT [MatchCodeToleranceId],[MatchCode],[Tolerance],[CreateDate]
      ,[CreateUsername],[UpdateDate],[UpdateUsername]
	 FROM
	   (SELECT TOP('' + CONVERT(nvarchar(10), @StartRowIndex + @MaximumRows) + '')''
ELSE SET @sql = ''SELECT''

--build the query
SET @sql = @sql + '' [MatchCodeToleranceId],[MatchCode],[Tolerance],[CreateDate]
      ,[CreateUsername],[UpdateDate],[UpdateUsername] ''

IF @MaximumRows >0
	SET @sql = @sql+'', ROW_NUMBER() OVER(ORDER BY '' + @OrderBy + '') as RowNum''

SET @sql = @sql + ''
 FROM ib_MatchCodeTolerance  
      '' + @where 

IF @MaximumRows = 0
	SET @sql = @sql+''
 ORDER BY '' + @OrderBy 

IF @MaximumRows >0
	SET @sql = @sql +  '') x
WHERE RowNum > '' + CONVERT(nvarchar(10), @StartRowIndex) + '' ORDER BY RowNum''

-- Execute the query
EXEC sp_executesql @sql

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_MatchCode_GetItemIndexForMatchCodeIdWhenSortableAndPaginate]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_MatchCode_GetItemIndexForMatchCodeIdWhenSortableAndPaginate]
	@TemplateId int,
	@GetItemIndexForMatchCodeId int,
	@@OrderBy varchar(100) = NULL

AS
SET NOCOUNT ON
  /*
<details>
	<summary>Returns the item index for a given TemplateId when sortable and paginate. A filter may be set</summary>
	<created author="Alister McLeod" Date="29 Mar 2010 15:09" /> 
</details>

-- History
-- 10 Apr 2011	AAJM	Added joins to facilitate additional column sorting
*/

--fix orderby
IF (ISNULL(@@OrderBy, '''')='''')
	SET @@OrderBy = ''m.MatchCode ASC'' 

BEGIN

DECLARE @SQL nvarchar(1000)
DECLARE @WHERE nvarchar(1000)

SET @WHERE = ''''
IF ISNULL(@TemplateId, -1) > 0
	SET @WHERE = @WHERE + '' AND m.TemplateId = '' + CAST(@TemplateId AS VARCHAR(100))

SET @sql = ''
DECLARE @Value int
SET @Value = -1;

WITH x AS
	   (SELECT''

--build the query
SET @sql = @sql + '' [MatchCodeId]  ''

SET @sql = @sql+'', ROW_NUMBER() OVER(ORDER BY '' + @@OrderBy + '') as RowNum''

SET @sql = @sql + ''
 FROM [ib_MatchCode] m
 LEFT JOIN [dbo].[ib_TemplateTypeClass] ttc ON m.TemplateTypeClassId = ttc.TemplateTypeClassId 
 LEFT JOIN [dbo].[ib_Broker] b ON m.BrokerId = b.BrokerId  
 WHERE 1=1 
      '' + @where 

SET @sql = @sql +  '')

SELECT TOP (1) @Value = CAST (RowNum - 1 AS INTEGER)
from x
where x.[MatchCodeId] = '' + CONVERT(NVARCHAR(10), @GetItemIndexForMatchCodeId)
+ '' ;

SELECT @Value;''

-- Execute the query
EXEC sp_executesql @sql

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_MatchCode_GetItemIndex_For_MatchCodeId_When_SortableAndPaginate]''
');

GO
EXECUTE ('
   /*
<details>
	<summary>Returns the item index for a given MatchCode Id when sortable and paginate. A filter may be set</summary>
	<created author="Emilian Damian" Date="2 Mar 2009" /> 
</details>
*/
CREATE PROCEDURE [dbo].[ib_MatchCode_GetItemIndex_For_MatchCodeId_When_SortableAndPaginate]
	@MatchCode varchar(100) = NULL,
	@FilterByStartOnly bit=1,
	@GetItemIndexForMatchCodeId int,
	@@OrderBy varchar(100) = NULL

AS
SET NOCOUNT ON

--fix orderby
IF (ISNULL(@@OrderBy, '''')='''')
	SET @@OrderBy = ''i.MatchCode ASC'' 

BEGIN

DECLARE @SQL nvarchar(1000)
DECLARE @WHERE nvarchar(1000)

SET @WHERE = ''''

IF ISNULL(@MatchCode, '''') != ''''
BEGIN
	IF @FilterByStartOnly = 1
		SET @WHERE =  ''[i].[MatchCode] LIKE '''''' + @MatchCode + ''%''''''
	ELSE SET @WHERE = ''[i].[MatchCode] LIKE ''''%'' + @MatchCode + ''%''''''
END

IF ISNULL(@WHERE, '''') != ''''
	BEGIN
		SET @WHERE = @WHERE;
	END

SET @sql = ''
DECLARE @Value int
SET @Value = -1
SELECT @Value = RowNum -1 
	 FROM
	   (SELECT''

--build the query
SET @sql = @sql + '' [MatchCodeId] ''

SET @sql = @sql+'', ROW_NUMBER() OVER(ORDER BY '' + @@OrderBy + '') as RowNum''
IF ISNULL(@WHERE, '''') != ''''
	BEGIN
		SET @WHERE = '' WHERE '' + @WHERE
	END
SET @sql = @sql + ''
  
 FROM [ib_MatchCode] i  '' + @where 
	SET @sql = @sql +  '') x
WHERE [MatchCodeId] = '' + CONVERT(nvarchar(10), @GetItemIndexForMatchCodeId)
+ ''; SELECT @Value''

-- Execute the query
EXEC sp_executesql @sql

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_MatchCode_GetMatchCodesByTemplateIdSortableAndPaginate]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_MatchCode_GetMatchCodesByTemplateIdSortableAndPaginate]
	@TemplateId int = NULL,
	@@OrderBy varchar(100) = NULL,
	@@StartRowIndex int = NULL,
	@@MaximumRows int = NULL,
	@MatchCode varchar(100) = NULL

AS
SET NOCOUNT ON
/*
<details>
	<summary>Returns the MatchCode Count by TemplateId. A filter on the TemplateId may be set</summary>
	<created author="Alister McLeod" Date="Monday, 29 March 2010, 14:45" />		
</details>

-- History
-- 10 Apr 2011	AAJM	Add Broker Code column
-- 16 Apr 2014	ED	EIB 25547 - Add filter by matchcode/exchange
*/

--fix orderby
IF (ISNULL(@@OrderBy, '''')='''')
	SET @@OrderBy = ''m.MatchCode ASC'' 

	--fix the top
IF IsNull(@@MaximumRows, 0) <= 0
	SET @@MaximumRows = 0
IF IsNull(@@StartRowIndex, -1) <= -1 OR @@MaximumRows = 0 
	SET @@StartRowIndex = 0

DECLARE @SQL nvarchar(1000)
DECLARE @WHERE nvarchar(1000)

SET @WHERE = ''''
IF @TemplateId IS NOT NULL
	SET @WHERE = @WHERE + '' AND m.TemplateId = '' + cast(@TemplateId as varchar(100))
IF @MatchCode IS NOT NULL
	SET @WHERE = @WHERE + '' AND m.MatchCode LIKE ''''%'' + @MatchCode +''%'''' ''
IF @@MaximumRows >0
	SET @sql = ''SELECT [MatchCodeId], [TemplateId], [MatchCode], [TemplateTypeClassId], [TemplateTypeClassCode], [BrokerCode]   
	 FROM
	   (SELECT TOP('' + CONVERT(nvarchar(10), @@StartRowIndex + @@MaximumRows) + '')''
ELSE SET @sql = ''SELECT''

--build the query
SET @sql = @sql + '' m.[MatchCodeId], m.[TemplateId], m.[MatchCode], m.[TemplateTypeClassId], ttc.[Code] AS [TemplateTypeClassCode], b.[Code] AS [BrokerCode] ''

IF @@MaximumRows >0
	SET @sql = @sql+'', ROW_NUMBER() OVER(ORDER BY '' + @@OrderBy + '') as RowNum''

SET @sql = @sql + ''
 FROM [dbo].[ib_MatchCode] m 
 LEFT JOIN [dbo].[ib_TemplateTypeClass] ttc ON m.TemplateTypeClassId = ttc.TemplateTypeClassId 
 LEFT JOIN [dbo].[ib_Broker] b ON m.BrokerId = b.BrokerId 
 WHERE 1=1 '' + @where 

IF @@MaximumRows = 0
	SET @sql = @sql+''
 ORDER BY '' + @@OrderBy 

IF @@MaximumRows >0
	SET @sql = @sql +  '') x
WHERE RowNum > '' + CONVERT(nvarchar(10), @@StartRowIndex) + '' ORDER BY RowNum''

-- Execute the query
EXEC sp_executesql @sql
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_MatchCode_GetMatchCodesByTemplateIdSortableAndPaginate_Count]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_MatchCode_GetMatchCodesByTemplateIdSortableAndPaginate_Count]
	@TemplateId int = NULL,
	@MatchCode varchar(100) = NULL
AS
SET NOCOUNT ON
/*
<details>
	<summary>Returns Match Codes -- sortable and paginate. A filter on the TemplateId may be set</summary>
	<created author="Alister McLeod" Date="Monday, 29 March 2010, 14:45" />		
</details>
--  16 Apr 2014     ED     EIB 25547 - Add filter by matchcode/exchange
*/
	
DECLARE @SQL nvarchar(1000)
DECLARE @WHERE nvarchar(1000)

SET @WHERE = ''''
	
IF @TemplateId IS NOT NULL
	SET @WHERE = @WHERE + '' AND m.TemplateId = '' + cast(@TemplateId as varchar(100))
IF @MatchCode IS NOT NULL
	SET @WHERE = @WHERE + '' AND m.MatchCode LIKE ''''%'' + @MatchCode +''%'''' ''

SET @sql = ''SELECT COUNT(MatchCodeId) 
	FROM [ib_MatchCode] m WHERE 1 = 1'' + @WHERE

EXEC sp_executesql @sql
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_MatchCode_GetMatchCodesPaginate_Count]''
');

GO
EXECUTE ('
/*
<details>
	<summary>Returns MatchCodes count</summary>
	<created author="Petru Konrad Bercea" Date="02 Mar 2009" /> 
</details>
*/
CREATE PROCEDURE [dbo].[ib_MatchCode_GetMatchCodesPaginate_Count]
	@MatchCode varchar(100) = NULL,
	@FilterByStartOnly bit=1
AS
SET NOCOUNT ON
	
DECLARE @SQL nvarchar(1000)
DECLARE @WHERE nvarchar(1000)

SET @WHERE = ''''

IF ISNULL(@MatchCode, '''') != ''''
BEGIN
	IF @FilterByStartOnly = 1
		SET @WHERE = '' WHERE [i].[MatchCode] LIKE '''''' + @MatchCode + ''%''''''
	ELSE SET @WHERE = '' WHERE [i].[MatchCode] LIKE ''''%'' + @MatchCode + ''%''''''
END

	SET @sql = ''SELECT COUNT(MatchCodeId) 
	FROM [ib_MatchCode] i (nolock) '' + @WHERE

EXEC sp_executesql @sql
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_MatchCode_GetMatchCodesSortableAndPaginate]''
');

GO
EXECUTE ('
/*
<details>
	<summary>Returns the MatchCodes sortable and paginate. </summary>
	<created author="Petru Konrad Bercea" date="2 Mar 2009"/>
</details>
--  06 May 2014     ED     EIB 25547 - fix query length
*/
CREATE PROCEDURE [dbo].[ib_MatchCode_GetMatchCodesSortableAndPaginate]
	@MatchCode varchar(100) = NULL,
	@FilterByStartOnly bit=1,
	@@OrderBy varchar(100) = NULL,
	@@StartRowIndex int = NULL,
	@@MaximumRows int = NULL

AS
SET NOCOUNT ON
--fix orderby
IF (ISNULL(@@OrderBy, '''')='''')
	SET @@OrderBy = ''i.MatchCode ASC'' 

--fix the top
IF IsNull(@@MaximumRows, 0) <= 0
	SET @@MaximumRows = 0
IF IsNull(@@StartRowIndex, -1) <= -1 OR @@MaximumRows = 0 
	SET @@StartRowIndex = 0

DECLARE @SQL nvarchar(max)
DECLARE @WHERE nvarchar(max)

SET @WHERE = ''''
SET @SQL = ''''

IF ISNULL(@MatchCode, '''') != ''''
BEGIN
	IF @FilterByStartOnly = 1
		SET @WHERE = '' WHERE [i].[MatchCode] LIKE '''''' + @MatchCode + ''%''''''
	ELSE SET @WHERE = '' WHERE [i].[MatchCode] LIKE ''''%'' + @MatchCode + ''%''''''
END

IF @@MaximumRows >0
	SET @sql = ''SELECT [MatchCodeId], [MatchCode], CONCAT(MatchCode,'''' - '''', Description) as Display
	 FROM
	   (SELECT TOP('' + CONVERT(nvarchar(10), @@StartRowIndex + @@MaximumRows) + '')''
ELSE SET @sql = ''SELECT''

--build the query
SET @sql = @sql + '' i.[MatchCodeId], i.[MatchCode], t.[Description] ''

IF @@MaximumRows >0
	SET @sql = @sql+'', ROW_NUMBER() OVER(ORDER BY '' + @@OrderBy + '') as RowNum''
ELSE SET @Sql = @sql + '' ''
SET @sql = @sql + ''
 FROM [ib_MatchCode] i (nolock) JOIN ib_Template t on i.TemplateId = t.TemplateId   
      '' + @where 

IF @@MaximumRows = 0
	SET @sql = @sql+''
 ORDER BY '' + @@OrderBy 

IF @@MaximumRows >0
	SET @sql = @sql +  '') as x
WHERE RowNum > '' + CONVERT(nvarchar(10), @@StartRowIndex) + '' ORDER BY RowNum''

-- Execute the query
EXEC sp_executesql @sql
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_NostroBalance_GetItemIndexForNostroBalanceIdWhenSortableAndPaginate]''
');

GO
EXECUTE ('/*
----------------------------------------------------------------------------------------------------

-- 26 Feb 09 : ED created
-- Purpose: get list count
*/

CREATE PROCEDURE [dbo].[ib_NostroBalance_GetItemIndexForNostroBalanceIdWhenSortableAndPaginate]
(
	@GetItemIndexForNostroBalanceId int output,
	@TemplateId int,
	@StartDate datetime,
	@OrderBy varchar(100) = NULL
)
AS
SET NOCOUNT ON
BEGIN
--fix orderby
IF (ISNULL(@OrderBy, '''')='''')
	SET @OrderBy = ''MatchCode ASC'' 

BEGIN

DECLARE @SQL nvarchar(1000)
DECLARE @WHERE nvarchar(1000)

SET @WHERE = '' WHERE t.TemplateId=''+convert(nvarchar,@TemplateId)+'' and convert(nvarchar,BalanceDate,21) >= '''''' + Convert(nvarchar, @StartDate, 21) + ''''''''

SET @sql = ''
DECLARE @Value int
SET @Value = -1
SELECT @Value = RowNum -1
	 FROM
	   (SELECT''

--build the query
SET @sql = @sql + '' NostroBalanceId ''

SET @sql = @sql+'', ROW_NUMBER() OVER(ORDER BY '' + @OrderBy + '') as RowNum''

SET @sql = @sql + ''
 FROM ib_NostroBalance 	nb
INNER JOIN ib_MatchCode mc ON nb.MatchCodeId=mc.MatchCodeId
INNER JOIN ib_Template t ON t.TemplateId=mc.TemplateId
      '' + @where 
	SET @sql = @sql +  '') x
WHERE NostroBalanceId = '' + CONVERT(nvarchar(10), @GetItemIndexForNostroBalanceId)
+ '' SELECT @Value''

-- Execute the query
EXEC sp_executesql @sql

END


END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_NostroBalance_GetNostroBalancesSortableAndPaginate]''
');

GO
EXECUTE ('/*
----------------------------------------------------------------------------------------------------

-- 26 Feb 09 	ED		Created
-- Purpose: get list

-- History:
-- 06 Oct 09	AAJM	Applied MatchCode Security based on UserId MBAL-11773
*/

CREATE PROCEDURE [dbo].[ib_NostroBalance_GetNostroBalancesSortableAndPaginate]
(
	@TemplateId int,
	@UserId uniqueidentifier,
	@StartDate datetime,
	@OrderBy varchar(100) = NULL,
	@StartRowIndex int = NULL,
	@MaximumRows int = NULL
)
AS
SET NOCOUNT ON
BEGIN
--fix orderby
IF (ISNULL(@OrderBy, '''')='''')
	SET @OrderBy = ''MatchCode ASC'' 

	--fix the top
IF IsNull(@MaximumRows, 0) <= 0
	SET @MaximumRows = 0
IF IsNull(@StartRowIndex, -1) <= -1 OR @MaximumRows = 0 
	SET @StartRowIndex = 0

DECLARE @SQL nvarchar(1000)
DECLARE @WHERE nvarchar(1000)

SET @WHERE = '' WHERE  (ar.Code = ''''ReadOnly'''' OR ar.Code = ''''Full'''') AND t.TemplateId=''+convert(nvarchar,@TemplateId)+'' and convert(nvarchar,BalanceDate,21) >= '''''' + Convert(nvarchar, @StartDate, 21) + ''''''''

IF @MaximumRows >0
	SET @sql = ''SELECT [NostroBalanceId],Description,[MatchCode],[BalanceDate],[InternalBalance],[ExternalBalance],[CreateDate]
      ,[CreateUsername],[UpdateDate],[UpdateUsername]
	 FROM
	   (SELECT TOP('' + CONVERT(nvarchar(10), @StartRowIndex + @MaximumRows) + '')''
ELSE SET @sql = ''SELECT''

--build the query
SET @sql = @sql + '' [NostroBalanceId],t.Description,[MatchCode],[BalanceDate],[InternalBalance],[ExternalBalance],nb.[CreateDate]
      ,nb.[CreateUsername],nb.[UpdateDate],nb.[UpdateUsername] ''

IF @MaximumRows >0
	SET @sql = @sql+'', ROW_NUMBER() OVER(ORDER BY '' + @OrderBy + '') as RowNum''

SET @sql = @sql + ''
 FROM ib_NostroBalance nb
INNER JOIN ib_MatchCode mc ON mc.MatchCodeId=nb.MatchCodeId  
INNER JOIN ib_Template t ON mc.TemplateId=t.TemplateId
INNER JOIN ib_UserMatchCodeAccess umca ON umca.UserId='''''' + convert(varchar(255), @UserId) + '''''' AND umca.MatchCodeId = mc.MatchCodeId 
INNER JOIN ib_AccessRight ar ON umca.AccessRightId = ar.AccessRightId
      '' + @where 

IF @MaximumRows = 0
	SET @sql = @sql+''
 ORDER BY '' + @OrderBy 

IF @MaximumRows >0
	SET @sql = @sql +  '') x
WHERE RowNum > '' + CONVERT(nvarchar(10), @StartRowIndex) + '' ORDER BY RowNum''

-- Execute the query
EXEC sp_executesql @sql

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Nostro_GetQueryResultsMatches]''
');

GO
EXECUTE ('-- =============================================
-- Author:		<P. Konrad Bercea>
-- Create date: <23.03.2009>
-- Description:	<Retrieves the Query Results>
--
-- Revision History
--
-- Konrad 26.03.2009 Added ShortNotes and AmountFrom and AmountTo replacing the Amount input param
-- Konrad 27.03.2009 Show Matches for a specific Match Group only.
-- =============================================
CREATE PROCEDURE [dbo].[ib_Nostro_GetQueryResultsMatches] 
	(
		@GroupNumber int
    )
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    DECLARE @SQL nvarchar(4000)
	DECLARE @WHERE nvarchar(4000)
    DECLARE @AmountSign decimal(18, 4)

    

	SET @WHERE = '' WHERE nm.GroupNumber=''+cast(@GroupNumber as varchar(100));


SET @sql = ''SELECT n.[NostroId],[ValueDate],[TransDate],[Amount],[TransactionType],[InternalReference],[ExternalReference]
					,[Narrative],n.[AccountId],n.[CurrencyId],n.[DataSourceId],[TempTableRecordId],
			CASE WHEN ABS(AMOUNT)!=AMOUNT THEN ABS(AMOUNT) ELSE NULL END as Payment,
			CASE WHEN ABS(AMOUNT)=AMOUNT THEN AMOUNT ELSE NULL END as Receipt
			,n.[DepartmentId]
			,GroupNumber
			,CASE WHEN n.[DepartmentId] IS NOT NULL THEN dpt.[Code] ELSE '''''''' END As DepartmentCode
			,n.[Notes] As notes
			,Substring(n.[Notes],0,20) As ShortNotes
            ,mc.[MatchCode] As MatchCode
            ,CASE WHEN tc.[InternalExternalCode] = ''''E'''' THEN ''''S'''' ELSE ''''L'''' END As LedgerOrStatement
			
	
	FROM [ib_Nostro] n (nolock)
		INNER JOIN ib_Account a ON a.AccountId=n.AccountId
		INNER JOIN ib_Firm f ON f.FirmId=a.FirmId
		INNER JOIN ib_TemplateCompare tc ON tc.DataSourceId=n.DataSourceId AND tc.FirmId=f.FirmId
		INNER JOIN ib_Template t ON t.TemplateId=tc.TemplateId
		LEFT JOIN ib_Department dpt ON dpt.DepartmentId=n.DepartmentId
		INNER JOIN ib_TemplateGroup tg ON tg.TemplateId=t.TemplateId AND tg.AccountId=n.AccountId  AND tg.CurrencyId=n.CurrencyId
        LEFT JOIN ib_MatchCode mc ON mc.MatchCode = tg.Description
		INNER JOIN ib_NostroMatch nm ON nm.NostroId=n.NostroId 
      '' + @WHERE 

-- Execute the query
EXEC sp_executesql @sql


END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Nostro_GetSortableAndPaginableCount]''
');

GO
SET ANSI_NULLS OFF

GO
EXECUTE ('/*
----------------------------------------------------------------------------------------------------

-- 12 Feb 09 : ED created
-- Purpose: Get the nostro records paginable count
*/


CREATE PROCEDURE [dbo].[ib_Nostro_GetSortableAndPaginableCount]
(
	@MatchCode varchar(100),
	@TemplateId int = null,
	@InternalExternalCode char(1),
	@WhatView varchar(255) = null
)
AS
SET NOCOUNT ON
BEGIN
			
IF (ISNULL(@WhatView, '''')='''')
	SET @WhatView = ''Outstanding''
 
DECLARE @SQL nvarchar(4000)
DECLARE @WHERE nvarchar(4000)
SET @WHERE = '' WHERE tg.[Description]=''''''+@MatchCode+'''''' AND InternalExternalCode=''''''+@InternalExternalCode+''''''''
IF (@TemplateId IS NOT NULL)
	SET @WHERE = @WHERE + '' AND tg.TemplateId = '' + cast(@TemplateId as varchar(100))
IF (@WhatView = ''Outstanding'')
	SET @WHERE = @WHERE + '' AND NOT EXISTS(SELECT 1 FROM ib_NostroMatch WHERE NostroId=n.NostroId) ''
ELSE
IF (@WhatView = ''Matching'')
	SET @WHERE = @WHERE + '' AND EXISTS(SELECT 1 FROM ib_NostroMatch WHERE NostroId=n.NostroId AND convert(varchar(10),CreateDate,111)=convert(varchar(10),getdate(),111))'' 
IF (@WhatView=''All'')
 	SET @WHERE = @WHERE + '' AND 
		(
		EXISTS(SELECT 1 FROM ib_NostroMatch WHERE NostroId=n.NostroId AND convert(varchar(10),CreateDate,111)=convert(varchar(10),getdate(),111))
		OR NOT EXISTS(SELECT 1 FROM ib_NostroMatch WHERE NostroId=n.NostroId))''
		 

 SET @sql = ''SELECT COUNT(*) ''

--build the query
SET @sql = @sql + '' ''


SET @sql = @sql + ''
 FROM [ib_Nostro] n (nolock)
	INNER JOIN ib_Account a ON a.AccountId=n.AccountId
	INNER JOIN ib_Firm f ON f.FirmId=a.FirmId
	INNER JOIN ib_TemplateCompare tc ON tc.DataSourceId=n.DataSourceId AND tc.FirmId=f.FirmId
	INNER JOIN ib_Template t ON t.TemplateId=tc.TemplateId
	INNER JOIN ib_TemplateGroup tg ON tg.TemplateId=t.TemplateId AND tg.AccountId=n.AccountId  AND tg.CurrencyId=n.CurrencyId
      '' + @where 

-- Execute the query
EXEC sp_executesql @sql


END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Peoplesoft_13]''
');

GO
SET ANSI_NULLS ON

GO
EXECUTE ('/*
<details>
 <summary>Deletes a data source by its id from the ib_DataSource table</summary>
 <created author="Laurentiu Macovei" Date="Friday, 8 September 2006 11:20PM GMT" /> 
</details>
*/
CREATE PROCEDURE [dbo].[ib_Peoplesoft_13]
(
	@DateAsBritishFrench  varchar(8),
	@Output               int = 0 output 
)
AS
SET NOCOUNT ON

  SET @Output = ISDATE(@DateAsBritishFrench)
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Position_GetSelected_krip_testing]''
');

GO
EXECUTE ('  /*
<details>
 <summary>Returns selected positions</summary>
 <created author="anil.kripalani" date="17 Oct 2006"/>
 <updated author="anil.kripalani" date="19 Oct 2006">
	new instr code parameter
 </updated>
 <updated author="anil.kripalani" date="28 Nov 2006">
	optimize
 </updated>
</details>
*/
create PROCEDURE [dbo].[ib_Position_GetSelected_krip_testing]
	@AsOfDate			DATETIME
	, @ExchangeCode		VARCHAR(25) = ''%''
	, @DataSourceCode	VARCHAR(100) = ''%''
	, @FirmCode			VARCHAR(100) = ''%''
	, @InstrumentCode	VARCHAR(100) = ''%''
AS
SET NOCOUNT ON

DECLARE @sql nvarchar(2000)

SET @sql = ''
SELECT TOP 1000 e.Code AS Exchange, ds.Code AS [Data Source]
	, i.Code AS [Instrument]
	, p.Quantity
	, CONVERT(VARCHAR(10), p.AsOfDate, 111) AS [As Of]
	, CONVERT(VARCHAR(4), p.ExpiryYear) + ''''/'''' + CONVERT(VARCHAR(2), p.ExpiryMonth) + CASE WHEN p.ExpiryDay IS NULL THEN '''''''' ELSE ''''/'''' + CONVERT(VARCHAR(2), p.ExpiryDay) END AS Expiry
	, p.StrikePrice AS [Strike Price], cur.Code AS [Currency]
	, p.OptionTypeCode AS [Opt Type]
	, f.Code AS [Firm], a.Code AS [Account], c.Code AS [Class]
	, p.MarketValue AS [Market Value]
	, p.TrxTypeCode AS [Trx Type]
	FROM ib_Position p
		JOIN ib_DataSource ds ON ds.DataSourceId = p.DataSourceId
		JOIN ib_Exchange e ON e.ExchangeId = p.ExchangeId
		JOIN ib_Firm f ON f.FirmId = p.FirmId
		LEFT OUTER JOIN ib_Account a ON a.AccountId = p.AccountId
		JOIN ib_Instrument i ON i.InstrumentId = p.InstrumentId
		LEFT OUTER JOIN ib_Class c ON c.ClassId = p.ClassId
		JOIN ib_Currency cur ON cur.CurrencyId = p.CurrencyId
	WHERE e.Code LIKE '''''' + @ExchangeCode + '''''' 
		AND ds.Code LIKE '''''' + @DataSourceCode + '''''' 
		AND f.Code LIKE '''''' + @FirmCode + '''''' 
		AND p.AsOfDate = '''''' + CONVERT(VARCHAR(30), @AsOfDate) + '''''' 
		AND i.Code LIKE '''''' + @InstrumentCode + '''''' 
	ORDER BY ds.Code, e.Code
''

exec sp_executesql @sql
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Report_GetReportsPaginateAndSortable]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Report_GetReportsPaginateAndSortable]
	@SiteID INT = NULL
	, @StartDate DATETIME = NULL
	, @EndDate DATETIME = NULL
	, @ReportType VARCHAR(50) = NULL
	, @@OrderBy VARCHAR(100) = NULL
	, @@StartRowIndex INT = NULL
	, @@MaximumRows INT = NULL
	, @UserId UNIQUEIDENTIFIER
AS
SET NOCOUNT ON

/*
<details>
	<summary> Selects records from Reports table. Allows filtering, sorting and ordering. </summary>
	<created author="Laurentiu Macovei" Date="Saturday, 05 Aug 2006 02:36AM GMT" />
	<updated author="Anil Kripalani" Date="8 Dec 2006">
		Include Notes too
	</updated>
	<updated author="Emilian Damian" Date="24 Feb 2009">
		changed format of date from 109 to 21
	</updated>
	-- 25 Feb 09 ED : convert CreateDate too
</details>
*/
--	17 Jan 2011		amk		MBAL-17233: for all sites, only show reports on sites user has access to

--fix orderby
IF (ISNULL(@@OrderBy, '''')='''')
	SET @@OrderBy = ''ReportId DESC'' 

DECLARE @sql nvarchar(1000)
DECLARE @where nvarchar(1000)
SET @where = ''''

--set the where condition
--check the siteID
IF @SiteID IS NOT NULL
	SET @where = '' AND r.SiteId = ''+ Convert(nvarchar, @SiteID)
	
IF @ReportType IS NOT NULL
	SET @where = '' AND r.ReportType = ''''''+ Convert(nvarchar, @ReportType) + ''''''''

--check the createDate
IF @StartDate IS NOT NULL 
	 SET @where = @where + '' AND convert(nvarchar,r.CreateDate,21) >= '''''' + Convert(nvarchar, @StartDate, 21) + ''''''''
IF @EndDate IS NOT NULL
	 SET @where = @where + '' AND convert(nvarchar,r.CreateDate,21) <= '''''' + Convert(nvarchar, @EndDate, 21) +''''''''


--fix the top
IF IsNull(@@MaximumRows, 0) <= 0
	SET @@MaximumRows = 0
IF IsNull(@@StartRowIndex, -1) <= -1 OR @@MaximumRows = 0 
	SET @@StartRowIndex = 0

IF @@MaximumRows >0
	SET @sql = ''
	SELECT ReportId, ReportType, Priority, TargetReportId, Status, Stage, ErrorMessage, ErrorDetails, Url, WebReportUrl, CreateDate, Name FROM
	   (SELECT TOP('' + CONVERT(nvarchar(10), @@StartRowIndex + @@MaximumRows) + '')''
ELSE SET @sql = ''SELECT''

--build the query
SET @sql = @sql + '' r.ReportId, r.ReportType, r.Priority, r.TargetReportId, r.Status, r.Stage, ISNULL(r.ErrorMessage + ''''; '''', '''''''') + ISNULL(CONVERT(VARCHAR(255), r.Notes), '''''''') AS ErrorMessage, r.ErrorDetails, r.Url, r.WebReportURL, r.CreateDate, s.Name''

IF @@MaximumRows >0
	SET @sql = @sql+'', ROW_NUMBER() OVER(ORDER BY '' + @@OrderBy + '') as RowNum''

SET @sql = @sql + ''
 FROM [dbo].[ib_Report] r
		INNER JOIN [dbo].[ib_Site] s ON s.SiteId = r.SiteId 
		INNER JOIN ib_SiteUser su ON su.UserId = '''''' + CONVERT(NVARCHAR(100), @UserId) 
			+ '''''' AND su.SiteId = r.SiteId ''

IF @where <> ''''
	SET @sql = @sql + '' WHERE '' + RIGHT(@where, LEN(@where) - 4)

IF @@MaximumRows = 0
	SET @sql = @sql+''
 ORDER BY '' + @@OrderBy 

IF @@MaximumRows >0
	SET @sql = @sql +  '') x
WHERE RowNum > '' + CONVERT(nvarchar(10), @@StartRowIndex) + '' ORDER BY RowNum''

-- Execute the query
EXEC sp_executesql @sql
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_RuleCondition_GetConditionsSortableAndPaginate]''
');

GO
EXECUTE ('

CREATE PROCEDURE [dbo].[ib_RuleCondition_GetConditionsSortableAndPaginate]
	@ruleId int,
	@@OrderBy VARCHAR(100) = NULL,
	@@StartRowIndex INT = NULL,
	@@MaximumRows INT = NULL
AS
SET NOCOUNT ON
	

IF (ISNULL(@@OrderBy, '''')='''')
	SET @@OrderBy = ''RC.CreateDate ASC'' 

IF ISNULL(@@MaximumRows, 0) <= 0
	SET @@MaximumRows = 0
	
IF ISNULL(@@StartRowIndex, -1) <= -1 OR @@MaximumRows = 0 
	SET @@StartRowIndex = 0

DECLARE @SQL NVARCHAR(max)
DECLARE @WHERE NVARCHAR(1000)

SET @WHERE = ''WHERE (1=1) AND RC.RuleId = '' + CAST(@ruleId as NVARCHAR(max))

IF @@MaximumRows >0
	SET @sql = 
	''SELECT 
		*
	 FROM
	   (SELECT TOP('' + CONVERT(NVARCHAR(10), @@StartRowIndex + @@MaximumRows) + '')''
ELSE SET @sql = ''SELECT''

--build the query
SET @sql = @sql + '' 
		RC.IsEnabled
		,RC.RuleConditionId
		,RC.RuleConditionId AS ConditionId
		,RC.InternalExternalCode
		,F.Description as Field1IdDescription
		,RC.Field1Id
		,COALESCE(SP.Description, RC.Value, ''''N\A'''') AS Value
		,RC.OperatorId
		,O.Description AS OperatorIdDescription
		,O.ShortDescription AS OperatorIdShortDescription
		,RC.CreateDate
		''

IF @@MaximumRows >0
	SET @sql = @sql+'', ROW_NUMBER() OVER(ORDER BY '' + @@OrderBy + '') as RowNum''
SET @sql = @sql + ''
	FROM ib_RuleCondition RC (nolock) 
	INNER JOIN
		ib_Field F ON F.FieldId = RC.Field1Id
	INNER JOIN
		ib_Operator O ON O.OperatorId = RC.OperatorId
	LEFT OUTER JOIN
		ib_Field SP ON SP.FieldId = RC.Field2Id AND RC.Field2Id IS NOT NULL
    '' + @where 

		
IF @@MaximumRows = 0
	SET @sql = @sql+''
 ORDER BY '' + @@OrderBy 

IF @@MaximumRows >0
	SET @sql = @sql +  '') as x
WHERE RowNum > '' + CONVERT(NVARCHAR(10), @@StartRowIndex) + '' ORDER BY RowNum''

-- Execute the query
PRINT @sql
EXEC sp_executesql @sql
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_RuleCondition_GetConditionsSortableAndPaginate_Count]''
');

GO
EXECUTE ('--EXEC [ib_Rule_GetRulesSortableAndPaginate_Count] 17
CREATE PROCEDURE [dbo].[ib_RuleCondition_GetConditionsSortableAndPaginate_Count]
	@ruleId int
AS 
SET NOCOUNT ON

DECLARE @SQL NVARCHAR(1000)
DECLARE @WHERE NVARCHAR(1000)

SET @WHERE = ''WHERE 1=1 AND RuleId = '' + CAST(@ruleId as NVARCHAR(max))

SET @sql = ''SELECT COUNT(RuleConditionId) 
	FROM [ib_RuleCondition] d (nolock)  
'' + @WHERE

EXEC sp_executesql @sql
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Rule_GetRulesSortableAndPaginate]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_Rule_GetRulesSortableAndPaginate]
	@filterTemplateId int = null,
	@matchCodeId int = null,
	@@OrderBy VARCHAR(100) = NULL,
	@@StartRowIndex INT = NULL,
	@@MaximumRows INT = NULL
AS
SET NOCOUNT ON
	

IF (ISNULL(@@OrderBy, '''')='''')
	SET @@OrderBy = ''R.RuleNumber ASC'' 

IF ISNULL(@@MaximumRows, 0) <= 0
	SET @@MaximumRows = 0
	
IF ISNULL(@@StartRowIndex, -1) <= -1 OR @@MaximumRows = 0 
	SET @@StartRowIndex = 0

DECLARE @SQL NVARCHAR(max)
DECLARE @WHERE NVARCHAR(1000)

SET @WHERE = ''WHERE (R.IsActive=1) ''
SET @filterTemplateId = COALESCE(@filterTemplateId,-1)
IF (@filterTemplateId > -1)
SET @WHERE = @WHERE + ''AND (R.TemplateId = '' + CAST(@filterTemplateId AS NVARCHAR(10)) + '')''



IF @@MaximumRows >0
	SET @sql = 
	''SELECT 
		*
	 FROM
	   (SELECT TOP('' + CONVERT(NVARCHAR(10), @@StartRowIndex + @@MaximumRows) + '')''
ELSE SET @sql = ''SELECT''

--build the query
SET @sql = @sql + '' 
		R.RuleId
		,IsEnabled
		,RuleNumber
		,Name
		,Tolerance
		,R.MatchCountTypeId
		,MT.Description AS MatchCountTypeIdDescription
		,R.ToleranceTypeId
		,TT.Description AS ToleranceTypeIdDescription
		,R.TemplateId
		,T.Description AS TemplateIdDescription
		,ISNULL(RC.ConditionsCount,0) AS [ConditionsCount]
		,ISNULL(MC.[MatchCodeCount],0) AS [MatchCodeCount]
		,R.CreateDate''

IF @@MaximumRows >0
	SET @sql = @sql+'', ROW_NUMBER() OVER(ORDER BY '' + @@OrderBy + '') as RowNum''
SET @sql = @sql + ''
	FROM ib_Rule R (nolock) 
	INNER JOIN	
		ib_Template T ON T.TemplateId = R.TemplateId
	INNER JOIn
		ib_ToleranceType TT ON TT.ToleranceTypeId = R.ToleranceTypeId
	INNER JOIN
		ib_MatchCountType MT ON MT.MatchCountTypeId = R.MatchCountTypeId
	LEFT OUTER JOIN
		(SELECT 
			COUNT(RuleConditionId) AS [ConditionsCount]
			,RuleId
		FROM 
			ib_RuleCondition
		GROUP BY
			RuleId)
		AS RC ON RC.RuleId = R.RuleId
	LEFT OUTER JOIN
		(SELECT 
			COUNT(RuleMatchCodeId) AS [MatchCodeCount]
			,RuleId
		FROM 
			ib_RuleMatchCode
		GROUP BY
			RuleId)
		AS MC ON MC.RuleId = R.RuleId
			''
	IF (ISNULL(@matchCodeId,-1) <> -1)
		SET @sql = @sql + ''
	INNER JOIN
		ib_RuleMatchCode RMC ON RMC.RuleId = R.RuleId AND RMC.MatchCodeId = '' + CAST(@matchCodeId AS NVARCHAR(10))
		
			
SET @sql = @sql + '' '' + @where 

		
IF @@MaximumRows = 0
	SET @sql = @sql+''
 ORDER BY '' + @@OrderBy 

IF @@MaximumRows >0
	SET @sql = @sql +  '') as x
WHERE RowNum > '' + CONVERT(NVARCHAR(10), @@StartRowIndex) + '' ORDER BY RowNum''

-- Execute the query
PRINT @sql
EXEC sp_executesql @sql
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Rule_GetRulesSortableAndPaginate_Count]''
');

GO
EXECUTE ('--EXEC [ib_Rule_GetRulesSortableAndPaginate_Count] 17
CREATE PROCEDURE [dbo].[ib_Rule_GetRulesSortableAndPaginate_Count]
	@filterTemplateId int = null
AS 
SET NOCOUNT ON

DECLARE @SQL NVARCHAR(1000)
DECLARE @WHERE NVARCHAR(1000)

SET @WHERE = ''WHERE IsActive=1''
	SET @filterTemplateId = COALESCE(@filterTemplateId,-1)
IF (@filterTemplateId > -1)
SET @WHERE = @WHERE + ''AND (TemplateId = '' + CAST(@filterTemplateId AS NVARCHAR(10)) + '')''
SET @sql = ''SELECT COUNT(RuleId) 
	FROM [ib_Rule] d (nolock)  
'' + @WHERE

EXEC sp_executesql @sql
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_ScheduledTask_GetQueueItemsSortableAndPaginate]''
');

GO
EXECUTE ('/*
	Updated By: Kirill Shilin
	Update On: 18.10.2011
	Issue: 19129 Queued Items List Sorting
	Changes: default sorting updated

*/
CREATE PROCEDURE [dbo].[ib_ScheduledTask_GetQueueItemsSortableAndPaginate]
	@taskId INT = NULL
	,@statusId INT = NULL
	,@begin DateTime = NULL
	,@end DateTime = NULL
   ,@@OrderBy VARCHAR(100) = NULL
   ,@@StartRowIndex INT = NULL
   ,@@MaximumRows INT = NULL
AS 
SET NOCOUNT ON


--select * from ib_ScheduledTask
IF ( ISNULL(@@OrderBy, '''') = '''' ) 
    SET @@OrderBy = ''COALESCE(CompletedOn,getdate()) DESC, ScheduledStart DESC'' 

	--fix the top
IF ISNULL(@@MaximumRows, 0) <= 0 
    SET @@MaximumRows = 0
IF ISNULL(@@StartRowIndex, -1) <= -1 OR
    @@MaximumRows = 0 
    SET @@StartRowIndex = 0

DECLARE @SQL NVARCHAR(2000)
DECLARE @WHERE NVARCHAR(1000)

SET @WHERE = ''WHERE (1=1)AND(COALESCE(TT.Name, ITT.Name) IS NOT NULL)''

IF ISNULL(@statusId, -1) <> -1
BEGIN
	SET @WHERE = @WHERE + '' AND (StatusId = '' + CONVERT(NVARCHAR(2),@statusId) + '')''
END

IF ISNULL(@taskId, -1) <> -1
BEGIN
	SET @WHERE = @WHERE + '' AND (QI.ScheduledTaskId = '' + CONVERT(NVARCHAR(2),@taskId) + '')''
END

IF ISNULL(@begin, -1) <> -1
BEGIN
	SET @WHERE = @WHERE + '' AND (ScheduledStart >= '' + CONVERT(NVARCHAR(20),@begin) + '')''
END

IF ISNULL(@end, -1) <> -1
BEGIN
	SET @WHERE = @WHERE + '' AND (ScheduledStart <= '' + CONVERT(NVARCHAR(2),@end) + '')''
END


IF @@MaximumRows > 0 
    SET @sql = ''SELECT *
	 FROM
	   (SELECT TOP('' + CONVERT(NVARCHAR(10), @@StartRowIndex + @@MaximumRows) +
        '')''
ELSE 
    SET @sql = ''SELECT''

--build the query
SET @sql = @sql + '' 
	QueueItemId
	, QI.StatusId
	, QS.Code AS StatusCode
	, QS.Name AS StatusIdName
	, DisplayMessage
	, ErrorMessage
	, CompletedOn
	, ScheduledStart
	, QI.ScheduledTaskId
	, ST.Name as ScheduledTaskIdName
	, COALESCE(TT.Name, ITT.Name) AS TaskTypeName
	, CASE WHEN T.TemplateId IS NULL THEN ''''All Templates'''' ELSE T.Description END AS TemplateName
	, S.Name AS SiteName
	, CAST(CASE QI.StatusId WHEN 4 THEN 1 WHEN 5 THEN 1 ELSE 0 END AS BIT) AS CanBeRestarted
	, CAST(CASE QI.StatusId WHEN 1 THEN 1 WHEN 6 THEN 1 ELSE 0 END AS BIT) AS CanBeDeleted
''

IF @@MaximumRows > 0 
    SET @sql = @sql + '', ROW_NUMBER() OVER(ORDER BY '' + @@OrderBy +
        '') as RowNum''
ELSE 
    SET @Sql = @sql + ''''
SET @sql = @sql + ''
 FROM [ib_QueueItem] QI (nolock)
 LEFT OUTER JOIN
	ib_Site S ON S.SiteId = QI.SiteId
LEFT OUTER JOIN
	ib_Template T ON T.TemplateId = QI.TemplateId
 LEFT OUTER JOIN
	[ib_ScheduledTask] ST ON QI.ScheduledTaskId = ST.ScheduledTaskId 
 LEFT OUTER JOIN
	[ib_TaskType] ITT ON ITT.TaskTypeId = QI.TaskTypeId AND ITT.Code <> ''''SCHD''''
 LEFT OUTER JOIN
    [ib_TaskType] TT ON TT.TaskTypeId = ST.TaskTypeId AND TT.Code <> ''''SCHD''''
 INNER JOIN
	ib_QueueStatus QS ON QS.QueueStatusId = QI.StatusId
   '' + @where 

IF @@MaximumRows = 0 
    SET @sql = @sql + ''
 ORDER BY '' + @@OrderBy 

IF @@MaximumRows > 0 
    SET @sql = @sql + '') as x
WHERE RowNum > '' + CONVERT(NVARCHAR(10), @@StartRowIndex) + '' ORDER BY RowNum''

PRINT @sql
-- Execute the query
EXEC sp_executesql @sql
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_ScheduledTask_GetQueueItemsSortableAndPaginate_Count]''
');

GO
EXECUTE ('--exec [dbo].[ib_ScheduledTask_GetQueueItemsSortableAndPaginate_Count]
CREATE PROCEDURE [dbo].[ib_ScheduledTask_GetQueueItemsSortableAndPaginate_Count]
	@taskId INT = NULL
	,@statusId INT = NULL
	,@begin DateTime = NULL
	,@end DateTime = NULL
AS
SET NOCOUNT ON
DECLARE @SQL nvarchar(1000)
DECLARE @WHERE nvarchar(1000)

SET @WHERE = ''WHERE 1=1 AND (COALESCE(TT.Name, ITT.Name) IS NOT NULL)''

IF ISNULL(@taskId, -1) <> -1
BEGIN
	SET @WHERE = @WHERE + '' AND (QI.ScheduledTaskId = '' + CONVERT(NVARCHAR(2),@taskId) + '')''
END

IF ISNULL(@statusId, -1) <> -1
BEGIN
	SET @WHERE = @WHERE + '' AND (StatusId = '' + CONVERT(NVARCHAR(2),@statusId) + '')''
END

IF ISNULL(@begin, -1) <> -1
BEGIN
	SET @WHERE = @WHERE + '' AND (ScheduledStart >= '' + CONVERT(NVARCHAR(20),@begin) + '')''
END

IF ISNULL(@end, -1) <> -1
BEGIN
	SET @WHERE = @WHERE + '' AND (ScheduledStart <= '' + CONVERT(NVARCHAR(2),@end) + '')''
END

	
	SET @sql = ''SELECT COUNT(QueueItemId) 
	FROM [ib_QueueItem] QI (nolock)  
	LEFT OUTER JOIN
		[ib_ScheduledTask] ST ON QI.ScheduledTaskId = ST.ScheduledTaskId 
	 LEFT OUTER JOIN
		[ib_TaskType] ITT ON ITT.TaskTypeId = QI.TaskTypeId AND ITT.Code <> ''''SCHD''''
	 LEFT OUTER JOIN
		[ib_TaskType] TT ON TT.TaskTypeId = ST.TaskTypeId AND TT.Code <> ''''SCHD''''
	 INNER JOIN
		ib_QueueStatus QS ON QS.QueueStatusId = QI.StatusId
'' + @WHERE

EXEC sp_executesql @sql
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_ScheduledTask_GetQueueLogsSortableAndPaginate]''
');

GO
EXECUTE ('--exec [dbo].[ib_ScheduledTask_GetQueueLogsSortableAndPaginate] @queueItemId=274,@@StartRowIndex=0,@@MaximumRows=25
CREATE PROCEDURE [dbo].[ib_ScheduledTask_GetQueueLogsSortableAndPaginate]
	@queueItemId INT
   ,@@OrderBy VARCHAR(100) = NULL
   ,@@StartRowIndex INT = NULL
   ,@@MaximumRows INT = NULL
AS 
SET NOCOUNT ON


--select * from ib_ScheduledTask
IF ( ISNULL(@@OrderBy, '''') = '''' ) 
    SET @@OrderBy = ''QueueLogId ASC'' 

	--fix the top
IF ISNULL(@@MaximumRows, 0) <= 0 
    SET @@MaximumRows = 0
IF ISNULL(@@StartRowIndex, -1) <= -1 OR
    @@MaximumRows = 0 
    SET @@StartRowIndex = 0

DECLARE @SQL NVARCHAR(1000)
DECLARE @WHERE NVARCHAR(1000)

SET @WHERE = ''WHERE (1=1)''


	SET @WHERE = @WHERE + '' AND QueueItemId = '' + CONVERT(NVARCHAR(10),@queueItemId)


IF @@MaximumRows > 0 
    SET @sql = ''SELECT *
	 FROM
	   (SELECT TOP('' + CONVERT(NVARCHAR(10), @@StartRowIndex + @@MaximumRows) +
        '')''
ELSE 
    SET @sql = ''SELECT''

--build the query
SET @sql = @sql + '' *,
    CASE Level WHEN 0 THEN ''''Off'''' WHEN 1 THEN ''''Error'''' WHEN 3 THEN ''''Warning'''' WHEN 5 THEN ''''Info''''
		WHEN 7 THEN ''''Verbose'''' END AS LevelName,
	''''Other'''' AS CategoryName
''

IF @@MaximumRows > 0 
    SET @sql = @sql + '', ROW_NUMBER() OVER(ORDER BY '' + @@OrderBy +
        '') as RowNum''
ELSE 
    SET @Sql = @sql + ''''
SET @sql = @sql + ''
 FROM [ib_QueueLog] QL (nolock)
 
   '' + @where 

IF @@MaximumRows = 0 
    SET @sql = @sql + ''
 ORDER BY QueueLogId''

IF @@MaximumRows > 0 
    SET @sql = @sql + '') as x
WHERE RowNum > '' + CONVERT(NVARCHAR(10), @@StartRowIndex) + '' ORDER BY RowNum''

PRINT @sql
-- Execute the query
EXEC sp_executesql @sql
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_ScheduledTask_GetQueueLogsSortableAndPaginate_Count]''
');

GO
EXECUTE ('--exec [dbo].[ib_ScheduledTask_GetQueueLogsSortableAndPaginate_Count] 263
CREATE PROCEDURE [dbo].[ib_ScheduledTask_GetQueueLogsSortableAndPaginate_Count]
	@queueItemId INT
AS
SET NOCOUNT ON
DECLARE @SQL nvarchar(1000)
DECLARE @WHERE nvarchar(1000)

SET @WHERE = ''WHERE 1=1''

SET @WHERE = @WHERE + '' AND QueueItemId = '' + CONVERT(NVARCHAR(10),@queueItemId)

	
	SET @sql = ''SELECT COUNT(QueueLogId) 
	FROM [ib_QueueLog] QI (nolock)  
	
'' + @WHERE

EXEC sp_executesql @sql
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_ScheduledTask_GetScheduledTasksSortableAndPaginate]''
');

GO
EXECUTE ('--[dbo].[ib_ScheduledTask_GetScheduledTasksSortableAndPaginate]
CREATE PROCEDURE [dbo].[ib_ScheduledTask_GetScheduledTasksSortableAndPaginate]
   @@OrderBy VARCHAR(100) = NULL
   ,@@StartRowIndex INT = NULL
   ,@@MaximumRows INT = NULL
AS 
SET NOCOUNT ON


--select * from ib_ScheduledTask
IF ( ISNULL(@@OrderBy, '''') = '''' ) 
    SET @@OrderBy = ''ST.Name ASC'' 

	--fix the top
IF ISNULL(@@MaximumRows, 0) <= 0 
    SET @@MaximumRows = 0
IF ISNULL(@@StartRowIndex, -1) <= -1 OR
    @@MaximumRows = 0 
    SET @@StartRowIndex = 0

DECLARE @SQL NVARCHAR(3000)
DECLARE @WHERE NVARCHAR(1000)

SET @WHERE = ''WHERE 1=1''

IF @@MaximumRows > 0 
    SET @sql = ''SELECT *
	 FROM
	   (SELECT TOP('' + CONVERT(NVARCHAR(10), @@StartRowIndex + @@MaximumRows) +
        '')''
ELSE 
    SET @sql = ''SELECT''

--build the query
SET @sql = @sql + '' ST.ScheduledTaskId, ST.Name, CONVERT(NVARCHAR(5),ST.RunAtTime, 8) AS RunAtTime, TT.Name AS TaskTypeName, 
	CASE ST.Frequency
		WHEN 1 THEN CAST(ST.RunAtSpecificDay AS NVARCHAR(20))
		WHEN 0 THEN NULL 
		WHEN 2 THEN
	CASE ST.RunAtSpecificDay WHEN 0 THEN ''''Sunday'''' 
		WHEN 0 THEN ''''Sunday'''' 
		WHEN 1 THEN ''''Monday'''' 
		WHEN 2 THEN ''''Tuesday'''' 
		WHEN 3 THEN ''''Wednesday'''' 
		WHEN 4 THEN ''''Thursday'''' 
		WHEN 5 THEN ''''Friday'''' 
		WHEN 6 THEN ''''Saturday'''' END END AS RunAtSpecificDayName,
	CASE ST.Frequency WHEN 0 THEN ''''Daily'''' WHEN 2 THEN ''''Weekly'''' WHEN 1 THEN ''''Monthly'''' WHEN 3 THEN ''''Every Hour'''' 
	END AS FrequencyName,
	NextRun,
	LastRun,
	ST.IsActive,
	CASE WHEN T.TemplateId IS NULL THEN ''''All Templates'''' ELSE	T.Description END AS Template,
	S.Name AS Site
''

IF @@MaximumRows > 0 
    SET @sql = @sql + '', ROW_NUMBER() OVER(ORDER BY '' + @@OrderBy +
        '') as RowNum''
ELSE 
    SET @Sql = @sql + ''''
SET @sql = @sql + ''
 FROM [ib_ScheduledTask] ST (nolock)
 INNER JOIN
	[ib_TaskType] TT ON TT.TaskTypeId = ST.TaskTypeId AND Code <> ''''SCHD''''
 INNER JOIN
	[ib_Assembly] A ON A.AssemblyId = TT.AssemblyId 
 LEFT OUTER JOIN
	ib_Site S ON S.SiteId = ST.SiteId
 LEFT OUTER JOIN
	ib_Template T ON T.TemplateId = ST.TemplateId
   '' + @where 

IF @@MaximumRows = 0 
    SET @sql = @sql + ''
 ORDER BY '' + @@OrderBy 

IF @@MaximumRows > 0 
    SET @sql = @sql + '') as x
WHERE RowNum > '' + CONVERT(NVARCHAR(10), @@StartRowIndex) + '' ORDER BY RowNum''

PRINT @sql
-- Execute the query
EXEC sp_executesql @sql
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_ScheduledTask_GetScheduledTasksSortableAndPaginate_Count]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_ScheduledTask_GetScheduledTasksSortableAndPaginate_Count]
AS
SET NOCOUNT ON
DECLARE @SQL nvarchar(1000)
DECLARE @WHERE nvarchar(1000)

SET @WHERE = ''WHERE 1=1''
	 
	SET @sql = ''SELECT COUNT(ScheduledTaskId) 
	FROM [ib_ScheduledTask] ST (nolock)  
	 INNER JOIN
	[ib_TaskType] TT ON TT.TaskTypeId = ST.TaskTypeId AND Code <> ''''SCHD''''
 INNER JOIN
	[ib_Assembly] A ON A.AssemblyId = TT.AssemblyId 
'' + @WHERE

EXEC sp_executesql @sql
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_SiteTemplate_GetItemIndex_For_SiteTemplateId_When_SortableAndPaginate]''
');

GO
EXECUTE (' /*
<details>
	<summary>Returns the item index for a given site template id when sortable and paginate. A filter on the TemplateId may be set</summary>
	<created author="Laurentiu Macovei" Date="Tuesday, 22 september 2006, 07:04PM GMT" />
</details>
*/
CREATE PROCEDURE [dbo].[ib_SiteTemplate_GetItemIndex_For_SiteTemplateId_When_SortableAndPaginate]
	@TemplateId int,
	@GetItemIndexForSiteTemplateId int,
	@@OrderBy varchar(100) = NULL

AS
SET NOCOUNT ON
--fix @GetItemIndexForSiteTemplateId

--fix orderby
IF (ISNULL(@@OrderBy, '''')='''')
	SET @@OrderBy = ''st.CreateDate ASC'' 

BEGIN

DECLARE @SQL nvarchar(1000)
DECLARE @WHERE nvarchar(1000)

SET @WHERE = ''''
IF ISNULL(@TemplateId, -1)>0
	SET @WHERE = @WHERE + '' AND st.TemplateId = '' + cast(@TemplateId as varchar(100))

SET @sql = ''
DECLARE @Value int
SET @Value = -1
SELECT @Value = RowNum -1
	 FROM
	   (SELECT''

--build the query
SET @sql = @sql + '' [SiteTemplateId] ''

SET @sql = @sql+'', ROW_NUMBER() OVER(ORDER BY '' + @@OrderBy + '') as RowNum''

SET @sql = @sql + ''
 FROM [ib_SiteTemplate] st  
	INNER JOIN [ib_Template] t ON st.TemplateId = t.TemplateId
	INNER JOIN [ib_Site] s ON st.SiteId = s.SiteId
      '' + @where 
	SET @sql = @sql +  '') x
WHERE [SiteTemplateId] = '' + CONVERT(nvarchar(10), @GetItemIndexForSiteTemplateId)
+ ''; SELECT @Value''

-- Execute the query
EXEC sp_executesql @sql

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_SiteTemplate_GetSiteTemplatesSortableAndPaginate]''
');

GO
EXECUTE ('/*
<details>
	<summary>Returns the site templates sortable and paginate. A filter on the TemplateId may be set</summary>
	<created author="Laurentiu Macovei" Date="Tuesday, 22 september 2006, 13:03PM GMT" />		
</details>
*/
CREATE PROCEDURE [dbo].[ib_SiteTemplate_GetSiteTemplatesSortableAndPaginate]
	@TemplateId int = NULL,
	@@OrderBy varchar(100) = NULL,
	@@StartRowIndex int = NULL,
	@@MaximumRows int = NULL

AS
SET NOCOUNT ON
--fix orderby
IF (ISNULL(@@OrderBy, '''')='''')
	SET @@OrderBy = ''st.CreateDate ASC'' 

	--fix the top
IF IsNull(@@MaximumRows, 0) <= 0
	SET @@MaximumRows = 0
IF IsNull(@@StartRowIndex, -1) <= -1 OR @@MaximumRows = 0 
	SET @@StartRowIndex = 0

DECLARE @SQL nvarchar(1000)
DECLARE @WHERE nvarchar(1000)

SET @WHERE = ''''
IF @TemplateId IS NOT NULL
	SET @WHERE = @WHERE + '' AND st.TemplateId = '' + cast(@TemplateId as varchar(100))

IF @@MaximumRows >0
	SET @sql = ''SELECT [SiteTemplateId], [SiteCode], CreateDate, CreateUsername, UpdateDate, UpdateUsername
	 FROM
	   (SELECT TOP('' + CONVERT(nvarchar(10), @@StartRowIndex + @@MaximumRows) + '')''
ELSE SET @sql = ''SELECT''

--build the query
SET @sql = @sql + '' st.[SiteTemplateId], s.[Code] as [SiteCode], st.CreateDate, st.CreateUsername, st.UpdateDate, st.UpdateUsername ''

IF @@MaximumRows >0
	SET @sql = @sql+'', ROW_NUMBER() OVER(ORDER BY '' + @@OrderBy + '') as RowNum''

SET @sql = @sql + ''
 FROM [ib_SiteTemplate] st  
	INNER JOIN [ib_Template] t ON st.TemplateId = t.TemplateId
	INNER JOIN [ib_Site] s ON st.SiteId = s.SiteId
      '' + @where 

IF @@MaximumRows = 0
	SET @sql = @sql+''
 ORDER BY '' + @@OrderBy 

IF @@MaximumRows >0
	SET @sql = @sql +  '') x
WHERE RowNum > '' + CONVERT(nvarchar(10), @@StartRowIndex) + '' ORDER BY RowNum''

-- Execute the query
EXEC sp_executesql @sql
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_SiteTemplate_GetSiteTemplatesSortableAndPaginate_Count]''
');

GO
EXECUTE ('/*
<details>
	<summary>Returns the site templates count. A filter on the TemplateId may be set</summary>
	<created author="Laurentiu Macovei" Date="Wednesday, 22 september 2006, 12:36AM GMT" />		
</details>
*/
CREATE PROCEDURE [dbo].[ib_SiteTemplate_GetSiteTemplatesSortableAndPaginate_Count]
	@TemplateId int = NULL
AS
SET NOCOUNT ON
	
DECLARE @SQL nvarchar(1000)
DECLARE @WHERE nvarchar(1000)

SET @WHERE = ''''
	
IF @TemplateId IS NOT NULL
	SET @WHERE = @WHERE + '' AND st.TemplateId = '' + cast(@TemplateId as varchar(100))

	SET @sql = ''SELECT COUNT(SiteTemplateId) 
	FROM [ib_SiteTemplate] st  
	INNER JOIN [ib_Template] t ON st.TemplateId = t.TemplateId
	INNER JOIN [ib_Site] s ON st.SiteId = s.SiteId '' + @WHERE

EXEC sp_executesql @sql
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_SiteUser_GetItemIndex_For_SiteUserId_When_SortableAndPaginate]''
');

GO
EXECUTE (' /*
<details>
	<summary>Returns the item index for a given Site User id when sortable and paginate. A filter on the UserId may be set</summary>
	<created author="laurentiu.macovei" date="Tue, 03 Oct 2006 17:58:18 GMT"/>
</details>
*/
CREATE PROCEDURE [dbo].[ib_SiteUser_GetItemIndex_For_SiteUserId_When_SortableAndPaginate]
	@UserId uniqueidentifier,
	@GetItemIndexForSiteUserId int,
	@@OrderBy varchar(100) = NULL

AS
SET NOCOUNT ON
--fix @GetItemIndexForSiteUserId

--fix orderby
IF (ISNULL(@@OrderBy, '''')='''')
	SET @@OrderBy = ''su.CreateDate ASC'' 

BEGIN

DECLARE @SQL nvarchar(1000)
DECLARE @WHERE nvarchar(1000)

SET @WHERE = ''''
IF Cast(ISNULL(@UserId, '''') as Varchar(100))<>''''
	SET @WHERE = @WHERE + '' AND su.UserId = '''''' + cast(@UserId as varchar(100))+''''''''

SET @sql = ''
DECLARE @Value int
SET @Value = -1
SELECT @Value = RowNum -1
	 FROM
	   (SELECT''

--build the query
SET @sql = @sql + '' [SiteUserId] ''

SET @sql = @sql+'', ROW_NUMBER() OVER(ORDER BY '' + @@OrderBy + '') as RowNum''

SET @sql = @sql + ''
 FROM [ib_SiteUser] su  
	INNER JOIN [aspnet_users] u ON su.UserId = u.UserId
	INNER JOIN [ib_Site] s ON su.SiteId = s.SiteId
      '' + @where 
	SET @sql = @sql +  '') x
WHERE [SiteUserId] = '' + CONVERT(nvarchar(10), @GetItemIndexForSiteUserId)
+ ''; SELECT @Value''

-- Execute the query
EXEC sp_executesql @sql

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_SiteUser_GetSiteUsersSortableAndPaginate]''
');

GO
EXECUTE ('/*
<details>
	<summary>Returns the Site Users sortable and paginate. A filter on the UserId may be set</summary>
	<created author="laurentiu.macovei" date="Tue, 03 Oct 2006 17:53:24 GMT"/>
</details>
*/
CREATE PROCEDURE [dbo].[ib_SiteUser_GetSiteUsersSortableAndPaginate]
	@UserId uniqueidentifier = NULL,
	@@OrderBy varchar(100) = NULL,
	@@startRowIndex int = NULL,
	@@MaximumRows int = NULL

AS
SET NOCOUNT ON
--fix orderby
IF (ISNULL(@@OrderBy, '''')='''')
	SET @@OrderBy = ''su.CreateDate ASC'' 

	--fix the top
IF IsNull(@@MaximumRows, 0) <= 0
	SET @@MaximumRows = 0
IF IsNull(@@startRowIndex, -1) <= -1 OR @@MaximumRows = 0 
	SET @@startRowIndex = 0

DECLARE @SQL nvarchar(1000)
DECLARE @WHERE nvarchar(1000)

SET @WHERE = ''''
IF @UserId IS NOT NULL
	SET @WHERE = @WHERE + '' AND su.UserId = '''''' + cast(@UserId as varchar(100))+''''''''

IF @@MaximumRows >0
	SET @sql = ''SELECT [SiteUserId], [IsPrimary], [SiteCode], CreateDate, CreateUsername, UpdateDate, UpdateUsername
	 FROM
	   (SELECT TOP('' + CONVERT(nvarchar(10), @@startRowIndex + @@MaximumRows) + '')''
ELSE SET @sql = ''SELECT''

--build the query
SET @sql = @sql + '' su.[SiteUserId], su.[IsPrimary], s.[Code] as [SiteCode], su.CreateDate, su.CreateUsername, su.UpdateDate, su.UpdateUsername ''

IF @@MaximumRows >0
	SET @sql = @sql+'', ROW_NUMBER() OVER(ORDER BY '' + @@OrderBy + '') as RowNum''

SET @sql = @sql + ''
 FROM [ib_SiteUser] su  
	INNER JOIN [aspnet_users] u ON su.UserId = u.UserId
	INNER JOIN [ib_Site] s ON su.SiteId = s.SiteId
      '' + @where 

IF @@MaximumRows = 0
	SET @sql = @sql+''
 ORDER BY '' + @@OrderBy 

IF @@MaximumRows >0
	SET @sql = @sql +  '') x
WHERE RowNum > '' + CONVERT(nvarchar(10), @@startRowIndex) + '' ORDER BY RowNum''

-- Execute the query
EXEC sp_executesql @sql
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_SiteUser_GetSiteUsersSortableAndPaginate_Count]''
');

GO
EXECUTE ('/*
<details>
	<summary>Returns the SiteUsers count. A filter on the UserId may be set</summary>
	<created author="laurentiu.macovei" date="Tue, 03 Oct 2006 02:16:53 GMT"/>
</details>
*/
CREATE PROCEDURE [dbo].[ib_SiteUser_GetSiteUsersSortableAndPaginate_Count]
	@UserID UniqueIdentifier = NULL
AS
SET NOCOUNT ON
	
DECLARE @SQL nvarchar(1000)
DECLARE @WHERE nvarchar(1000)

SET @WHERE = ''''
	
IF @UserID IS NOT NULL
	SET @WHERE = @WHERE + '' AND su.UserID = '''''' + convert(varchar(100), @UserId)+''''''''

	SET @sql = ''SELECT COUNT(SiteUserId) 
	FROM [ib_SiteUser] su  
	INNER JOIN [ib_Site] s ON s.SiteID = su.SiteId '' + @WHERE

EXEC sp_executesql @sql
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_SwiftStatementSeed_GetPaged]''
');

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Gets records from the ib_SwiftStatementSeed table passing page index and page count parameters
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[ib_SwiftStatementSeed_GetPaged]
(

	@WhereClause varchar (2000)  ,

	@OrderBy varchar (2000)  ,

	@PageIndex int   ,

	@PageSize int   
)
AS


				
				BEGIN
				DECLARE @PageLowerBound int
				DECLARE @PageUpperBound int
				
				-- Set the page bounds
				SET @PageLowerBound = @PageSize * @PageIndex
				SET @PageUpperBound = @PageLowerBound + @PageSize

				IF (@OrderBy IS NULL OR LEN(@OrderBy) < 1)
				BEGIN
					-- default order by to first column
					SET @OrderBy = ''[SwiftStatementSeedId]''
				END

				-- SQL Server 2005 Paging
				DECLARE @SQL AS nvarchar(MAX)
				SET @SQL = ''WITH PageIndex AS (''
				SET @SQL = @SQL + '' SELECT''
				IF @PageSize > 0
				BEGIN
					SET @SQL = @SQL + '' TOP '' + CONVERT(nvarchar, @PageUpperBound)
				END
				SET @SQL = @SQL + '' ROW_NUMBER() OVER (ORDER BY '' + @OrderBy + '') as RowIndex''
				SET @SQL = @SQL + '', [SwiftStatementSeedId]''
				SET @SQL = @SQL + '', [AccountId]''
				SET @SQL = @SQL + '', [StatementNumberSeed]''
				SET @SQL = @SQL + '', [CreateDate]''
				SET @SQL = @SQL + '', [CreateUsername]''
				SET @SQL = @SQL + '', [UpdateDate]''
				SET @SQL = @SQL + '', [UpdateUsername]''
				SET @SQL = @SQL + '' FROM [dbo].[ib_SwiftStatementSeed]''
				IF LEN(@WhereClause) > 0
				BEGIN
					SET @SQL = @SQL + '' WHERE '' + @WhereClause
				END
				SET @SQL = @SQL + '' ) SELECT''
				SET @SQL = @SQL + '' [SwiftStatementSeedId],''
				SET @SQL = @SQL + '' [AccountId],''
				SET @SQL = @SQL + '' [StatementNumberSeed],''
				SET @SQL = @SQL + '' [CreateDate],''
				SET @SQL = @SQL + '' [CreateUsername],''
				SET @SQL = @SQL + '' [UpdateDate],''
				SET @SQL = @SQL + '' [UpdateUsername]''
				SET @SQL = @SQL + '' FROM PageIndex''
				SET @SQL = @SQL + '' WHERE RowIndex > '' + CONVERT(nvarchar, @PageLowerBound)
				IF @PageSize > 0
				BEGIN
					SET @SQL = @SQL + '' AND RowIndex <= '' + CONVERT(nvarchar, @PageUpperBound)
				END
				SET @SQL = @SQL + '' ORDER BY '' + @OrderBy
				EXEC sp_executesql @SQL
				
				-- get row count
				SET @SQL = ''SELECT COUNT(*) AS TotalRowCount''
				SET @SQL = @SQL + '' FROM [dbo].[ib_SwiftStatementSeed]''
				IF LEN(@WhereClause) > 0
				BEGIN
					SET @SQL = @SQL + '' WHERE '' + @WhereClause
				END
				EXEC sp_executesql @SQL
			
				END
			

');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TaskType_GetTaskTypesSortableAndPaginate]''
');

GO
EXECUTE ('--exec [dbo].[ib_TaskType_GetTaskTypesSortableAndPaginate]
CREATE PROCEDURE [dbo].[ib_TaskType_GetTaskTypesSortableAndPaginate]
   @@OrderBy VARCHAR(100) = NULL
   ,@@StartRowIndex INT = NULL
   ,@@MaximumRows INT = NULL
AS 
SET NOCOUNT ON



IF ( ISNULL(@@OrderBy, '''') = '''' ) 
    SET @@OrderBy = ''TT.Code ASC'' 

	--fix the top
IF ISNULL(@@MaximumRows, 0) <= 0 
    SET @@MaximumRows = 0
IF ISNULL(@@StartRowIndex, -1) <= -1 OR
    @@MaximumRows = 0 
    SET @@StartRowIndex = 0

DECLARE @SQL NVARCHAR(1000)
DECLARE @WHERE NVARCHAR(1000)

SET @WHERE = ''WHERE 1=1 AND (Code<>''''SCHD'''')''

IF @@MaximumRows > 0 
    SET @sql = ''SELECT [TaskTypeId], [Code], [Description], [Name], [IsActive]
	 FROM
	   (SELECT TOP('' + CONVERT(NVARCHAR(10), @@StartRowIndex + @@MaximumRows) +
        '')''
ELSE 
    SET @sql = ''SELECT''

--build the query
SET @sql = @sql + '' TT.[TaskTypeId], TT.[Code], TT.[Description], TT.[Name], TT.[IsActive] ''

IF @@MaximumRows > 0 
    SET @sql = @sql + '', ROW_NUMBER() OVER(ORDER BY '' + @@OrderBy +
        '') as RowNum''
ELSE 
    SET @Sql = @sql + ''''
SET @sql = @sql + ''
 FROM [ib_TaskType] TT (nolock)
 INNER JOIN vw_Assembly A ON A.AssemblyId = TT.AssemblyId
 '' + @where 

IF @@MaximumRows = 0 
    SET @sql = @sql + ''
 ORDER BY '' + @@OrderBy 

IF @@MaximumRows > 0 
    SET @sql = @sql + '') as x
WHERE RowNum > '' + CONVERT(NVARCHAR(10), @@StartRowIndex) + '' ORDER BY RowNum''

-- Execute the query
EXEC sp_executesql @sql
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TaskType_GetTaskTypesSortableAndPaginate_Count]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_TaskType_GetTaskTypesSortableAndPaginate_Count]
AS
SET NOCOUNT ON
DECLARE @SQL nvarchar(1000)
DECLARE @WHERE nvarchar(1000)

SET @WHERE = ''WHERE 1=1 AND (Code <> ''''SCHD'''')''
	
	
	SET @sql = ''SELECT COUNT(TaskTypeId) 
	FROM [ib_TaskType] TT (nolock)  
	INNER JOIN ib_Assembly A ON A.AssemblyId = TT.AssemblyId 
'' + @WHERE

EXEC sp_executesql @sql
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TemplateCompare_GetItemIndex_For_TemplateCompareId_When_SortableAndPaginate]''
');

GO
EXECUTE (' /*
<details>
	<summary>Returns the item index for a given template compare id when sortable and paginate. A filter on the TemplateId may be set</summary>
	<created author="Laurentiu Macovei" Date="Tuesday, 22 september 2006, 07:04PM GMT" />
	<updated author="laurentiu.macovei" date="Sat, 30 Sep 2006 02:11:32 GMT">
		Fixed the sql server 2005 bug by adding the datasourceId to the query, even though it makes no sense.
		Try to remove it from select and you''ll see the bug.
	</updated>
</details>
*/
CREATE PROCEDURE [dbo].[ib_TemplateCompare_GetItemIndex_For_TemplateCompareId_When_SortableAndPaginate]
	@TemplateId int,
	@GetItemIndexForTemplateCompareId int,
	@@OrderBy varchar(100) = NULL

AS
SET NOCOUNT ON
--fix @GetItemIndexForTemplateCompareId

--fix orderby
IF (ISNULL(@@OrderBy, '''')='''')
	SET @@OrderBy = ''tc.InternalExternalCode ASC'' 

DECLARE @SQL nvarchar(1000)
DECLARE @WHERE nvarchar(1000)

SET @WHERE = ''''
IF @TemplateId IS NOT NULL
	SET @WHERE = @WHERE + '' AND tc.TemplateId = '' + cast(@TemplateId as varchar(100))

SET @sql = ''
DECLARE @Value int
SET @Value = -1;
WITH x as
	   (
SELECT''

--build the query
SET @sql = @sql + '' tc.[TemplateCompareId] as [TemplateCompareId], tc.DataSourceID, tc.InternalExternalCode
''

SET @sql = @sql+'', ROW_NUMBER() OVER(ORDER BY '' + @@OrderBy + '') as RowNum''

SET @sql = @sql + ''
 FROM [ib_TemplateCompare] tc  
	INNER JOIN [ib_Template] t ON tc.TemplateId = t.TemplateId
	INNER JOIN [ib_DataSource] ds ON tc.DataSourceId = ds.DataSourceId
	INNER JOIN [ib_Firm] f ON tc.FirmID = f.FirmID
      '' + @where 

--DO NOT REMOVE DataSourceId from the selectect, otherwise a sql 2005 bug will occur
	SET @sql = @sql +  ''
) 
SELECT TOP 1 Cast(RowNum - 1  as Integer), DataSourceId

--*
	 FROM x

WHERE x.[TemplateCompareId] = '' + CONVERT(nvarchar(10), @GetItemIndexForTemplateCompareId)
+ ''

--SELECT @Value''

-- Execute the query
EXEC sp_executesql @sql
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TemplateCompare_GetTemplateComparesSortableAndPaginate]''
');

GO
EXECUTE ('/*
<details>
	<summary>Returns the template compare sortable and paginate. A filter on the TemplateId may be set</summary>
	<created author="Laurentiu Macovei" Date="Tuesday, 22 september 2006, 13:03PM GMT" />		
</details>
*/
CREATE PROCEDURE [dbo].[ib_TemplateCompare_GetTemplateComparesSortableAndPaginate]
	@TemplateId int = NULL,
	@@OrderBy varchar(100) = NULL,
	@@StartRowIndex int = NULL,
	@@MaximumRows int = NULL

AS
SET NOCOUNT ON
--fix orderby
IF (ISNULL(@@OrderBy, '''')='''')
	SET @@OrderBy = ''tc.InternalExternalCode ASC'' 

	--fix the top
IF IsNull(@@MaximumRows, 0) <= 0
	SET @@MaximumRows = 0
IF IsNull(@@StartRowIndex, -1) <= -1 OR @@MaximumRows = 0 
	SET @@StartRowIndex = 0

DECLARE @SQL nvarchar(1000)
DECLARE @WHERE nvarchar(1000)

SET @WHERE = ''''
IF @TemplateId IS NOT NULL
	SET @WHERE = @WHERE + '' AND tc.TemplateId = '' + cast(@TemplateId as varchar(100))

IF @@MaximumRows >0
	SET @sql = ''SELECT [TemplateCompareId], [DataSourceCode], [FirmCode], [InternalExternalCode]
	 FROM
	   (SELECT TOP('' + CONVERT(nvarchar(10), @@StartRowIndex + @@MaximumRows) + '')''
ELSE SET @sql = ''SELECT''

--build the query
SET @sql = @sql + '' tc.[TemplateCompareId], ds.[Code] as [DataSourceCode], f.[Code] as [FirmCode], tc.[InternalExternalCode] ''

IF @@MaximumRows >0
	SET @sql = @sql+'', ROW_NUMBER() OVER(ORDER BY '' + @@OrderBy + '') as RowNum''

SET @sql = @sql + ''
 FROM [ib_TemplateCompare] tc  
	INNER JOIN [ib_Template] t ON tc.TemplateId = t.TemplateId
	INNER JOIN [ib_DataSource] ds ON tc.DataSourceId = ds.DataSourceId
	INNER JOIN [ib_Firm] f ON tc.FirmID = f.FirmID
      '' + @where 

IF @@MaximumRows = 0
	SET @sql = @sql+''
 ORDER BY '' + @@OrderBy 

IF @@MaximumRows >0
	SET @sql = @sql +  '') x
WHERE RowNum > '' + CONVERT(nvarchar(10), @@StartRowIndex) + '' ORDER BY RowNum''

-- Execute the query
EXEC sp_executesql @sql
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TemplateCompare_GetTemplateComparesSortableAndPaginate_Count]''
');

GO
EXECUTE ('/*
<details>
	<summary>Returns the template compare count. A filter on the TemplateId may be set</summary>
	<created author="Laurentiu Macovei" Date="Wednesday, 22 september 2006, 12:36AM GMT" />		
</details>
*/
CREATE PROCEDURE [dbo].[ib_TemplateCompare_GetTemplateComparesSortableAndPaginate_Count]
	@TemplateId int = NULL
AS
SET NOCOUNT ON
	
DECLARE @SQL nvarchar(1000)
DECLARE @WHERE nvarchar(1000)

SET @WHERE = ''''
	
IF @TemplateId IS NOT NULL
	SET @WHERE = @WHERE + '' AND tc.TemplateId = '' + cast(@TemplateId as varchar(100))

	SET @sql = ''SELECT COUNT(TemplateCompareId) 
	FROM [ib_TemplateCompare] tc  
	INNER JOIN [ib_Template] t ON tc.TemplateId = t.TemplateId
	INNER JOIN [ib_DataSource] ds ON tc.DataSourceId = ds.DataSourceId
	INNER JOIN [ib_Firm] f ON tc.FirmID = f.FirmID '' + @WHERE

EXEC sp_executesql @sql
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TemplateGroup_GetItemIndex_For_TemplateGroupId_When_SortableAndPaginate]''
');

GO
EXECUTE ('


 /*
<details>
	<summary>Returns the item index for a given template group id when sortable and paginate. A filter on the TemplateId may be set</summary>
	<created author="Laurentiu Macovei" Date="Tuesday, 22 september 2006, 07:04PM GMT" />
	<updated author="laurentiu.macovei" date="Sat, 30 Sep 2006 02:13:14 GMT">
	</updated>
</details>
*/
CREATE PROCEDURE [dbo].[ib_TemplateGroup_GetItemIndex_For_TemplateGroupId_When_SortableAndPaginate]
	@TemplateId int,
	@GetItemIndexForTemplateGroupId int,
	@@OrderBy varchar(100) = NULL,
	@Exchange varchar(100) = NULL,
	@MatchCode varchar(100) = NULL

AS
SET NOCOUNT ON
--fix @GetItemIndexForTemplateGroupId
-- 13 May 2014  ED  EIB 25606 - fix sp for currency sorting
--fix orderby
IF (ISNULL(@@OrderBy, '''')='''')
	SET @@OrderBy = ''tg.Description ASC'' 

BEGIN

DECLARE @SQL nvarchar(max)
DECLARE @WHERE nvarchar(max)

SET @WHERE = ''''
IF ISNULL(@TemplateId, -1)>0
	SET @WHERE = @WHERE + '' AND tg.TemplateId = '' + cast(@TemplateId as varchar(100))

IF @MatchCode IS NOT NULL
	SET @WHERE = @WHERE + '' AND tg.Description LIKE ''''%'' + @MatchCode +''%'''' ''

IF @Exchange IS NOT NULL
	SET @WHERE = @WHERE + '' AND e.[Code] LIKE ''''%'' + @Exchange +''%'''' ''

SET @sql = ''
DECLARE @Value int
SET @Value = -1
SELECT @Value = RowNum -1
	 FROM
	   (SELECT''

--build the query
SET @sql = @sql + '' [TemplateGroupId] ''

SET @sql = @sql+'', ROW_NUMBER() OVER(ORDER BY '' + @@OrderBy + '') as RowNum''

SET @sql = @sql + ''
 FROM [ib_TemplateGroup] tg  
	LEFT JOIN [ib_Exchange] e ON tg.ExchangeID = e.ExchangeId
	LEFT JOIN [ib_Firm] f ON tg.FirmID = f.FirmID
	LEFT JOIN [ib_Class] c ON tg.ClassID = c.ClassID
	LEFT JOIN [ib_Currency] crrcy ON tg.CurrencyId = crrcy.CurrencyId
	LEFT JOIN [ib_Account] a ON tg.AccountID = a.AccountID
	LEFT JOIN [ib_Instrument] i ON tg.InstrumentID = i.InstrumentID
	INNER JOIN [ib_Template] t ON tg.TemplateId = t.TemplateId
      '' + @where 
	SET @sql = @sql +  '') x
WHERE [TemplateGroupId] = '' + CONVERT(nvarchar(10), @GetItemIndexForTemplateGroupId)
+ ''; SELECT @Value''

-- Execute the query
EXEC sp_executesql @sql

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TemplateGroup_GetTemplateGroupsSortableAndPaginate]''
');

GO
EXECUTE ('/*
<details>
	<summary>Returns the template groups sortable and paginate. A filter on the TemplateId may be set</summary>
	<created author="Laurentiu Macovei" Date="Tuesday, 22 september 2006, 13:03PM GMT" />		
	<updated author="Petru Konrad Bercea" Date="Monday, 23 february 2009 9:34PM GMT">
		Added Currency
    </updated>
</details>
--  16 Apr 2014     ED     EIB 25547 - Add filter by matchcode/exchange
--  06 May 2014     ED     EIB 25547 - fix query length
*/
CREATE PROCEDURE [dbo].[ib_TemplateGroup_GetTemplateGroupsSortableAndPaginate]
	@TemplateId int = NULL,
	@@OrderBy varchar(100) = NULL,
	@@StartRowIndex int = NULL,
	@@MaximumRows int = NULL,
	@Exchange varchar(100) = NULL,
	@MatchCode varchar(100) = NULL

AS
SET NOCOUNT ON
--fix orderby
IF (ISNULL(@@OrderBy, '''')='''')
	SET @@OrderBy = ''tg.Description ASC'' 

	--fix the top
IF IsNull(@@MaximumRows, 0) <= 0
	SET @@MaximumRows = 0
IF IsNull(@@StartRowIndex, -1) <= -1 OR @@MaximumRows = 0 
	SET @@StartRowIndex = 0

DECLARE @SQL nvarchar(max)
DECLARE @WHERE nvarchar(max)

SET @WHERE = ''''
IF @TemplateId IS NOT NULL
	SET @WHERE = @WHERE + '' AND tg.TemplateId = '' + cast(@TemplateId as varchar(100))

IF @MatchCode IS NOT NULL
	SET @WHERE = @WHERE + '' AND tg.Description LIKE ''''%'' + @MatchCode +''%'''' ''

IF @Exchange IS NOT NULL
	SET @WHERE = @WHERE + '' AND e.[Code] LIKE ''''%'' + @Exchange +''%'''' ''

IF @@MaximumRows >0
	SET @sql = ''SELECT [TemplateGroupId], [ExchangeCode], [FirmCode], [ClassCode], [CurrencyCode], [AccountCode], [InstrumentCode], [Description]
	 FROM
	   (SELECT TOP('' + CONVERT(nvarchar(10), @@StartRowIndex + @@MaximumRows) + '')''
ELSE SET @sql = ''SELECT''

--build the query
SET @sql = @sql + '' tg.[TemplateGroupId], e.[Code] as [ExchangeCode], f.[Code] as [FirmCode], c.[Code] as [ClassCode], crrcy.[Code] as [CurrencyCode], a.[Code] as [AccountCode], I.[Code] as [InstrumentCode], tg.[Description] ''

IF @@MaximumRows >0
	SET @sql = @sql+'', ROW_NUMBER() OVER(ORDER BY '' + @@OrderBy + '') as RowNum''

SET @sql = @sql + ''
 FROM [ib_TemplateGroup] tg  
	LEFT JOIN [ib_Exchange] e ON tg.ExchangeID = e.ExchangeId
	LEFT JOIN [ib_Firm] f ON tg.FirmID = f.FirmID
	LEFT JOIN [ib_Class] c ON tg.ClassID = c.ClassID
	LEFT JOIN [ib_Currency] crrcy ON tg.CurrencyId = crrcy.CurrencyId
	LEFT JOIN [ib_Account] a ON tg.AccountID = a.AccountID
	LEFT JOIN [ib_Instrument] i ON tg.InstrumentID = i.InstrumentID
	INNER JOIN [ib_Template] t ON tg.TemplateId = t.TemplateId
      '' + @where 

IF @@MaximumRows = 0
	SET @sql = @sql+''
 ORDER BY '' + @@OrderBy 

IF @@MaximumRows >0
	SET @sql = @sql +  '') x
WHERE RowNum > '' + CONVERT(nvarchar(10), @@StartRowIndex) + '' ORDER BY RowNum''

-- Execute the query
EXEC sp_executesql @sql
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TemplateGroup_GetTemplateGroupsSortableAndPaginate_Count]''
');

GO
EXECUTE ('/*
<details>
	<summary>Returns the template groups count. A filter on the TemplateId may be set</summary>
	<created author="Laurentiu Macovei" Date="Wednesday, 22 september 2006, 12:36AM GMT" />		
	<updated author="Petru Konrad Bercea" Date="Monday, 23 february 2009 9:34PM GMT">
     Added Currency
    </updated>
</details>
--  16 Apr 2014     ED     EIB 25547 - Add filter by matchcode/exchange
*/
CREATE PROCEDURE [dbo].[ib_TemplateGroup_GetTemplateGroupsSortableAndPaginate_Count]
	@TemplateId int = NULL,
	@Exchange varchar(100) = NULL,
	@MatchCode varchar(100) = NULL
AS
SET NOCOUNT ON
	
DECLARE @SQL nvarchar(1000)
DECLARE @WHERE nvarchar(1000)

SET @WHERE = ''''
	
IF @TemplateId IS NOT NULL
	SET @WHERE = @WHERE + '' AND tg.TemplateId = '' + cast(@TemplateId as varchar(100))

IF @MatchCode IS NOT NULL
	SET @WHERE = @WHERE + '' AND tg.Description LIKE ''''%'' + @MatchCode +''%'''' ''

IF @Exchange IS NOT NULL
	SET @WHERE = @WHERE + '' AND e.[Code] LIKE ''''%'' + @Exchange +''%'''' ''

	SET @sql = ''SELECT COUNT(TemplateGroupId) 
	FROM [ib_TemplateGroup] tg  
	LEFT JOIN [ib_Exchange] e ON tg.ExchangeID = e.ExchangeId
	LEFT JOIN [ib_Firm] f ON tg.FirmID = f.FirmID
	LEFT JOIN [ib_Class] c ON tg.ClassID = c.ClassID
	LEFT JOIN [ib_Currency] crrcy ON tg.CurrencyId = crrcy.CurrencyId
	LEFT JOIN [ib_Account] a ON tg.AccountID = a.AccountID
	LEFT JOIN [ib_Instrument] i ON tg.InstrumentID = i.InstrumentID
	INNER JOIN [ib_Template] t ON tg.TemplateId = t.TemplateId
'' + @WHERE

EXEC sp_executesql @sql
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Template_GetItemIndex_For_TemplateId_When_SortableAndPaginate]''
');

GO
EXECUTE ('
   /*
<details>
	<summary>Returns the item index for a given template id when sortable and paginate. A filter may be set</summary>
	<created author="laurentiu.macovei" date="Thu, 22 Sep 2006 16:48:47 GMT"/>
</details>
*/
CREATE PROCEDURE [dbo].[ib_Template_GetItemIndex_For_TemplateId_When_SortableAndPaginate]
	@GetItemIndexForTemplateId int,
	@@OrderBy varchar(100) = NULL

AS
SET NOCOUNT ON
--fix @GetItemIndexForTemplateId

--fix orderby
IF (ISNULL(@@OrderBy, '''')='''')
	SET @@OrderBy = ''t.TypeCode ASC'' 

BEGIN

DECLARE @SQL nvarchar(1000)
DECLARE @WHERE nvarchar(1000)

SET @WHERE = ''''

SET @sql = ''
DECLARE @Value int
SET @Value = -1
SELECT @Value = RowNum
	 FROM
	   (SELECT''

--build the query
SET @sql = @sql + '' [TemplateId] ''

SET @sql = @sql+'', ROW_NUMBER() OVER(ORDER BY '' + @@OrderBy + '') as RowNum''

SET @sql = @sql + ''
 FROM [ib_Template] t  
      '' + @where 
	SET @sql = @sql +  '') x
WHERE [TemplateId] = '' + CONVERT(nvarchar(10), @GetItemIndexForTemplateId)
+ ''; SELECT @Value''

-- Execute the query
EXEC sp_executesql @sql

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Template_GetTemplatesSortableAndPaginate]''
');

GO
EXECUTE ('
/*
<details>
	<summary>Returns the Templates sortable and paginate. </summary>
	<created author="laurentiu.macovei" date="Thu, 22 Sep 2006 16:33:45 GMT"/>
</details>
*/
CREATE PROCEDURE [dbo].[ib_Template_GetTemplatesSortableAndPaginate]
	@@OrderBy varchar(100) = NULL,
	@@StartRowIndex int = NULL,
	@@MaximumRows int = NULL

AS
SET NOCOUNT ON
--fix orderby
IF (ISNULL(@@OrderBy, '''')='''')
	SET @@OrderBy = ''t.TypeCode ASC'' 

	--fix the top
IF IsNull(@@MaximumRows, 0) <= 0
	SET @@MaximumRows = 0
IF IsNull(@@StartRowIndex, -1) <= -1 OR @@MaximumRows = 0 
	SET @@StartRowIndex = 0

DECLARE @SQL nvarchar(1000)
DECLARE @WHERE nvarchar(1000)

SET @WHERE = ''''

IF @@MaximumRows >0
	SET @sql = ''SELECT [TemplateId], [TypeCode], [Description], IsNull(IsAutomatchEnabled,0) as [IsAutomatchEnabled],
				(SELECT Count(TemplateGroupId) FROM [dbo].[ib_TemplateGroup] tg WHERE tg.TemplateId = x.TemplateId)  TemplateGroups,
				(SELECT Count(TemplateCompareId) FROM [dbo].[ib_TemplateCompare] tc WHERE tc.TemplateId = x.TemplateId)  TemplateCompares,
				(SELECT Count(SiteTemplateId) FROM [dbo].[ib_SiteTemplate] st WHERE st.TemplateId = x.TemplateId)  SiteTemplates,
				(SELECT COUNT(MatchCodeId) FROM [dbo].[ib_MatchCode] mc WHERE mc.TemplateId = x.TemplateId) MatchCodesCount
	 FROM
	   (SELECT TOP('' + CONVERT(nvarchar(10), @@StartRowIndex + @@MaximumRows) + '')''
ELSE SET @sql = ''SELECT''

--build the query
SET @sql = @sql + '' t.[TemplateId], t.[TypeCode], t.[Description], t.[CreateDate], t.[CreateUsername], t.[UpdateDate], t.[UpdateUsername], tt.IsAutomatchEnabled ''

IF @@MaximumRows >0
	SET @sql = @sql+'', ROW_NUMBER() OVER(ORDER BY '' + @@OrderBy + '') as RowNum''
ELSE SET @Sql = @sql + '', 
		(SELECT Count(tg.TemplateGroupId) FROM [dbo].[ib_TemplateGroup] tg WHERE tg.TemplateId = t.TemplateId)  TemplateGroups,
		(SELECT Count(tc.TemplateCompareId) FROM [dbo].[ib_TemplateCompare] tc WHERE tc.TemplateId = t.TemplateId)  TemplateCompares,
		(SELECT Count(st.SiteTemplateId) FROM [dbo].[ib_SiteTemplate] st WHERE st.TemplateId = t.TemplateId)  SiteTemplates
''
SET @sql = @sql + ''
 FROM [ib_Template] t 
 LEFT OUTER JOIN [ib_TemplateType] TT ON T.TypeCode = TT.Code
      '' + @where 

IF @@MaximumRows = 0
	SET @sql = @sql+''
 ORDER BY '' + @@OrderBy 

IF @@MaximumRows >0
	SET @sql = @sql +  '') as x
WHERE RowNum > '' + CONVERT(nvarchar(10), @@StartRowIndex) + '' ORDER BY RowNum''

-- Execute the query
EXEC sp_executesql @sql
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_Template_GetTemplatesSortableAndPaginate_Count]''
');

GO
EXECUTE ('/*
<details>
	<summary>Returns the Templates count</summary>
	<created author="laurentiu.macovei" date="Thu, 22 Sep 2006 16:44:41 GMT"/>
</details>
*/
CREATE PROCEDURE [dbo].[ib_Template_GetTemplatesSortableAndPaginate_Count]
AS
SET NOCOUNT ON
	
DECLARE @SQL nvarchar(1000)
DECLARE @WHERE nvarchar(1000)

SET @WHERE = ''''
	
	SET @sql = ''SELECT COUNT(TemplateId) 
	FROM [ib_Template] t  '' + @WHERE

EXEC sp_executesql @sql
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TrxType_GetDataSourceTrxTypesSortableAndPaginate]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_TrxType_GetDataSourceTrxTypesSortableAndPaginate]
    @DataSourceID INT = NULL
   ,@@OrderBy VARCHAR(100) = NULL
   ,@@StartRowIndex INT = NULL
   ,@@MaximumRows INT = NULL
AS 
SET NOCOUNT ON

IF ( ISNULL(@@OrderBy, '''') = '''' ) 
    SET @@OrderBy = ''ds.Code ASC'' 

	--fix the top
IF ISNULL(@@MaximumRows, 0) <= 0 
    SET @@MaximumRows = 0
IF ISNULL(@@StartRowIndex, -1) <= -1 OR
    @@MaximumRows = 0 
    SET @@StartRowIndex = 0

DECLARE @SQL NVARCHAR(1000)
DECLARE @WHERE NVARCHAR(1000)

SET @WHERE = ''WHERE (1=1)''

IF @DataSourceID IS NOT NULL 
    BEGIN
        SET @WHERE = @WHERE + ''AND(DataSourceId='' +
            CAST(@DataSourceID AS NVARCHAR(10)) + '')''
    END

SET @SQL = ''
	SELECT * FROM 
	(
		SELECT 
			[TrxTypeId],
			[DataSourceId], 
			[Code], 
			[Description],
			ROW_NUMBER() OVER(ORDER BY d.CreateDate  ASC) as RowNum,
			CreateDate,
			UpdateDate,
			CreateUsername,
			UpdateUserName
			,IsPosition
			,IsTrade
			,IsPremium
			,IsPandS
			,IsPandL
			,ExcludeFromTradeRec
			,IsCancellation
			,IsOptionMarketValue
			,IsAutoMatched
		FROM
			[ib_TrxType] d 
			'' + @WHERE + ''
	) AS ds ''

IF @@MaximumRows > 0 
    SET @sql = @sql + ''WHERE [RowNum] > '' +
        CONVERT(NVARCHAR(10), @@StartRowIndex) + '' AND [RowNum] <= '' +
        CONVERT(NVARCHAR(10), @@StartRowIndex + @@MaximumRows)
	
SET @sql = @sql + ''
		ORDER BY '' + @@OrderBy

PRINT @sql
-- Execute the query
EXEC sp_executesql @sql
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_TrxType_GetDataSourceTrxTypesSortableAndPaginate_Count]''
');

GO
EXECUTE ('CREATE PROCEDURE [dbo].[ib_TrxType_GetDataSourceTrxTypesSortableAndPaginate_Count]
    @DataSourceID INT = NULL
   ,@@OrderBy VARCHAR(100) = NULL
   ,@@StartRowIndex INT = NULL
   ,@@MaximumRows INT = NULL
AS 
SET NOCOUNT ON

DECLARE @SQL NVARCHAR(1000)
DECLARE @WHERE NVARCHAR(1000)

SET @WHERE = ''WHERE (1=1)''
	
IF @DataSourceID IS NOT NULL 
    BEGIN
        SET @WHERE = @WHERE + ''AND(DataSourceId='' +
            CAST(@DataSourceID AS NVARCHAR(10)) + '')''
    END

SET @sql = ''SELECT COUNT(TrxTypeId) 
	FROM [ib_TrxType] d (nolock)  
'' + @WHERE

EXEC sp_executesql @sql
');

GO
EXECUTE ('PRINT N''Creating [dbo].[ib_is_H_Load]''
');

GO
EXECUTE ('
-- =============================================
-- Author:		Lee Manifold (stub only)
-- Create date: 12 Jul 2006
-- Description:	Uploads data from G type tables into the ib tables 
-- =============================================
CREATE PROCEDURE [dbo].[ib_is_H_Load] 

AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	--*** Bruce slap in your code here!!!

END
');

GO
EXECUTE ('PRINT N''Creating [dbo].[vw_ib_CashReport_BrokerData_Get]''
');

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Gets records from the vw_ib_CashReport_BrokerData view passing page index and page count parameters
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [dbo].[vw_ib_CashReport_BrokerData_Get]
(

	@WhereClause varchar (2000)  ,

	@OrderBy varchar (2000)  ,

	@PageIndex int   ,

	@PageSize int   
)
AS


                    
                    BEGIN
    
                    DECLARE @PageLowerBound int
                    DECLARE @PageUpperBound int
                    
                    -- Set the page bounds
                    SET @PageLowerBound = @PageSize * @PageIndex
                    SET @PageUpperBound = @PageLowerBound + @PageSize
    
                    IF (@OrderBy IS NULL OR LEN(@OrderBy) < 1)
                    BEGIN
                        -- default order by to first column
                        SET @OrderBy = ''[DataSourceId]''
                    END
    
                    -- SQL Server 2005 Paging
                    DECLARE @SQL AS nvarchar(MAX)
                    SET @SQL = ''WITH PageIndex AS (''
                    SET @SQL = @SQL + '' SELECT''
                    IF @PageSize > 0
                    BEGIN
                        SET @SQL = @SQL + '' TOP '' + CONVERT(nvarchar, @PageUpperBound)
                    END
                    SET @SQL = @SQL + '' ROW_NUMBER() OVER (ORDER BY '' + @OrderBy + '') as RowIndex''
                    SET @SQL = @SQL + '', [DataSourceId]''
                    SET @SQL = @SQL + '', [BrokerName]''
                    SET @SQL = @SQL + '', [CurrencyId]''
                    SET @SQL = @SQL + '', [CurrencyCode]''
                    SET @SQL = @SQL + '', [CurrencyName]''
                    SET @SQL = @SQL + '', [TemplateTypeClassId]''
                    SET @SQL = @SQL + '', [TemplateTypeClassCode]''
                    SET @SQL = @SQL + '', [MatchCode]''
                    SET @SQL = @SQL + '', [TemplateTypeClassName]''
                    SET @SQL = @SQL + '', [InstrumentTypeCode]''
                    SET @SQL = @SQL + '', [InstrumentTypeName]''
                    SET @SQL = @SQL + '', [Internal_TOTE]''
                    SET @SQL = @SQL + '', [Internal_PandS]''
                    SET @SQL = @SQL + '', [Internal_AdjOTE]''
                    SET @SQL = @SQL + '', [Internal_AdjSegNon]''
                    SET @SQL = @SQL + '', [External_TOTE]''
                    SET @SQL = @SQL + '', [External_PandS]''
                    SET @SQL = @SQL + '', [External_AdjOTE]''
                    SET @SQL = @SQL + '', [External_AdjSegNon]''
                    SET @SQL = @SQL + '', [Difference]''
                    SET @SQL = @SQL + '', [CashReportId]''
                    SET @SQL = @SQL + '', [InstrumentTypeId]''
                    SET @SQL = @SQL + '', [MatchCodeId]''
                    SET @SQL = @SQL + '', [TodaysDate]''
                    SET @SQL = @SQL + '', [cheque_adj]''
                    SET @SQL = @SQL + '' FROM [dbo].[vw_ib_CashReport_BrokerData]''
                    IF LEN(@WhereClause) > 0
                    BEGIN
                        SET @SQL = @SQL + '' WHERE '' + @WhereClause
                    END
                    SET @SQL = @SQL + '' ) SELECT''
                    SET @SQL = @SQL + '' [DataSourceId],''
                    SET @SQL = @SQL + '' [BrokerName],''
                    SET @SQL = @SQL + '' [CurrencyId],''
                    SET @SQL = @SQL + '' [CurrencyCode],''
                    SET @SQL = @SQL + '' [CurrencyName],''
                    SET @SQL = @SQL + '' [TemplateTypeClassId],''
                    SET @SQL = @SQL + '' [TemplateTypeClassCode],''
                    SET @SQL = @SQL + '' [MatchCode],''
                    SET @SQL = @SQL + '' [TemplateTypeClassName],''
                    SET @SQL = @SQL + '' [InstrumentTypeCode],''
                    SET @SQL = @SQL + '' [InstrumentTypeName],''
                    SET @SQL = @SQL + '' [Internal_TOTE],''
                    SET @SQL = @SQL + '' [Internal_PandS],''
                    SET @SQL = @SQL + '' [Internal_AdjOTE],''
                    SET @SQL = @SQL + '' [Internal_AdjSegNon],''
                    SET @SQL = @SQL + '' [External_TOTE],''
                    SET @SQL = @SQL + '' [External_PandS],''
                    SET @SQL = @SQL + '' [External_AdjOTE],''
                    SET @SQL = @SQL + '' [External_AdjSegNon],''
                    SET @SQL = @SQL + '' [Difference],''
                    SET @SQL = @SQL + '' [CashReportId],''
                    SET @SQL = @SQL + '' [InstrumentTypeId],''
                    SET @SQL = @SQL + '' [MatchCodeId],''
                    SET @SQL = @SQL + '' [TodaysDate],''
                    SET @SQL = @SQL + '' [cheque_adj]''
                    SET @SQL = @SQL + '' FROM PageIndex''
                    SET @SQL = @SQL + '' WHERE RowIndex > '' + CONVERT(nvarchar, @PageLowerBound)
                    IF @PageSize > 0
                    BEGIN
                        SET @SQL = @SQL + '' AND RowIndex <= '' + CONVERT(nvarchar, @PageUpperBound)
                    END
                    IF LEN(@OrderBy) > 0
                    BEGIN
                        SET @SQL = @SQL + '' ORDER BY '' + @OrderBy
                    END
                    EXEC sp_executesql @SQL
    
                    -- get row count
                    SET @SQL = ''SELECT COUNT(*) AS TotalRowCount''
                    SET @SQL = @SQL + '' FROM [dbo].[vw_ib_CashReport_BrokerData]''
                    IF LEN(@WhereClause) > 0
                    BEGIN
                        SET @SQL = @SQL + '' WHERE '' + @WhereClause
                    END
                    EXEC sp_executesql @SQL
                    
                    END
                

');

GO
EXECUTE ('PRINT N''Creating [security].[Feature_GetPaged]''
');

GO
EXECUTE ('
	

/*
----------------------------------------------------------------------------------------------------

-- Created By:  ()
-- Purpose: Gets records from the Feature table passing page index and page count parameters
----------------------------------------------------------------------------------------------------
*/


CREATE PROCEDURE [security].[Feature_GetPaged]
(

	@WhereClause varchar (2000)  ,

	@OrderBy varchar (2000)  ,

	@PageIndex int   ,

	@PageSize int   
)
AS


				
				BEGIN
				DECLARE @PageLowerBound int
				DECLARE @PageUpperBound int
				
				-- Set the page bounds
				SET @PageLowerBound = @PageSize * @PageIndex
				SET @PageUpperBound = @PageLowerBound + @PageSize

				IF (@OrderBy IS NULL OR LEN(@OrderBy) < 1)
				BEGIN
					-- default order by to first column
					SET @OrderBy = ''[FeatureId]''
				END

				-- SQL Server 2005 Paging
				DECLARE @SQL AS nvarchar(MAX)
				SET @SQL = ''WITH PageIndex AS (''
				SET @SQL = @SQL + '' SELECT''
				IF @PageSize > 0
				BEGIN
					SET @SQL = @SQL + '' TOP '' + CONVERT(nvarchar, @PageUpperBound)
				END
				SET @SQL = @SQL + '' ROW_NUMBER() OVER (ORDER BY '' + @OrderBy + '') as RowIndex''
				SET @SQL = @SQL + '', [FeatureId]''
				SET @SQL = @SQL + '', [FeatureCode]''
				SET @SQL = @SQL + '', [FeatureName]''
				SET @SQL = @SQL + '' FROM [security].[Feature]''
				IF LEN(@WhereClause) > 0
				BEGIN
					SET @SQL = @SQL + '' WHERE '' + @WhereClause
				END
				SET @SQL = @SQL + '' ) SELECT''
				SET @SQL = @SQL + '' [FeatureId],''
				SET @SQL = @SQL + '' [FeatureCode],''
				SET @SQL = @SQL + '' [FeatureName]''
				SET @SQL = @SQL + '' FROM PageIndex''
				SET @SQL = @SQL + '' WHERE RowIndex > '' + CONVERT(nvarchar, @PageLowerBound)
				IF @PageSize > 0
				BEGIN
					SET @SQL = @SQL + '' AND RowIndex <= '' + CONVERT(nvarchar, @PageUpperBound)
				END
				SET @SQL = @SQL + '' ORDER BY '' + @OrderBy
				EXEC sp_executesql @SQL
				
				-- get row count
				SET @SQL = ''SELECT COUNT(*) AS TotalRowCount''
				SET @SQL = @SQL + '' FROM [security].[Feature]''
				IF LEN(@WhereClause) > 0
				BEGIN
					SET @SQL = @SQL + '' WHERE '' + @WhereClause
				END
				EXEC sp_executesql @SQL
			
				END
			

');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ib_PasswordHistory]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_PasswordHistory] ADD CONSTRAINT [FK_PasswordHistory_aspnet_Users] FOREIGN KEY ([UserId]) REFERENCES [dbo].[aspnet_Users] ([UserId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ib_Account]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Account] ADD CONSTRAINT [FK_ib_Account_ib_Account] FOREIGN KEY ([ParentAccountId]) REFERENCES [dbo].[ib_Account] ([AccountId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Account] ADD CONSTRAINT [FK_ib_Account_ib_Firm] FOREIGN KEY ([FirmId]) REFERENCES [dbo].[ib_Firm] ([FirmId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ib_FirmDataSource]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_FirmDataSource] ADD CONSTRAINT [FK_ib_FirmDataSource_ib_DataSource] FOREIGN KEY ([DataSourceId]) REFERENCES [dbo].[ib_DataSource] ([DataSourceId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_FirmDataSource] ADD CONSTRAINT [FK_FirmDataSource_Firm] FOREIGN KEY ([FirmId]) REFERENCES [dbo].[ib_Firm] ([FirmId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ib_TradeReconciliation]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_TradeReconciliation] ADD CONSTRAINT [FK_ib_TradeReconciliation_ib_Template] FOREIGN KEY ([TemplateId]) REFERENCES [dbo].[ib_Template] ([TemplateId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[Log]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[Log] ADD CONSTRAINT [FK_LogStatus_Log] FOREIGN KEY ([LogStatusSysId]) REFERENCES [dbo].[LogStatus] ([LogStatusSysId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[Log] ADD CONSTRAINT [FK_ReceiveLlocation_Log] FOREIGN KEY ([ReceiveLocationSysId]) REFERENCES [dbo].[ReceiveLocation] ([ReceiveLocationSysId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[Log] ADD CONSTRAINT [FK_Step_Log] FOREIGN KEY ([StepSysId]) REFERENCES [dbo].[Step] ([StepSysId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ReceiveLocation]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ReceiveLocation] ADD CONSTRAINT [FK_Package_ReceiveLocation] FOREIGN KEY ([PackageSysId]) REFERENCES [dbo].[Package] ([PackageSysId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ReceiveLocation] ADD CONSTRAINT [FK_DataSource_ReceiveLocation] FOREIGN KEY ([DataSourceId]) REFERENCES [dbo].[ib_DataSource] ([DataSourceId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ib_ImbalanceReportDetail]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_ImbalanceReportDetail] ADD CONSTRAINT [FK_ib_ImbalanceReportDetail_PositionRealisedCash] FOREIGN KEY ([PositionsRealisedCashId]) REFERENCES [dbo].[PositionsRealisedCash] ([PositionsRealisedCashId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_ImbalanceReportDetail] ADD CONSTRAINT [FK_ib_ImbalanceReportDetail_ib_Account] FOREIGN KEY ([AccountId]) REFERENCES [dbo].[ib_Account] ([AccountId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_ImbalanceReportDetail] ADD CONSTRAINT [FK_ib_ImbalanceReportDetail_ib_Class] FOREIGN KEY ([ClassId]) REFERENCES [dbo].[ib_Class] ([ClassId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_ImbalanceReportDetail] ADD CONSTRAINT [FK_ib_ImbalanceReportDetail_ib_Currency] FOREIGN KEY ([CurrencyId]) REFERENCES [dbo].[ib_Currency] ([CurrencyId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_ImbalanceReportDetail] ADD CONSTRAINT [FK_ib_ImbalanceReportDetail_ib_Exchange] FOREIGN KEY ([ExchangeId]) REFERENCES [dbo].[ib_Exchange] ([ExchangeId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_ImbalanceReportDetail] ADD CONSTRAINT [FK_ib_ImbalanceReportDetail_ib_Firm] FOREIGN KEY ([FirmId]) REFERENCES [dbo].[ib_Firm] ([FirmId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_ImbalanceReportDetail] ADD CONSTRAINT [FK_ib_ImbalanceReportDetail_ib_ImbalanceReport] FOREIGN KEY ([ImbalanceReportId]) REFERENCES [dbo].[ib_ImbalanceReport] ([ImbalanceReportId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_ImbalanceReportDetail] ADD CONSTRAINT [FK_ib_ImbalanceReportDetail_ib_Instrument] FOREIGN KEY ([InstrumentId]) REFERENCES [dbo].[ib_Instrument] ([InstrumentId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[PositionsRealisedCash]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[PositionsRealisedCash] ADD CONSTRAINT [FK_PositionsRealisedCash_Account] FOREIGN KEY ([AccountId]) REFERENCES [dbo].[ib_Account] ([AccountId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[PositionsRealisedCash] ADD CONSTRAINT [FK_PositionsRealisedCash_Currency] FOREIGN KEY ([CurrencyId]) REFERENCES [dbo].[ib_Currency] ([CurrencyId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[PositionsRealisedCash] ADD CONSTRAINT [FK_PositionsRealisedCash_DataSource] FOREIGN KEY ([DataSourceId]) REFERENCES [dbo].[ib_DataSource] ([DataSourceId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[PositionsRealisedCash] ADD CONSTRAINT [FK_PositionsRealisedCash_Exchange] FOREIGN KEY ([ExchangeId]) REFERENCES [dbo].[ib_Exchange] ([ExchangeId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[PositionsRealisedCash] ADD CONSTRAINT [FK_PositionsRealisedCash_Firm] FOREIGN KEY ([FirmId]) REFERENCES [dbo].[ib_Firm] ([FirmId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[PositionsRealisedCash] ADD CONSTRAINT [FK_PositionsRealisedCash_Instrument] FOREIGN KEY ([InstrumentId]) REFERENCES [dbo].[ib_Instrument] ([InstrumentId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[aspnet_Membership]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[aspnet_Membership] ADD CONSTRAINT [FK__aspnet_Me__Appli__6596F9B5] FOREIGN KEY ([ApplicationId]) REFERENCES [dbo].[aspnet_Applications] ([ApplicationId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[aspnet_Membership] ADD CONSTRAINT [FK__aspnet_Me__UserI__668B1DEE] FOREIGN KEY ([UserId]) REFERENCES [dbo].[aspnet_Users] ([UserId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[aspnet_Paths]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[aspnet_Paths] ADD CONSTRAINT [FK__aspnet_Pa__Appli__172E5549] FOREIGN KEY ([ApplicationId]) REFERENCES [dbo].[aspnet_Applications] ([ApplicationId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[aspnet_Roles]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[aspnet_Roles] ADD CONSTRAINT [FK__aspnet_Ro__Appli__041B80D5] FOREIGN KEY ([ApplicationId]) REFERENCES [dbo].[aspnet_Applications] ([ApplicationId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[aspnet_Users]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[aspnet_Users] ADD CONSTRAINT [FK__aspnet_Us__Appli__556091EC] FOREIGN KEY ([ApplicationId]) REFERENCES [dbo].[aspnet_Applications] ([ApplicationId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[aspnet_PersonalizationAllUsers]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[aspnet_PersonalizationAllUsers] ADD CONSTRAINT [FK__aspnet_Pe__PathI__1CE72E9F] FOREIGN KEY ([PathId]) REFERENCES [dbo].[aspnet_Paths] ([PathId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[aspnet_PersonalizationPerUser]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[aspnet_PersonalizationPerUser] ADD CONSTRAINT [FK__aspnet_Pe__PathI__20B7BF83] FOREIGN KEY ([PathId]) REFERENCES [dbo].[aspnet_Paths] ([PathId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[aspnet_PersonalizationPerUser] ADD CONSTRAINT [FK__aspnet_Pe__UserI__21ABE3BC] FOREIGN KEY ([UserId]) REFERENCES [dbo].[aspnet_Users] ([UserId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[aspnet_Profile]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[aspnet_Profile] ADD CONSTRAINT [FK__aspnet_Pr__UserI__7A92169B] FOREIGN KEY ([UserId]) REFERENCES [dbo].[aspnet_Users] ([UserId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[aspnet_UsersInRoles]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[aspnet_UsersInRoles] ADD CONSTRAINT [FK__aspnet_Us__RoleI__08E035F2] FOREIGN KEY ([RoleId]) REFERENCES [dbo].[aspnet_Roles] ([RoleId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[aspnet_UsersInRoles] ADD CONSTRAINT [FK__aspnet_Us__UserI__07EC11B9] FOREIGN KEY ([UserId]) REFERENCES [dbo].[aspnet_Users] ([UserId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [security].[RoleFeature]''
');

GO
EXECUTE ('ALTER TABLE [security].[RoleFeature] ADD CONSTRAINT [FK_RoleFeature_Role] FOREIGN KEY ([RoleId]) REFERENCES [dbo].[aspnet_Roles] ([RoleId])
');

GO
EXECUTE ('ALTER TABLE [security].[RoleFeature] ADD CONSTRAINT [FK_RoleFeature_Feature] FOREIGN KEY ([FeatureId]) REFERENCES [security].[Feature] ([FeatureId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ib_SiteUser]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_SiteUser] ADD CONSTRAINT [FK_ib_SiteUser_aspnet_Users] FOREIGN KEY ([UserId]) REFERENCES [dbo].[aspnet_Users] ([UserId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_SiteUser] ADD CONSTRAINT [FK_ib_SiteUser_ib_Site] FOREIGN KEY ([SiteId]) REFERENCES [dbo].[ib_Site] ([SiteId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ib_UserMatchCodeAccess]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_UserMatchCodeAccess] ADD CONSTRAINT [FK_ib_UserMatchCodeAccess_aspnet_Users] FOREIGN KEY ([UserId]) REFERENCES [dbo].[aspnet_Users] ([UserId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_UserMatchCodeAccess] ADD CONSTRAINT [FK_ib_UserMatchCodeAccess_AccessRight] FOREIGN KEY ([AccessRightId]) REFERENCES [dbo].[ib_AccessRight] ([AccessRightId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_UserMatchCodeAccess] ADD CONSTRAINT [FK_ib_UserMatchCodeAccess_MatchCode] FOREIGN KEY ([MatchCodeId]) REFERENCES [dbo].[ib_MatchCode] ([MatchCodeId]) ON DELETE CASCADE
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ib_Adjustment]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Adjustment] ADD CONSTRAINT [FK_Adjustment_Account] FOREIGN KEY ([AccountId]) REFERENCES [dbo].[ib_Account] ([AccountId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Adjustment] ADD CONSTRAINT [FK_Adjustment_DetailAccount] FOREIGN KEY ([DetailAccountId]) REFERENCES [dbo].[ib_Account] ([AccountId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Adjustment] ADD CONSTRAINT [FK_Adjustment_AdjustmentHeader] FOREIGN KEY ([AdjustmentHeaderId]) REFERENCES [dbo].[ib_AdjustmentHeader] ([AdjustmentHeaderId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Adjustment] ADD CONSTRAINT [FK_Adjustment_AdjustmentReason] FOREIGN KEY ([AdjustmentReasonId]) REFERENCES [dbo].[ib_AdjustmentReason] ([AdjustmentReasonId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Adjustment] ADD CONSTRAINT [FK_Adjustment_AdjustmentStatus] FOREIGN KEY ([AdjustmentStatusId]) REFERENCES [dbo].[ib_AdjustmentStatus] ([AdjustmentStatusId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Adjustment] ADD CONSTRAINT [FK_Adjustment_AdjustmentUserStatus] FOREIGN KEY ([AdjustmentUserStatusId]) REFERENCES [dbo].[ib_AdjustmentUserStatus] ([AdjustmentUserStatusId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Adjustment] ADD CONSTRAINT [FK_Adjustment_MatchingAdjustment] FOREIGN KEY ([MatchingAdjustmentId]) REFERENCES [dbo].[ib_Adjustment] ([AdjustmentId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Adjustment] ADD CONSTRAINT [FK_Adjustment_ReplacesAdjustment] FOREIGN KEY ([ReplacesAdjustmentId]) REFERENCES [dbo].[ib_Adjustment] ([AdjustmentId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Adjustment] ADD CONSTRAINT [FK_ib_Adjustment_ib_Template] FOREIGN KEY ([TemplateId]) REFERENCES [dbo].[ib_Template] ([TemplateId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Adjustment] ADD CONSTRAINT [FK_ib_Adjustment_ib_Exchange] FOREIGN KEY ([ExchangeId]) REFERENCES [dbo].[ib_Exchange] ([ExchangeId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Adjustment] ADD CONSTRAINT [FK_ib_Adjustment_ib_Instrument] FOREIGN KEY ([InstrumentId]) REFERENCES [dbo].[ib_Instrument] ([InstrumentId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Adjustment] ADD CONSTRAINT [FK_ib_Adjustment_ib_Currency] FOREIGN KEY ([CurrencyId]) REFERENCES [dbo].[ib_Currency] ([CurrencyId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Adjustment] ADD CONSTRAINT [FK_ib_Adjustment_ib_TemplateGroup] FOREIGN KEY ([TemplateGroupId]) REFERENCES [dbo].[ib_TemplateGroup] ([TemplateGroupId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Adjustment] ADD CONSTRAINT [FK_Adjustment_MatchCode] FOREIGN KEY ([MatchCodeId]) REFERENCES [dbo].[ib_MatchCode] ([MatchCodeId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Adjustment] ADD CONSTRAINT [FK_Adjustment_DataSource] FOREIGN KEY ([DataSourceId]) REFERENCES [dbo].[ib_DataSource] ([DataSourceId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Adjustment] ADD CONSTRAINT [FK_Adjustment_Firm] FOREIGN KEY ([FirmId]) REFERENCES [dbo].[ib_Firm] ([FirmId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Adjustment] ADD CONSTRAINT [FK_Adjustment_Class] FOREIGN KEY ([ClassId]) REFERENCES [dbo].[ib_Class] ([ClassId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ib_CashReportDetail]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_CashReportDetail] ADD CONSTRAINT [FK_CashReportDeail_Account] FOREIGN KEY ([AccountId]) REFERENCES [dbo].[ib_Account] ([AccountId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_CashReportDetail] ADD CONSTRAINT [FK_CashReportDetail_CashReport] FOREIGN KEY ([CashReportId]) REFERENCES [dbo].[ib_CashReport] ([CashReportId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_CashReportDetail] ADD CONSTRAINT [FK_CashReportDetail_DataSource] FOREIGN KEY ([DataSourceId]) REFERENCES [dbo].[ib_DataSource] ([DataSourceId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_CashReportDetail] ADD CONSTRAINT [FK_CashReportDetail_Exchange] FOREIGN KEY ([ExchangeId]) REFERENCES [dbo].[ib_Exchange] ([ExchangeId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_CashReportDetail] ADD CONSTRAINT [FK_CashReportDetail_Firm] FOREIGN KEY ([FirmId]) REFERENCES [dbo].[ib_Firm] ([FirmId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_CashReportDetail] ADD CONSTRAINT [FK_CashReportDetail_Class] FOREIGN KEY ([ClassId]) REFERENCES [dbo].[ib_Class] ([ClassId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_CashReportDetail] ADD CONSTRAINT [FK_CashReportDetail_Instrument] FOREIGN KEY ([InstrumentId]) REFERENCES [dbo].[ib_Instrument] ([InstrumentId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_CashReportDetail] ADD CONSTRAINT [FK_CashReportDetail_Currency] FOREIGN KEY ([CurrencyId]) REFERENCES [dbo].[ib_Currency] ([CurrencyId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ib_CloseOutReportDetail]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_CloseOutReportDetail] ADD CONSTRAINT [FK_ib_CloseOutReportDetail_ib_Account] FOREIGN KEY ([AccountId]) REFERENCES [dbo].[ib_Account] ([AccountId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_CloseOutReportDetail] ADD CONSTRAINT [FK_ib_CloseOutReportDetail_ib_Class] FOREIGN KEY ([ClassId]) REFERENCES [dbo].[ib_Class] ([ClassId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_CloseOutReportDetail] ADD CONSTRAINT [FK_ib_CloseOutReportDetail_ib_CloseOutReport] FOREIGN KEY ([CloseOutReportId]) REFERENCES [dbo].[ib_CloseOutReport] ([CloseOutReportId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_CloseOutReportDetail] ADD CONSTRAINT [FK_ib_CloseOutReportDetail_ib_Exchange] FOREIGN KEY ([ExchangeId]) REFERENCES [dbo].[ib_Exchange] ([ExchangeId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_CloseOutReportDetail] ADD CONSTRAINT [FK_ib_CloseOutReportDetail_ib_Instrument] FOREIGN KEY ([InstrumentId]) REFERENCES [dbo].[ib_Instrument] ([InstrumentId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_CloseOutReportDetail] ADD CONSTRAINT [FK_ib_CloseOutReportDetail_ib_Firm] FOREIGN KEY ([FirmId]) REFERENCES [dbo].[ib_Firm] ([FirmId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_CloseOutReportDetail] ADD CONSTRAINT [FK_ib_CloseOutReportDetail_ib_InstrumentType] FOREIGN KEY ([InstrumentTypeId]) REFERENCES [dbo].[ib_InstrumentType] ([InstrumentTypeId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ib_Money]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Money] ADD CONSTRAINT [FK_ib_Money_ib_Account] FOREIGN KEY ([AccountId]) REFERENCES [dbo].[ib_Account] ([AccountId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Money] ADD CONSTRAINT [FK_ib_Money_ib_DataSource] FOREIGN KEY ([DataSourceId]) REFERENCES [dbo].[ib_DataSource] ([DataSourceId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Money] ADD CONSTRAINT [FK_ib_Money_ib_Firm] FOREIGN KEY ([FirmId]) REFERENCES [dbo].[ib_Firm] ([FirmId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ib_PeoplesoftBalancesLog]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_PeoplesoftBalancesLog] ADD CONSTRAINT [FK_ib_PeoplesoftBalancesLog_AccountId] FOREIGN KEY ([AccountId]) REFERENCES [dbo].[ib_Account] ([AccountId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_PeoplesoftBalancesLog] ADD CONSTRAINT [FK_ib_PeoplesoftBalancesLog_CurrencyId] FOREIGN KEY ([CurrencyId]) REFERENCES [dbo].[ib_Currency] ([CurrencyId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ib_SwiftStatement]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_SwiftStatement] ADD CONSTRAINT [FK_ib_SwiftStatement_AccountId] FOREIGN KEY ([AccountId]) REFERENCES [dbo].[ib_Account] ([AccountId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_SwiftStatement] ADD CONSTRAINT [FK_ib_SwiftStatement_CurrencyId] FOREIGN KEY ([CurrencyId]) REFERENCES [dbo].[ib_Currency] ([CurrencyId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_SwiftStatement] ADD CONSTRAINT [FK_ib_SwiftStatement_GapNostroId] FOREIGN KEY ([GapNostroId]) REFERENCES [dbo].[ib_Nostro] ([NostroId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ib_TemplateGroup]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_TemplateGroup] ADD CONSTRAINT [FK_ib_TemplateGroup_ib_Account] FOREIGN KEY ([AccountId]) REFERENCES [dbo].[ib_Account] ([AccountId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_TemplateGroup] ADD CONSTRAINT [FK_ib_TemplateGroup_ib_Class] FOREIGN KEY ([ClassId]) REFERENCES [dbo].[ib_Class] ([ClassId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_TemplateGroup] ADD CONSTRAINT [FK_ib_TemplateGroup_ib_Currency] FOREIGN KEY ([CurrencyId]) REFERENCES [dbo].[ib_Currency] ([CurrencyId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_TemplateGroup] ADD CONSTRAINT [FK_ib_TemplateGroup_ib_Exchange] FOREIGN KEY ([ExchangeId]) REFERENCES [dbo].[ib_Exchange] ([ExchangeId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_TemplateGroup] ADD CONSTRAINT [FK_ib_TemplateGroup_ib_Firm] FOREIGN KEY ([FirmId]) REFERENCES [dbo].[ib_Firm] ([FirmId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_TemplateGroup] ADD CONSTRAINT [FK_ib_TemplateGroup_ib_Instrument] FOREIGN KEY ([InstrumentId]) REFERENCES [dbo].[ib_Instrument] ([InstrumentId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_TemplateGroup] ADD CONSTRAINT [FK_ib_TemplateGroup_ib_Template] FOREIGN KEY ([TemplateId]) REFERENCES [dbo].[ib_Template] ([TemplateId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ib_TradeReconciliationDetail]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_TradeReconciliationDetail] ADD CONSTRAINT [FK_ib_TradeReconciliationDetail_DetailAccountId] FOREIGN KEY ([DetailAccountId]) REFERENCES [dbo].[ib_Account] ([AccountId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_TradeReconciliationDetail] ADD CONSTRAINT [FK_ib_TradeReconciliationDetail_ib_Account] FOREIGN KEY ([AccountId]) REFERENCES [dbo].[ib_Account] ([AccountId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_TradeReconciliationDetail] ADD CONSTRAINT [FK_TradeReconciliationDetail_Adjustment] FOREIGN KEY ([AdjustmentId]) REFERENCES [dbo].[ib_Adjustment] ([AdjustmentId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_TradeReconciliationDetail] ADD CONSTRAINT [FK_ib_TradeReconciliationDetail_ib_Class] FOREIGN KEY ([ClassId]) REFERENCES [dbo].[ib_Class] ([ClassId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_TradeReconciliationDetail] ADD CONSTRAINT [FK_ib_TradeReconciliationDetail_ib_Currency] FOREIGN KEY ([CurrencyId]) REFERENCES [dbo].[ib_Currency] ([CurrencyId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_TradeReconciliationDetail] ADD CONSTRAINT [FK_TradeReconciliationDetail_DataSource] FOREIGN KEY ([DataSourceId]) REFERENCES [dbo].[ib_DataSource] ([DataSourceId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_TradeReconciliationDetail] ADD CONSTRAINT [FK_ib_TradeReconciliationDetail_ib_Exchange] FOREIGN KEY ([ExchangeId]) REFERENCES [dbo].[ib_Exchange] ([ExchangeId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_TradeReconciliationDetail] ADD CONSTRAINT [FK_ib_TradeReconciliationDetail_ib_Firm] FOREIGN KEY ([FirmId]) REFERENCES [dbo].[ib_Firm] ([FirmId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_TradeReconciliationDetail] ADD CONSTRAINT [FK_ib_TradeReconciliationDetail_ib_Instrument] FOREIGN KEY ([InstrumentId]) REFERENCES [dbo].[ib_Instrument] ([InstrumentId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_TradeReconciliationDetail] ADD CONSTRAINT [FK_ib_TradeReconciliationDetail_ib_TradeReconciliation] FOREIGN KEY ([TradeReconciliationId]) REFERENCES [dbo].[ib_TradeReconciliation] ([TradeReconciliationId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_TradeReconciliationDetail] ADD CONSTRAINT [FK_ib_TradeReconciliationDetail_ib_Trx] FOREIGN KEY ([TrxId]) REFERENCES [dbo].[ib_Trx] ([TrxId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ib_Trx]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Trx] ADD CONSTRAINT [FK_ib_Trx_DetailAccountId] FOREIGN KEY ([DetailAccountId]) REFERENCES [dbo].[ib_Account] ([AccountId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Trx] ADD CONSTRAINT [FK_Trx_Account] FOREIGN KEY ([AccountId]) REFERENCES [dbo].[ib_Account] ([AccountId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Trx] ADD CONSTRAINT [FK_Trx_MatchingAdjustment] FOREIGN KEY ([MatchingAdjustmentId]) REFERENCES [dbo].[ib_Adjustment] ([AdjustmentId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Trx] ADD CONSTRAINT [FK_ib_Trx_ib_Class] FOREIGN KEY ([ClassId]) REFERENCES [dbo].[ib_Class] ([ClassId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Trx] ADD CONSTRAINT [FK_Transaction_Currency] FOREIGN KEY ([CurrencyId]) REFERENCES [dbo].[ib_Currency] ([CurrencyId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Trx] ADD CONSTRAINT [FK_ib_Trx_ib_DataSource] FOREIGN KEY ([DataSourceId]) REFERENCES [dbo].[ib_DataSource] ([DataSourceId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Trx] ADD CONSTRAINT [FK_Transaction_Exchange] FOREIGN KEY ([ExchangeId]) REFERENCES [dbo].[ib_Exchange] ([ExchangeId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Trx] ADD CONSTRAINT [FK_Transaction_Firm] FOREIGN KEY ([FirmId]) REFERENCES [dbo].[ib_Firm] ([FirmId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Trx] ADD CONSTRAINT [FK_Trx_Instrument] FOREIGN KEY ([InstrumentId]) REFERENCES [dbo].[ib_Instrument] ([InstrumentId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ib_Nostro]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Nostro] ADD CONSTRAINT [FK_Nostro_Account] FOREIGN KEY ([AccountId]) REFERENCES [dbo].[ib_Account] ([AccountId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Nostro] ADD CONSTRAINT [FK_Nostro_Currency] FOREIGN KEY ([CurrencyId]) REFERENCES [dbo].[ib_Currency] ([CurrencyId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Nostro] ADD CONSTRAINT [FK_Nostro_DataSource] FOREIGN KEY ([DataSourceId]) REFERENCES [dbo].[ib_DataSource] ([DataSourceId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Nostro] ADD CONSTRAINT [FK_Nostro_Department] FOREIGN KEY ([DepartmentId]) REFERENCES [dbo].[ib_Department] ([DepartmentId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Nostro] ADD CONSTRAINT [FK_ib_Nostro_ib_NostroBalancingId] FOREIGN KEY ([NostroBalancingItemId]) REFERENCES [dbo].[ib_NostroBalancingItem] ([NostroBalancingItemId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Nostro] ADD CONSTRAINT [FK_ib_Nostro_NostroMatchId] FOREIGN KEY ([NostroMatchId]) REFERENCES [dbo].[ib_NostroMatch] ([NostroMatchId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ib_Position]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Position] ADD CONSTRAINT [FK_Position_Account] FOREIGN KEY ([AccountId]) REFERENCES [dbo].[ib_Account] ([AccountId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Position] ADD CONSTRAINT [FK_ib_Position_ib_Class] FOREIGN KEY ([ClassId]) REFERENCES [dbo].[ib_Class] ([ClassId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Position] ADD CONSTRAINT [FK_Position_Currency] FOREIGN KEY ([CurrencyId]) REFERENCES [dbo].[ib_Currency] ([CurrencyId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Position] ADD CONSTRAINT [FK_ib_Position_ib_DataSource] FOREIGN KEY ([DataSourceId]) REFERENCES [dbo].[ib_DataSource] ([DataSourceId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Position] ADD CONSTRAINT [FK_Position_Exchange] FOREIGN KEY ([ExchangeId]) REFERENCES [dbo].[ib_Exchange] ([ExchangeId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Position] ADD CONSTRAINT [FK_Position_Firm] FOREIGN KEY ([FirmId]) REFERENCES [dbo].[ib_Firm] ([FirmId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Position] ADD CONSTRAINT [FK_Position_Instrument] FOREIGN KEY ([InstrumentId]) REFERENCES [dbo].[ib_Instrument] ([InstrumentId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ib_SwiftStatementSeed]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_SwiftStatementSeed] ADD CONSTRAINT [FK_SwiftStatementSeed_Account] FOREIGN KEY ([AccountId]) REFERENCES [dbo].[ib_Account] ([AccountId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ib_Account]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Account] ADD CONSTRAINT [FK_ib_Account_ib_Class] FOREIGN KEY ([ClassId]) REFERENCES [dbo].[ib_Class] ([ClassId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ib_AdjustmentHeader]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_AdjustmentHeader] ADD CONSTRAINT [FK_AdjustmentHeader_AdjustmentType] FOREIGN KEY ([AdjustmentTypeId]) REFERENCES [dbo].[ib_AdjustmentType] ([AdjustmentTypeId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_AdjustmentHeader] ADD CONSTRAINT [FK_AdjustmentHeader_Price] FOREIGN KEY ([PriceId]) REFERENCES [dbo].[ib_Price] ([PriceId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_AdjustmentHeader] ADD CONSTRAINT [FK_AdjustmentHeader_AdjustmentStatus] FOREIGN KEY ([AdjustmentStatusId]) REFERENCES [dbo].[ib_AdjustmentStatus] ([AdjustmentStatusId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_AdjustmentHeader] ADD CONSTRAINT [FK_AdjustmentHeader_AdjustmentReason] FOREIGN KEY ([AdjustmentReasonId]) REFERENCES [dbo].[ib_AdjustmentReason] ([AdjustmentReasonId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_AdjustmentHeader] ADD CONSTRAINT [FK_AdjustmentHeader_AdjustmentUserStatus] FOREIGN KEY ([AdjustmentUserStatusId]) REFERENCES [dbo].[ib_AdjustmentUserStatus] ([AdjustmentUserStatusId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_AdjustmentHeader] ADD CONSTRAINT [FK_TradeReconciliationSummary] FOREIGN KEY ([TradeReconciliationSummaryId]) REFERENCES [dbo].[ib_TradeReconciliationSummary] ([TradeReconciliationSummaryId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ib_TaskType]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_TaskType] ADD CONSTRAINT [FK_ib_TaskType_ib_Assembly] FOREIGN KEY ([AssemblyId]) REFERENCES [dbo].[ib_Assembly] ([AssemblyId]) ON UPDATE CASCADE
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ib_BaseDataSource]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_BaseDataSource] ADD CONSTRAINT [FK_ib_BaseDataSource_ib_Base] FOREIGN KEY ([BaseId]) REFERENCES [dbo].[ib_Base] ([BaseId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_BaseDataSource] ADD CONSTRAINT [FK_ib_BaseDataSource_ib_DataSource] FOREIGN KEY ([DataSourceId]) REFERENCES [dbo].[ib_DataSource] ([DataSourceId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ib_Instrument]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Instrument] ADD CONSTRAINT [FK_ib_Instrument_ib_Base] FOREIGN KEY ([BaseId]) REFERENCES [dbo].[ib_Base] ([BaseId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Instrument] ADD CONSTRAINT [FK_Instrument_InstrumentType] FOREIGN KEY ([InstrumentTypeId]) REFERENCES [dbo].[ib_InstrumentType] ([InstrumentTypeId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ib_InstrumentDataSource]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_InstrumentDataSource] ADD CONSTRAINT [FK_ib_InstrumentDataSource_ib_Base] FOREIGN KEY ([BaseId]) REFERENCES [dbo].[ib_Base] ([BaseId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_InstrumentDataSource] ADD CONSTRAINT [FK_InstrumentDataSource_Currency] FOREIGN KEY ([CurrencyId]) REFERENCES [dbo].[ib_Currency] ([CurrencyId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_InstrumentDataSource] ADD CONSTRAINT [FK_ib_InstrumentDataSource_ib_DataSource] FOREIGN KEY ([DataSourceId]) REFERENCES [dbo].[ib_DataSource] ([DataSourceId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_InstrumentDataSource] ADD CONSTRAINT [FK_InstrumentDataSource_Instrument] FOREIGN KEY ([InstrumentId]) REFERENCES [dbo].[ib_Instrument] ([InstrumentId]) ON DELETE CASCADE
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ib_MatchCode]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_MatchCode] ADD CONSTRAINT [FK_ib_MatchCode_ib_Broker] FOREIGN KEY ([BrokerId]) REFERENCES [dbo].[ib_Broker] ([BrokerId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_MatchCode] ADD CONSTRAINT [FK_TemplateId] FOREIGN KEY ([TemplateId]) REFERENCES [dbo].[ib_Template] ([TemplateId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_MatchCode] ADD CONSTRAINT [FK_MatchCode_TemplateTypeClass] FOREIGN KEY ([TemplateTypeClassId]) REFERENCES [dbo].[ib_TemplateTypeClass] ([TemplateTypeClassId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ib_Broker]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Broker] ADD CONSTRAINT [FK_ib_Broker_Datasource] FOREIGN KEY ([DatasourceId]) REFERENCES [dbo].[ib_DataSource] ([DataSourceId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ib_CashGroupExchange]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_CashGroupExchange] ADD CONSTRAINT [FK_CashGroupExchange_CashGroup] FOREIGN KEY ([CashGroupId]) REFERENCES [dbo].[ib_CashGroup] ([CashGroupId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_CashGroupExchange] ADD CONSTRAINT [FK_CashGroupExchange_Exchange] FOREIGN KEY ([ExchangeId]) REFERENCES [dbo].[ib_Exchange] ([ExchangeId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ib_CashReportSummary]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_CashReportSummary] ADD CONSTRAINT [FK_CashReportSummary_ImbalanceReport] FOREIGN KEY ([ImbalanceReportId]) REFERENCES [dbo].[ib_ImbalanceReport] ([ImbalanceReportId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_CashReportSummary] ADD CONSTRAINT [FK_CashReportSummary_CashReport] FOREIGN KEY ([CashReportId]) REFERENCES [dbo].[ib_CashReport] ([CashReportId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_CashReportSummary] ADD CONSTRAINT [FK_CashReportSummary_MatchCode] FOREIGN KEY ([MatchCodeId]) REFERENCES [dbo].[ib_MatchCode] ([MatchCodeId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_CashReportSummary] ADD CONSTRAINT [FK_CashReportSummary_DataSource] FOREIGN KEY ([DatasourceId]) REFERENCES [dbo].[ib_DataSource] ([DataSourceId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_CashReportSummary] ADD CONSTRAINT [FK_CashReportSummary_Exchange] FOREIGN KEY ([ExchangeId]) REFERENCES [dbo].[ib_Exchange] ([ExchangeId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_CashReportSummary] ADD CONSTRAINT [FK_CashReportSummary_Currency] FOREIGN KEY ([CurrencyId]) REFERENCES [dbo].[ib_Currency] ([CurrencyId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_CashReportSummary] ADD CONSTRAINT [FK_CashReportSummary_InstrumentType] FOREIGN KEY ([InstrumentTypeId]) REFERENCES [dbo].[ib_InstrumentType] ([InstrumentTypeId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ib_CashReport]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_CashReport] ADD CONSTRAINT [FK_CashReport_ImbalanceReportId] FOREIGN KEY ([ImbalanceReportId]) REFERENCES [dbo].[ib_ImbalanceReport] ([ImbalanceReportId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ib_CloseOutReportSummary]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_CloseOutReportSummary] ADD CONSTRAINT [FK_ib_CloseOutReportSummary_ib_CloseOutReport] FOREIGN KEY ([CloseOutReportId]) REFERENCES [dbo].[ib_CloseOutReport] ([CloseOutReportId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_CloseOutReportSummary] ADD CONSTRAINT [FK_ib_CloseOutReportSummary_ib_Exchange] FOREIGN KEY ([ExchangeId]) REFERENCES [dbo].[ib_Exchange] ([ExchangeId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_CloseOutReportSummary] ADD CONSTRAINT [FK_ib_CloseOutReportSummary_ib_Instrument] FOREIGN KEY ([InstrumentId]) REFERENCES [dbo].[ib_Instrument] ([InstrumentId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_CloseOutReportSummary] ADD CONSTRAINT [FK_ib_CloseOutReportSummary_ib_InstrumentType] FOREIGN KEY ([InstrumentTypeId]) REFERENCES [dbo].[ib_InstrumentType] ([InstrumentTypeId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ib_CloseOutReport]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_CloseOutReport] ADD CONSTRAINT [FK_ib_CloseOutReport_ib_Template] FOREIGN KEY ([TemplateId]) REFERENCES [dbo].[ib_Template] ([TemplateId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ib_DataSourceConfiguration]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_DataSourceConfiguration] ADD CONSTRAINT [FK_ib_DataSourceConfiguration_ib_ConfigurationType] FOREIGN KEY ([ConfigurationTypeId]) REFERENCES [dbo].[ib_ConfigurationType] ([ConfigurationTypeId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_DataSourceConfiguration] ADD CONSTRAINT [FK_ib_DataSourceConfiguration_ib_DataSource] FOREIGN KEY ([DataSourceId]) REFERENCES [dbo].[ib_DataSource] ([DataSourceId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ib_CurrencyDataSource]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_CurrencyDataSource] ADD CONSTRAINT [FK_CurrencyDataSource_Currency] FOREIGN KEY ([CurrencyId]) REFERENCES [dbo].[ib_Currency] ([CurrencyId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_CurrencyDataSource] ADD CONSTRAINT [FK_ib_CurrencyDataSource_ib_DataSource] FOREIGN KEY ([DataSourceId]) REFERENCES [dbo].[ib_DataSource] ([DataSourceId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ib_DataSource]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_DataSource] ADD CONSTRAINT [FK_ib_DataSource_ib_Currency] FOREIGN KEY ([DefaultCurrencyId]) REFERENCES [dbo].[ib_Currency] ([CurrencyId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ib_EquityHeader]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_EquityHeader] ADD CONSTRAINT [FK_ib_EquityHeader_ib_Currency] FOREIGN KEY ([CurrencyId]) REFERENCES [dbo].[ib_Currency] ([CurrencyId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_EquityHeader] ADD CONSTRAINT [FK_ib_EquityHeader_ib_Template] FOREIGN KEY ([TemplateId]) REFERENCES [dbo].[ib_Template] ([TemplateId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ib_Fee]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Fee] ADD CONSTRAINT [FK_ib_Fee_ib_Currency] FOREIGN KEY ([CurrencyId]) REFERENCES [dbo].[ib_Currency] ([CurrencyId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Fee] ADD CONSTRAINT [FK_ib_Fee_ib_FeeType] FOREIGN KEY ([FeeTypeId]) REFERENCES [dbo].[ib_FeeType] ([FeeTypeId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Fee] ADD CONSTRAINT [FK_ib_Fee_ib_Trx] FOREIGN KEY ([TrxId]) REFERENCES [dbo].[ib_Trx] ([TrxId]) ON DELETE CASCADE
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ib_ImbalanceReportSummary]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_ImbalanceReportSummary] ADD CONSTRAINT [FK_ib_ImbalanceReportSummary_ib_Currency] FOREIGN KEY ([CurrencyId]) REFERENCES [dbo].[ib_Currency] ([CurrencyId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_ImbalanceReportSummary] ADD CONSTRAINT [FK_ib_ImbalanceReportSummary_ib_Exchange] FOREIGN KEY ([ExchangeId]) REFERENCES [dbo].[ib_Exchange] ([ExchangeId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_ImbalanceReportSummary] ADD CONSTRAINT [FK_ib_ImbalanceReportSummary_ib_ImbalanceReport] FOREIGN KEY ([ImbalanceReportId]) REFERENCES [dbo].[ib_ImbalanceReport] ([ImbalanceReportId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_ImbalanceReportSummary] ADD CONSTRAINT [FK_ib_ImbalanceReportSummary_ib_Instrument] FOREIGN KEY ([InstrumentId]) REFERENCES [dbo].[ib_Instrument] ([InstrumentId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ib_InstrumentDetail]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_InstrumentDetail] ADD CONSTRAINT [FK_ib_InstrumentDetail_ib_Currency] FOREIGN KEY ([CurrencyId]) REFERENCES [dbo].[ib_Currency] ([CurrencyId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_InstrumentDetail] ADD CONSTRAINT [FK_ib_InstrumentDetail_ib_Instrument] FOREIGN KEY ([InstrumentId]) REFERENCES [dbo].[ib_Instrument] ([InstrumentId]) ON DELETE CASCADE
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ib_Price]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Price] ADD CONSTRAINT [FK_ib_Price_ib_Currency] FOREIGN KEY ([CurrencyId]) REFERENCES [dbo].[ib_Currency] ([CurrencyId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Price] ADD CONSTRAINT [FK_ib_Price_ib_DataSource] FOREIGN KEY ([DataSourceId]) REFERENCES [dbo].[ib_DataSource] ([DataSourceId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Price] ADD CONSTRAINT [FK_ib_Price_ib_Exchange] FOREIGN KEY ([ExchangeId]) REFERENCES [dbo].[ib_Exchange] ([ExchangeId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Price] ADD CONSTRAINT [FK_ib_Price_ib_ImportFile] FOREIGN KEY ([ImportFileId]) REFERENCES [dbo].[ib_ImportFile] ([ImportFileId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Price] ADD CONSTRAINT [FK_ib_Price_ib_Instrument] FOREIGN KEY ([InstrumentId]) REFERENCES [dbo].[ib_Instrument] ([InstrumentId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ib_TradeReconciliationSummary]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_TradeReconciliationSummary] ADD CONSTRAINT [FK_ib_TradeReconciliationSummary_ib_Currency] FOREIGN KEY ([CurrencyId]) REFERENCES [dbo].[ib_Currency] ([CurrencyId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_TradeReconciliationSummary] ADD CONSTRAINT [FK_ib_TradeReconciliationSummary_ib_Exchange] FOREIGN KEY ([ExchangeId]) REFERENCES [dbo].[ib_Exchange] ([ExchangeId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_TradeReconciliationSummary] ADD CONSTRAINT [FK_ib_TradeReconciliationSummary_ib_Instrument] FOREIGN KEY ([InstrumentId]) REFERENCES [dbo].[ib_Instrument] ([InstrumentId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_TradeReconciliationSummary] ADD CONSTRAINT [FK_ib_TradeReconciliationSummary_ib_TradeReconciliation] FOREIGN KEY ([TradeReconciliationId]) REFERENCES [dbo].[ib_TradeReconciliation] ([TradeReconciliationId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ib_PriceReportSummary]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_PriceReportSummary] ADD CONSTRAINT [FK_PriceReportSummary_Currency] FOREIGN KEY ([CurrencyId]) REFERENCES [dbo].[ib_Currency] ([CurrencyId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_PriceReportSummary] ADD CONSTRAINT [FK_PriceReportSummary_ExternalDataSource] FOREIGN KEY ([External_DataSourceId]) REFERENCES [dbo].[ib_DataSource] ([DataSourceId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_PriceReportSummary] ADD CONSTRAINT [FK_PriceReportSummary_InternalDataSource] FOREIGN KEY ([Internal_DataSourceId]) REFERENCES [dbo].[ib_DataSource] ([DataSourceId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_PriceReportSummary] ADD CONSTRAINT [FK_PriceReportSummary_Exchange] FOREIGN KEY ([ExchangeId]) REFERENCES [dbo].[ib_Exchange] ([ExchangeId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_PriceReportSummary] ADD CONSTRAINT [FK_PriceReportSummary_Instrument] FOREIGN KEY ([InstrumentId]) REFERENCES [dbo].[ib_Instrument] ([InstrumentId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_PriceReportSummary] ADD CONSTRAINT [FK_PriceReportSummary_PriceReport] FOREIGN KEY ([PriceReportId]) REFERENCES [dbo].[ib_PriceReport] ([PriceReportId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_PriceReportSummary] ADD CONSTRAINT [FK_PriceReportSummary_InternalPrice] FOREIGN KEY ([Internal_PriceId]) REFERENCES [dbo].[ib_Price] ([PriceId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_PriceReportSummary] ADD CONSTRAINT [FK_PriceReportSummary_ExternalPrice] FOREIGN KEY ([External_PriceId]) REFERENCES [dbo].[ib_Price] ([PriceId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ib_DataSourceExchange]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_DataSourceExchange] ADD CONSTRAINT [FK_ib_DataSourceExchange_ib_DataSource] FOREIGN KEY ([DataSourceId]) REFERENCES [dbo].[ib_DataSource] ([DataSourceId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_DataSourceExchange] ADD CONSTRAINT [FK_ib_DataSourceExchange_ib_Exchange] FOREIGN KEY ([ExchangeId]) REFERENCES [dbo].[ib_Exchange] ([ExchangeId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ib_DataSourceMapping]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_DataSourceMapping] ADD CONSTRAINT [FK_ib_DataSourceMapping_ib_DataSource] FOREIGN KEY ([DataSourceId]) REFERENCES [dbo].[ib_DataSource] ([DataSourceId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_DataSourceMapping] ADD CONSTRAINT [FK_ib_DataSourceMapping_ib_DataSource1] FOREIGN KEY ([MappedDataSourceId]) REFERENCES [dbo].[ib_DataSource] ([DataSourceId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ib_ImportFile]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_ImportFile] ADD CONSTRAINT [FK_ib_ImportFile_ib_DataSource] FOREIGN KEY ([DataSourceId]) REFERENCES [dbo].[ib_DataSource] ([DataSourceId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ib_ImportSettings]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_ImportSettings] ADD CONSTRAINT [FK_ib_ImportSettings_ib_DataSource] FOREIGN KEY ([DataSourceId]) REFERENCES [dbo].[ib_DataSource] ([DataSourceId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ib_InstrumentTypeDataSource]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_InstrumentTypeDataSource] ADD CONSTRAINT [FK_ib_InstrumentTypeDataSource_ib_DataSource] FOREIGN KEY ([DataSourceId]) REFERENCES [dbo].[ib_DataSource] ([DataSourceId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_InstrumentTypeDataSource] ADD CONSTRAINT [FK_ib_InstrumentTypeDataSource_ib_InstrumentType] FOREIGN KEY ([InstrumentTypeId]) REFERENCES [dbo].[ib_InstrumentType] ([InstrumentTypeId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ib_TemplateCompare]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_TemplateCompare] ADD CONSTRAINT [FK_ib_TemplateCompare_ib_DataSource] FOREIGN KEY ([DataSourceId]) REFERENCES [dbo].[ib_DataSource] ([DataSourceId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_TemplateCompare] ADD CONSTRAINT [FK_ib_TemplateCompare_ib_Firm] FOREIGN KEY ([FirmId]) REFERENCES [dbo].[ib_Firm] ([FirmId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_TemplateCompare] ADD CONSTRAINT [FK_ib_TemplateCompare_ib_Template] FOREIGN KEY ([TemplateId]) REFERENCES [dbo].[ib_Template] ([TemplateId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ib_TrxType]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_TrxType] ADD CONSTRAINT [FK_ib_TrxType_ib_DataSource] FOREIGN KEY ([DataSourceId]) REFERENCES [dbo].[ib_DataSource] ([DataSourceId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ib_ImportMonitor]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_ImportMonitor] ADD CONSTRAINT [FK_ImportMonitor_DataSource] FOREIGN KEY ([DataSourceId]) REFERENCES [dbo].[ib_DataSource] ([DataSourceId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ib_Field]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Field] ADD CONSTRAINT [FK_ib_Field_ib_DataType] FOREIGN KEY ([DataTypeId]) REFERENCES [dbo].[ib_DataType] ([DataTypeId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ib_Operator]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Operator] ADD CONSTRAINT [FK_ib_Operator_ib_DataType] FOREIGN KEY ([DataTypeId]) REFERENCES [dbo].[ib_DataType] ([DataTypeId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ib_Nostro_NotesHistory]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Nostro_NotesHistory] ADD CONSTRAINT [FK_ib_Nostro_NotesHistory_ib_Department] FOREIGN KEY ([DepartmentId]) REFERENCES [dbo].[ib_Department] ([DepartmentId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Nostro_NotesHistory] ADD CONSTRAINT [FK_ib_Nostro_NotesHistory_ib_Nostro] FOREIGN KEY ([NostroId]) REFERENCES [dbo].[ib_Nostro] ([NostroId]) ON DELETE CASCADE
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ib_EquityCash]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_EquityCash] ADD CONSTRAINT [FK_ib_EquityCash_ib_EquityHeader] FOREIGN KEY ([EquityHeaderId]) REFERENCES [dbo].[ib_EquityHeader] ([EquityHeaderId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ib_Equity]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Equity] ADD CONSTRAINT [FK_ib_Equity_ib_EquityHeader] FOREIGN KEY ([EquityHeaderId]) REFERENCES [dbo].[ib_EquityHeader] ([EquityHeaderId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ib_RuleCondition]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_RuleCondition] ADD CONSTRAINT [FK_ib_RuleCondition_ib_Field] FOREIGN KEY ([Field1Id]) REFERENCES [dbo].[ib_Field] ([FieldId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_RuleCondition] ADD CONSTRAINT [FK_ib_RuleCondition_ib_Field1] FOREIGN KEY ([Field2Id]) REFERENCES [dbo].[ib_Field] ([FieldId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_RuleCondition] ADD CONSTRAINT [FK_ib_RuleCondition_ib_Operator] FOREIGN KEY ([OperatorId]) REFERENCES [dbo].[ib_Operator] ([OperatorId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_RuleCondition] ADD CONSTRAINT [FK_ib_RuleCondition_ib_Rule] FOREIGN KEY ([RuleId]) REFERENCES [dbo].[ib_Rule] ([RuleId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ib_ImbalanceReport]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_ImbalanceReport] ADD CONSTRAINT [FK_ib_ImbalanceReport_ib_Template] FOREIGN KEY ([TemplateId]) REFERENCES [dbo].[ib_Template] ([TemplateId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ib_RuleMatchCode]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_RuleMatchCode] ADD CONSTRAINT [FK_ib_RuleMatchCode_ib_MatchCode] FOREIGN KEY ([MatchCodeId]) REFERENCES [dbo].[ib_MatchCode] ([MatchCodeId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_RuleMatchCode] ADD CONSTRAINT [FK_ib_RuleMatchCode_ib_Rule] FOREIGN KEY ([RuleId]) REFERENCES [dbo].[ib_Rule] ([RuleId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ib_NostroBalance]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_NostroBalance] ADD CONSTRAINT [FK_MatchCodeId] FOREIGN KEY ([MatchCodeId]) REFERENCES [dbo].[ib_MatchCode] ([MatchCodeId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ib_Rule]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Rule] ADD CONSTRAINT [FK_ib_Rule_ib_MatchCountType] FOREIGN KEY ([MatchCountTypeId]) REFERENCES [dbo].[ib_MatchCountType] ([MatchCountTypeId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Rule] ADD CONSTRAINT [FK_ib_Rule_ib_RuleType] FOREIGN KEY ([RuleTypeId]) REFERENCES [dbo].[ib_RuleType] ([RuleTypeId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Rule] ADD CONSTRAINT [FK_ib_Rule_ib_Template] FOREIGN KEY ([TemplateId]) REFERENCES [dbo].[ib_Template] ([TemplateId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Rule] ADD CONSTRAINT [FK_ib_Rule_ib_ToleranceType] FOREIGN KEY ([ToleranceTypeId]) REFERENCES [dbo].[ib_ToleranceType] ([ToleranceTypeId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ib_NostroMatch]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_NostroMatch] ADD CONSTRAINT [FK_NostroMatchTypeId] FOREIGN KEY ([NostroMatchTypeId]) REFERENCES [dbo].[ib_NostroMatchType] ([NostroMatchTypeId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_NostroMatch] ADD CONSTRAINT [FK_NostroId] FOREIGN KEY ([NostroId]) REFERENCES [dbo].[ib_Nostro] ([NostroId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_NostroMatch] ADD CONSTRAINT [FK_ib_NostroMatch_ib_Rule] FOREIGN KEY ([RuleId]) REFERENCES [dbo].[ib_Rule] ([RuleId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ib_PriceReport]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_PriceReport] ADD CONSTRAINT [FK_PriceReport_Template] FOREIGN KEY ([TemplateId]) REFERENCES [dbo].[ib_Template] ([TemplateId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ib_QueueLog]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_QueueLog] ADD CONSTRAINT [FK_ib_QueueLog_ib_QueueItem] FOREIGN KEY ([QueueItemId]) REFERENCES [dbo].[ib_QueueItem] ([QueueItemId]) ON DELETE CASCADE ON UPDATE CASCADE
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ib_QueueItem]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_QueueItem] ADD CONSTRAINT [FK_ib_QueueItem_ib_QueueStatus] FOREIGN KEY ([StatusId]) REFERENCES [dbo].[ib_QueueStatus] ([QueueStatusId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_QueueItem] ADD CONSTRAINT [FK_ib_QueueItem_ib_ScheduledTask] FOREIGN KEY ([ScheduledTaskId]) REFERENCES [dbo].[ib_ScheduledTask] ([ScheduledTaskId]) ON DELETE CASCADE
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_QueueItem] ADD CONSTRAINT [FK_ib_QueueItem_ib_Site] FOREIGN KEY ([SiteId]) REFERENCES [dbo].[ib_Site] ([SiteId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_QueueItem] ADD CONSTRAINT [FK_ib_QueueItem_ib_Template] FOREIGN KEY ([TemplateId]) REFERENCES [dbo].[ib_Template] ([TemplateId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_QueueItem] ADD CONSTRAINT [FK_ib_QueueItem_ib_TaskType] FOREIGN KEY ([TaskTypeId]) REFERENCES [dbo].[ib_TaskType] ([TaskTypeId]) ON DELETE CASCADE
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ib_Report]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_Report] ADD CONSTRAINT [FK_ib_Report_ib_Site] FOREIGN KEY ([SiteId]) REFERENCES [dbo].[ib_Site] ([SiteId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ib_RuleType]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_RuleType] ADD CONSTRAINT [FK_ib_RuleType_ib_TemplateType] FOREIGN KEY ([TemplateTypeId]) REFERENCES [dbo].[ib_TemplateType] ([TemplateTypeId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ib_ScheduledTask]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_ScheduledTask] ADD CONSTRAINT [FK_ib_ScheduledTask_ib_TaskType] FOREIGN KEY ([TaskTypeId]) REFERENCES [dbo].[ib_TaskType] ([TaskTypeId]) ON UPDATE CASCADE
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_ScheduledTask] ADD CONSTRAINT [FK_ib_ScheduledTask_ib_Site] FOREIGN KEY ([SiteId]) REFERENCES [dbo].[ib_Site] ([SiteId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_ScheduledTask] ADD CONSTRAINT [FK_ib_ScheduledTask_ib_Template] FOREIGN KEY ([TemplateId]) REFERENCES [dbo].[ib_Template] ([TemplateId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ib_SiteTemplate]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_SiteTemplate] ADD CONSTRAINT [FK_ib_SiteTemplate_ib_Site] FOREIGN KEY ([SiteId]) REFERENCES [dbo].[ib_Site] ([SiteId])
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_SiteTemplate] ADD CONSTRAINT [FK_ib_SiteTemplate_ib_Template] FOREIGN KEY ([TemplateId]) REFERENCES [dbo].[ib_Template] ([TemplateId])
');

GO
EXECUTE ('PRINT N''Adding foreign keys to [dbo].[ib_TemplateTypeClass]''
');

GO
EXECUTE ('ALTER TABLE [dbo].[ib_TemplateTypeClass] ADD CONSTRAINT [FK_TemplateTypeClass_TemplateType] FOREIGN KEY ([TemplateTypeId]) REFERENCES [dbo].[ib_TemplateType] ([TemplateTypeId])
');

GO
SET NOEXEC OFF;

GO
IF N'$(IsSqlCmdEnabled)' <> N'True'
  SET NOEXEC ON;

GO
IF NOT EXISTS (SELECT 1 FROM [$(DatabaseName)].[dbo].[__MigrationLogCurrent] WHERE [migration_id] = CAST ('12e5f6de-57cb-4306-9967-84097e737154' AS UNIQUEIDENTIFIER))
  PRINT '***** FINISHED EXECUTING MIGRATION "Migrations\1.0.0\001_20190625-0815_MitrascaS.sql", ID: {12e5f6de-57cb-4306-9967-84097e737154} *****
';

GO
IF NOT EXISTS (SELECT 1 FROM [$(DatabaseName)].[dbo].[__MigrationLogCurrent] WHERE [migration_id] = CAST ('12e5f6de-57cb-4306-9967-84097e737154' AS UNIQUEIDENTIFIER))
  INSERT [$(DatabaseName)].[dbo].[__MigrationLog] ([migration_id], [script_checksum], [script_filename], [complete_dt], [applied_by], [deployed], [version], [package_version], [release_version])
  VALUES                                         (CAST ('12e5f6de-57cb-4306-9967-84097e737154' AS UNIQUEIDENTIFIER), 'F4A534908304A256B4416C9E8C11F4384B73676545B1E6A9671283A096954E18', 'Migrations\1.0.0\001_20190625-0815_MitrascaS.sql', SYSDATETIME(), SYSTEM_USER, 1, NULL, '$(PackageVersion)', CASE '$(ReleaseVersion)' WHEN '' THEN NULL ELSE '$(ReleaseVersion)' END);

GO
SET IMPLICIT_TRANSACTIONS, NUMERIC_ROUNDABORT OFF;
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, NOCOUNT, QUOTED_IDENTIFIER ON;

GO
IF DB_NAME() != '$(DatabaseName)'
  USE [$(DatabaseName)];

GO
IF NOT EXISTS (SELECT 1 FROM [$(DatabaseName)].[dbo].[__MigrationLogCurrent] WHERE [migration_id] = CAST ('746588d5-ce31-46cd-80f7-fecd70c76eb4' AS UNIQUEIDENTIFIER))
  PRINT '

***** EXECUTING MIGRATION "Migrations\1.0.1\001_20190625-1408_MitrascaS.sql", ID: {746588d5-ce31-46cd-80f7-fecd70c76eb4} *****';

GO
IF EXISTS (SELECT 1 FROM [$(DatabaseName)].[dbo].[__MigrationLogCurrent] WHERE [migration_id] = CAST ('746588d5-ce31-46cd-80f7-fecd70c76eb4' AS UNIQUEIDENTIFIER))
BEGIN
  PRINT '----- Skipping "Migrations\1.0.1\001_20190625-1408_MitrascaS.sql", ID: {746588d5-ce31-46cd-80f7-fecd70c76eb4} as it has already been run on this database';
  SET NOEXEC ON;
END

GO
EXECUTE ('PRINT N''Altering [dbo].[ib_EquityCash_Select]...'';


');

GO
EXECUTE ('/*
Programmer:  Bruce McQuien	
Description:  Selects cash records from ib_equitycash.
Date:  28/11/2006
*/

--test sergiu

ALTER PROC dbo.ib_EquityCash_Select
@EquityHeaderId int,
@InternalExternalCode char(1)

AS
SET NOCOUNT ON


SELECT [Description]
      ,[Amount]
	  ,[InternalExternalCode] 
FROM [dbo].[ib_EquityCash]
WHERE EquityHeaderId = @EquityHeaderId
AND InternalExternalCode = @InternalExternalCode
');

GO
SET NOEXEC OFF;

GO
IF N'$(IsSqlCmdEnabled)' <> N'True'
  SET NOEXEC ON;

GO
IF NOT EXISTS (SELECT 1 FROM [$(DatabaseName)].[dbo].[__MigrationLogCurrent] WHERE [migration_id] = CAST ('746588d5-ce31-46cd-80f7-fecd70c76eb4' AS UNIQUEIDENTIFIER))
  PRINT '***** FINISHED EXECUTING MIGRATION "Migrations\1.0.1\001_20190625-1408_MitrascaS.sql", ID: {746588d5-ce31-46cd-80f7-fecd70c76eb4} *****
';

GO
IF NOT EXISTS (SELECT 1 FROM [$(DatabaseName)].[dbo].[__MigrationLogCurrent] WHERE [migration_id] = CAST ('746588d5-ce31-46cd-80f7-fecd70c76eb4' AS UNIQUEIDENTIFIER))
  INSERT [$(DatabaseName)].[dbo].[__MigrationLog] ([migration_id], [script_checksum], [script_filename], [complete_dt], [applied_by], [deployed], [version], [package_version], [release_version])
  VALUES                                         (CAST ('746588d5-ce31-46cd-80f7-fecd70c76eb4' AS UNIQUEIDENTIFIER), '506DEF97E48D2875B24CB6601A44AB97B23A9F30DDF786220747DEE9661B9C6B', 'Migrations\1.0.1\001_20190625-1408_MitrascaS.sql', SYSDATETIME(), SYSTEM_USER, 1, NULL, '$(PackageVersion)', CASE '$(ReleaseVersion)' WHEN '' THEN NULL ELSE '$(ReleaseVersion)' END);

GO
PRINT '# Committing transaction';

COMMIT TRANSACTION;

GO







------------------------------------------------------------------------------------------------------------------------
------------------------------------------       POST-DEPLOYMENT SCRIPTS      ------------------------------------------
------------------------------------------------------------------------------------------------------------------------

SET IMPLICIT_TRANSACTIONS, NUMERIC_ROUNDABORT OFF;
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, NOCOUNT, QUOTED_IDENTIFIER ON;
IF DB_NAME() != '$(DatabaseName)'
  USE [$(DatabaseName)];

GO

PRINT '----- executing post-deployment script "Post-Deployment\01_Finalize_Deployment.sql" -----';
GO

---------------------- BEGIN POST-DEPLOYMENT SCRIPT: "Post-Deployment\01_Finalize_Deployment.sql" ------------------------
/*
Post-Deployment Script Template
--------------------------------------------------------------------------------------
 This file contains SQL statements that will be appended to the build script.
 Use SQLCMD syntax to include a file in the post-deployment script.
 Example:      :r .\myfile.sql
 Use SQLCMD syntax to reference a variable in the post-deployment script.
 Example:      :setvar TableName MyTable
               SELECT * FROM [$(TableName)]
--------------------------------------------------------------------------------------
*/

GO
----------------------- END POST-DEPLOYMENT SCRIPT: "Post-Deployment\01_Finalize_Deployment.sql" -------------------------

SET IMPLICIT_TRANSACTIONS, NUMERIC_ROUNDABORT OFF;
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, NOCOUNT, QUOTED_IDENTIFIER ON;
IF DB_NAME() != '$(DatabaseName)'
  USE [$(DatabaseName)];

GO


IF SERVERPROPERTY('EngineEdition') != 5 AND HAS_PERMS_BY_NAME(N'sys.xp_logevent', N'OBJECT', N'EXECUTE') = 1
BEGIN
  DECLARE @databaseName AS nvarchar(2048), @eventMessage AS nvarchar(2048)
  SET @databaseName = REPLACE(REPLACE(DB_NAME(), N'\', N'\\'), N'"', N'\"')
  SET @eventMessage = N'Redgate SQL Change Automation: { "deployment": { "description": "Redgate SQL Change Automation deployed $(ReleaseVersion) to ' + @databaseName + N'", "database": "' + @databaseName + N'" }}'
  EXECUTE sys.xp_logevent 55000, @eventMessage
END
PRINT 'Deployment completed successfully.'
GO




SET NOEXEC OFF; -- Resume statement execution if an error occurred within the script pre-amble
